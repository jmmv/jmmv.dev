<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/post.html</link><description>Recent content in Posts on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Nov 2023 13:50:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/post/feed.xml" rel="self" type="application/rss+xml"/><item><title>Code reviews: A success story</title><link>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</link><pubDate>Tue, 21 Nov 2023 13:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</guid><description>Code reviews have a bad rep: they are antagonistic in nature and, sometimes, pure red tape. Some argue that they are bad practice; others say that peer programming is better. And while these may be true, I want to tell you a story about a case where code reviews worked well!
Meet X: a junior engineer in the Bazel team circa 2018, tasked to implement two features: A and B. As you may know, Google is big into code reviews&amp;mdash;and their tooling for this is awesome; believe me&amp;mdash;so this was the standard process for X to get his code checked in.</description><enclosure url="https://jmmv.dev/images/2023-11-21-code-review.png" length="134980" type="image/jpeg"/></item><item><title>SSH agent forwarding and tmux done right</title><link>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</link><pubDate>Fri, 17 Nov 2023 08:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</guid><description>The SSH agent is a little daemon that holds your private keys in memory. This is particularly handy when your keys are protected by a passphrase: you can unlock and add your keys to the agent once and, from then on, any SSH client such as ssh(1) can interact with the keys without asking you for the passphrase again.
The SSH agent becomes even handier when you primarily work on a remote workstation over SSH.</description></item><item><title>Why do I know shell, and how can you?</title><link>https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html</link><pubDate>Fri, 10 Nov 2023 08:00:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html</guid><description>&lt;p>&lt;em>&amp;ldquo;Why do you know so much shell?&amp;rdquo;&lt;/em> is a question I&amp;rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I was &amp;ldquo;forced&amp;rdquo; to write tools in it for a while and, because of that, I made a conscious effort to learn the language and get better at it.&lt;/p>
&lt;p>You see, most people that write shell don&amp;rsquo;t want to deal with it. They stitch together whatever works into a script and call it a day, making a bunch of spaghetti even if it goes against the coding best practices they already know. And when they encounter some odd syntax they don&amp;rsquo;t recognize, their reaction is to say &amp;ldquo;this has to be rewritten in Python!&amp;rdquo; instead of taking a breath and trying to really understand what&amp;rsquo;s going on. It doesn&amp;rsquo;t help that plenty of senior engineers scoff at shell scripts.&lt;/p>
&lt;p>And it is true: the shell is arcane and has many flaws as a programming language. I don&amp;rsquo;t want to convince you to start writing new tools in it. But the shell is also an incredible rapid prototyping language, and you can use it to solve business problems really quickly and with surprisingly little code. If you pause for a second to learn it, you&amp;rsquo;ll realize that you can bend tradition and write maintainable shell code too. Hear out how I got into writing so much shell and how you can get better at it too.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-10-sh-manpage.jpg" length="425448" type="image/jpeg"/></item><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item><item><title>Links: October 2023 edition</title><link>https://jmmv.dev/2023/10/links-october-2023-edition.html</link><pubDate>Tue, 31 Oct 2023 12:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/links-october-2023-edition.html</guid><description>&lt;p>Inspired by the works of &lt;a href="https://eatonphil.com/">Phil Eaton&lt;/a>, I&amp;rsquo;ve been highlighting articles and projects that I find interesting in &lt;del>Twitter&lt;/del> X and Mastodon. Some of these posts were more &amp;ldquo;successful&amp;rdquo; than I had expected, which I take to mean that doing this is interesting to you all. So, it&amp;rsquo;s probably a good idea to periodically collect them all in a post with a very brief commentary on each.&lt;/p>
&lt;p>Here is a recap of the interesting articles that came my way in October 2023. This does &lt;em>not&lt;/em> mean that these articles were published during this period: some of them are older but I just (re)discovered them now. I&amp;rsquo;ll avoid referencing my own articles: you can find those by &lt;a href="https://jmmv.dev/archive.html">in the archive&lt;/a>.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>BazelCon 2023 et al. trip report</title><link>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</link><pubDate>Mon, 30 Oct 2023 03:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</guid><description>&lt;p>I&amp;rsquo;m exhausted. I just came back to Seattle from a 10-day trip in which I attended three different Bazel events: the Build Meetup in Reykjavik, the Bazel Community Day in Munich, and BazelCon 2023 in Munich too. Oh, and because I was on the other side of the world, I also paid a visit to my family in Spain.&lt;/p>
&lt;p>Attending these events has been incredibly useful and productive: I got exposure to many ideas and discussions that would just not happen online, I got to build connections with very interesting people and, of course, it has also been super fun too to reconnect with old coworkers and friends.&lt;/p>
&lt;p>This article contains the summary of the things I learned and the things I want to follow up on. These are just a bunch of cleaned-up notes which I took and are in the context of &lt;em>my&lt;/em> work with &lt;a href="https://bazel.build/">Bazel&lt;/a> at &lt;a href="https://www.snowflake.com/">Snowflake&lt;/a> and &lt;em>my&lt;/em> interests on build tools, so this is not endorsed by Snowflake.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-30-bazelcon.jpg" length="663230" type="image/jpeg"/></item><item><title>Hello, Blog System/5!</title><link>https://jmmv.dev/2023/10/hello-blog-system5.html</link><pubDate>Fri, 27 Oct 2023 16:14:00 +0200</pubDate><guid>https://jmmv.dev/2023/10/hello-blog-system5.html</guid><description>Blog System/5 is my new Substack publication in which I write about the variety of software and systems engineering topics that pique my interest. If that sounds too generic to you, it&amp;rsquo;s because it is: there are too many cool things to write about! And yes, this sounds exactly the same as this blog. Read on to understand the motivation behind the new publication and &lt;em>subscribe now&lt;/em> to not miss a beat!</description><enclosure url="https://jmmv.dev/images/2023-10-28-blog-system5-logo.png" length="76109" type="image/jpeg"/></item><item><title>Build farm visualizations</title><link>https://jmmv.dev/2023/10/build-farm-visualizations.html</link><pubDate>Fri, 20 Oct 2023 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/build-farm-visualizations.html</guid><description>If you have followed our recent infrastructure posts, you know by now that we are actively migrating Snowflake&amp;rsquo;s build to Bazel. What we haven&amp;rsquo;t shared yet is that we have deployed our own Build Barn cluster to support Bazel&amp;rsquo;s remote execution features. We have chosen to run our own build farm service for resource governance and security purposes, but also because the behavior of this system impacts the developer experience so directly that we want to have full in-house control and knowledge of it.</description></item><item><title>Unit-testing shell scripts and tools with shtk</title><link>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</link><pubDate>Wed, 11 Oct 2023 08:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</guid><description>&lt;p>While working on this static blog a few days ago, I made a change to its templates that warranted an automated test. I could have written a trivial shell script to do it, but instead I reached out for shtk&amp;rsquo;s unit-testing module. I &lt;a href="https://twitter.com/jmmv/status/1710309896670081083">tweeted about it&lt;/a> right away to just say that you can, in fact, write tests in shell because lots of developers are skeptical about any script longer than 10 lines of code.&lt;/p>
&lt;p>Interestingly, this reply came through: a pointer to a contemporary, under-development library for writing tests in Bash. Which made me think: &amp;ldquo;Hey, I had already done that years ago&amp;hellip; but nobody knows about it. Gotta fix that with a blog post!&amp;rdquo; But first, I had to bring shtk back from its ashes because I had not touched it for more than 6 years and it wasn&amp;rsquo;t read for show and tell. So I did something that I wanted to do back in the day but never did: I put together &lt;a href="https://shtk.jmmv.dev/">a website for shtk&lt;/a> to host its &lt;a href="https://shtk.jmmv.dev/docs.html">reference manual&lt;/a> and I fixed a few obvious rough edges.&lt;/p>
&lt;p>With those tweaks out of the way, we come to this article. In here, I want to show you how writing decent tests in shell is entirely possible and how shtk&amp;rsquo;s testing platform provides unique features to do integration testing of CLI apps written in any language.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-11-shell-hammer-wrench.jpg" length="398237" type="image/jpeg"/></item><item><title>Analyzing OOMs in IntelliJ with Bazel</title><link>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</link><pubDate>Sat, 07 Oct 2023 12:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</guid><description>&lt;p>A few months ago, we described how we fixed &lt;a href="https://jmmv.dev/2023/03/addressing-bazel-ooms.html">three different OOM scenarios&lt;/a> in our ongoing migration to the Bazel build system here at Snowflake. Things had been sailing along just fine since then&amp;hellip; but a new issue showed up recently: our &lt;a href="https://ij.bazel.build/">IntelliJ with Bazel (IjwB)&lt;/a> Java project started showing OOMs during its sync phase.&lt;/p>
&lt;p>The reason this issue surfaced now is because, as we continue our migration to Bazel, our IjwB project has grown in size. Months ago, our project only covered a Java binary, but now that we have migrated all of its unit and integration tests as well, the project covers them too. It is common for tests to be more expensive to build and run than the binary they validate&amp;mdash;tests depend on the binary&amp;rsquo;s dependencies &lt;em>plus&lt;/em> many other helper tools for testing&amp;mdash;and these caused the project to grow too big to fit in our development environments. Or did they?&lt;/p></description></item><item><title>5 ways to instantiate Rust structs in tests</title><link>https://jmmv.dev/2023/10/rust-test-structs.html</link><pubDate>Fri, 06 Oct 2023 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/rust-test-structs.html</guid><description>&lt;p>I&amp;rsquo;m a big fan of static typing and I&amp;rsquo;ve found that using narrow types for each entity in the object model of my programs reduces errors. Rust is particularly well-suited at this task: its lack of implicit type conversions eliminates surprises, and its ownership semantics allow type transformations with zero cost.&lt;/p>
&lt;p>Unfortunately, (ab)using narrow types in an app&amp;rsquo;s domain is &lt;em>really&lt;/em> annoying when writing tests. While non-test code rarely instantiates new objects&amp;mdash;in the case of a REST service, this would only happen at the service&amp;rsquo;s boundaries&amp;mdash;tests instantiate objects infinitely more times than non-test code. Code patterns that may seem reasonable in non-test code can become unbearable in tests.&lt;/p>
&lt;p>In this post, I want to look into the various ways in which you can instantiate strongly-typed objects. For each, I show examples and describe their pros and cons. And yes, as a matter of fact, I have tried them all before&amp;hellip; and I can&amp;rsquo;t yet make my mind as to which one is best.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-06-rust-test-structs.png" length="138979" type="image/jpeg"/></item><item><title>Good performance is not just big O</title><link>https://jmmv.dev/2023/09/performance-is-not-big-o.html</link><pubDate>Fri, 08 Sep 2023 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/09/performance-is-not-big-o.html</guid><description>&lt;p>Having a fast and responsive app is orthogonal to &amp;ldquo;knowing your big &lt;i>O&lt;/i>s&amp;rdquo;. Unfortunately, most tech companies over-emphasize algorithms in interviews and downplay systems knowledge, and I believe that&amp;rsquo;s one reason behind sluggish apps and bloated systems.&lt;/p>
&lt;p>I&amp;rsquo;ve seen this play out repeatedly. Interviewers ask a LeetCode-style coding question, which is then followed by the ritual of discussing time and memory complexity. Candidates ace the answers. But then&amp;hellip; their &amp;ldquo;real&amp;rdquo; code suffers from subtle yet impactful performance problems.&lt;/p>
&lt;p>Focusing on big &lt;em>O&lt;/em> complexity rarely matters in most apps. Sure, it&amp;rsquo;s important to think about your algorithmic choices, but there are so many more details to worry about that have a direct impact on app performance and responsiveness. Let&amp;rsquo;s look at a bunch of them!&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-09-08-speed-bumps-limit.jpg" length="372231" type="image/jpeg"/></item><item><title>Costs exposed: Frameworks</title><link>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</link><pubDate>Thu, 31 Aug 2023 07:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</guid><description>&lt;p>&lt;a href="https://jmmv.dev/2023/06/fast-machines-slow-machines.html">&amp;ldquo;Fast machines, slow machines&amp;rdquo;&lt;/a>&amp;hellip; ah, the post that spawned these series. As I frantically typed that article while replying to angry tweets, the thought came to mind: software engineering as a whole is hyper-focused on lowering the costs to write new code, yet there is a disregard for the costs that these improvements bring to other disciplines in a company on even to end users.&lt;/p>
&lt;p>So, in this series finale, I want to compare how some choices that apparently lower development costs actually increase costs elsewhere. I also want to highlight how, if we made different decisions during development, we could possibly expose those extra costs early on. This is beneficial because exposing costs upfront allows us to make tough choices when there is still a chance of changing course.&lt;/p>
&lt;p>To make things specific, I will look at how the use of modern frameworks that facilitate development can end up hurting performance, reliability, and usability. So let&amp;rsquo;s start with a three-part rant first (sorry) and then let&amp;rsquo;s look at what we might do.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-31-dirt-pile.jpg" length="773447" type="image/jpeg"/></item><item><title>Costs exposed: On-call ticket handling</title><link>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</link><pubDate>Sat, 26 Aug 2023 07:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</guid><description>&lt;p>In the previous post, I proposed that certain engineering practices expose systemic costs and help with planning while other practices hide those same costs and disturb ongoing plans.&lt;/p>
&lt;p>The idea I&amp;rsquo;m trying to convey is hard to communicate in the abstract so, in that post, I used the differences between a monorepo and a multirepo setup as an example. Today, I&amp;rsquo;ll expore a different scenario to support the same idea. I&amp;rsquo;m going to talk about how certain ticket assignment practices during on-call operations can expose service support costs vs. how other practices hide them.&lt;/p>
&lt;p>Keep in mind that, just like in the previous post, I do not want to compare the general merits of one approach vs. the other. The &lt;em>only&lt;/em> thing I want to compare is whether one approach centralizes toil and allows management to quantify its cost vs. how another approach hides toil by smearing it over the whole team in hard-to-quantify ways. Whether management &lt;em>actually does something&lt;/em> to correct the situation once the costs are exposed is a different story.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-26-tickets-phone.jpg" length="539252" type="image/jpeg"/></item><item><title>Costs exposed: Monorepo vs. multirepo</title><link>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</link><pubDate>Wed, 23 Aug 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</guid><description>&lt;p>In software engineering organizations, there are certain practices that keep costs under control even if those &lt;em>seem&lt;/em> more expensive at first. Unfortunately, because such practices &lt;em>feel&lt;/em> more expensive, teams choose to keep their status quo even when they know it is suboptimal. This choice ends up hurting productivity and morale because planned work is continuously interrupted, which in turn drags project completion.&lt;/p>
&lt;p>The reason I say &lt;em>seem&lt;/em> and not &lt;em>are&lt;/em> is because the alternatives to these cost-exposing practices also suffer from costs. The difference is that, while the former surface costs, leading to the need to allocate time and people to infrastructure work, the latter keeps the costs smeared over teams and individuals in ways that are difficult to account and plan for.&lt;/p>
&lt;p>To illustrate what I&amp;rsquo;m trying to say, I&amp;rsquo;ll present three different scenarios in which this opinion applies. All of these case studies come from past personal experiences while working in different teams and projects. The first one covered in this post is about the adoption of a monorepo vs. the use of multiple different repositories. The other two will come in follow-up articles.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-23-freebsd-gnome-repos.png" length="162711" type="image/jpeg"/></item></channel></rss>