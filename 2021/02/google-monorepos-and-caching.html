<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>How does Google keep build times low? - Julio Merino (jmmv.dev)</title><meta property="og:title" content="How does Google keep build times low? - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="How does Google keep build times low? - Julio Merino (jmmv.dev)"><meta name=description content="Monorepos are an interesting beast. If mended properly, they enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable monsters of tangled dependencies, slow builds, and frustrating developer experiences. Whether you have a good or bad experience directly depends on the level of engineering support behind the monorepo. Simply put, monorepos require dedicated teams and tools to run nicely. In this post, I will look at how almost-perfect caching plays a key role in keeping build times manageable under such an environment."><meta property="og:description" content="Monorepos are an interesting beast. If mended properly, they enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable monsters of tangled dependencies, slow builds, and frustrating developer experiences. Whether you have a good or bad experience directly depends on the level of engineering support behind the monorepo. Simply put, monorepos require dedicated teams and tools to run nicely. In this post, I will look at how almost-perfect caching plays a key role in keeping build times manageable under such an environment."><meta property="twitter:description" content="Monorepos are an interesting beast. If mended properly, they enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2021/02/google-monorepos-and-caching.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2021/02/google-monorepos-and-caching.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.161663676cac4bf21abc8967ec3267c26026aa58e9f392c5f3427e0ef089fe6b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;Julio Merino</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/essays.html>Essays</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>How does Google keep build times low?</h1><p>February 26, 2021 &#183;
About 11 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/featured>featured</a>, <a href=/tags/monorepo>monorepo</a>, <a href=/tags/opinion>opinion</a></p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>Monorepos have existed for a very long time. The basic idea behind them is to store the complete source code of your company or product, <em>including</em> all of its dependencies, in a single source repository and have an integrated build and test process for the whole.</p><p>I like to think of the BSD systems as the canonical example of open-source monorepos, but these were never seen as good practice by many (c.f. <a href=https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar>CatB</a>). Monorepos have only become popular during the last decade because of Google&rsquo;s engineering practices and their increasing desire to <a href=https://www.oreilly.com/library/view/software-engineering-at/9781492082781/>share details with the public</a>. Google&rsquo;s monorepo is probably the largest in the world, and if works at their scale&mdash;the thinking goes&mdash;it must be good for everyone else, right? Not so fast.</p><p>Monorepos are an interesting beast. If mended properly, they indeed enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable monsters of tangled dependencies, slow builds, and frustrating developer experiences. Whether you have a good or bad experience directly depends on the level of engineering support behind the monorepo. Simply put, monorepos require dedicated teams (plural) <em>and</em> tools to run nicely (not just random engineers &ldquo;volunteering&rdquo; their efforts), and these cost a lot of time and money.</p><p>As a consequence of this cost, you must be wary before adopting a monorepo model. You must have a good story around support upfront, or else you are in for long-term pain. And once you are in a monorepo, the &ldquo;long term&rdquo; is guaranteed because untangling the dependency mess that arises in such an environment can be next to impossible. The worst scenario is when you did not actively decide to implant a monorepo, but you end up in one due to organic or unexpected quick growth&mdash;in which case your tooling and practices are almost certainly not ready for it.</p><p>In this post, I will look at how Google is able to successfully run the world&rsquo;s largest monorepo while keeping build times minimal. They can, for example, validate and merge most PRs on CI within minutes while having the almost-absolute confidence that they won&rsquo;t break <em>anything</em>&mdash;yet it&rsquo;s impossible to build the whole repository in those few minutes. I&rsquo;ll restrict this post to analyzing build times and will specifically avoid talking about test times. Both are crucially important but both have very different solutions. Maybe a follow-up post will cover tests üòâ.</p><h1 id=one-repo-vs-many>One repo vs. many</h1><p>A key feature of a monorepo, as mentioned earlier, is to have a unified build process for the whole. In the common case, the repository has a single entry point at the top level, which means that the entire repository has to be built for every change to ensure the health of the tree. It might be possible for individual engineers to hand-pick which parts of the tree to build on their development machine (e.g. by running <code>make</code> on a subdirectory), but CI environments will blindly do builds from the root.</p><p>This approach, tied to the fact that monorepos grow unboundedly with the company or product they support, causes build times to balloon&mldr; until they grind the development processes to a halt. If you add to this that most build systems need occasional clean operations, frustration is guaranteed:</p><ul><li>Multi-minute- or multi-hour-long penalties make it very hard to interact with the codebase.</li><li>Pull requests are almost impossible to manage as they need long validation times and might hit unpredicted merge conflicts.</li><li>Quality suffers because developers won&rsquo;t want to pay the penalty of yet another CI run just to address nits raised in the final pass of a code review.</li></ul><p>Facing these circumstances, the natural temptation is to split the repository into smaller pieces and regain control of the build times. (This, by the way, is the specific project I&rsquo;m involved in right now.) And, depending on the tooling you are subject to and the freedom (or lack thereof) you have in changing it, this may be the only possible/correct answer. But why? Why would moving to smaller repositories fix build times? The total amount of code won&rsquo;t get smaller just by splitting it; if anything, it might <em>grow</em> even more! The answer may be obvious:</p><blockquote><p>Multiple repositories introduce synchronization points. Under such a model, the cross-repository dependencies are expressed as <em>binary</em> package dependencies with specific version numbers. In essence, the smaller repositories leverage builds that <em>others have already done</em> and thus bound their build times.</p></blockquote><h1 id=say-hello-to-caching>Say hello to caching</h1><p>Yet&mldr; Google&rsquo;s monorepo is known for <em>not</em> using binary artifacts: they build <em>everything</em> at head with the exception of the most basic C++ toolchain (known as crosstool in <del>Google</del> Bazel parlance) for bootstrapping reasons. How do they pull this off? The answer is simple and is the exact same as given above: they leverage builds that others have already done. And the specific way they do this is by applying a common solution to performance problems: caching.</p><blockquote><p>Google builds rely on a <em>cross-user</em> (remote) massive artifact cache that stores the outputs of all build actions. This cache is what introduces the same &ldquo;synchronization points&rdquo; that multiple repositories benefit from. By leveraging this cache, the vast majority of dependencies needed for any given build will have already been compiled by someone or something else and will be reused.</p></blockquote><p>But&mldr; caching alone is insufficient to fix build times unless you get 90%+ cache hit rates overall. And that&rsquo;s where the differences between awful build times in a monorepo and great build times lie. In the next sections, I&rsquo;ll look into the specific mechanisms that lead to such high cache hit rates. And if Google can have them, so can you. <a href=https://bazel.build/>Bazel</a>, from its inception, has been trying to spread these practices to the public&mdash;but you can apply these same concepts with other build tools too.</p><h1 id=ensure-action-determinism>Ensure action determinism</h1><p>First of all, we have to ensure that build actions (e.g. compiler invocations, resource bundling) are deterministic. Given a set of input files and tools to process them, the output must not be subject to environmental differences. In other words: build actions must be sufficiently-specified so that they don&rsquo;t rely on hidden dependencies that could change their outputs.</p><p>I covered this topic in depth in the previous &ldquo;<a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a>&rdquo; post where I analyzed how this simple idea allows incremental builds to always work. I also glanced over some of the many other benefits that it brings, including how it can lead to optimal build times, which is what I&rsquo;m covering here.</p><p>Deterministic actions are the foundation to reducing build times in a monorepo. So&mldr; you must sort this out before you can take advantage of any of the remaining points.</p><h1 id=reduce-the-number-of-configurations>Reduce the number of configurations</h1><p>Once build actions are deterministic, the next thing to worry about is increasing the chances of reusing previously-cached actions for any given build. This is generally only possible when builds use the exact same configuration, or else their outputs will differ and may be incompatible with each other. For example: a debug build will not be able to safely reuse the outputs of a release build. Which is kinda obvious, but there aren&rsquo;t just two configurations. There tend to be more. Many more.</p><p>In fact, the number of build configurations grows with the size of the project&mdash;and, paradoxically, the number of options grows to <em>reduce</em> build times. You see: when engineers suffer from painfully slow builds, in the best of their intentions, they add knobs to conditionally compile certain parts of the project to speed things up. Which is great in single-user/single-machine builds, but it doesn&rsquo;t scale and is an anti-pattern in a monorepo world where we must have almost-perfect caching across users.</p><p>Thus, for monorepo builds to be quick, we actually have to homogenize configurations so that most engineers and CI are running almost the same configuration. In practical terms, this means having debug builds for interactive development, and release builds for production usage. And that&rsquo;s about it.</p><p>As an anecdote, we encountered this specific issue while onboard a certain iOS team into remote builds. This team had been developing on laptops only, and because they had slow builds, the engineers had added many feature flags to make components optional. When we moved them to remote builds and remote caching, we saw very little benefit: these users were <em>still</em> rebuilding everything and the reason was because they could not make use of previously-cached results due to different configurations. Once we removed most build-time conditionals, they started truly seeing the benefits of remote caching/execution and faster builds. Counterintuitive, isn&rsquo;t it?</p><h1 id=use-ci-to-populate-the-cache>Use CI to populate the cache</h1><p>By this point, we know that our actions are deterministic and that user builds have a chance to reuse the cache because we have made builds uniform. But here comes the question: how do we seed the cache?</p><p>There are different alternatives, but we must first talk about security.</p><p>A <em>cross-user</em> cache of build artifacts must be populated only from trusted sources. We cannot have a developer&rsquo;s workstation inject output artifacts that were built on their machine because the developer could have tampered with the outputs. This means that the cross-user remote cache can only be populated from machines that cannot be tampered with. (If the cache is not used across users, then no extra precautions are necessary.) These trusted sources come in two forms:</p><ol><li><p>The first one, and the one that&rsquo;s easy to apply almost in any case, are CI runs. CI runs happen on machines that are not (and should not be!) directly accessible by the larger engineering population, thus we can trust that the output they generate comes precisely from the code and tools that were fed to them.</p></li><li><p>The second one, and the one that&rsquo;s more subtle, are user-initiated builds. When an engineer is building on their workstation, we <em>can</em> cache their build outputs across users <em>if</em> we generate those outputs using a trusted environment. Such a trusted environment comes in the form of <em>remote execution</em>. Under a remote execution scenario, the build machine sends individual build actions to a remote service. This service, which is trusted too, runs actions on behalf of the user, but the user doesn&rsquo;t have a chance to interfere with the outputs before they are saved into the cache.</p></li></ol><p>You might think that a compromised compiler is an attack vector in this scenario: the engineer modifies the compiler, sends it to the remote CI machine or remote execution worker to build a piece of code, and the outputs that contain malicious code are injected into the cache. But that&rsquo;s not the case. Remember: the compiler is also an <em>input</em> to the action, just like the source files are. If you tamper with the compiler, then the action&rsquo;s signature changes, which means the cache key changes, which means nobody will be able to address such cache entry unless they have the same compromised compiler.</p><p>In the end, you want to take both approaches. You want periodic CI runs to populate the cache as these ensure that the cache is frequently repopulated from HEAD. And you want to incrementally cache outputs that originate from interactive builds and PRs to keep up with drift and to keep up with possible divergences in the configurations that they use.</p><p>As long as users stick to the blessed configurations discussed in the previous section, and as long as you have these sources of data to populate the cache, then you should start seeing high cache hit ratios and faster build times overall.</p><h1 id=are-monorepos-worth-it>Are monorepos worth it?</h1><p>Definitely. I&rsquo;m a believer that they are good, and not only because of Google: the BSDs taught me this principle a very long time ago. That said, it&rsquo;s true that they can be a poor choice unless your engineering practices and tools keep up, which as mentioned in the opening, can be extremely expensive. If you cannot afford the cost, it might be better to stay with multiple smaller repositories and let smaller groups of developers handle them in an ad-hoc manner. The whole won&rsquo;t be as nice, but the overall experience might be less frustrating.</p><p>In the end, monorepos are an &ldquo;implementation detail&rdquo; of bundling multiple separate components in one place. Having a monorepo should <em>not</em> imply that you must build the whole thing every time you make a change. Having multiple repositories should not mean that they are isolated islands. And the latter is, precisely, what we are trying to prove in my current team: we want to see how well we can integrate smaller repositories without actually being a monorepo. Because, with suboptimal tooling&mldr; build times are not the only problem. Source control is another major one: Git, if you happen to use it, is not the greatest choice for monorepos.</p><hr><p>If you enjoyed this post, subscribe to this blog to keep up with two upcoming, related topics! One will be on ensuring build times remain low once we have achieved them; and the other may be on how Google keeps test runs on CI fast.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2021/02/endbasic-0.6.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2021/03/oncall-wellbeing.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=How+does+Google+keep+build+times+low%3F&amp;url=https%3A%2F%2Fjmmv.dev%2F2021%2F02%2Fgoogle-monorepos-and-caching.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=How+does+Google+keep+build+times+low%3F&amp;u=https%3A%2F%2Fjmmv.dev%2F2021%2F02%2Fgoogle-monorepos-and-caching.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=How+does+Google+keep+build+times+low%3F+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2021%2F02%2Fgoogle-monorepos-and-caching.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container><div class=row><div class="col-4 order-2 texr-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDIxLzAyL2dvb2dsZS1tb25vcmVwb3MtYW5kLWNhY2hpbmcuaHRtbA==/stamp.gif" style=display:none></noscript></body></html>