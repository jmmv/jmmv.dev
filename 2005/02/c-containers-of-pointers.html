<!DOCTYPE html>
<html>
  <head>
    

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- The above 3 meta tags *must* come first in the head; any other head
      content must come *after* these tags -->

<meta name="description"
      content="One of the things C++ provides to programmers is that pointers can be avoided in much situations, and IMHO, they should be (specially in public class interfa...">
<meta name="author" content="Julio Merino">

<meta content="http://julio.meroh.net/2005/02/c-containers-of-pointers.html" property="og:url">

<link rel="canonical" href="http://julio.meroh.net/2005/02/c-containers-of-pointers.html">
<link rel="alternate" type="application/rss+xml" title="Julio Merino" href="http://julio.meroh.net/feed.xml" />

<link rel="stylesheet" href="/css/main.css">

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="/js/html5shiv-3.7.2.min.js"></script>
  <script src="/js/respond-1.4.2.min.js"></script>
<![endif]-->

    <title>C++: Containers of pointers - Julio Merino</title>
    <meta content="C++: Containers of pointers - Julio Merino" property="og:title">
  </head>

  <body>
    <header class="site-header">

<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed"
              data-toggle="collapse" data-target="#navbar"
              aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Julio Merino</a>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
          
            
              
                <li><a class="page-link"
                href="/about/"
                >About</a></li>
              
            
          
        
          
            
              
                <li><a class="page-link"
                href="/essays/"
                >Essays</a></li>
              
            
          
        
          
            
              
                <li><a class="page-link"
                href="/software/"
                >Software</a></li>
              
            
          
        
          
            
              
                <li><a class="page-link"
                href="/work/"
                >Work</a></li>
              
            
          
        
      </ul>

      <form class="navbar-form navbar-right" method="get" role="search"
            action="http://www.google.com/search">
          <div class="form-group">
            <input type="text" name="query" class="form-control"
                   placeholder="Search">
            <input type="hidden" name="sitesearch" value="http://julio.meroh.net">
          </div>
          <button type="submit" value="Search" class="btn btn-default">
            <span class="glyphicon glyphicon-search" aria-hidden="true"></span>
          </button>
      </form>
    </div>
  </div>
</nav>

</header>


    <div class="page-header">
      <div class="container">
        <h1>C++: Containers of pointers</h1>

        <p>Wed, 09 Feb 2005 12:44:00 +0000</p>

        
      </div>
    </div>

    <div class="container">
      <article>
        <p>One of the things C++ provides to programmers is that pointers can be avoided in much situations, and IMHO, they should be (specially in public class interfaces). However, there are some times in which pointers must be used.</p>  <p>Consider an abstract base class and multiple specializations of it; if you want to define a container of all these objects, no matter which derived class they belong to, the container must hold the parent's type. But you can't use an object (nor a reference) of this type, basically for two reasons: you can't instantiate one and, even if you could (no abstract members), the derived object could loose all of its specific properties when converted to the parent one.</p>  <p>In the above scenario, you are required to use pointers. And, when doing so, you hit a problem: the operations that are applied to containers will work at the pointer level, not at the object level, so all comparisons will be wrong. Let's clarify this with an example.</p>  <p>Suppose we have a set of pointers to strings and we add several objects to it:</p>  <pre>std::set&lt;std::string*&gt; s;<br />s.insert(new std::string("String 1"));<br />s.insert(new std::string("String 2"));<br />s.insert(new std::string("String 3"));</pre>  <p>We are now asked to check whether "String 2" is part of the set (in this example we are checking for <i>equality</i>).  You can't use the <tt>s.find</tt> operation, because it will compare <tt>pointers</tt> rather than strings; so unless you know the address of the object you are looking for, you won't be able to find it. A solution could be to manually iterate all over the set and check each element against the string we want. Ugly, isn't it?</p>  <p>Fortunately, we can use the standard algorithms, but we will have to construct a custom predicate that, given two pointers, compares their <i>contents</i>.  Our predicate could look like the following (requires the <tt>functional</tt> header):</p>  <pre>template &lt;class T&gt;<br />struct unref_equal_to : public std::binary_function&lt;T, T, bool&gt;<br />{<br />   bool operator()(const T& x, const T&amp; y) const { return *x == *y; }<br />};</pre>  <p>Despite the operator taking two references, it <i>must</i> take pointers (because <tt>T</tt> will have to be a pointer type); otherwise, nasty things will happen.  Then, all it does is apply the <tt>==</tt> (equality) operator on the unreferenced objects and return the result, which will do what we want (in this case, compare the string contents).</p>  <p>Now, how do we apply this predicate to look for a specific string in our previous set?  Easy; we need the <tt>std::find_if</tt> standard algorithm, which takes a predicate as an argument.  Let's see what we'd do:</p>  <pre>std::string what("String 2");<br />std::set&lt;std::string*&gt;::const_iterator i =<br />   std::find_if(s.begin(), s.end(),<br />                std::bind2nd(unref_equal_to&lt;std::string*&gt;(),<br />                &what));<br />if (i != s.end())<br />   std::cout &lt;&lt; "String 2 is part of s!" &lt;&lt; std::endl;</pre><p></p>  <p>Don't let this scare you, specially the <tt>std::bind2nd</tt> part.  This function is used to set the second argument of the <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">binary function</a> we created above (which has some special properties).  OTOH, the <tt>std::find_if</tt> algorithm will take care to fill in the first argument on each iteration it does over the set, so we will get the expected comparisons.</p><p class="mobile-post"></p>

      </article>

      <div class="post-links">
        <p>
          

          

          <a href="/feed.xml">Subscribe
          via RSS</a>
          &middot;
          <a href="/blog/">Go to posts index</a>
        </p>

        <form class="form-inline"
            action="https://feedburner.google.com/fb/a/mailverify"
            method="post"
            target="popupwindow"
            onsubmit="window.open('https://feedburner.google.com/fb/a/mailverify?uri=jmmv', 'popupwindow', 'scrollbars=yes,width=550,height=520');return true">
          <div class="form-group form-group-sm">
            <input type="text" style="width: 400px" name="email"
                    placeholder="Enter your email to subscribe to new posts"
                    class="form-control input-sm"/>
          </div>
          <button type="submit" value="Subscribe"
                  class="btn btn-default btn-sm">
            <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
          </button>
          &nbsp;&nbsp;&nbsp;Delivered by
          <input type="hidden" value="jmmv" name="uri"/>
          <input type="hidden" name="loc" value="en_US"/>
          <a href="https://feedburner.google.com" target="_blank">FeedBurner</a>
        </form>
      </div>

      
      <div id="disqus_thread">
        <script>
          var disqus_config = function () {
            this.page.url = "http://julio.meroh.net/2005/02/c-containers-of-pointers.html";
            this.page.identifier = "/2005/02/c-containers-of-pointers";
          };
          (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');

            s.src = '//jmmv.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
          powered by Disqus.</a>
        </noscript>
      </div>
      
      <p>Comments from the original Blogger-hosted post:</p>
      <script src="https://apis.google.com/js/plusone.js"></script>
      <div class="g-comments"
           data-href="http://julipedia.meroh.net/2005/02/c-containers-of-pointers.html"
           data-first_party_property="BLOGGER"
           data-view_type="FILTERED_POSTMOD">
      </div>
      
      
    </div>

    <div class="container">
  <footer>
    <p class="pull-right"><a href="#">Back to top</a></p>
    <p>Copyright 2016 Julio Merino</p>
  </footer>
</div>

<script src="/js/jquery-1.11.2.min.js">
</script>
<script
  src="/css/bootstrap.min.js">
</script>

<script src="/js/auto-toc-1.0.0.dist.js">
</script>

<script>
$("p:contains('NOTE: ')").addClass("callout callout-info");
$("p:contains('IMPORTANT: ')").addClass("callout callout-info");
$("p:contains('WARNING: ')").addClass("callout callout-warning");
$("p:contains('DANGER: ')").addClass("callout callout-danger");
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
  m.parentNode.insertBefore(a,m)})(window,document,'script',
  '//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63557333-1', 'auto');
  ga('send', 'pageview');
</script>


  </body>
</html>
