<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Understanding Bazel remote caching - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Understanding Bazel remote caching - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Understanding Bazel remote caching - Julio Merino (jmmv.dev)"><meta name=description content="The previous article on Bazel action non-determinism provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the article did not mention is that actions are also the fundamental unit of caching during execution to avoid doing already-done work.
In this second part of the series, I want to revisit the very basics of how Bazel runs actions and how remote caching (not remote execution, because that&rsquo;ll come later) works. The goal here is to introduce the Action Cache (AC), the Content Addressable Storage (CAS), how they play together, and then have some fun in describing the many ways in which it&rsquo;s possible to poison such a cache in an accidental or malicious manner.
"><meta property="og:description" content="The previous article on Bazel action non-determinism provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the article did not mention is that actions are also the fundamental unit of caching during execution to avoid doing already-done work.
In this second part of the series, I want to revisit the very basics of how Bazel runs actions and how remote caching (not remote execution, because that&rsquo;ll come later) works. The goal here is to introduce the Action Cache (AC), the Content Addressable Storage (CAS), how they play together, and then have some fun in describing the many ways in which it&rsquo;s possible to poison such a cache in an accidental or malicious manner.
"><meta property="twitter:description" content="The previous article on Bazel action non-determinism provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/09/bazel-remote-caching.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/09/bazel-remote-caching.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-09-05-bazel-remote-caching-cover-image.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-09-05-bazel-remote-caching-cover-image.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzA5L2JhemVsLXJlbW90ZS1jYWNoaW5nLmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/bazel-remote-caching")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Understanding Bazel remote caching</h1><p>September 5, 2025 &#183;
About 12 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/bazel-remote-caching>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-09-05-bazel-remote-caching-cover-image.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>The previous article on <a href=/2025/07/bazel-action-determinism.html>Bazel action non-determinism</a> provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the article did not mention is that actions are <em>also</em> the fundamental unit of caching during execution to avoid doing already-done work.</p><p>In this second part of the series, I want to revisit the very basics of how Bazel runs actions and how remote caching (<em>not</em> remote execution, because that&rsquo;ll come later) works. The goal here is to introduce the <strong>Action Cache (AC)</strong>, the <strong>Content Addressable Storage (CAS)</strong>, how they play together, and then have some fun in describing the many ways in which it&rsquo;s possible to poison such a cache in an accidental or malicious manner.</p><h1 id=the-action-cache-ac>The Action Cache (AC)</h1><p>Picture this build file with two targets that generate one action each:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;foo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;foo.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;sleep 5; echo foo &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;bar&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;bar.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:foo&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;sleep 5; { cat $&lt; ; echo bar; } &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>And now this sequence of commands:</p><ol><li><p><code>bazel build //:bar</code>: This first command causes Bazel to build <code>//:bar</code>, possibly from scratch. This takes at least 10 seconds due to the <code>sleep</code> calls we introduced in the commands. As a side-effect of this operation, Bazel populates its in-memory graph with the actions that it executed and the outputs they produced.</p></li><li><p><code>bazel build //:bar</code>: This second command asks Bazel to do the same build as the first command and, because we <em>just</em> built <code>//:bar</code> and Bazel&rsquo;s in-memory state is untouched, we expect Bazel to do absolutely nothing. In fact, this command completes (or should complete) in just a few milliseconds due to Bazel&rsquo;s design.</p></li><li><p><code>bazel shutdown</code>: This third command shuts the background local Bazel server process down. All in-memory state populated by the first command is lost.</p></li><li><p><code>bazel build //:bar</code>: This fourth command asks Bazel to do the same build as the first and second commands. We didn&rsquo;t run a <code>bazel clean</code> so all on-disk state is still present, so we should expect Bazel to <em>not</em> rebuild <code>//:foo</code> nor <code>//:bar</code>. And indeed they are not rebuilt: Bazel also &ldquo;does nothing&rdquo; like in that second command (the <code>sleep</code>s don&rsquo;t run), but the build is visibly slower in this case.</p></li></ol><p>The problem or, rather, question is&mldr; how does Bazel <em>know</em> that there is nothing to do on that fourth command? A system like Make would discover that all output files are &ldquo;up to date&rdquo; by comparing their timestamps against those of their inputs, but remember that Bazel tracks output staleness by inspecting the content <em>digests</em> of the inputs and ensuring they haven&rsquo;t changed.</p><p>Enter the <strong>Action Cache (AC)</strong>: an on-disk persistent cache that helps Bazel determine whether the outputs of an action are already present on disk and whether they already have the expected (up-to-date) content. The AC lives under <code>~/.cache/bazel/_bazel_${USER?}/${WORKSPACE_HASH?}/action_cache/</code> and is stored in a special binary format that you can dump with <code>bazel dump --action_cache</code>.</p><p>Conceptually, the AC maps the <code>ActionKey</code>s that we saw in the previous article to their corresponding <code>ActionResult</code>s. In practice, the AC keys are a more succinct representation of the on-disk state of the inputs to the action: up until Bazel 9, the keys were known as &ldquo;digest keys&rdquo; but things have <a href=https://github.com/bazelbuild/bazel/commit/ec10da4e3fada5fdf80d809d44b32e331e2b322b>changed recently</a> to allow Bazel to better explain why certain actions are rebuilt; the details are uninteresting in this article though.</p><p>But what is an <code>ActionResult</code>? The &ldquo;action result&rdquo; records, well, the side-effects of the action. Among other things, the <code>ActionResult</code> contains:</p><ul><li>The exit code of the process executed by the action.</li><li>A mapping of output <em>names</em> to output <em>digests</em>.</li></ul><p>The mapping of output names to digests is the piece of information I want to focus on because this is what allows the fourth Bazel invocation above to discover that it has &ldquo;nothing to do&rdquo;. When Bazel has lost its in-memory state of an action, Bazel queries the AC to determine the names of its outputs. If those files exist on disk, then Bazel can compute their digests and compare those against the digests recorded in the <code>ActionResult</code>. If they match, Bazel can conclude that the action does not have to be re-executed.</p><p>And this explains why the fourth Bazel invocation is visibly slower than the second invocation, even if both are &ldquo;fully cached&rdquo;: when the in-memory state of an action is lost, Bazel has to re-digest all input and output files that are on disk, and these are slow operations, typically I/O-bound. If you have seen annoying pauses with the <code>checking cached actions</code> message, you now know what they are about.</p><h1 id=introducing-remote-caching>Introducing remote caching</h1><p>The AC is, maybe surprisingly, a concept that exists even if Bazel is <em>not</em> talking to a remote cache or execution system. But what happens when we introduce a remote cache into the mix?</p><p>First of all, the remote cache needs to be able to answer the same questions as the local AC: &ldquo;given an action key, is the action result already known?&rdquo; But let&rsquo;s think through what goes into the result of such a query. Does the remote AC capture the same information that goes into a local <code>ActionResult</code>, or does it do something different?</p><p>Given that we are talking about a remote cache, it&rsquo;s tempting to say that the value of the cache entry should embed the <em>content</em> of the output files: after all, if Bazel scores a remote AC hit, Bazel will need to retrieve the resulting output files to use them for subsequent actions, right? Not so fast:</p><ul><li><p>What if Bazel <em>already</em> has the output files on disk but is just querying the remote AC because the local in-memory state was lost? In this case, you want the response from the cache to be as small and quick as possible: you do not want to fetch the output contents again because they may be very large.</p></li><li><p>What if you (the user) <em>don&rsquo;t care</em> about the output&rsquo;s content? Take a look at the actions in the example above: if <em>all</em> of them are cached, when I ask Bazel to build <code>//:bar</code> I <em>probably</em> only want to download <code>bar.txt</code> from the remote cache. I may not care about the intermediate <code>foo.txt</code>, so why should I be forced to fetch it when I query the cache just to know if <code>//:foo</code> is known?</p></li><li><p>What if I&rsquo;m using remote execution and I&rsquo;m building and running a test? The test runs remotely, so the local machine does not need to download <em>any</em> file at all!</p></li></ul><p>This is why the <code>ActionResult</code>, even for the remote AC, does <em>not</em> contain the content of the outputs.</p><p>But then&mldr; how is the remote cache ever useful across users or machines, or even in a simple sequence like this?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>bazel build //:bar
</span></span><span class=line><span class=cl>bazel clean
</span></span><span class=line><span class=cl>bazel build //:bar
</span></span></code></pre></div><p>The <code>bazel clean</code> in between these two builds causes all disk state (the local AC and the local output tree) to be lost. In this situation, Bazel will leverage the remote AC to know the names of the output files and their digests for each action&mldr; but if those outputs are not present on the local disk anymore, then what? Do we just rebuild the action? That&rsquo;d&mldr; work, but it&rsquo;d defeat the whole purpose of remote caching.</p><p>Enter the <strong>Content Addressable Storage (CAS)</strong>, another cache provided by the remote caching system to solve this problem. The CAS maps file digests (<em>not</em> names!) to their <em>contents</em>. Nothing more, nothing less. By leveraging both the AC and the CAS, Bazel can recreate its on-disk view of an already-built target by first checking with the AC what files should exist and then leveraging the CAS to fetch those files.</p><p>Let&rsquo;s visualize everything explained above via sequence diagrams.</p><p>This first diagram represents the initial <code>bazel build //:bar</code> invocation, assuming that <code>//:bar</code> has not been built at all by anyone beforehand. This means that Bazel will not be able to score any local nor remote AC hits and therefore will have to execute all actions:</p><figure><img src=/images/2025-09-05-bazel-remote-caching-uncached-build.png width=100%></figure><p>This second diagram represents the second <code>bazel build //:bar</code> invocation executed after <code>bazel clean</code>. In this case, all local state has been lost, but Bazel is able to score remote cache hits and recreate the local disk state by downloading entries from the remote AC and CAS. The dashed lines against the CAS represent optional operations, controlled by the use (or not) of the &ldquo;Build Without The Bytes&rdquo; feature.</p><figure><img src=/images/2025-09-05-bazel-remote-caching-cached-build.png width=100%></figure><p>Before moving on to the fun stuff, a little subtlety: whenever the AC and CAS use digests, they don&rsquo;t just use a hash. Instead, they use hash/size pairs. This adds extra protection against <a href=https://en.wikipedia.org/wiki/Length_extension_attack>length extension attacks</a> and allows both Bazel and the remote cache to cheaply detect data inconsistencies should they ever happen.</p><h1 id=lets-poison-the-cache>Let&rsquo;s poison the cache</h1><p>With any remote caching system, we must fear the possibility of invalid cached entries. We have two main types of &ldquo;invalid entries&rdquo; to worry about:</p><ul><li><p><strong>Actions that point to results that, when reused, lead to inconsistent or broken builds.</strong> This can happen if the cache keys fail to capture some detail of the execution environment. For example: if we have different glibc versions on the machines that store action results into the remote cache, we can end up with object files that are incompatible across machines because the glibc version is <em>not</em> part of the cache key.</p></li><li><p><strong>Actions that point to malicious results injected by a malicious actor.</strong> The attack vector looks like this: a malicious actor makes a <code>CppCompile</code> action point to a poisoned object file that steals credentials and uploads them to a remote server. This object file is later pulled by other machines when building tools that engineers run or when building binaries that end up in production, leading to the compromised code spreading to those binaries.</p></li></ul><p>Scary stuff. But can this attack vector happen? Let&rsquo;s see how an attacker might try to compromise the remote cache.</p><p>If the attacker can inject a malicious blob into the CAS, we now have a new entry indexed by its digest that points to some dangerous file. But&mldr; how can we access such file? To access such file, we must first know its digest. Bazel uses the digests stored in the AC to determine which files to download from the CAS so, as long as there is no entry in the AC pointing to the bad blob, the bad blob is invisible to users and is not used. We have no problem here.</p><p>The real danger comes from an attacker having write access to the AC. If the attacker can write arbitrary entries to the AC, they can pretty much point any action to compromised results. Therefore, the content of the AC is precious.</p><h1 id=protecting-the-remote-cache>Protecting the remote cache</h1><p>In order to offer a secure and reliable remote cache system, we must restrict who can write to the cache. And because we can&rsquo;t control what users do on their machines (intentionally or not), the only option we have is to restrict writes to the AC to builds that run on CI. After all, CI is a trusted environment so we can assume attackers cannot compromise it.</p><p>But that&rsquo;s not enough! Attackers can <em>still</em> leverage a naive CI system to inject malicious outputs into the cache. Consider this: an attacker creates a PR that modifies the scripts executed by CI. This change leverages the credentials of the CI system to write a poisoned entry into the AC. This poisoned entry targets an action that almost-never changes (something at the bottom of the build graph) to prevent it from being evicted soon after. The attacker runs the PR through CI and then deletes the PR to erase traces of their actions. From there on, the poisoned artifact remains in the cache and can be reused by other users.</p><p>Yikes. How do we protect against this? The reality is that we just cannot, at least not in a very satisfactory way. If the CI system runs untrusted code as submitted in a PR, the CI system can be compromised. We can mitigate the threat by doing these:</p><ul><li><p>For CI runs against PRs (code not yet reviewed and merged):</p><ul><li><p>Disallow running the CI workflows if the changes modify the CI infrastructure in any way (CI configurations, scripts run by CI, the Bazel configuration files, etc.)</p></li><li><p>Configure Bazel with <code>--noremote_upload_local_results</code> so that <code>genrule</code>s or other actions that could produce tampered outputs cannot propagate those to other users.</p></li></ul></li><li><p>For CI runs against merged code:</p><ul><li>Configure Bazel with <code>--remote_upload_local_results</code> so that they are the only ones that can populate the remote cache. If there is any malicious activity happening at this stage, which could still happen via sloppy code reviews or smart deceit, at least you will be able to collect audit logs and have the possibility of tracing back the bad changes to a person.</li></ul></li></ul><p>This configuration should provide a reasonably secure system at the expense of slightly lower cache hit rates: users will not be able to benefit from cached artifacts until their code has been merged and later built by CI. But&mldr; doing otherwise would be reckless.</p><p>Before concluding: what about the CAS? Is it truly safe to allow users to freely write to the CAS? As we have seen before, it is really difficult for a malicious entry in the CAS to become problematic unless it is referenced by the AC. But still, we have a couple of scenarios to worry about:</p><ul><li><p><strong>DoS attacks:</strong> Malicious users could bring the remote cache &ldquo;down&rdquo; (making it less effective) by flooding the CAS with noise, pushing valid artifacts out of it, or by exhausting all available network bandwidth. This is not a big concern in a corporate environment where you&rsquo;d be able to trace abusive load to a user, but you might still run into this due to accidental situations.</p></li><li><p><strong>Information disclosure:</strong> If a malicious user can somehow guess the digest of a sensitive file (e.g. a file with secrets), they could fetch such file. So&mldr; how much do you trust cryptography?</p></li></ul><h1 id=next-steps>Next steps</h1><p>As presented in this article, deploying an effective remote cache for Bazel in a manner that&rsquo;s secure is not trivial. And if you try to make the setup secure, the effectiveness of the remote cache is lower that desirable because users can only leverage remote caching for builds executed on CI: any builds they run locally, possibly with configurations that CI doesn&rsquo;t plan for, won&rsquo;t be cached.</p><p>The only way to offer a truly secure remote caching system is by <em>also</em> leveraging remote execution. We&rsquo;ll see how and why in the next episode.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/07/bazel-action-determinism.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/09/bazel-remote-execution.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Understanding+Bazel+remote+caching&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-caching.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Understanding+Bazel+remote+caching&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-caching.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Understanding+Bazel+remote+caching+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-caching.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>