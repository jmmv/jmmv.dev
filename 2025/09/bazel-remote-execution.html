<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Trusting builds with Bazel remote execution - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Trusting builds with Bazel remote execution - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Trusting builds with Bazel remote execution - Julio Merino (jmmv.dev)"><meta name=description content="The previous article on Bazel remote caching concluded that using just a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The reason behind the restrictions was that it is impossible to safely reuse a cache across users. Or is it?
In this article, we&rsquo;ll see how leveraging remote execution in conjunction with a remote cache opens the door to safely sharing the cache across users. The reason is that remote execution provides a trusted execution environment for actions, and this opens the door to cross-user result sharing. Let&rsquo;s see why and how.
"><meta property="og:description" content="The previous article on Bazel remote caching concluded that using just a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The reason behind the restrictions was that it is impossible to safely reuse a cache across users. Or is it?
In this article, we&rsquo;ll see how leveraging remote execution in conjunction with a remote cache opens the door to safely sharing the cache across users. The reason is that remote execution provides a trusted execution environment for actions, and this opens the door to cross-user result sharing. Let&rsquo;s see why and how.
"><meta property="twitter:description" content="The previous article on Bazel remote caching concluded that using just a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/09/bazel-remote-execution.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/09/bazel-remote-execution.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-09-12-bazel-remote-execution-cover-image.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-09-12-bazel-remote-execution-cover-image.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzA5L2JhemVsLXJlbW90ZS1leGVjdXRpb24uaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/bazel-remote-execution")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Trusting builds with Bazel remote execution</h1><p>September 12, 2025 &#183;
About 12 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/bazel-remote-execution>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-09-12-bazel-remote-execution-cover-image.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>The previous article on <a href=/2025/09/bazel-remote-caching.html>Bazel remote caching</a> concluded that using <em>just</em> a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The reason behind the restrictions was that it is impossible to safely reuse a cache across users. Or is it?</p><p>In this article, we&rsquo;ll see how leveraging remote execution in conjunction with a remote cache opens the door to safely sharing the cache across users. The reason is that remote execution provides a trusted execution environment for actions, and this opens the door to cross-user result sharing. Let&rsquo;s see why and how.</p><h1 id=remote-execution-basics>Remote execution basics</h1><p>As we saw in <a href=/2025/07/bazel-action-determinism.html>the article about action determinism</a>, Bazel&rsquo;s fundamental unit of execution is <em>the action</em>. Consequently, a remote execution system is going to concern itself with efficiently running individual actions, not builds, and caching the results of those. This distinction is critical because there are systems out there that work differently, such as <a href=https://www.microsoft.com/en-us/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/>Microsoft&rsquo;s CloudBuild</a>, <a href=https://www.buildbuddy.io/docs/remote-bazel/>Buildbuddy&rsquo;s Remote Bazel</a>, or even <a href=/2025/03/bazel-next-generation.html>the shiny and new Bonanza</a>.</p><p>When we configure remote execution via the <code>--remote_executor</code> flag, Bazel enables the <code>remote</code> action <a href=/2019/12/bazel-strategies.html>execution strategy</a> by default for all actions, just as if we had done <code>--strategy=remote</code>. But this is only a default and users can mix-and-match remote and local strategies by leveraging the various <code>--strategy*</code> selection flags or by specifying execution requirements in individual actions.</p><figure><img src=/images/2025-09-12-bazel-remote-execution-strategies.png width=100%></figure><p>A remote execution system is complicated as it is typically implemented by many services:</p><ul><li><p><strong>Multiple frontends.</strong> These are responsible for accepting user requests and tracking results. These might include implement a second-level CAS to fan out traffic to clients.</p></li><li><p><strong>A scheduler.</strong> This is responsible for enqueuing action requests and distributing them to workers. Whether the scheduler uses a pull or push model to distribute work is implementation dependent.</p></li><li><p><strong>Multiple workers.</strong> These are responsible for action execution and are organized in pools of distinct types (workers for x86, workers for arm64, etc.) Internally, a worker is divided into two conceptual parts: the <strong>worker</strong> itself, which is the privileged service that monitors action execution, and the <strong>runner</strong>, which is a containerized process that actually runs the untrusted action code.</p></li><li><p><strong>The components of a remote cache (a CAS and an AC).</strong> The CAS is essential for communication between Bazel and the workers. The AC, which is optional, is necessary for action caching. The architecture of the cache varies from service to service.</p></li></ul><p>For the purposes of this article, I want to focus primarily on the workers and their interactions with the AC and the CAS. I&rsquo;m not going to talk about frontends nor schedulers except for showing how they help isolate remote action execution from the Bazel process.</p><h1 id=worker-and-accas-interactions>Worker and AC/CAS interactions</h1><p>Let&rsquo;s look at the interaction between these components in more detail. To set the stage, take a look at the <code>combine</code> action from this sample build file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;generate&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;gen.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;echo generated &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;combine&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;combined.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:src.txt&#34;</span><span class=p>,</span> <span class=s2>&#34;:gen.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;cat $(location :src.txt) $(location :gen.txt) &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>The <code>combine</code> action has two types of inputs: a checked-in source file, <code>src.txt</code>, and a file generated during the build, <code>gen.txt</code>. This distinction is interesting because the way these files end up in the CAS is different: Bazel is the one responsible for uploading <code>src.txt</code> into the CAS, but <code>gen.txt</code> is uploaded by the worker upon action completion.</p><p>When we ask Bazel to build <code>//:combine</code> remotely, and assuming <code>//:generate</code> has already been built and cached at some point in the past, we&rsquo;ll experience something like this:</p><figure><img src=/images/2025-09-12-bazel-remote-execution-execution.png width=100%></figure><p>That&rsquo;s a lot of interactions, right?! Yes; yes they are. A remote execution system is not simple and it&rsquo;s not always an obvious win: coordinating all of these networked components is costly. The overheads become tangible when dealing with short-lived actions&mdash;a better fit for persistent workers&mdash;or when you have a sequential chain of actions&mdash;a good fit for <a href=/2019/12/bazel-dynamic-execution-strategy.html>the dynamic execution strategy</a>.</p><p>What I want you to notice here, because it&rsquo;s critical for our analysis, is the shaded area. Note how all interactions within this area are driven by the remote execution service, <em>not</em> Bazel. Once an action enters the remote execution system, neither Bazel <em>nor the machine running Bazel</em> have any way of tampering with the execution of the remote action. They cannot influence the action&rsquo;s behavior, and they cannot interfere with the way it saves its outputs into the AC and the CAS.</p><p>And this decoupling, my friend, is the key insight that allows Bazel to safely share the results of actions across users no matter who initiated them. However, the devil lies in the implementation details.</p><h1 id=securing-the-worker>Securing the worker</h1><p>Given the above, we now know that remote workers are a trusted environment: the actions that go into a worker are fully specified by their action key and, therefore, whatever they produce and is stored into the AC and the CAS will match that action key. So if we trust the inputs to the action, we can trust its outputs, and we can do this retroactively&mldr; right?</p><p>Well, not so fast. For this to be true, actions must be deterministic, and they aren&rsquo;t always <a href=/2025/07/bazel-action-determinism.html>as we already saw</a>. Some sources of non-determinism are &ldquo;OK&rdquo; in this context though, like timestamps, because these come from within the worker and cannot be tampered with. Other sources of non-determinism are problematic though, like this one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;generate&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;gen.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;curl -L https://secure.example.com/payload.txt &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>An attacker could compromise the network request to modify the content of the downloaded file, but only for long enough to poison the remote cache with a malicious artifact. Once poisoned, they could restore the remote file to its original content and it would be very difficult to notice that the entry in the remote cache did not match the intent of this rule.</p><p>It is tempting to say: &ldquo;ah, the above should be fixed by ensuring the checksum of the download is valid&rdquo;, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;generate&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;gen.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        curl -L https://secure.example.com/payload.txt &gt;$@
</span></span></span><span class=line><span class=cl><span class=s2>        [ &#34;$$(sha256sum $@ | awk &#39;{print $1}&#39;)&#34; = &#34;known checksum&#34; ]
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>And I&rsquo;d say, yes, you absolutely need to do checksum validation because there are legitimate cases where you&rsquo;ll find yourself writing code like this&mldr; in repo rules. Unfortunately, such checks are still insufficient for safe remote execution because, remember: actions can run from unreviewed code, or the code that runs them can be merged into the tree after a careless review (which is more common than you think). Consequently, the only thing you can and must do here is to <strong>disable network access</strong> in the remote worker.</p><p>That said, <em>just</em> disabling network access may still be &ldquo;not good enough&rdquo; to have confidence in the safety of remote execution. A remote execution system is trying to run untrusted code within a safe production environment: code that could try to attack the worker to escape whatever sandbox/container you have deployed, code that could try to influence other actions running on the same machine, or code that could exfiltrate secrets present in the environment. Securing these is going to come down to standard practices for untrusted code execution, none of which are specific to Bazel, so I&rsquo;m not going to cover them. Needless to say, it&rsquo;s a difficult problem.</p><h1 id=securing-the-build>Securing the build</h1><p>If we have done all of the above, we now have a remote execution system that we can trust to run actions in a secure manner and to store their results in <em>both</em> the AC and the CAS. But&mldr; this, on its own, is still insufficient to secure builds end-to-end, and we would like to have trusted end-to-end builds to establish a chain of trust between sources and production artifacts, right?</p><p>To secure a build, we must protect the AC and restrict writes to it to happen exclusively from the remote workers. Only them, who we have determined cannot be interfered with, know that the results of an action correspond to its declared inputs&mdash;and therefore, only them can establish the critical links between an AC entry and one or more files in the CAS. You&rsquo;d imagine that simply setting <code>--noremote_upload_local_results</code> would be enough, but it isn&rsquo;t. A malicious user could still tamper with this flag in transient CI runs or&mldr; well, in their local workstation. And it&rsquo;s because of this latter scenario that the only possible way to close this gap is via network level ACLs: the AC should only be writable from within the remote execution cluster.</p><p>But&mldr; you guessed it: that&rsquo;s <em>still</em> insufficient. Even if we disallow Bazel clients from writing to the AC, an attacker can still make Bazel run malicious actions <em>outside</em> of the remote execution cluster&mdash;that is, on the CI machine locally, which does have network access. Such action wouldn&rsquo;t record its result in the AC, but the <em>output</em> of the action would go into the CAS, and this problematic action could then be consumed by a subsequent action as an input.</p><p>The problem here stems from users being able to bypass remote execution by tweaking <code>--strategy*</code> flags. One option to protect against this situation is the same as we saw before: disallow CI runs of PRs that modify Bazel flags so that users cannot &ldquo;escape&rdquo; remote execution. Unfortunately, this doesn&rsquo;t have great ergonomics because users often need to change the <code>.bazelrc</code> file as part of routine operation.</p><p>Bazel&rsquo;s answer to this problem is the widely-unknown <strong>invocation policy</strong> feature. I say unknown because I do not see it documented in the output of <code>bazel help</code> and I cannot find any details about it whatsoever online&mdash;yet I know of its existence from my time at Google and I see its implementation in the Bazel code base, so we can reverse-engineer how it works.</p><h1 id=invocation-policies>Invocation policies</h1><p>As the name implies, an <strong>invocation policy</strong> is a mechanism to enforce specific command-line flag settings during a build or test with the goal of ensuring that conventions and security policies are consistently applied. The policy does so by defining rules to set, override, or restrict the values of flags, such as <code>--strategy</code>.</p><p>The policy is defined using the <code>InvocationPolicy</code> protobuf message defined in <a href="https://cs.opensource.google/bazel/bazel/+/master:src/main/protobuf/invocation_policy.proto;drc=04aec051070d5bb0455b8ed0aea9a869b4078af4"><code>src/main/protobuf/invocation_policy.proto</code></a>. This message contains a list of <code>FlagPolicy</code> messages, each of which defines a rule for a specific flag. The possible rules, which can be applied conditionally on the Bazel command being executed, are:</p><ul><li><code>SetValue</code>: Sets a flag to a specific value. You can control whether the user can override this value. This is useful for enforcing best practices or build-time configurations.</li><li><code>UseDefault</code>: Forces a flag to its default value, effectively preventing the user from setting it.</li><li><code>DisallowValues</code>: Prohibits the use of certain values for a flag. If a user attempts to use a disallowed value, Bazel will produce an error. You can also specify a replacement value to be used instead of the disallowed one.</li><li><code>AllowValues</code>: Restricts a flag to a specific set of allowed values. Any other value will be rejected.</li></ul><p>To use an invocation policy, you have to define the policy as an instance of the <code>InvocationPolicy</code> message in text or base64-encoded binary protobuf format and pass the payload to Bazel using the <code>--invocation_policy</code> flag in a way that users cannot influence (e.g. directly from your CI infrastructure, not from workflow scripts checked into the repo).</p><p>Let&rsquo;s say you want to enforce a policy where the <code>--genrule_strategy</code> flag is always set to <code>remote</code> when running the <code>bazel test</code> command, and you want to prevent users from overriding this setting. We define the following policy in a <code>policy.txt</code> file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=n>flag_policies</span><span class=o>:</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=n>flag_name</span><span class=o>:</span> <span class=s>&#34;genrule_strategy&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=n>commands</span><span class=o>:</span> <span class=s>&#34;build&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=n>set_value</span><span class=o>:</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=n>flag_value</span><span class=o>:</span> <span class=s>&#34;remote&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=n>behavior</span><span class=o>:</span> <span class=n>FINAL_VALUE_THROW_ON_OVERRIDE</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>And then we invoke Bazel like this (again, remember: this flag should be passed by CI in a way that users cannot influence):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bazel --invocation_policy<span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span>cat policy.txt<span class=k>)</span><span class=s2>&#34;</span> build ...
</span></span></code></pre></div><p>If you now try to play with the <code>--genrule_strategy</code> flag, you&rsquo;ll notice that any overrides you provide don&rsquo;t work. (Bazel 9 will offer a new <code>FINAL_VALUE_THROW_ON_OVERRIDE</code> flag behavior to error out instead of silently ignoring overrides which will make the experience nicer in this case.)</p><h1 id=case-study-remote-local-fallback-poisoning>Case study: remote local fallback poisoning</h1><p>Before concluding, I&rsquo;d like to show you an interesting outage we faced due to Bazel being allowed to write AC entries from a trusted CI environment. The problem we saw was that, at some point, users started reporting that their builds were completely broken: somehow, the build of our custom singlejar helper tool, a C++ binary that&rsquo;s commonly used in Java builds, started failing due to the inability of the C++ compiler to find some header files.</p><p>This didn&rsquo;t make any sense. If we built the tree at a previous point in time, the problem didn&rsquo;t surface. And as we discovered later, if we disabled remote caching on a current commit the problem didn&rsquo;t appear either. Through a series of steps, we found that singlejar&rsquo;s build from scratch would fail if we tried to build it locally <em>without</em> the sandbox. But&mldr; that&rsquo;s not something we do routinely, so how did this kind of breakage leak into the AC?</p><p>The problem stemmed from our use of <code>--remote_local_fallback</code>, a flag we had enabled long ago to mitigate flakiness when leveraging remote execution. Because of this flag, we had hit this problematic path:</p><ol><li><p>An build started on CI. This build used a remote-only configuration, forcing all actions to run on the remote cluster.</p></li><li><p>Bazel ran actions remotely for a while, but at some point, encountered problems while building singlejar.</p></li><li><p>Because of <code>--remote_local_fallback</code>, Bazel decided to build singlejar on the CI machine, not on the remote worker, and it used the <code>standalone</code> strategy, <em>not</em> the <code>sanboxed</code> strategy, to do so. This produced an action result that was later incompatible with sandboxed / remote actions.</p></li><li><p>Because of <code>--remote_upload_local_results</code>, the &ldquo;bad&rdquo; action result was injected into the AC.</p></li><li><p>From here on, any remote build that picked the bad action result would fail.</p></li></ol><p>The mitigation to this problem was to flush the problematic artifact from the remote cache, and the immediate solution was to set <code>--remote_local_fallback_strategy=sandboxed</code> which&mldr; Bazel claims is deprecated and a no-op, but in reality this works and I haven&rsquo;t been able to find an alternative (at least not in Bazel 7) via any of the other strategy flags.</p><p>The real solution, however, is to ensure that remote execution doesn&rsquo;t require the local fallback option for reliability reasons, and to prevent Bazel from injecting AC entries for actions that do not run in the remote workers.</p><h1 id=parting-words>Parting words</h1><p>With that, this series to revisit Bazel&rsquo;s action execution fundamentals, remote caching, and remote execution is complete. Which means I can <em>finally</em> tell you the thing that started this whole endeavor: the very specific, cool, and technical solution I implemented to work around a hole in the action keys that can lead to very problematic non-determinism.</p><p>But, to read on that topic, you&rsquo;ll have to wait for the next episode!</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/09/bazel-remote-caching.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/09/glibc-versions-bazel.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Trusting+builds+with+Bazel+remote+execution&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-execution.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Trusting+builds+with+Bazel+remote+execution&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-execution.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Trusting+builds+with+Bazel+remote+execution+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fbazel-remote-execution.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.jmmv.dev/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>