<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Bazel and glibc versions - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Bazel and glibc versions - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Bazel and glibc versions - Julio Merino (jmmv.dev)"><meta name=description content="Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, gets a cache hit from the developer&rsquo;s build, and produces a release artifact. Everything looks green. But when you deploy to production, the service crashes with a mysterious error: version 'GLIBC_2.28' not found. What went wrong?
"><meta property="og:description" content="Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, gets a cache hit from the developer&rsquo;s build, and produces a release artifact. Everything looks green. But when you deploy to production, the service crashes with a mysterious error: version 'GLIBC_2.28' not found. What went wrong?
"><meta property="twitter:description" content="Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/09/glibc-versions-bazel.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/09/glibc-versions-bazel.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-09-19-glibc-versions-bazel-cover-image.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-09-19-glibc-versions-bazel-cover-image.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzA5L2dsaWJjLXZlcnNpb25zLWJhemVsLmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/glibc-versions-bazel")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Bazel and glibc versions</h1><p>September 19, 2025 &#183;
About 11 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/unix>unix</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/glibc-versions-bazel>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-09-19-glibc-versions-bazel-cover-image.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, gets a cache hit from the developer&rsquo;s build, and produces a release artifact. Everything looks green. But when you deploy to production, the service crashes with a mysterious error: <code>version 'GLIBC_2.28' not found</code>. What went wrong?</p><p>The answer lies in the subtle but dangerous interaction between Bazel&rsquo;s caching, remote execution, and differing glibc versions across your fleet. In previous posts in this series, I&rsquo;ve covered the fundamentals of <a href=/2025/07/bazel-action-determinism.html>action non-determinism</a>, <a href=/2025/09/bazel-remote-caching.html>remote caching</a>, and <a href=/2025/09/bazel-remote-execution.html>execution execution</a>. Now, finally, we&rsquo;ll build on those to tackle this specific problem.</p><p>This article dives deep into how glibc versions can break build reproducibility and presents several ways to fix it&mdash;from an interesting hack (which spawned this whole series) to the ultimate, most robust solution.</p><h1 id=the-scenario>The scenario</h1><p>Suppose you have a pretty standard (corporate?) development environment like the following:</p><ul><li><p><strong>Developer workstations (WS).</strong> This is where Bazel runs during daily development, and Bazel can execute build actions both locally and remotely.</p></li><li><p><strong>A CI system.</strong> This is a distributed cluster of machines that run jobs, including PR merge validation and production release builds. These jobs execute Bazel too, who in turn executes build actions both locally and remotely.</p></li><li><p><strong>The remote execution (RE) system.</strong> This is a distributed cluster of worker machines that execute individual Bazel build actions remotely. The key components we want to focus on today are the AC, the CAS, and the workers&mdash;all of which I covered in detail in the previous two articles.</p></li><li><p><strong>The production environment (PROD).</strong> This is where you deploy binary artifacts to serve your users. No build actions run here.</p></li></ul><figure><img src=/images/2025-09-19-glibc-versions-bazel-environment.png width=100%></figure><p>All of the systems above run some version of Linux, and it is tempting to wish to keep such version in sync across them all. The reasons would include keeping operations simpler and ensuring that build actions can run consistently no matter where they are executed.</p><p>However, this wish is misguided and plain impossible. It is misguided because you may not want to run the same Linux distribution on all three environments: after all, the desktop distribution you run on WS may not be the best choice for RE workers, CI nodes, nor production. And it is plain impossible because, even if you aligned versions to the dot, you would need to take upgrades at some point: distributed upgrades must be rolled out over a period of time (weeks or even months) for reliability, so you&rsquo;d have to deal with version skew anyway.</p><p>To make matters more complicated, the remote AC is writable from all of WS, CI, and RE to maximize Bazel cache hits and optimize build times. This goes against best security practices (so there are mitigations in place to protect PROD), but it&rsquo;s a necessity to support an ongoing onboarding into Bazel and RE.</p><h1 id=the-problem>The problem</h1><p>The question becomes: can the Linux version skew among all machines involved cause problems with remote caching?</p><p>It sure can because C and C++ build actions tend to pick up system-level dependencies in a way that Bazel is unaware of (by default), and those influence the output the actions produce. Here, look at this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ nm prod-binary | grep GLIBC_2.28
</span></span><span class=line><span class=cl>        U mtx_init@@GLIBC_2.28
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p><strong>The version of glibc leaks into binaries</strong> and <strong>this is invisible to Bazel&rsquo;s C/C++ action keys</strong>. glibc versions its symbols to provide runtime backwards compatibility when their internal details change, and this means that binaries built against newer glibc versions may not run on systems with older glibc versions.</p><p>How is this a problem though? Let&rsquo;s take a look by making the problem specific. Consider the following environment:</p><table><thead><tr><th>Environment</th><th>Purpose</th><th>glibc version</th></tr></thead><tbody><tr><td>WS</td><td>Developer workstations</td><td>2.28</td></tr><tr><td>CI-1</td><td>CI production environment</td><td>2.17</td></tr><tr><td>CI-2</td><td>CI staging environment</td><td>2.28</td></tr><tr><td>RE</td><td>Shared RE cluster</td><td>2.17</td></tr><tr><td>PROD</td><td>Production deployments</td><td>2.17</td></tr></tbody></table><p>In this environment, developers run Bazel in WS for their day-to-day work, and CI-1 runs Bazel to support development flows (PR merge-time checks) and to produce binaries for PROD. CI-2 sometimes runs builds too. All of these systems can write to the AC that lives in RE.</p><p>As it so happens, one of the C++ actions involved in the build of <code>prod-binary</code>, say <code>//base:my_lib</code>, has a <code>local</code> tag which forces the action to bypass remote execution. This can lead to the following sequence of events:</p><ol><li><p>A developer runs a build on a WS. <code>//base:my_lib</code> has changed so it is rebuilt on the WS. The action uses the C++ compiler, so the object files it produces pick up the dependency on glibc 2.28. The result of the action is injected into the remote cache.</p></li><li><p>CI-1 schedules a job to build <code>prod-binary</code> for release. This job runs Bazel on a machine with glibc 2.17 and leverages the RE cluster which also contain glibc 2.17. Many C++ actions get rebuilt <em>but</em> <code>//base:my_lib</code> is reused from the cache. The production artifact now has a dependency on symbols from glibc 2.28.</p></li><li><p>Release engineering picks the output of CI-1, deploys the production binary to PROD, and&mldr; boom, PROD explodes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>./prod-binary: /lib64/libc.so.6: version `GLIBC_2.28&#39; not found (required by ./prod-binary)
</span></span></code></pre></div></li></ol><p>The fact that the developer WS could write to the AC is very problematic on its own, but we could encounter this same scenario if we first ran the production build on CI-2 for testing purposes and then reran it on CI-1 to generate the final artifact.</p><p>So, what do we do now? In a default Bazel configuration, C and C++ action keys are underspecified and can lead us to non-deterministic behavior when we have a mixture of host systems compiling them.</p><h1 id=solution-a-manually-partition-the-ac>Solution A: manually partition the AC</h1><p>Let&rsquo;s start with the case where you aren&rsquo;t yet ready to strictly restrict writes to the AC from RE workers, yet you want to prevent obvious mistakes that lead to production breaks.</p><p>The idea here is to capture the glibc version that is used in the local and remote environments, pick the higher of the two, and make that version number an input to the C/C++ toolchain. This causes the version to become part of the cache keys and should prevent the majority of the mistakes we may see.</p><p>WARNING: This is The Hack I recently implemented and that drove me to writing this article series! Prefer the options presented later, but know that you have this one up your sleeve if you must mitigate problems quickly.</p><p>To implement this hack, the first thing we have to do is capture the local glibc version. We can do this with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;glibc-local-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;glibc-local-version.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;grep GNU_LIBC_VERSION bazel-out/stable-status.txt </span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s2>        | cut -d &#39; &#39; -f 2- &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>stamp</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>tags</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;sandboxed&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>One important tidbit here is the use of the <code>stable-status.txt</code> file, indirectly via the requirement of stamping. This is necessary to force this action to rerun on every build because we don&rsquo;t want to hit the case of using an old <code>bazel-out</code> tree against an upgraded system. As a consequence, we need to modify the script pointed at by <code>--workspace_status_command</code> script (you have one, right?) to emit the glibc version:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;STABLE_GNU_LIBC_VERSION </span><span class=k>$(</span>getconf GNU_LIBC_VERSION<span class=k>)</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>The second thing we have to do is capture the remote glibc version. This is&mldr; trickier because there is no tag to force Bazel to run an action remotely. Even if we assume remote execution, features like the dynamic spawn strategy or the remote local fallback could cause the action to run locally at random. To prevent problems, we have to detect whether the action is running within RE workers or not, and the way to do that will depend on your environment:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;glibc-remote-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;glibc-remote-version.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        if [ ! -e /etc/remote-worker.cookie ]; then
</span></span></span><span class=line><span class=cl><span class=s2>            # Trick dynamic scheduling (when it is enabled) into
</span></span></span><span class=line><span class=cl><span class=s2>            # preferring to run the action remotely.
</span></span></span><span class=line><span class=cl><span class=s2>            #
</span></span></span><span class=line><span class=cl><span class=s2>            # You have two choices here: fail hard, which makes
</span></span></span><span class=line><span class=cl><span class=s2>            # this correct, or accept that this is a heuristic by
</span></span></span><span class=line><span class=cl><span class=s2>            # making the failure unlikely with a sleep.  You might
</span></span></span><span class=line><span class=cl><span class=s2>            # want the sleep if you don&#39;t want build breakages
</span></span></span><span class=line><span class=cl><span class=s2>            # when there is significant action queuing, for
</span></span></span><span class=line><span class=cl><span class=s2>            # example.
</span></span></span><span class=line><span class=cl><span class=s2>            exit 1
</span></span></span><span class=line><span class=cl><span class=s2>            #sleep 60
</span></span></span><span class=line><span class=cl><span class=s2>        fi
</span></span></span><span class=line><span class=cl><span class=s2>        getconf GNU_LIBC_VERSION &gt;$@
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>The third part of the puzzle is to select the highest glibc version between the two that we collected. We can do this with the following <code>genrule</code>, leveraging <code>sort</code>&rsquo;s <code>-V</code> flag to compare versions. This flag is a GNU extension&mldr; but we are talking about glibc anyway here so I&rsquo;m not going to be <a href=/2021/08/useless-use-of-gnu.html>bothered by it</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;glibc-max-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;:glibc-local-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;:glibc-remote-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;glibc-max-version.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        local=&#34;$$(cat $(location :glibc-local-version)
</span></span></span><span class=line><span class=cl><span class=s2>            | cut -d &#39; &#39; -f 2)&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        remote=&#34;$$(cat $(location :glibc-remote-version)
</span></span></span><span class=line><span class=cl><span class=s2>            | cut -d &#39; &#39; -f 2)&#34;
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        echo &#34;Local glibc version: $$</span><span class=si>{local}</span><span class=s2>&#34; 1&gt;&amp;2
</span></span></span><span class=line><span class=cl><span class=s2>        echo &#34;Remote glibc version: $$</span><span class=si>{remote}</span><span class=s2>&#34; 1&gt;&amp;2
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        chosen=&#34;$$(printf &#34;$$local</span><span class=se>\n</span><span class=s2>$$remote</span><span class=se>\n</span><span class=s2>&#34;
</span></span></span><span class=line><span class=cl><span class=s2>            | sort -rV | head -1)&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        echo &#34;$$</span><span class=si>{chosen}</span><span class=s2>&#34; &gt;$@
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>And, finally, we can go to our C++ toolchain definition and modify it to depend on the <code>glibc-max-version</code> produced by the previous action:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>filegroup</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;toolchain_files&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=c1># ...</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;:glibc-max-version&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=c1># ...</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cc_toolchain</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;glibc_safe_toolchain&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>all_files</span> <span class=o>=</span> <span class=n>toolchain_files</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Ta-da! All of our C/C++ actions now encode the highest possible glibc version that the outputs they produce may depend on. And, while not perfect, this is an easy workaround to guard against most mistakes.</p><p>But can we do better? Of course.</p><h1 id=solution-b-restrict-ac-writes-to-re-only>Solution B: restrict AC writes to RE only</h1><p>Based on the previous articles, what we should think about is plugging the AC hole and forcing build actions to <em>always</em> run on the RE workers. In this way, we would precisely control the environment that generates action outputs and we should be good to go.</p><p>Unfortunately, we can still encounter problems! Remember how I said that, at some point, you will have to upgrade glibc versions? What happens when you are in the middle of a rolling upgrade to your RE workers? The worker pool will end up with different &ldquo;partitions&rdquo;, each with a different glibc version, and you will still run into this issue.</p><p>To handle this case, you would need to have <em>different</em> worker pools, one with the old glibc version and one with the new version, and then make the worker pool name be part of the action keys. You would then have to migrate from one pool to the other in a controlled manner. This would work well at the expense of reducing cache effectiveness, causing a a big toll on operations, and making the rollout risky because the switch from one pool to another is a all-or-nothing proposition.</p><h1 id=solution-c-sysroots>Solution C: sysroots</h1><p>The real solution comes in the form of sysroots. The idea is to install multiple parallel versions of glibc in <em>all</em> environments and then modify the Bazel C/C++ toolchain to explicitly use a specific one. In this way, the glibc version becomes part of the cache key and all build outputs are pinned to a deterministic glibc version. This allows us to roll out a new version slowly with a code change, pinning the version switch to a specific code commit that can be rolled back if necessary, and keeping the property of <a href=https://reproducible-builds.org/>reproducible builds</a> for older commits.</p><p>This is the solution outlined at the end of <a href=/2024/08/glibc-versions-runtime.html>Picking glibc versions at runtime</a> and is the only solution that can provide you 100% safety against the problem presented in this article. It is difficult to implement, though, because convincing GCC and clang to not use system-provided libraries is tricky and because this solution will sound alien to most of your peers.</p><h1 id=what-will-you-do>What will you do?</h1><p>The problem presented in this article is far from theoretical, but it&rsquo;s often forgotten about because typical build environments don&rsquo;t present significant skew across Linux versions. This means that facing new glibc symbols is unlikely, so the chances of ending up with binary-incompatible artifacts are low. But they can still happen, and they can happen at the worst possible moment.</p><p>Therefore, you need to take action. I&rsquo;d strongly recommend that you go towards the sysroot solution because it&rsquo;s the only one that&rsquo;ll give you a stable path for years to come, but I also understand that it&rsquo;s hard to implement. Therefore, take the solutions in the order I gave them to you: start with the hack to mitigate obvious problems, follow that up with securing the AC, and finally go down the sysroot rabbit hole.</p><p>As for the glibc 2.17 mentioned en-passing above, well, it is ancient by today standards at 13 years of age, but it is what triggered this article in the first place. glibc 2.17 was kept alive for many years by the CentOS 7 distribution&mdash;an LTS system used as a core building block by companies and that reached EOL a year ago, causing headaches throughout the industry. Personally, I believe that relying on LTS distributions is a mistake that ends up costing more money/time than tracking a rolling release, but I&rsquo;ll leave that controversial topic for a future opinion post.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/09/bazel-remote-execution.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/09/you-are-holding-build-files-wrong.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Bazel+and+glibc+versions&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fglibc-versions-bazel.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Bazel+and+glibc+versions&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fglibc-versions-bazel.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Bazel+and+glibc+versions+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F09%2Fglibc-versions-bazel.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>