<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>BazelCon 2025 recap - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="BazelCon 2025 recap - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="BazelCon 2025 recap - Julio Merino (jmmv.dev)"><meta name=description content="It has been just over two years since I started Blog System/5, and that means it&rsquo;s time for the now-usual(?) BazelCon 2025 trip report!
The conference, arranged by the Linux Foundation, took place in Atlanta, GA, USA over three days: one for tutorials and two for the main talks. An extra hackathon day, organized by Aspect Build, followed. Unfortunately, a canceled flight meant I missed the tutorials, but I attended the rest of the events. As usual, it was a super-fun time to connect with old acquaintances and an energizing event that left me with plenty of new topics to research.
"><meta property="og:description" content="It has been just over two years since I started Blog System/5, and that means it&rsquo;s time for the now-usual(?) BazelCon 2025 trip report!
The conference, arranged by the Linux Foundation, took place in Atlanta, GA, USA over three days: one for tutorials and two for the main talks. An extra hackathon day, organized by Aspect Build, followed. Unfortunately, a canceled flight meant I missed the tutorials, but I attended the rest of the events. As usual, it was a super-fun time to connect with old acquaintances and an energizing event that left me with plenty of new topics to research.
"><meta property="twitter:description" content="It has been just over two years since I started Blog System/5, and that means it&rsquo;s time for the now-usual(?) BazelCon 2025 trip report!
The conference, arranged by the Linux Foundation, took â€¦"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/11/bazelcon-2025-recap.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/11/bazelcon-2025-recap.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-11-23-bazelcon.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-11-23-bazelcon.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzExL2JhemVsY29uLTIwMjUtcmVjYXAuaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/bazelcon-2025-recap")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>BazelCon 2025 recap</h1><p>November 23, 2025 &#183;
About 28 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/snowflake>snowflake</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/bazelcon-2025-recap>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-11-23-bazelcon.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>It has been just over two years since I started Blog System/5, and that means it&rsquo;s time for the now-usual(?) BazelCon 2025 trip report!</p><p>The conference, arranged by the Linux Foundation, took place in Atlanta, GA, USA over three days: one for tutorials and two for the main talks. An extra hackathon day, organized by Aspect Build, followed. Unfortunately, a canceled flight meant I missed the tutorials, but I attended the rest of the events. As usual, it was a super-fun time to connect with old acquaintances and an energizing event that left me with plenty of new topics to research.</p><p>What follows is not a complete summary of the conference, as there were many talks I did not attend and conversations I missed. If you want the full firehose of videos, see the <a href="https://www.youtube.com/playlist?list=PLak8-7eFSpowmNiR2lhvJEomLA140yban">Bazel Con 2025 YouTube playlist</a>. And if you want a TL;DR&mldr; I&rsquo;d pick the following highlights:</p><ul><li>The ecosystem is maturing with <code>bzlmod</code> becoming mandatory and the BUILD Foundation being a reality in the near horizon.</li><li>Performance remains a key focus of the Bazel core team and the community, with innovative approaches like Skycache for client-side speed, sophisticated RE improvements for backend efficiency, and new rulesets like <code>rules_img</code> that focus on build speed.</li><li>Community tooling is expanding Bazel&rsquo;s scope, with projects like Aspect&rsquo;s task runner aiming to solve long-standing workflow gaps.</li></ul><p>But the above is just tiny peek into the conference. So, strap your seat belts and let&rsquo;s dive into the conference.</p><h1 id=opening-words>Opening words</h1><p>Google opened by emphasizing their commitment to Bazel, highlighting its growing internal adoption. Their reasoning is that Bazel improves security and hermeticity, in addition to the usual benefits of faster builds and easier open-sourcing of code. This statement seems to be a response to last year&rsquo;s proposal to create a non-Google Bazel Foundation, which would act as a &ldquo;backup plan&rdquo; should Google ever withdraw from the project.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/N4e5TsiFqzQ?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Google provided two examples of its growing Bazel adoption. The first is <a href=https://quantumai.google/>Quantum AI</a>, primarily written in Python and Rust, which saw an 80% reduction in CI time after a migration to Bazel that was driven by just one SWE. The second is their <a href=https://cloud.google.com/distributed-cloud>Google Distributed Cloud (GDC)</a>, a version of their cloud product that can run on-premise and in air-gapped instances. The GDC codebase weighs 2.6 GB, is developed by 1,300 engineers, and produces 600 GB of release artifacts. I have to question if the latter is a number to be proud of: when does this madness in bloat stop?</p><p>The introduction concluded with a few statistics: Bazel&rsquo;s <code>#general</code> Slack channel has grown by 18% from the previous year to 8,500 users; there are about 10,800 repos on GitHub with <code>MODULE.bazel</code> files; and there are about 120,000 <code>bzl</code> files on GitHub.</p><h1 id=community-updates>Community updates</h1><p>The next session was the customary round of community updates, presented by Jay Conrod from EngFlow and Alex Eagle from Aspect Build.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Zpfl82MU4U0?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Here are the highlights:</p><ul><li><p><strong>Training day:</strong> There were six different sessions on the Sunday before the conference, and EngFlow is leading training efforts worldwide.</p></li><li><p><strong>Gazelle:</strong> C++ support is on the way for this tool. Version 2.0 will simplify the extensions interface and improve performance.</p></li><li><p><strong>BCR Mirror:</strong> Cloudflare is now hosting a mirror for the Bazel Central Registry (BCR). You can use it with Bazel 8.4+ by adding <code>common --module_mirrors=https://bcr.cloudflaremirrors.com/</code> to your configuration&mdash;and this will become a default in a future release.</p></li><li><p><strong>Documentation:</strong> The most common complaint in community surveys remains the documentation and the steep learning curve. To address this, <a href=https://registry.bazel.build/>the BCR website</a> now features icons for sponsorship requests, deprecation notices, and provenance attestations. Furthermore, the Starlark documentation has been published and is now easier to read. In a move to empower the community, the documentation has been migrated out of Google&rsquo;s internal infrastructure and is available at <a href=https://preview.bazel.build/>https://preview.bazel.build/</a>.</p></li><li><p><strong>BUILD Foundation:</strong> The foundation currently has three founding members (Spotify, Uber, and Canva) and is looking for four more. The initial meeting is scheduled for December 4th. More on this in its own section.</p></li></ul><p>Bzlmod was also a significant topic in this talk, but since it was covered at length in other presentations as well, I have dedicated a separate section to it below.</p><h1 id=state-of-the-union>State of the union</h1><p>As is tradition, the next session was the State of the Union talk, led by John Field and Tobias Werth from Google.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/FwruvTfClwk%20?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Here are some of the highlights from the update:</p><ul><li><p><strong>Local remote repo caching:</strong> This <a href=https://docs.google.com/document/d/1ZScqiIQi9l7_8eikbsGI-rjupdbCI7wgm1RYD76FJfM/edit>new feature</a> is intended to allow the caching of repository rules across different workspaces.</p></li><li><p><strong>Experimental WASM support:</strong> There is <a href=https://github.com/bazelbuild/bazel/discussions/25537>experimental support for WASM tools in repo rules</a> to enable platform-independent tooling, but its future is still uncertain.</p></li><li><p><strong>Performance improvements:</strong></p><ul><li>Changes to <code>NestedSets</code> can save up to 20% of memory.</li><li>Optimizations in Merkle tree handling can reduce wall time by up to 30%.</li><li>Analysis phase caching is coming soon (see the &ldquo;Skycache&rdquo; section below for more details).</li><li>There are ongoing efforts to cap disk usage.</li><li>Path stripping, a feature announced last year, is now more mature and integrated with more rule sets, offering up to an 84% reduction in build time.</li><li>Analysis time on flag changes has been reduced.</li></ul></li><li><p><strong>Java improvements:</strong> Caching has been improved, and method signature changes no longer affect downstream header builds.</p></li><li><p><strong>Starlark flags:</strong> A new scoping API is available for Starlark flags.</p></li><li><p><strong><code>PROJECT.scl</code>:</strong> A <a href=https://github.com/bazelbuild/bazel/issues/24839>new file</a> is being introduced to provide a canonical place for project owners to map targets to flags. More details on its own section.</p></li><li><p><strong>Starlarkification:</strong> This effort is almost complete. All rules are now decoupled, with the exception of a few integration points for C++. As of Bazel 9, autoloading of rules is disabled, which means users must now explicitly <code>@load</code> all the rules they use.</p></li><li><p><strong>Starlark type system:</strong> <a href=https://github.com/bazelbuild/starlark/issues/106>Type annotations and type-checking</a> are coming to Starlark. The syntax will be supported in Bazel 9, with type-checking planned for Bazel 10. The syntax aims for compatibility with Python 3 types, which introduces some limitations on what can be expressed.</p></li><li><p><strong>JetBrains Bazel plugin:</strong> The <a href=https://plugins.jetbrains.com/plugin/22977-bazel>JetBrains-owned Bazel plugin</a> has reached general availability, making the Google-owned plugin a legacy tool. This new plugin promises a much-improved user experience, as it is faster and better integrates the Bazel build graph with IntelliJ&rsquo;s native understanding of the project structure, avoiding expensive &ldquo;sync&rdquo; steps.</p></li><li><p><strong>Internal APIs:</strong> There is ongoing work to separate core logic from service interactions (such as remote builds and file system operations), which sounds very similar to how Buck 2 was designed from the start.</p></li></ul><p>Much like the community updates talk, this one also opened with bzlmod. Let&rsquo;s dive into that topic next.</p><h1 id=bzlmod>bzlmod</h1><p>The workspace is dead; long live bzlmod! With Bazel 9, support for old-style workspaces has been removed, and given that the vast majority of rulesets now support bzlmod, it&rsquo;s time for everyone to complete their migration. This is a positive development because bzlmod, through the <a href=https://registry.bazel.build/>Bazel Central Registry (BCR)</a>, simplifies rule discovery, project dependencies, and version conflict resolution. Interestingly, but not surprisingly, bzlmod and the BCR have effectively become a package manager for C++.</p><p>But it&rsquo;s not all roses. The bzlmod migration has been a significant source of friction for the community due to the intrusive and difficult nature of the change. If you haven&rsquo;t completed the transition, you can no longer upgrade to newer Bazel versions. The official documentation has also been subpar (which is not surprising), although a great set of <a href=https://blog.engflow.com/2024/06/27/migrating-to-bazel-modules-aka-bzlmod---the-easy-parts/>articles from EngFlow</a> is now available to clarify the migration process in great detail.</p><p>To assist with the migration, an <a href=https://bazel.build/external/migration_tool>automated migration tool</a> is now available, and various people have reported success using AI tools to help with the transition. In a related development, there is now a Maintainer Community Program (MCP) for the BCR.</p><p>One major pain point I have faced, and one that seems to affect many others, is the tendency of the Bazel ecosystem to couple rule versions with library versions. For example, if you are using an old version of <code>protobuf</code> with an equally old version of <code>rules_proto</code> that is not compatible with bzlmod, you must upgrade <code>rules_proto</code> to migrate. However, this in turn forces you to upgrade <code>protobuf</code> itself. Updating a library can introduce API incompatibilities and behavioral changes, making the upgrade to bzlmod and subsequent major Bazel releases much more difficult than it needs to be.</p><h1 id=re-action-routing>RE action routing</h1><p>Before we dive into remote execution, let me clarify some terminology. Remote Execution is abbreviated as RE, not RBE. RBE was Google&rsquo;s now-discontinued cloud product for RE. While the terms are often used interchangeably today (even on Bazel&rsquo;s own website), it&rsquo;s a good idea to stick to RE. Similarly, avoid using the term &ldquo;build farm&rdquo; as there is a specific RE implementation named <a href=https://github.com/buildfarm/buildfarm>Buildfarm</a>.</p><p>Remote execution is always a hot topic at BazelCon, and for good reason. One of Bazel&rsquo;s biggest selling points is the performance boost from distributing builds across multiple machines, and nearly every Bazel-related startup offers some form of remote execution solution.</p><p>In the first RE-focused talk, Son Luong Ngoc from BuildBuddy explained how their product routes actions to maximize performance and minimize execution latency.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/iQqLtuBzkKE?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The talk began with a clear premise: remote builds are spiky and hard to binpack, so how can they be scheduled efficiently for both performance and cost? Here are some of the key features of their RE implementation:</p><ul><li><p><strong>Executor types:</strong> BuildBuddy provides both managed (OCI, Firecracker, macOS) and self-hosted (Docker, Windows, GPU, and more) executors, each with different performance, isolation, and cost characteristics.</p></li><li><p><strong>Multiple action queues:</strong> Executors are organized into pools, and actions can specify which pool they should run on. When an action is received, the scheduler enqueues it in up to three different executors to minimize tail latency, based on the <a href=https://dl.acm.org/doi/10.1145/2517349.2522716>Sparrow scheduler research paper</a>.</p></li><li><p><strong>Work stealing:</strong> Dynamic scaling of executor pools is critical for handling spiky build workloads while keeping costs down. To make this more efficient, BuildBuddy allows new executors to steal work from existing ones, which helps redistribute the load.</p></li><li><p><strong>Action merging:</strong> This feature coalesces multiple execution requests for the same action into a single execution. As we learned, this can be problematic if a misbehaving executor stalls multiple clients (e.g., several CI jobs). To address this, BuildBuddy speculatively re-executes a running action on a different executor after a certain threshold has passed.</p></li><li><p><strong>Action cancellation:</strong> When a user presses Ctrl+C, they are likely to modify code and restart the build, so continuing to run in-flight actions is wasteful. For greater efficiency, BuildBuddy catches the finished event <em>from the BEP</em> and attempts to cancel all remotely-queued actions.</p></li><li><p><strong>Binpacking:</strong> Different actions have different resource requirements, and it can be difficult to manually assign them to the right pool and executor. BuildBuddy automatically profiles executed actions (for metrics like peak memory and CPU consumption) and stores this information in the <code>auxiliary_metadata</code> field of the action result, which is then stored on the server. The scheduler uses these details to route actions more effectively.</p></li><li><p><strong>Cold starts:</strong> Executing remote actions is similar to running lambda functions: a worker must be started, a container image fetched, and the action executed. To optimize this, BuildBuddy uses affinity routing, where a key is computed based on the primary output name (which is unique for each action) to extract platform, target, and output details. This allows similar actions to be routed to similar executors.</p></li><li><p><strong>Recycled runners:</strong> Some customers need to maintain heavyweight processes on the remote worker, such as test databases or the Docker daemon. While not hermetic, this is often desirable for high-performance scenarios. The use of these features is customized through execution properties.</p></li><li><p><strong>Custom resources:</strong> Some actions may require access to specialized resources like GPUs, FPGAs, or simulators. For better binpacking, customers can define the &ldquo;size&rdquo; of different executor types and annotate actions with the resources they consume.</p></li><li><p><strong>Fair scheduling:</strong> With multi-tenancy, users can set a &ldquo;priority&rdquo; for the actions of a build using the <code>--remote_execution_priority</code> flag. A common use case is to define three priority bands: interactive builds, CI, and cron jobs. The BuildBuddy scheduler takes this property into account.</p></li></ul><p>After detailing these existing features, the talk concluded with a glimpse into the future: extending the RE protocol with a remote <em>build graph</em> API. The current protocol is very chatty, making it difficult to colocate actions (such as a compile-link-test chain). A protocol that understands action relationships could significantly improve this.</p><p>This talk left me wondering which of these features are also offered by other major RE vendors and open-source implementations. I briefly chatted with the EngFlow folks at the conference and they told me they have most of these too; it&rsquo;d be nice to have a comparison chart among vendors and free solutions.</p><h1 id=re-cost-savings-vs-reliability>RE cost savings vs. reliability</h1><p>The next major topic for RE was cost savings and reliability, which was covered in at least two talks.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Otjbpn2rB3w?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The first talk, presented by Rahul Roy from Glean, focused on how their adoption of Buildbarn for scalability unexpectedly doubled their CI costs. The primary causes for this increase were an up-to-20% per-action overhead in the Buildbarn worker and a lack of Bazel client caching in their GitHub Actions runners.</p><p>To solve these issues, they chose to adopt <a href=https://aws.amazon.com/ec2/spot/>spot instances</a> in their deployment of Buildbarn on GCP&rsquo;s Kubernetes offering, but this is not as easy as it seems:</p><ul><li><p>The default Kubernetes autoscaler relies on CPU and memory utilization for its decisions, but these metrics are poor predictors of CI traffic patterns. Action queue length is a much better indicator of developer activity, so a custom autoscaler is needed to achieve reasonable behavior.</p></li><li><p>Fair scaling can disrupt ongoing builds because GCP only provides a 90-second shutdown notice before preempting instances, which is not enough time to terminate running actions gracefully.</p></li><li><p>Cold runners are significantly slower than hot ones because they start with empty local caches. To mitigate this, they implemented a solution to reuse runner disks, but only for disks that had been used for builds covering more than 50% of the build graph. This strategy reduced startup times from eight minutes to less than one.</p></li></ul><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/NO028kW_VDc?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The second talk, given by Gabriel Russo from Databricks and Yuval Kaplan from EngFlow, focused on building at scale and how a naive move to remote execution can actually make CI slower.</p><p>They investigated the specific problem of using Docker in actions. The default behavior for remote actions is to bring up a fresh worker for each execution and tear it down afterward, wiping all state. However, Docker is stateful, which meant that actions were performing a great deal of redundant work. To solve this, they moved the snapshotter (a part of <code>containerd</code>) out of the action sandbox and into the execution container, allowing it to be shared across all actions on a given machine.</p><p>The takeaway is that you must be careful with RE. Your intuition for how local processes interact, especially with local state, does not always apply, and you can inadvertently make builds much slower and more expensive. But how do you develop such intuition? That question provides a perfect segue to the next talk.</p><h1 id=understanding-build-behavior>Understanding build behavior</h1><p>Bazel is a complex piece of software, and its interactions with other systems are not always straightforward. When things go wrong, can the data tell us what happened? Users are often frustrated by unexpected cache misses, frequently rebuilt targets, non-hermetic actions, and flaky tests. This was the topic of a talk co-presented by Eloise Pozzi from Canva and Helen Altshuler from EngFlow.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/NdZIeAbS32Q?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The answer to the question above is obviously yes, the data can tell us. But it&rsquo;s not easy because there is <em>a lot</em> of data to comb through. Bazel produces the following datasets:</p><ul><li><p><strong>Build Event Protocol (BEP):</strong> A stream of events that Bazel sends to a remote server to publish build metadata and report progress. The metadata is the closest thing you will get to &ldquo;usage telemetry&rdquo; from Bazel as it captures all builds that were executed (who ran them and with which flags, what was executed, etc.) My pet peeve is that the BEP is incredibly complex and really difficult to manipulate post-facto, but I encourage you to generate one locally (via <code>--build_event_json_file</code>) and to spend &ldquo;a few&rdquo; minutes understanding what&rsquo;s in there.</p></li><li><p><strong>Exec log:</strong> This log captures everything that happened for actions, regardless of where they ran (the BEP only contains minimal details on local-only actions). It is not captured by default due to its verbosity. The <code>--execution_log_compact_file</code> flag, available since Bazel 7.1, makes it possible to capture this log unconditionally. Note that you need a parser to convert this binary log into something that can be read and compared across versions, and you need to manually build this parser out of Bazel&rsquo;s source tree; yikes.</p></li><li><p><strong>Exec graph log:</strong> This log captures how actions depend on each other. It can help quantify drag on the critical path, determine if the critical path is unique, or identify if there are competing ones. Use it to identify actions to prioritize for end-to-end build optimization.</p></li><li><p><strong>Query commands:</strong> See <a href=https://bazel.build/query/language>the reference</a> for <code>bazel query</code>, <code>bazel cquery</code>, and <code>bazel aquery</code>.</p></li><li><p><strong>JSON profile:</strong> Also known as the <a href=https://bazel.build/advanced/performance/json-trace-profile>performance profile</a>, this captures a timeline of all actions executed by Bazel and can help understand build bottlenecks and tune parallelization.</p></li><li><p><strong>RE profile:</strong> Similar to the JSON profile but this is captured server-side by some RE implementations. EngFlow generates one of these with specific details on how the workers executed actions (e.g. which pool ran an action, which is not something that&rsquo;s visible to Bazel).</p></li></ul><p>Returning to the BEP, it&rsquo;s worth noting that one of the last messages it emits is <code>buildToolLogs</code>, which contains links to some of the other logs mentioned above. If you are using remote caching, these links will point to remote cache entries, allowing you to fetch them after the fact for any user build you need to investigate.</p><p>The talk also included a description of how to debug cache misses between CI and interactive developer builds, and I felt it was an almost-literal rehearsal of <a href=/2025/07/bazel-action-determinism.html>the article I wrote months ago</a> on the same topic.</p><h1 id=ide-support-for-monorepos>IDE support for monorepos</h1><p>The next talk I attended, which hits close to my heart, was on exposing developer tools to the <code>PATH</code>. I believe that <code>bazel run</code> provides a terrible user experience, so I was keen to hear about alternatives. The talk was given by Florian Berchtold from Zipline.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/g_5jyXsCELk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>One possible solution to this dilemma is to use <a href=https://direnv.net/>direnv</a>, a long-standing tool that hooks into the shell&rsquo;s before-prompt command to run arbitrary code when entering specific directories. Scary? Yes. Useful? Also yes. The idea is to leverage direnv to bring project-specific tools into the <code>PATH</code>.</p><p>But where do these tools come from? While some people use package managers like <a href=https://github.com/NixOS/nixpkgs>nixpkgs</a>, this can lead to duplication and inconsistencies in a Bazel-native world. For example, it&rsquo;s common to pull in <code>buildifier</code> via bzlmod, but you might also want to expose it in the <code>PATH</code>. This is where <a href=https://github.com/buildbuddy-io/bazel_env.bzl><code>bazel_env</code></a> comes in: a hook for direnv that fetches tools using Bazel.</p><p>The talk explained how to use <code>bazel_env</code> with dev containers to install <code>bazelisk</code>, <code>direnv</code>, IDE extensions, and even <a href=https://github.com/withered-magic/starpls>starpls</a> (the LSP for Starlark). It was also mentioned that for C++, <a href=https://github.com/hedronvision/bazel-compile-commands-extractor>bazel-compile-commands-extractor</a> with <code>clangd</code> works reasonably well for VSCode but struggles with large repositories. For those, <a href="https://github.com/luminartech/dev-tools?tab=readme-ov-file#configure-vs-code-for-bazel">configure-vscode-for-bazel</a> is recommended for a better experience.</p><p>The speaker also prepared a sample repository to demonstrate Bazel integration in the IDE for various languages, which you can find at <a href=https://github.com/hofbi/bazel-ide>hofbi/bazel-ide</a>.</p><h1 id=skycache>Skycache</h1><p>A few months ago, we hosted <a href=https://www.linkedin.com/feed/update/urn:li:activity:7295871444343734272/>a Buildbarn mini-conference</a> at Snowflake where, in my opinion, the most exciting talk was Ed Schouten&rsquo;s presentation on Bonanza. Shortly after, I published an article imagining <a href=/2025/03/bazel-next-generation.html>the next generation of Bazel builds</a>, because Bazel&rsquo;s fat client model is problematic in many scenarios.</p><p>At BazelCon, we now heard Google&rsquo;s approach to solving slow cold builds and Bazel client scalability in a talk on Skycache by Shahan Yang.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/1A8LMZ21t6Y?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The core idea of Skycache is to serialize and remotely cache <a href=https://bazel.build/reference/skyframe>Skyframe</a>, Bazel&rsquo;s internal tracking system for build state (also known as the &ldquo;build graph&rdquo;). In his talk, Shahan outlined three major considerations for making this solution viable:</p><ul><li><p><strong>Top-down pruning:</strong> When you get a cache hit for a node in the graph, you don&rsquo;t have to worry about anything below that node anymore. You can throw away everything underneath to keep memory usage constrained.</p></li><li><p><strong>Invalidation computation:</strong> To determine what needs to be re-fetched from the cache, Skycache assumes &ldquo;the same baseline&rdquo; and then looks for file changes between the local system and the cache to find &ldquo;what&rsquo;s missing&rdquo;. I know, this sounds fuzzy; refer back to the talk for the specifics.</p></li><li><p><strong>Efficiency:</strong> For some nodes, it&rsquo;s cheaper to recompute them than to fetch them from the cache, and this was true for many nodes before applying two optimizations. One was in the nested sets data structure, because the original approach to serializing them caused a 10x space blowup. The other was around serializing individual node values, because most of the time, those values share internals across nodes.</p></li></ul><p>Internal dogfooding of Skycache showed that some builds dropped from 46 to 13 seconds, with similar reductions observed for analyzed targets, loaded packages, and more.</p><p>On the server side, this solution is RAM-intensive (similar to Bazel&rsquo;s in-memory representations) and is complicated by the fact that users want to build at older versions and with a high version cadence. To be effective, Skycache needs to maintain &ldquo;thousands of base images&rdquo;.</p><p>A specific insight toward the end of the talk was that, for Google as a whole, 2.5% of targets account for 90% of all targets built. This suggests a potential optimization where only those targets are cached, but this has not yet been implemented.</p><p>There is no open-source implementation of Skycache, but the talk provided hints about which classes would need to be implemented to make it work. It seems that it shouldn&rsquo;t be too difficult: the serialization code is already in place, so all that&rsquo;s required is integration with a key-value store and Git.</p><p>While this talk was fascinating, I can&rsquo;t help but feel that Google&rsquo;s solution is a bit strange. They are opting to maintain a fat Bazel client instead of moving it entirely to the cloud, as Bonanza is attempting to do, and this feels weird to me knowing how the rest of their infrastructure works (or used to work a few years back).</p><h1 id=dynamic-actions-and-buck-2>Dynamic actions and Buck 2</h1><p>Yes, this was BazelCon, but given Buck&rsquo;s spiritual heritage, it was no surprise to see some Buck 2 content. Andreas Herrmann from Tweag took the stage to compare Bazel and Buck 2&rsquo;s approaches to the efficient compilation of Haskell, highlighting the key role of dynamic actions in Buck 2.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/eA-3Gfr4epU?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The core of the issue lies in how Haskell modules and libraries are compiled and exposed in the Haskell rules. The summary is as follows:</p><ul><li><p>Modules are individual <code>.hs</code> source files. These act as the compilation unit.</p></li><li><p>Libraries are collections of modules, and is what&rsquo;s often modeled in the build via <code>haskell_library</code> rules. Therefore, library targets tend to group various modules.</p></li><li><p>Compiling an <code>.hs</code> file produces an <code>.o</code> object file but also a <code>.hi</code> interface file. Think of the latter as a precompiled header or an interface JAR.</p></li><li><p>To compile a module, we need the <code>.hi</code> files of its dependencies, <em>not</em> their <code>.o</code> files. This is the key difference between compiling a <code>cc_library</code> vs. a <code>haskell_library</code>, because in the C/C++ case, all individual sources can be compiled in any order, but in the Haskell case, they cannot.</p></li></ul><p>With this in mind, the central question is: how can we parallelize the compilation of modules <em>within a library</em> when they must be compiled in dependency order?</p><p>In Bazel, the solution is to model the internal library modules as separate <code>haskell_module</code> rules, each with a static representation of its cross-module dependencies. However, this approach can be incredibly noisy. While Gazelle can help mitigate the issue, it is still not an ideal user experience.</p><p>Buck 2, on the other hand, provides dynamic dependencies, which make it possible to infer the module-level dependency graph <em>at build time</em>. The idea is to have an action that runs <code>ghc -m</code> to emit the cross-module dependency &ldquo;mini-graph&rdquo; for a set of modules, and then use a dynamic action to generate module-level compilation actions with the correct dependencies.</p><h1 id=task-execution-via-starlark>Task execution via Starlark</h1><p>One of my <a href=/2015/04/on-bazel-and-open-source.html>original critiques of Bazel in 2015</a> was that while Bazel is excellent at <em>building</em>, it is not well-suited for other workflows. The specific example I gave was that developers want to <em>install</em> the software they have just built (the equivalent of <code>make install</code>), which is not easy to model in Bazel.</p><p>Well, fear no more. Aspect Build is developing a solution to this problem with Starlark-defined tasks and a custom CLI to run them. I found this to be very exciting, and it was a &ldquo;hot topic&rdquo; at the hackathon that followed the conference.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/j7-IMZ2q5W4?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The premise of the talk was that, even with Bazel, developers still often rely on auxiliary scripts to install tools, Makefiles to drive workflows like setting up test servers or linting code, and YAML files to define complex CI tasks. While all of this should ideally be expressed in Bazel, there is currently no good way to do so.</p><p>In essence, Bazel is missing a &ldquo;task runner&rdquo;, and this is where <a href=https://aspect.build/axl>Aspect&rsquo;s newly-announced Extension Language (AXL)</a> comes in. It&rsquo;s a Starlark dialect for running tasks, which requires the <a href=https://github.com/aspect-build/aspect-cli>Aspect CLI</a> to execute. The CLI is a companion tool to Bazel that once &ldquo;replaced&rdquo; Bazel but no longer does.</p><p>With the new AXL language, you can define tasks in a way that is very similar to defining rules: you create a Starlark function, receive a context, and can then perform &ldquo;stuff&rdquo;. The key difference between tasks and rules is that tasks can trivially execute a build with <code>ctx.bazel.build</code>. Even more exciting is the ability to iterate over the BEP events that the build emits and interact with them!</p><p>The talk also demonstrated the use of WASM binaries for things like buildozer to write platform-agnostic AXL scripts that help with migrations and the like. But the sky is the limit here, and the new <a href=https://github.com/aspect-extensions/>aspect-extensions</a> GitHub organization is meant to collect all user-contributed tasks.</p><h1 id=build-foundation>BUILD Foundation</h1><p>The desire to create a Bazel foundation to protect the project and ecosystem, should Google ever &ldquo;pull the plug&rdquo;, was announced a year ago, but not much has seemed to happen since. In reality, a lot has been going on behind the scenes, but nothing has yet materialized for the average user.</p><p>As part of the unconference, we voted to have a BoF on the foundation to discuss its future.</p><p>The main question we tried to answer during the session was, &ldquo;What could the foundation <em>do</em>?&rdquo; Many ideas were brainstormed, including funding a technical writer, improving the quality of pull requests, maintaining important rulesets, and tackling tricky IDE integrations. However, the most popular idea was for the foundation to act as an intermediary between the community and Google, helping to prioritize the projects that the community needs most.</p><p>I think there is an AI transcript of the session somewhere but there is no recording. You&rsquo;ll have to stay tuned for the news, or you can get involved via Slack. Reach out to Alex Eagle or Helen Altshuler.</p><h1 id=flagsets>Flagsets</h1><p>When you have a small repository with a single project, you can easily record project settings (such as compilation targets and debug flags) in the top-level <code>.bazelrc</code> file. But what do you do when you start combining multiple projects into one repository? The build settings for a backend service might be different from those required for a frontend application.</p><p><code>PROJECT.scl</code> files are here to help, and Susan Steinman and Greg Estren from Google were on hand to explain them.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/kqMOwABJguc?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The key problem being addressed is that while everyone intuitively understands what a &ldquo;project&rdquo; is, Bazel lacks a first-class representation of this concept. By introducing such a concept, the goal is to make <code>bazel build //foo</code> work consistently everywhere, without the need to specify any flags. This is the opposite of the current situation, where it is common for developers to create auxiliary scripts to run Bazel with different flags for different targets.</p><p>As for the format of <code>PROJECT.scl</code>, the presenters reminded us that <code>.bazelrc</code> is an ad-hoc language and one of the few places where Bazel does not use Starlark, despite the community&rsquo;s desire for consistency. As a result, these new project files are written in the language we have all come to appreciate.</p><p>More specifically, <code>PROJECT.scl</code> files can appear multiple times in the directory tree, just like <code>BUILD</code> files. The first one found when walking up the tree from a given build target is the one that is used. The file contains a project definition, which in turn contains buildable units. These units can enforce different policies for flags, such as setting default flag values for a target or preventing users from modifying certain flags. Finally, it is also possible to define multiple configurations for a unit (e.g., release vs. development) and to switch between them using <code>--scl_config=NAME</code>.</p><h1 id=target-aware-workflows-with-bazel-diff>Target-aware workflows with bazel-diff</h1><p>One mistake that <em>everyone</em> makes when moving to a monorepo is retaining operations that scale with the <em>size of the monorepo</em> instead of the <em>size of the change</em>. In particular, it is extremely common to see CI workflows that run <code>bazel test //...</code>, either executing all tests from scratch or hoping that remote caching will prevent the re-running of unmodified tests. This is a bad practice. The overhead is significant, and the end-user experience is often terrible, especially when flaky tests are present.</p><p><a href=https://github.com/Tinder/bazel-diff/>bazel-diff</a> is a tool that helps determine the targets affected by a given code change, allowing Bazel to build and test <em>only</em> those targets. Maxwell Elliott and Connor Wybranowsky were on hand to share the impact that developing this tool at Tinder has had on the company&rsquo;s developer workflows.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/rCFc3tFcVVE?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The initial results of deploying <code>bazel-diff</code> were a 40% reduction in CI times at the 90th percentile, and up to a 76% reduction in the worst case. These kinds of improvements were transformative for users. In particular, because CI flows became much faster and more accurate, developers began to take ownership of test breakages and flakiness.</p><p>Unfortunately, as is often the case with &ldquo;transformative performance improvements&rdquo; (remember SSDs or the M1 chip?), the codebase continued to grow and eventually consumed all the gains from <code>bazel-diff</code>.</p><p>To improve on the original deployment, the new approach is to integrate <code>bazel-diff</code> more deeply with CI. The idea is to dynamically generate pipelines based on the changes in a pull request and select which ones to run at review time. For example, if any of the modified files have automated formatters, only the formatter pipelines will be triggered.</p><p>To recap, the presenters mentioned that the end-to-end adoption of <code>bazel-diff</code> has helped them save up to 93% of their time in CI. While the extra gains beyond the initial 76% did not lead to the same kinds of cultural changes that were originally observed, developers always appreciate faster workflows.</p><h1 id=supply-chain-security>Supply chain security</h1><p>If you have attended previous BazelCons, you will know that supply chain security is a recurring topic. This year was no different, with Mark Zeren from Broadcom and Tony Aiuto from Datadog presenting the latest news in this area.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Q4p-I9TsUnA?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>The reason this topic is relevant to the conference is that Bazel is a key tool for producing reliable SBOMs, thanks to its hermeticity, sandboxing features, and fine-grained build graph entries. However, it&rsquo;s not quite there yet.</p><p>From the beginning, Bazel included <code>rules_license</code> as a way to define per-package licensing details. However, this ruleset was &ldquo;thrown over the wall&rdquo; by Google when Bazel was first open-sourced and has not been fit for purpose.</p><p>Today, there is a new ruleset called <a href=https://github.com/bazel-contrib/supply-chain><code>supply-chain</code></a>, with only one person from Google on the eight-person team. This new ruleset focuses on two things: metadata rules that code authors can apply to their <code>BUILD</code> files, and tools to generate provenance information and produce SBOMs. These two components are separate because the metadata rules are designed to be stable over time, while the tools are expected to change frequently.</p><p>What is missing from the new ruleset is licensing: the ability to generate copyright notices, validate linkage, and so on.</p><h1 id=faster-container-builds-with-rules_img>Faster container builds with rules_img</h1><p>As I mentioned earlier, your intuition about what works well for local actions may not apply to remote actions, and container image building is a prime example of this.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/biYXmAv4Ppk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>In this talk, Malte Poll from Tweag took the stage to introduce <a href=https://github.com/bazel-contrib/rules_img><code>rules_img</code></a>, a new ruleset that replaces <code>rules_oci</code> and <code>rules_docker</code>. It is designed to minimize large blob transfers, resulting in significantly more efficient container builds.</p><p>I do not have written notes on this talk because I was too focused absorbing the many, many details given during the talk, so I strongly encourage you to watch it.</p><h1 id=my-talk-on-java-test-slowness>My talk on Java test slowness</h1><p>To conclude this long recap, I will leave you with my own lightning talk on how our Java integration tests at Snowflake became significantly slower after we migrated from Maven to Bazel.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/-1qrpqFsqQ0?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>It&rsquo;s only eight minutes long, but if you want the summary: Maven and Bazel compile Java code differently. Maven writes class files to a few directories on disk, while Bazel creates intermediate JAR files for every Java library. With Bazel&rsquo;s more-detailed build graph, this causes an explosion in the <code>CLASSPATH</code> size and means that class files must be read from compressed JAR (ZIP) files instead of from disk.</p><p>I spent some time analyzing the problem and ruled out obvious factors like sandboxing and ZIP compression. I concluded that reading from JAR files is indeed slower than reading individual files from disk. (Why? I&rsquo;m not sure, but I suspect there is an optimization that could be made in the class loader to fix this.)</p><p>To mitigate the problem, I created a new rule that uses the <code>singlejar</code> tool to merge all intermediate JARs into one. But this was easier said than done. The resulting combined JAR was huge and could not be reused across tests, so I had to develop a complex dependency-pruning rule to generate a combined JAR that could be reused across all tests without introducing class duplicatesâ€”all while remaining remote-execution-friendly.</p><p>With this new rule in place, we saw test runtimes drop by about 10 seconds per test, which brought them back to pre-Bazel levels. And with the improvements that Bazel brings to the build, an end-to-end reduction in test times.</p><hr><p>And that&rsquo;s a wrap! This has been more of a detailed summary than a brief recap, but my goal was to clean up and share all the notes I took during the conference. Apologies for the many talks I could not cover in this recap. Once again, head to the <a href="https://www.youtube.com/playlist?list=PLak8-7eFSpowmNiR2lhvJEomLA140yban">BazelCon 2025 YouTube playlist</a> for all recordings.</p><p>If you are involved with Bazel at all or have any interest in build systems, I strongly encourage you to plan to attend next year. You&rsquo;ll learn a lot from the talks of course, but what&rsquo;s more, you&rsquo;ll get to meet key people from tens of companies&mdash;people that hold the keys to how modern build tools and scalable development processes are being developed worldwide.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/software/getoptsargs.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/12/from-azure-functions-to-freebsd.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>ðŸ‘
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>ðŸ‘Ž
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=BazelCon+2025+recap&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F11%2Fbazelcon-2025-recap.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=BazelCon+2025+recap&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F11%2Fbazelcon-2025-recap.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=BazelCon+2025+recap+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F11%2Fbazelcon-2025-recap.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.jmmv.dev/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>