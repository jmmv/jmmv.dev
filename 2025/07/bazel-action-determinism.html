<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Bazel and action (non-) determinism - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Bazel and action (non-) determinism - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Bazel and action (non-) determinism - Julio Merino (jmmv.dev)"><meta name=description content="A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. For the most part, Bazel helps ensure that they are, but in the odd cases when they aren&rsquo;t, builds can fail in subtle and frustrating ways, eroding trust in the build system.
This article is the first in a series on Bazel&rsquo;s execution model. Having explained these concepts many times, I want to provide a detailed reference before explaining a cool solution to a problem I recently developed at work. We will start with action non-determinism, then cover remote caching and execution, and finally, explore the security implications of these features.
This first article explains what non-determinism is, how it manifests, and how you can diagnose and prevent it in your own builds. Let&rsquo;s begin.
"><meta property="og:description" content="A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. For the most part, Bazel helps ensure that they are, but in the odd cases when they aren&rsquo;t, builds can fail in subtle and frustrating ways, eroding trust in the build system.
This article is the first in a series on Bazel&rsquo;s execution model. Having explained these concepts many times, I want to provide a detailed reference before explaining a cool solution to a problem I recently developed at work. We will start with action non-determinism, then cover remote caching and execution, and finally, explore the security implications of these features.
This first article explains what non-determinism is, how it manifests, and how you can diagnose and prevent it in your own builds. Let&rsquo;s begin.
"><meta property="twitter:description" content="A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/07/bazel-action-determinism.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/07/bazel-action-determinism.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-07-21-bazel-action-determinism-cover.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-07-21-bazel-action-determinism-cover.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src=https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzA3L2JhemVsLWFjdGlvbi1kZXRlcm1pbmlzbS5odG1s/stamp.gif style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/bazel-action-determinism")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Bazel and action (non-) determinism</h1><p>July 21, 2025 &#183;
About 15 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/bazel-action-determinism>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-07-21-bazel-action-determinism-cover.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. For the most part, Bazel helps ensure that they are, but in the odd cases when they aren&rsquo;t, builds can fail in subtle and frustrating ways, eroding trust in the build system.</p><p>This article is the first in a series on Bazel&rsquo;s execution model. Having explained these concepts many times, I want to provide a detailed reference before explaining a cool solution to a problem I recently developed at work. We will start with action non-determinism, then cover remote caching and execution, and finally, explore the security implications of these features.</p><p>This first article explains what non-determinism is, how it manifests, and how you can diagnose and prevent it in your own builds. Let&rsquo;s begin.</p><h1 id=bazel-execution-basics>Bazel execution basics</h1><p>Consider the following example build file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>cc_library</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;bs5-lib&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;lib1.c&#34;</span><span class=p>,</span> <span class=s2>&#34;lib2.c&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cc_binary</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;bs5-bin&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;main.c&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>deps</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:bs5-lib&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>This build file specifies two <strong>targets</strong>: the <code>bs5-lib</code> target, which builds a C library from two source files, and the <code>bs5-bin</code> target, which builds a C binary from one source file and links it against the <code>bs5-lib</code> library.</p><p>These two targets instantiate the <code>cc_library</code> and <code>cc_binary</code> <strong>rules</strong> by binding them to specific <strong>attributes</strong> (the values of <code>srcs</code> and <code>deps</code>).</p><p>Processing these rules during dependency analysis yields a collection of <strong>actions</strong>:</p><ul><li><p>The <code>cc_library</code> rule used to define the <code>bs5-lib</code> target generates:</p><ul><li><p>A <code>CppCompile</code> action to compile the <code>lib1.c</code> file into the <code>lib1.o</code> object file.</p><p>Its command line may be: <code>cc -o lib1.o lib1.c</code></p></li><li><p>A <code>CppCompile</code> action to compile the <code>lib2.c</code> file into the <code>lib2.o</code> object file.</p><p>Its command line may be: <code>cc -o lib2.o lib2.c</code></p></li><li><p>A <code>CppArchive</code> action to link <code>lib1.o</code> and <code>lib2.o</code> together into the <code>bs5-lib.a</code> archive.</p><p>Its command line may be: <code>ar rcsD bs5-lib.a lib1.o lib2.o</code></p></li></ul></li><li><p>The <code>cc_binary</code> rule used to define the <code>bs5-bin</code> target generates:</p><ul><li><p>A <code>CppCompile</code> action to compile the <code>main.c</code> file into the <code>main.o</code> object file.</p><p>Its command line may be: <code>cc -o main.o main.c</code></p></li><li><p>A <code>CppLink</code> action to link <code>main.o</code> and <code>bs5-lib.a</code> together into the <code>bs5-bin</code> executable.</p><p>Its command line may be: <code>cc -o bs5-bin main.o bs5-lib.a</code></p></li></ul></li></ul><p>Note that nowhere in the list above do you see target names. Actions work with <em>file</em>-level dependencies, not <em>target</em>-level dependencies. If you need to visualize this, think of the target dependency graph and the action dependency graph as two disjoint entities. (Skyframe tracks them as just one graph but we can ignore that fact here.)</p><p>It&rsquo;s this, actions, that are the atomic unit of execution in Bazel. Once Bazel is done with its <strong>loading</strong> and <strong>analysis</strong> phases, it enters the <strong>execution</strong> phase. During execution, the &ldquo;only&rdquo; thing that Bazel does is dispatch actions for execution via its <a href=/2019/12/bazel-strategies.html>execution strategies</a>, trying to maximize parallelism as determined by the constraints of the action dependency graph.</p><h1 id=build-actions-anatomy>Build actions anatomy</h1><p>To break down an action into its parts, let&rsquo;s examine what goes into defining the <code>CppLink</code> action above, and to do that, let&rsquo;s first focus on its simple command line to produce the <code>bs5-bin</code> binary from the <code>main.o</code> object file and the <code>bs5-lib.a</code> static library:</p><pre tabindex=0><code>cc -o bs5-bin main.o bs5-lib.a
</code></pre><p>Bazel tracks the command line as part of the action, but things are a bit more complex than that. And to explain the &ldquo;complexity&rdquo;, let&rsquo;s try to understand what problems Bazel is trying to solve compared to a more rudimentary build tool like Make.</p><p>If you have used (or still use) Make, you would have likely expressed the corresponding build rule as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-make data-lang=make><span class=line><span class=cl><span class=nf>bs5-main</span><span class=o>:</span> <span class=n>main</span>.<span class=n>o</span> <span class=n>bs</span>5-<span class=n>lib</span>.<span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o bs5-main main.o bs5-lib.a
</span></span></code></pre></div><p>which looks&mldr; OK, I guess. But what happens if you do this?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># Build the binary.</span>
</span></span><span class=line><span class=cl>make bs5-main
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Build the binary _again_ in stripped mode.</span>
</span></span><span class=line><span class=cl>make bs5-main <span class=nv>LDFLAGS</span><span class=o>=</span>-s
</span></span></code></pre></div><p>An inconsistent build! The <code>bs5-main</code> binary is <em>not</em> stripped as you would expect because the second <code>make</code> invocation does <em>nothing</em>! <code>make</code> has no idea that the <code>LDFLAGS</code> variable is involved in the target definition so it doesn&rsquo;t know that the target has to be rebuilt to honor the variable change.</p><p>This type of scenario is what leads to having to run <code>make clean</code> from time to time in a Make-based build system because the outputs that Make produces get out of sync with environmental changes. And the reason is that the <em>only</em> thing that <code>make</code> tracks to determine whether a target needs to be rebuilt are the file timestamps of the inputs that are <em>explicitly listed</em> in the rule (<code>main.o</code> and <code>bs5-lib.a</code> in this example).</p><p>Now you&rsquo;d say: but you can fix it! &ldquo;Just&rdquo; do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-make data-lang=make><span class=line><span class=cl><span class=c># An unconditional rule that captures the content of LDFLAGS.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>ldflags</span>.<span class=n>stamp</span>.2
</span></span><span class=line><span class=cl><span class=nf>ldflags.stamp.2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>LDFLAGS<span class=k>)</span> &gt;ldflags.stamp.2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># A conditional rule that only updates the timestamp of the stamp file if the
</span></span></span><span class=line><span class=cl><span class=c># content captured by the unconditional rule changes.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>ldflags.stamp</span><span class=o>:</span> <span class=n>ldflags</span>.<span class=n>stamp</span>.2
</span></span><span class=line><span class=cl>    @cmp -s ldflags.stamp ldflags.stamp.2 <span class=o>||</span> cp ldflags.stamp.2 ldflags.stamp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># The rule we had before, but with an extra dependency on the stamp file.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>bs5-main</span><span class=o>:</span> <span class=n>main</span>.<span class=n>o</span> <span class=n>bs</span>5-<span class=n>lib</span>.<span class=n>a</span> <span class=n>ldflags</span>.<span class=n>stamp</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o bs5-main main.o bs5-lib.a
</span></span></code></pre></div><p>And indeed this ensures that the <code>bs5-main</code> target gets re-linked if <code>LDFLAGS</code> changes. But I hope you&rsquo;ll agree that this is <em>awful</em> and that nobody does it because: one, most folks writing <code>Makefile</code>s aren&rsquo;t aware of the problem; and, two, even if they are, it&rsquo;s too hard to get it right (see&mldr; we forgot about the value of <code>CC</code> and whatever other environment variables might influence <code>CC</code>&rsquo;s behavior like, you know, the <code>PATH</code>?).</p><p>I didn&rsquo;t come here to bash against Make. OK, maybe I <em>did</em> because folks out there often say &ldquo;Make works just fine and it&rsquo;s much simpler than Bazel!&rdquo; when in reality they are oblivious to a bunch of very real problems that later <a href=/2023/08/costs-exposed-monorepo-multirepo.html>waste <em>other people</em>&rsquo;s time</a> when their build environment subtly breaks. &lt;/rant></p><p>Bazel and other next-generation build systems solve this specific problem and more by being comprehensive about what they track at the action level, and using that information to determine whether an action needs to be rebuilt or not. In particular, a Bazel action is defined by these parts:</p><ul><li><p><strong>The command line to execute</strong>, which in this case is <code>cc -o bs5-bin main.o bs5-lib.a</code>.</p></li><li><p><strong>Hashes of the input files</strong> required to execute the command. These include &ldquo;obvious&rdquo; inputs like the source files specified in the targets but <em>also</em> the files required to execute the tools of the action (e.g. the compiler&rsquo;s own files). In this case, the list of input files could look like: <code>main.o</code>, <code>bs5-lib.a</code>, <em>and</em> <code>cc</code>.</p></li><li><p><strong>The configuration of the environment</strong> in which the action runs. This includes environment variables, the host and target platforms, and things like that. In this case, the configuration could include the value of <code>PATH</code> and whether we are building in debug or optimized mode. Configurations are expressed as a hash, though, because of the many details that go into computing them.</p></li></ul><p>These three properties define <em>quite</em> precisely the relation between the context of an action and the outputs it produces, and this is the main technique that Bazel uses to <a href=/2020/12/google-no-clean-builds.html>avoid clean builds</a> at large scale.</p><h1 id=hello-non-determinism>Hello non-determinism</h1><p>But pay attention to the &ldquo;quite&rdquo; word in &ldquo;quite precisely&rdquo; right above. I did not say &ldquo;perfectly&rdquo; because there are still ways for non-deterministic behavior to leak into a Bazel build, meaning that <code>bazel clean</code> and unexpected rebuilds (e.g. due to cache expiration) could still change the behavior of a build.</p><p>Consider this innocuous example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;date&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;date.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;date &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>This rule says: stick the output of the <code>date</code> command, which prints the current date, into the <code>date.txt</code> file. Obviously, &ldquo;current date&rdquo; varies over time so we should expect the above to give us trouble. And indeed it does: look at this sequence of commands where I&rsquo;ve removed all irrelevant Bazel console noise:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ bazel build //:date
</span></span><span class=line><span class=cl>INFO: 2 processes: 1 internal, 1 linux-sandbox.
</span></span><span class=line><span class=cl>$ cat bazel-bin/date.txt
</span></span><span class=line><span class=cl>Mon Jul  7 17:59:29 PDT 2025
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ bazel build //:date
</span></span><span class=line><span class=cl>INFO: 1 process: 1 internal.
</span></span><span class=line><span class=cl>$ cat bazel-bin/date.txt
</span></span><span class=line><span class=cl>Mon Jul  7 17:59:29 PDT 2025
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ bazel clean
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ bazel build //:date
</span></span><span class=line><span class=cl>INFO: 2 processes: 1 internal, 1 linux-sandbox.
</span></span><span class=line><span class=cl>$ cat bazel-bin/date.txt
</span></span><span class=line><span class=cl>Mon Jul  7 18:02:15 PDT 2025
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>The first Bazel build claims to have executed 1 action in the sandbox and the <code>date.txt</code> file shows us the date when that happened. The second Bazel build does nothing and <code>date.txt</code> remains unmodified. But if we later follow that by a Bazel clean and a third Bazel build, we see that the content of <code>date.txt</code> is now different. Non-determinism has leaked into the build, and&mldr; that&rsquo;s problematic.</p><h1 id=how-bad-is-non-determinism-really>How bad is non-determinism really?</h1><p>Non-determinism is a problem because it prevents achieving <a href=https://reproducible-builds.org/>reproducible builds</a>. On the one hand, this voids the security guarantees that come from being able to reproduce builds in different environments: if the output of the build is not bit-for-bit identical to its inputs, you can&rsquo;t verify that a binary that&rsquo;s being used in production actually comes from the sources it claims to have been built from. On the other hand, this leads to situations where developers get different behavior depending on when/where they build the code: you do not want to hear the &ldquo;works on my machine&rdquo; excuse when troubleshooting a bug. So, it <em>is</em> bad.</p><p>But one interesting property of Bazel&rsquo;s action model is that a single non-deterministic action does not necessarily poison the whole build. Take a look at this build file that defines a chain of actions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># date target: Writes a non-deterministic date to its output.</span>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;date&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;date.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;date &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># copy target: Consumes the output of &#34;date&#34; and copies it to</span>
</span></span><span class=line><span class=cl><span class=c1># its output.</span>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;copy&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;copy.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;cp $&lt; $@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:date&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># count target: Consumes the output of &#34;copy&#34; and produces an</span>
</span></span><span class=line><span class=cl><span class=c1># output that does not vary due to the input non-determinism.</span>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;count&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;count.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;wc -l $&lt; &gt;$@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:copy&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># copy2 target: Consumes the output of &#34;count&#34; and copies it to</span>
</span></span><span class=line><span class=cl><span class=c1># its output.</span>
</span></span><span class=line><span class=cl><span class=n>genrule</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;copy2&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>outs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;copy2.txt&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>cmd</span> <span class=o>=</span> <span class=s2>&#34;cp $&lt; $@&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;:count&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>The interesting bit here is in the <code>count</code> target, which counts the lines in its input and writes the resulting number to its output. While this target consumes a non-deterministic input, its output is deterministic because the number of lines in the input is constant: <code>date</code> writes a different timestamp each time, but it always produces one line.</p><p>The fact that the target produces a deterministic output allows Bazel to stop &ldquo;propagating&rdquo; non-determinism across the build. Remember that actions track <em>input hashes</em>, <strong>not</strong> <em>input timestamps</em>. Once <code>count</code> is re-executed after changes to <code>date</code>, the output of <code>count</code> will have the same hash as it did before, and <code>copy2</code> will conclude that it doesn&rsquo;t need to be rerun.</p><p>Let&rsquo;s try it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ bazel build //:copy2
</span></span><span class=line><span class=cl>INFO: <span class=m>5</span> processes: <span class=m>1</span> internal, <span class=m>4</span> linux-sandbox.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ rm -f bazel-bin/date.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ bazel build //:copy2 --explain log
</span></span><span class=line><span class=cl>INFO: <span class=m>4</span> processes: <span class=m>1</span> action cache hit, <span class=m>1</span> internal, <span class=m>3</span> linux-sandbox.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat log
</span></span><span class=line><span class=cl>Build options: --explain<span class=o>=</span>log
</span></span><span class=line><span class=cl>Executing action <span class=s1>&#39;BazelWorkspaceStatusAction stable-status.txt&#39;</span>: unconditional execution is requested.
</span></span><span class=line><span class=cl>Executing action <span class=s1>&#39;Executing genrule //:date&#39;</span>: One of the files has changed.
</span></span><span class=line><span class=cl>Executing action <span class=s1>&#39;Executing genrule //:copy&#39;</span>: One of the files has changed.
</span></span><span class=line><span class=cl>Executing action <span class=s1>&#39;Executing genrule //:count&#39;</span>: One of the files has changed.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>The sequence of commands above proves the point: the first build of the <code>copy2</code> target tells us that Bazel executed 4 sandboxed actions (one for each target). If we then remove the non-deterministic file from the output tree and ask Bazel to rebuild the <code>copy2</code> target, we see how it only rebuilt 3 targets and 1 of them scored a cache hit. And by inspecting the log we asked Bazel to produce, we see that it effectively rebuilt <code>date</code>, <code>copy</code>, and <code>count</code>, but it didn&rsquo;t have to rebuild <code>copy2</code> because the non-determinism didn&rsquo;t propagate further.</p><p>In a Make world, the above sequence of commands would have invalidated the whole build because Make just checks timestamps, and targets almost-always update the timestamps of their outputs unless we go through great extents to prevent it (like I did earlier on in the stamp file rule with its call to <code>cmp -s</code>).</p><h1 id=possible-non-determinism-causes>Possible non-determinism causes</h1><p>In the previous example, it was rather obvious that a call to <code>date</code> could be problematic. But this is not the only source of non-determinism, and oftentimes the reason behind the non-determinism isn&rsquo;t as obvious. Here is a more comprehensive list of possible causes:</p><ul><li><p><strong>Date and time.</strong> You might not be calling <code>date</code>, but build tools&mdash;especially code generators and archivers like zip&mdash;love injecting timestamps in their output files. These may be obvious, like comments in generated files, or subtle, like values written in binary metadata headers.</p></li><li><p><strong>System identifiers.</strong> Similarly to &ldquo;current date&rdquo;, there are tools that query the current PID, UID, GID, etc. and inject those values in their outputs.</p></li><li><p><strong>Sort ordering.</strong> Hash tables are the star data structure in computer science and they are everywhere. Unfortunately, there are tools that leak their internal use of hash tables into output files by, for example, emitting unsorted lists.</p></li><li><p><strong>Accessing the network.</strong> Just <em>don&rsquo;t</em>.</p></li><li><p><strong>Unexpected/unknown dependencies on host tools.</strong> Calling a tool from the system means introducing hidden dependencies on whatever the tool itself depends on. For example, the tool might read a configuration file that alters its behavior.</p></li><li><p><strong><a href=/2019/12/bazel-dynamic-execution-introduction.html>Dynamic execution</a>.</strong> This powerful feature that helps improve incremental build times in interactive scenarios can easily lead to non-determinism if the remote execution environment and the local execution environment aren&rsquo;t equivalent (where equivalent is tricky to define).</p></li><li><p><strong><a href=https://github.com/bazel-contrib/rules_foreign_cc>Foreign CC rules</a>.</strong> Bazel tries to enforce action determinism as we saw earlier, but other build systems make little efforts to do so. If you end up nesting build systems, as is the case when using this ruleset, it&rsquo;s very likely that you are introducing non-determinism.</p></li><li><p><strong>Randomness.</strong> Tools can decide to read from <code>/dev/random</code> and do something with that value, in which case you definitely have non-determinism.</p></li></ul><h1 id=doesnt-sandboxing-fix-it-all>Doesn&rsquo;t sandboxing fix it all?</h1><p>The list above is long, and there is this assumption, especially from newcomers to Bazel, that Bazel&rsquo;s sandboxing ensures that build behavior is deterministic.</p><p>In a theoretical world, that would be true: Bazel would execute each action in a precisely controlled environment to ensure that actions behaved exactly the same from run to run. This would require using a cycle-accurate virtual machine to precisely control instruction scheduling (multithreading can also introduce non-determinism) and entropy sources, but as you can imagine, this would make build execution extremely slow.</p><p>In a practical world, sandboxing has to grant some concessions in the name of performance: otherwise, people will end up <a href=https://github.com/bazelbuild/bazel/issues/8230>disabling sandboxing</a>, nullifying all of its benefits.</p><p>Furthermore, sandboxing isn&rsquo;t something magical you can &ldquo;do&rdquo; from userspace (unless you write a full machine emulator). Sandboxing requires kernel support, and different kernels offer different sandboxing technologies. In turn, this means that what Bazel can sandbox or not depends on the machine that Bazel is running on. For example: Bazel&rsquo;s sandbox on Linux is able to restrict file accesses, offer stable PIDs, and forbid network accesses&mdash;but the macOS sandbox, <a href=/2019/11/macos-sandbox-exec.html>based on the deprecated sandbox-exec</a>, cannot mangle the PID namespace.</p><h1 id=diagnosing-non-determinism>Diagnosing non-determinism</h1><p>So. We know non-deterministic actions can exist in a Bazel build and that sandboxing isn&rsquo;t going to protect us from them. In that case, how can we tell if such actions have leaked into our build? We can use the &ldquo;execution log&rdquo; feature in Bazel to write a detailed log of all the actions that Bazel executes. Then, we can <code>diff</code> the logs of two separate builds and see if they differ.</p><p>Looking back to our chain of actions from the last example, we could capture two fresh execution logs by doing this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ bazel clean
</span></span><span class=line><span class=cl>$ bazel build --noremote_accept_cached --execution_log_json_file<span class=o>=</span>before //:copy2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ bazel clean
</span></span><span class=line><span class=cl>$ bazel build --noremote_accept_cached --execution_log_json_file<span class=o>=</span>after //:copy2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>Note: it is important to start from a clean build <em>and</em> to tell Bazel to not reuse remotely-cached actions. In this way, we force Bazel to reexecute the whole build, which should uncover non-determinism if it exists. Also, make sure to keep <code>--execution_log_sort</code> enabled (the default).</p><p>Once we have run the above, we can proceed to diff the logs. I like doing <code>diff -u before after | cdiff</code>, but you can use whichever file diffing UI you prefer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gd>--- before 2025-07-15 18:02:46.838524511 -0700
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ after  2025-07-15 18:02:51.870531304 -0700
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -25,7 +25,7 @@
</span></span></span><span class=line><span class=cl><span class=gu></span>   &#34;actualOutputs&#34;: [{
</span></span><span class=line><span class=cl>     &#34;path&#34;: &#34;bazel-out/k8-fastbuild/bin/date.txt&#34;,
</span></span><span class=line><span class=cl>     &#34;digest&#34;: {
</span></span><span class=line><span class=cl><span class=gd>-      &#34;hash&#34;: &#34;d6e32f2792db61b80e67707fa24bc3f3704d65267b871809cd9d2969fe80d39d&#34;,
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+      &#34;hash&#34;: &#34;c2ae04c2b2ff29fd70372a9e399a8f8d5f18ea7395d45d9a34fdbc9decac854b&#34;,
</span></span></span><span class=line><span class=cl><span class=gi></span>       &#34;sizeBytes&#34;: &#34;29&#34;,
</span></span><span class=line><span class=cl>       &#34;hashFunctionName&#34;: &#34;SHA-256&#34;
</span></span><span class=line><span class=cl>     },
</span></span><span class=line><span class=cl><span class=gu>@@ -63,7 +63,7 @@
</span></span></span><span class=line><span class=cl><span class=gu></span>   &#34;inputs&#34;: [{
</span></span><span class=line><span class=cl>     &#34;path&#34;: &#34;bazel-out/k8-fastbuild/bin/date.txt&#34;,
</span></span><span class=line><span class=cl>     &#34;digest&#34;: {
</span></span><span class=line><span class=cl><span class=gd>-      &#34;hash&#34;: &#34;d6e32f2792db61b80e67707fa24bc3f3704d65267b871809cd9d2969fe80d39d&#34;,
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+      &#34;hash&#34;: &#34;c2ae04c2b2ff29fd70372a9e399a8f8d5f18ea7395d45d9a34fdbc9decac854b&#34;,
</span></span></span><span class=line><span class=cl><span class=gi></span>       &#34;sizeBytes&#34;: &#34;29&#34;,
</span></span><span class=line><span class=cl>       &#34;hashFunctionName&#34;: &#34;SHA-256&#34;
</span></span><span class=line><span class=cl>     },
</span></span></code></pre></div><p>Voila. The first chunk of the log tells us that the first non-deterministic action is the one that writes the <code>date.txt</code> file, and the second chunk of the log tells us that there is another action that consumes said file as an input.</p><h1 id=keeping-on-top-of-non-determinism>Keeping on top of non-determinism</h1><p>Let&rsquo;s finish the article by giving you some practical tips to remove non-determinism from the build and to make sure it doesn&rsquo;t come back:</p><ul><li><p><strong>Set up a CI pipeline that identifies new instances of non-determinism</strong>. Unless you are proactive about it, non-determinism will creep back in because neither the local sandbox not remote execution can fully prevent it.</p></li><li><p><strong>Keep the local sandbox enabled.</strong> It may not be perfect but it&rsquo;s much better than nothing. Also, enable <code>--nosandbox_default_allow_network</code> explicitly because, for historical reasons, the sandbox did <em>not</em> forbid network access and the default hasn&rsquo;t been flipped yet.</p></li><li><p><strong>Rely on hermetic toolchains.</strong> Do not use the system-provided ones because they tend to have dependencies on system-provided files that are invisible to the Bazel action definitions. (E.g. if you use the host-provided <code>gcc</code>, the compiler will happily embed <code>/usr/lib/gcc/x86_64-linux-gnu/15/crtbegin.o</code> into the final binary and this will be invisible to Bazel.)</p></li><li><p><strong>Force remote execution.</strong> Sometimes, non-determinism is inevitable or really hard to avoid (e.g. if you use the Foreign CC ruleset). Under these conditions, your best bet is to force the problematic actions to run remotely under a strictly controlled environment and to provision the remote cache so that such actions &ldquo;never&rdquo; fall out. If done correctly, this will &ldquo;hide&rdquo; the non-determinism because, once an action has been built, it will never be rebuilt again until its known inputs actually change.</p></li><li><p><strong>Sanitize the action&rsquo;s environment.</strong> Use <code>--action_env</code> and <code>--host_action_env</code> to keep settings like the <code>PATH</code> consistent across machines, and use <code>--strict_action_env</code> to minimize the environment variables that leak into action execution.</p></li><li><p><strong>Think about network access.</strong> If you must, do it from repo rules and <em>always</em> verify that whatever you downloaded matches known checksums. If you are strict about checksum validation, you&rsquo;ll still have a non-hermetic build, but at least, you&rsquo;ll have a deterministic one. If you have such behavior in a test, don&rsquo;t allow its results to be cached by means of the <code>no-remote-cache</code> tag.</p></li></ul><p>And with that, it&rsquo;s time to conclude until the next episode on remote caching.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/06/endbox-journey-lessons.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/09/bazel-remote-caching.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Bazel+and+action+%28non-%29+determinism&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F07%2Fbazel-action-determinism.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Bazel+and+action+%28non-%29+determinism&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F07%2Fbazel-action-determinism.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Bazel+and+action+%28non-%29+determinism+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F07%2Fbazel-action-determinism.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>