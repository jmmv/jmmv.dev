<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Hardware discovery: ACPI & Device Tree - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Hardware discovery: ACPI & Device Tree - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Hardware discovery: ACPI & Device Tree - Julio Merino (jmmv.dev)"><meta name=description content="If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&mdash;say a sound card or a network card&mdash;had physical switches or jumpers in it. These switches configured the card&rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.
But that wasn&rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software which specific cards you had and how you had configured them. Remember SET BLASTER=A220 I5 D1 H5? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.
Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus ISA &ldquo;Plug and Play&rdquo;, or PnP for short, was born in the early 1990s&mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&rsquo;s scene where we just attach devices to external USB connectors and things &ldquo;magically work&rdquo;.
But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.
"><meta property="og:description" content="If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&mdash;say a sound card or a network card&mdash;had physical switches or jumpers in it. These switches configured the card&rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.
But that wasn&rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software which specific cards you had and how you had configured them. Remember SET BLASTER=A220 I5 D1 H5? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.
Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus ISA &ldquo;Plug and Play&rdquo;, or PnP for short, was born in the early 1990s&mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&rsquo;s scene where we just attach devices to external USB connectors and things &ldquo;magically work&rdquo;.
But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.
"><meta property="twitter:description" content="If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/02/hardware-autoconfiguration.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/02/hardware-autoconfiguration.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-02-28-jumpers.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-02-28-jumpers.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzAyL2hhcmR3YXJlLWF1dG9jb25maWd1cmF0aW9uLmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/hardware-autoconfiguration")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Hardware discovery: ACPI & Device Tree</h1><p>February 28, 2025 &#183;
About 16 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/hardware>hardware</a>, <a href=/tags/unix>unix</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/hardware-autoconfiguration>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-02-28-jumpers.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&mdash;say a sound card or a network card&mdash;had physical switches or jumpers in it. These switches configured the card&rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.</p><p>But that wasn&rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software <em>which</em> specific cards you had and how you had configured them. Remember <code>SET BLASTER=A220 I5 D1 H5</code>? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.</p><p>Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus <a href=https://wiki.osdev.org/ISA>ISA &ldquo;Plug and Play&rdquo;</a>, or PnP for short, was born in the early 1990s&mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&rsquo;s scene where we just attach devices to external USB connectors and things &ldquo;magically work&rdquo;.</p><p>But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=hardware-topology>Hardware topology</h1><p>When you learn about the <a href=https://en.wikipedia.org/wiki/Von_Neumann_architecture>Von Neumann architecture</a> in school, you are typically told that there is a CPU, a chunk of memory, and&mldr; &ldquo;I/O devices&rdquo;. The CPU and memory portions are where all the focus is put and the I/O devices portion is always &ldquo;left to the reader&rdquo;. However, there is <em>a lot</em> of stuff happening in that nebulous cloud.</p><p>The first question that arises is: what&rsquo;s in that I/O cloud? Well, take a look:</p><figure><img src=/images/2025-02-28-w2k-device-manager.png><figcaption>The Windows 2000 Device Manager showing the devices by their connection, not by their type. I've chosen to show you this configuration of a virtual machine instead of what a current Windows 11 system shows because the older view is simpler to digest.</figcaption></figure><p>Whoa, that&rsquo;s a lot of stuff, but we can classify the items in the &ldquo;nebulous cloud of I/O devices&rdquo; into two categories:</p><ul><li>The devices themselves, obviously.</li><li>The busses that connect those devices to the CPU.</li></ul><p>Both are important: you might have a fancy keyboard with extra keys that requires a special driver, and this keyboard might come in PS/2 and USB versions. The driver for the keyboard may be the same for each version, but the &ldquo;glue&rdquo; that attaches this keyboard to either bus is different, and the way the kernel can tell whether the keyboard is attached to one port or another also differs.</p><p>So how does the kernel know how to find hardware without tons of repeated code for every bus, you ask? It does so via its knowledge of the hardware topology. Just above, I showed you Windows&rsquo; view of this, but for the rest of this article, I&rsquo;ll use the BSD internals (and NetBSD specifically) because that&rsquo;s what I know best. Don&rsquo;t let that put you off though: all kernels have to do something similar and the differences among them are likely not meaningful.</p><p>Here is a little snippet of the <a href=https://github.com/NetBSD/src/blob/a6998e32a89571344dc476036a4af47672d183f0/sys/arch/amd64/conf/GENERIC>default NetBSD kernel configuration file for the amd64 platform</a>. This snippet lays out the topology of serial ports in the PC and the busses in which they may appear:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>pci*    at mainbus? bus ?
</span></span><span class=line><span class=cl>pcib*   at pci? dev ? function ?
</span></span><span class=line><span class=cl>puc*    at pci? dev ? function ?
</span></span><span class=line><span class=cl>com*    at puc? port ?
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>isa0    at mainbus?
</span></span><span class=line><span class=cl>isa0    at pcib?
</span></span><span class=line><span class=cl>com0    at isa? port 0x3f8 irq 4
</span></span><span class=line><span class=cl>com1    at isa? port 0x2f8 irq 3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>acpi0   at mainbus0
</span></span><span class=line><span class=cl>com*    at acpi?
</span></span></code></pre></div><p>Daunting if you have never seen anything like this, I know, but let me translate this to a diagram:</p><figure><img src=/images/2025-02-28-com-device-tree.png><figcaption>Representation of how the <tt>com</tt> device is expected to appear under various busses according to the kernel configuration file.</figcaption></figure><p>Much clearer in picture form, right? What this chunk of configuration does is tell the kernel the places where the <code>com</code> driver can find serial ports. We have a chunk that says that <code>com0</code> and <code>com1</code> can appear on the ISA bus at <em>specific</em> I/O addresses and interrupts, and in turn that the ISA bus may be a directly-addressable physical bus (<code>isa0 at mainbus?</code>) and/or an ISA bus exposed via a PCI bridge (<code>isa0 at pcib?</code>). Then, we have additional entries telling us that the serial ports can also be configured via ACPI (<code>com* at acpi?</code>), and that the serial ports may exist on expansion cards (<code>com* at puc?</code>) providing communication ports via the PCI bus (<code>puc* at pci?</code>).</p><p>The problem is: the kernel configuration tells us <em>what may exist</em>, not <em>what actually exists</em> on a machine. In a sense, the configuration file &ldquo;wires&rdquo; the code of the device drivers like <code>com</code> so that they can find devices that appear under the <code>isa</code>, <code>pci</code>, or <code>acpi</code> busses. But the kernel must still, at runtime, check and see where the devices actually are. How does that happen?</p><h1 id=hardware-auto-configuration>Hardware auto-configuration</h1><p>To answer the question of how the kernel discovers which hardware is present and where it is, let&rsquo;s dissect NetBSD&rsquo;s <a href=https://man.netbsd.org/autoconf.9>autoconf(9)</a> manual page:</p><blockquote><p>Autoconfiguration is the process of matching hardware devices with an appropriate device driver. In its most basic form, autoconfiguration consists of the recursive process of finding and attaching all devices on a bus, including other busses.</p></blockquote><p>From this paragraph, we can extract the following: the kernel contains a collection of device drivers (like the <code>com</code> presented earlier). Device drivers are just code that knows how to interact with specific devices, but the &ldquo;location&rdquo; of these devices in the hardware topology may vary (the &ldquo;bindings&rdquo; to <code>isa</code>, <code>puc</code>, and <code>acpi</code> in the earlier example). Moving on:</p><blockquote><p>The autoconfiguration framework supports direct configuration where the bus driver can determine the devices present. The autoconfiguration framework also supports indirect configuration where the drivers must probe the bus looking for the presence of a device. Direct configuration is preferred since it can find hardware regardless of the presence of proper drivers.</p></blockquote><p>Direct and indirect configuration. Hmm. This sounds like the PnP story, and it kinda does. See, pay close attention to these two lines from the earlier snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>com0    at isa? port 0x3f8 irq 4
</span></span><span class=line><span class=cl>com1    at isa? port 0x2f8 irq 3
</span></span></code></pre></div><p>These are the BSD equivalent of the <code>SET BLASTER=A220 I5 D1 H5</code> command for DOS I mentioned in the introduction: they tell the kernel which precise addresses and interrupts to use for the two standard PC serial ports <em>if an ISA bus is present</em>.</p><p>But what about <code>com* at puc?</code> and <code>com* at acpi?</code>? These lines are neat because they do <em>not</em> tell us, in advance, where to find the serial ports: we expect the kernel to discover those details at runtime so that we don&rsquo;t have to recompile the kernel when the hardware changes. But even if these two look similar, they are quite different: the <code>com* at puc?</code> is an indirect configuration entry: the <code>puc</code> driver will have to probe the PCI bus for the presence of a communications card and, if one exists, tell the <code>com</code> driver that it can attach to it. On the other hand, the <code>com* at acpi?</code> entry is direct: the kernel will read the ACPI configuration (a static table) to know where the ports are and then use those details to configure the <code>com</code> driver.</p><p>Alright, so this raises <em>another</em> question. What <em>is</em> ACPI?</p><h1 id=acpi>ACPI</h1><p>ACPI, despite being declared with <code>acpi0 at mainbus0</code> in a form similar to <code>isa0 at mainbus?</code>, is <em>not</em> a bus: ACPI does not physically connect devices to one another. To understand what ACPI does, we can start by realizing that it stands for <a href=https://en.wikipedia.org/wiki/ACPI>Advanced Configuration and Power Interface</a> and then, quoting the Wikipedia article:</p><blockquote><p>Advanced Configuration and Power Interface (ACPI) is an open standard that operating systems can use to discover and configure computer hardware components, to perform power management (e.g. putting unused hardware components to sleep), auto configuration (e.g. Plug and Play and hot swapping), and status monitoring.</p></blockquote><p>ACPI is about configuration, and the kernel uses the ACPI tables, present in any modern PC, to find where devices are. To illustrate how this works, let&rsquo;s look at the <code>com* at acpi?</code> line. This line says that the serial port can be configured via ACPI if ACPI happens to have an entry for it. And you know, we can peek into the ACPI tables of a running machine to see what that might be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># acpidump -dt | grep -A15 COM1
</span></span><span class=line><span class=cl>Device (COM1)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    Name (_HID, EisaId (&#34;PNP0501&#34;) /* 16550A-compatible COM Serial Port */)  // _HID: Hardware ID
</span></span><span class=line><span class=cl>    Name (_UID, One)  // _UID: Unique ID
</span></span><span class=line><span class=cl>    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        IO (Decode16,
</span></span><span class=line><span class=cl>            0x03F8,             // Range Minimum
</span></span><span class=line><span class=cl>            0x03F8,             // Range Maximum
</span></span><span class=line><span class=cl>            0x01,               // Alignment
</span></span><span class=line><span class=cl>            0x08,               // Length
</span></span><span class=line><span class=cl>            )
</span></span><span class=line><span class=cl>        IRQNoFlags ()
</span></span><span class=line><span class=cl>            {4}
</span></span><span class=line><span class=cl>    })
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl># ‚ñà
</span></span></code></pre></div><p><em>(Pro-tip: you can use <code>acpidump</code> to extract the Windows license key bound to your machine, if any. I&rsquo;ve needed to do this in the past to install Windows in a VM after replacing the host OS with FreeBSD.)</em></p><p>Voila. The ACPI tables provided by the system tell us a similar story to what the explicit <code>com0 at isa?</code> entry did (and no surprise here because this is a legacy device): there is a serial port at base address 0x3f8 that uses interrupt 4. But also, this table tells us the hardware identifier for this entry: <code>PNP0501</code>. Grepping through the NetBSD kernel code base for this identifier, we land on the <a href=https://github.com/NetBSD/src/blob/caa9bad5633244c08bb86b00eab45f3d92882415/sys/dev/acpi/com_acpi.c#L60><code>dev/acpi/com_acpi.c</code></a> file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>device_compatible_entry</span> <span class=n>compat_data</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 16550A-compatible COM port */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=p>.</span><span class=n>compat</span> <span class=o>=</span> <span class=s>&#34;PNP0501&#34;</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>COM_TYPE_NORMAL</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p><em>(Another pro-tip: master <a href=https://github.com/BurntSushi/ripgrep>ripgrep</a>. Knowing how to find a needle in the haystack of a large code base will grant you super-powers among your coworkers. Being able to pinpoint where specifically to start an investigation based on a &ldquo;random-looking&rdquo; string is invaluable.)</em></p><p>Aha! This <code>com_acpi.c</code> file provides the necessary glue to direct the generic serial port <code>com</code> driver to the hardware via whatever the ACPI tables prescribe. From here, the kernel can proceed to <em>attach</em> the driver to the device and connect the dots between the user-space <code>/dev/ttyS0</code> interface to the physical serial port.</p><h1 id=device-tree>Device Tree</h1><p>In the world of embedded devices powered by SOCs&mdash;"<a href=https://en.wikipedia.org/wiki/System_on_a_chip>System on a Chip</a>", a term that describes single chips that provide all functions to build a computer, ranging from the CPU to sound and network cards&mdash;we don&rsquo;t have ACPI tables. What we used to have instead was explicit code <em>for every board/chip combination</em> that knew how to address the hardware in each SOC. Linux used to be a mess of half-baked and abandoned forks, each supporting a different board without hopes of unification into mainline due to the lack of generic interfaces.</p><p>The <a href=https://www.devicetree.org/>Device Tree</a> specification fixed this issue for the most part for architectures like aarch64. With Device Tree, each hardware or OS vendor provides a static table that describes the layout of a board&rsquo;s hardware separately from the code of the kernel. Then, the kernel peeks into this table to know which devices exist and where they are in the machine layout, much like it does with ACPI.</p><p>A big difference with ACPI, however, is that the kernel cannot query the Device Tree from the hardware because&mldr; well, the Device Tree is external to the hardware. The kernel expects the Device Tree to &ldquo;exist in memory&rdquo; either because the kernel image <em>embeds</em> the Device Tree for the target board or because the boot loader loads the Device Tree from disk and passes it to the kernel.</p><p>Once the kernel has the Device Tree though, the hardware discovery process is similar to the one in ACPI: the kernel scans the Device Tree and looks for drivers that can attach to device nodes based on hardware identifiers. From the perspective of the kernel configuration, things look very similar between amd64 and aarch64. See this snippet from the <a href=https://github.com/NetBSD/src/blob/a6998e32a89571344dc476036a4af47672d183f0/sys/arch/evbarm/conf/GENERIC64>generic kernel of the evbarm port</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>armfdt0     at root
</span></span><span class=line><span class=cl>simplebus*  at fdt? pass 0
</span></span><span class=line><span class=cl>com*        at fdt? pass 4
</span></span></code></pre></div><p>This configuration snippet tells the aarch64 kernel that a <code>com</code> device may appear on <code>fdt</code>, which stands for &ldquo;Flat Device Tree&rdquo;. In turn, <code>armfdt0 at root</code> says that there is a specific driver named <code>armfdt0</code> that provides access to the <code>fdt</code> loaded by the boot loader on an ARM machine.</p><p>We can inspect the Device Tree from the command line as the Device Tree is exposed via the same interface that OpenFirmware used due to its historical roots. For example, to fetch the portion of the Device Tree for the serial port on an aarch64 machine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ofctl serial1</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Caching <span class=m>121</span> nodes and <span class=m>781</span> properties<span class=o>]</span>
</span></span><span class=line><span class=cl>clocks                  0000000e <span class=m>00000000</span> ........ ........   ........
</span></span><span class=line><span class=cl>compatible              6272636d 2c62636d <span class=m>32383335</span> 2d617578   <span class=s2>&#34;brcm,bcm2835-aux
</span></span></span><span class=line><span class=cl><span class=s2>            0010:       2d756172 7400.... ........ ........   -uart&#34;</span>
</span></span><span class=line><span class=cl>interrupts              <span class=m>00000001</span> 0000001d ........ ........   ........
</span></span><span class=line><span class=cl>name                    <span class=m>73657269</span> 616c00.. ........ ........   <span class=s2>&#34;serial&#34;</span>
</span></span><span class=line><span class=cl>phandle                 0000004c ........ ........ ........   ...L
</span></span><span class=line><span class=cl>pinctrl-0               0000000f ........ ........ ........   ....
</span></span><span class=line><span class=cl>pinctrl-names           <span class=m>64656661</span> 756c7400 ........ ........   default.
</span></span><span class=line><span class=cl>reg                     7e215040 <span class=m>00000040</span> ........ ........   ~!P@...@
</span></span><span class=line><span class=cl>status                  6f6b6179 00...... ........ ........   okay.
</span></span><span class=line><span class=cl><span class=c1># ‚ñà</span>
</span></span></code></pre></div><p>A binary dump. OK, fine, we can intuit <em>something</em> out of this, but it isn&rsquo;t particularly clear. The problem here is that we are looking at the binary encoding of the Device Tree (the DTB). But the DTB is built from a set of corresponding source files (one or more DTS files), and if we look at the common <a href=https://github.com/NetBSD/src/blob/caa9bad5633244c08bb86b00eab45f3d92882415/sys/external/gpl2/dts/dist/arch/arm/boot/dts/bcm283x.dtsi#L385>DTS for Broadcom 283x boards</a>, we find the following more-readable content:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>/ {
</span></span><span class=line><span class=cl>    aliases {
</span></span><span class=line><span class=cl>        /* ... */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        serial1 = &#34;/soc/serial@7e215040&#34;;
</span></span><span class=line><span class=cl>    };
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    soc {
</span></span><span class=line><span class=cl>        /* ... */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        serial@7e215040 {
</span></span><span class=line><span class=cl>            compatible = &#34;brcm,bcm2835-aux-uart&#34;;
</span></span><span class=line><span class=cl>            reg = &lt;0x7e215040 0x40&gt;;
</span></span><span class=line><span class=cl>            interrupts = &lt;0x01 0x1d&gt;;
</span></span><span class=line><span class=cl>            clocks = &lt;0x0e 0x00&gt;;
</span></span><span class=line><span class=cl>            status = &#34;okay&#34;;
</span></span><span class=line><span class=cl>            pinctrl-names = &#34;default&#34;;
</span></span><span class=line><span class=cl>            pinctrl-0 = &lt;0x0f&gt;;
</span></span><span class=line><span class=cl>            phandle = &lt;0x4c&gt;;
</span></span><span class=line><span class=cl>        };
</span></span><span class=line><span class=cl>    };
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>The detail to highlight here is the <code>brcm,bcm2835-aux-uart</code> identifier. If we search for this in the code base with the ripgrep super-powers you gained earlier, we find the <a href=https://github.com/NetBSD/src/blob/caa9bad5633244c08bb86b00eab45f3d92882415/sys/arch/arm/broadcom/bcm2835_com.c#L54><code>arch/arm/broadcom/bcm2835_com.c</code></a> file, which contains:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>device_compatible_entry</span> <span class=n>compat_data</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=p>.</span><span class=n>compat</span> <span class=o>=</span> <span class=s>&#34;brcm,bcm2835-aux-uart&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>DEVICE_COMPAT_EOL</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Once again: we found the glue that connects a generic <code>com</code> driver to a specific hardware device.</p><h1 id=loading-dtbs-at-boot-time>Loading DTBs at boot time</h1><p>Let&rsquo;s dig a bit further though. I mentioned earlier that the boot loader is responsible for loading the Device Tree into memory and passing it to the kernel. How is that done? Well, it really depends on the specific machine you are dealing with. In here, I&rsquo;m just going to <em>very briefly</em> touch upon how the Raspberry Pi does it because that&rsquo;s the specific non-PC hardware I have access to. And for this, I&rsquo;ll take you through the investigative journey I took.</p><p>The specific problem I faced was that NetBSD was <em>not</em> able to discover the SPI bus even when I had enabled the right SPI driver in the kernel for my Raspberry Pi 3B. By that point, I was aware that DTBs existed and I suspected that something might be wrong with them, so my first instinct was to check and see what the DTB had to say about the SPI.</p><p>Digging through the FAT partition of the disk image I was using, I found the <code>dtb/broadcom/bcm2837-rpi-3-b.dtb</code> file&mdash;the DTB for my specific board. The way the Raspberry Pi boot loader finds this file is by looking for a file matching the board&rsquo;s own name (<code>bcm2837-rpi-3-b.dtb</code>) in the location specified by the <a href=https://www.raspberrypi.com/documentation/computers/config_txt.html#os_prefix><code>os_prefix</code> configuration property</a> in the <code>config.txt</code> placed at the root of the FAT partition.</p><p>Once I found that file and after learning about the <code>dtc</code> tool (the Device Tree Compiler) which transforms DTS files into DTBs and vice versa, I could decompile the DTS:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ dtc -I dtb -O dts bcm2837-rpi-3-b.dtb -o bcm2837-rpi-3-b.dts
</span></span><span class=line><span class=cl>... various warnings ...
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>Then, peeking into the decompiled DTS file, I found:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>spi@7e204000 {
</span></span><span class=line><span class=cl>    compatible = &#34;brcm,bcm2835-spi&#34;;
</span></span><span class=line><span class=cl>    reg = &lt;0x7e204000 0x200&gt;;
</span></span><span class=line><span class=cl>    interrupts = &lt;0x02 0x16&gt;;
</span></span><span class=line><span class=cl>    clocks = &lt;0x06 0x14&gt;;
</span></span><span class=line><span class=cl>    #address-cells = &lt;0x01&gt;;
</span></span><span class=line><span class=cl>    #size-cells = &lt;0x00&gt;;
</span></span><span class=line><span class=cl>    status = &#34;disabled&#34;;
</span></span><span class=line><span class=cl>    dmas = &lt;0x0b 0x06 0x0b 0x07&gt;;
</span></span><span class=line><span class=cl>    dma-names = &#34;tx\0rx&#34;;
</span></span><span class=line><span class=cl>    phandle = &lt;0x49&gt;;
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>I verified that the SPI kernel driver recognized the <code>brcm,bcm2835-spi</code> identifier just as we did earlier on for the serial port. And it did match, so I was puzzled for a moment.</p><p>But then I noticed the innocuous <code>status = "disabled"</code> line. Aha! The SPI device was disabled by default. I modified that line with <code>status = "okay"</code> following what other entries in the DTS did, recompiled the DTS into the DTB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ dtc -I dts -O dtb bcm2837-rpi-3-b.dts -o bcm2837-rpi-3-b.dtb
</span></span><span class=line><span class=cl>... various warnings ...
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>&mldr; rebooted the board and&mldr; voila!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># dmesg | grep spi
</span></span><span class=line><span class=cl>[     1.000003] bcmspi0 at simplebus1: SPI
</span></span><span class=line><span class=cl>[     1.000003] bcmspi0: interrupting on icu irq 54
</span></span><span class=line><span class=cl>[     1.000003] spi0 at bcmspi0: SPI bus
</span></span><span class=line><span class=cl># ‚ñà
</span></span></code></pre></div><p>The kernel successfully attached the SPI driver and the SPI bus started working, which in turn led to a multi-hour debugging session to make the EndBASIC ST7735S driver work&mdash;but in the end it did.</p><figure><video width=100% controls>
<source src=/images/2025-02-28-rpi3-lcd-endbox.mp4 type=video/mp4></video><figcaption>Demonstration of the "EndBASIC Dev Kit" box I'm working on, booting NetBSD, showing the EndBASIC console on a small LCD, and then running the Game of Life.</figcaption></figure><p>Yes, there are nicer ways to do what I did here because the DTBs are provided by upstream and you should not be modifying them. What you should do instead is create a DTB overlay, which is a separate small DTB that &ldquo;patches&rdquo; the upstream DTB, and then tell the boot loader to process it via the <code>dtoverlay</code> stanza in the <code>config.txt</code> file. Details left to you, reader. Just beware that the Raspberry Pi boot loader is picky about file paths and <a href=https://www.raspberrypi.com/documentation/computers/config_txt.html>the documentation is your friend</a> here.</p><h1 id=how-do-acpi-and-device-tree-differ>How do ACPI and Device Tree differ?</h1><p>Based on everything I told you about here, ACPI and Device Tree look oddly similar&mdash;and that&rsquo;s because they are! From the perspective of <em>describing</em> hardware to the kernel, the two technologies are equivalent, but they differ for historical reasons. ACPI has its roots in APM, a PC technology, whereas Device Tree is based on <a href=https://en.wikipedia.org/wiki/Open_Firmware>OpenFirmware</a>, a technology that originated at Sun Microsystems for its SPARC machines and that was later used by Apple on their PowerPC-based Macs.</p><p>One difference between the two, though, is that ACPI does more than just describe hardware. ACPI provides a bunch of hardware-specific routines in a bytecode that the operating system can call into to manipulate the hardware. This is often maligned because ACPI introduces non-free and opaque blobs in the interaction between the operating system kernel and the hardware, but <a href=https://mjg59.dreamwidth.org/68350.html>Matthew Garret has a great essay on why ACPI is necessary</a> and why it is better than all other alternatives, possibly including Device Tree.</p><p>In any case, that&rsquo;s all for today. I found this exercise of dealing with the Device Tree pretty fun and I thought I could share something interesting with you all. I intentionally omitted many details because the topic of hardware configuration is vast and tricky, but you can continue building your knowledge from the bits above and from the fabulous <a href=https://wiki.osdev.org/>OSDev wiki</a>.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/02/ioctls-rust.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/03/bazel-at-snowflake-two-years-in.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Hardware+discovery%3A+ACPI+%26+Device+Tree&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fhardware-autoconfiguration.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Hardware+discovery%3A+ACPI+%26+Device+Tree&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fhardware-autoconfiguration.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Hardware+discovery%3A+ACPI+%26+Device+Tree+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fhardware-autoconfiguration.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.jmmv.dev/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>