<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>ioctls from Rust - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="ioctls from Rust - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="ioctls from Rust - Julio Merino (jmmv.dev)"><meta name=description content="In Unix-like systems, &ldquo;everything is a file and a file is defined as a byte stream you can open, read from, write to, and ultimately close&rdquo;&mldr; right? Right? Well, not quite. It&rsquo;s better to say file descriptors provide access to almost every system that the kernel provides, but not that they can all be manipulated with the same quartet of system calls, nor that they all behave as byte streams.
Because you see: network connections are manipulated via file descriptors indeed, but you don&rsquo;t open them: you bind, listen/accept and/or connect to them. And then you don&rsquo;t read from and write to network connections: you somehow send to and recv from them. Device drivers are similar: yes, hardware devices are represented as &ldquo;virtual files&rdquo; in the /dev hierarchy and many support read and write&mldr; but these two system calls are not sufficient to access the breath of functionality that the hardware drivers provide. No, you need ioctl.
ioctl is the poster child of the system call that breaks Unix&rsquo;s &ldquo;everything is a file&rdquo; paradigm. ioctl is the API that allows out-of-band communication with the kernel side of an open file descriptor. To see cool examples, refer back to my previous article where I demonstrated how to drive graphics from the console without X11: in that post, we had to open the console device, but then we had to use ioctl to obtain the properties of the framebuffer, and then we had to mmap the device&rsquo;s content for direct access: no reads nor writes involved.
All the code I showed you in that earlier post was written in C to keep the graphics article to-the-point, but the code I&rsquo;m really working on is part of EndBASIC, and thus it is all Rust. And the thing is, ioctls are not easy to issue from Rust. In fact, after 7 years of Rust-ing, it&rsquo;s the first time I&rsquo;ve had to reach for unsafe code blocks, and there was no good documentation on how to deal with ioctl. So this posts aims to fix that by presenting what ways there are to call ioctls from Rust&mldr; and, of course, diving a bit deeper into what ioctls actually are.
"><meta property="og:description" content="In Unix-like systems, &ldquo;everything is a file and a file is defined as a byte stream you can open, read from, write to, and ultimately close&rdquo;&mldr; right? Right? Well, not quite. It&rsquo;s better to say file descriptors provide access to almost every system that the kernel provides, but not that they can all be manipulated with the same quartet of system calls, nor that they all behave as byte streams.
Because you see: network connections are manipulated via file descriptors indeed, but you don&rsquo;t open them: you bind, listen/accept and/or connect to them. And then you don&rsquo;t read from and write to network connections: you somehow send to and recv from them. Device drivers are similar: yes, hardware devices are represented as &ldquo;virtual files&rdquo; in the /dev hierarchy and many support read and write&mldr; but these two system calls are not sufficient to access the breath of functionality that the hardware drivers provide. No, you need ioctl.
ioctl is the poster child of the system call that breaks Unix&rsquo;s &ldquo;everything is a file&rdquo; paradigm. ioctl is the API that allows out-of-band communication with the kernel side of an open file descriptor. To see cool examples, refer back to my previous article where I demonstrated how to drive graphics from the console without X11: in that post, we had to open the console device, but then we had to use ioctl to obtain the properties of the framebuffer, and then we had to mmap the device&rsquo;s content for direct access: no reads nor writes involved.
All the code I showed you in that earlier post was written in C to keep the graphics article to-the-point, but the code I&rsquo;m really working on is part of EndBASIC, and thus it is all Rust. And the thing is, ioctls are not easy to issue from Rust. In fact, after 7 years of Rust-ing, it&rsquo;s the first time I&rsquo;ve had to reach for unsafe code blocks, and there was no good documentation on how to deal with ioctl. So this posts aims to fix that by presenting what ways there are to call ioctls from Rust&mldr; and, of course, diving a bit deeper into what ioctls actually are.
"><meta property="twitter:description" content="In Unix-like systems, &ldquo;everything is a file and a file is defined as a byte stream you can open, read from, write to, and ultimately close&rdquo;&mldr; right? Right? Well, not quite. …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2025/02/ioctls-rust.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2025/02/ioctls-rust.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2025-02-13-ioctls-rust-cover-image.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2025-02-13-ioctls-rust-cover-image.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI1LzAyL2lvY3Rscy1ydXN0Lmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/ioctls-rust")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>ioctls from Rust</h1><p>February 13, 2025 &#183;
About 14 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/rust>rust</a>, <a href=/tags/unix>unix</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/ioctls-rust>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2025-02-13-ioctls-rust-cover-image.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>In Unix-like systems, &ldquo;everything is a file and a file is defined as a byte stream you can <code>open</code>, <code>read</code> from, <code>write</code> to, and ultimately <code>close</code>&rdquo;&mldr; right? <em>Right?</em> Well, not quite. It&rsquo;s better to say <em>file descriptors</em> provide access to almost every system that the kernel provides, but not that they can all be manipulated with the same quartet of system calls, nor that they all behave as byte streams.</p><p>Because you see: network connections are manipulated via file descriptors indeed, but you don&rsquo;t <code>open</code> them: you <code>bind</code>, <code>listen</code>/<code>accept</code> and/or <code>connect</code> to them. And then you don&rsquo;t <code>read</code> from and <code>write</code> to network connections: you somehow <code>send</code> to and <code>recv</code> from them. Device drivers are similar: yes, hardware devices are represented as &ldquo;virtual files&rdquo; in the <code>/dev</code> hierarchy and many support <code>read</code> and <code>write</code>&mldr; but these two system calls are not sufficient to access the breath of functionality that the hardware drivers provide. No, you need <code>ioctl</code>.</p><p><code>ioctl</code> is the poster child of the system call that breaks Unix&rsquo;s &ldquo;everything is a file&rdquo; paradigm. <code>ioctl</code> is the API that allows out-of-band communication with the kernel side of an open file descriptor. To see cool examples, <a href=/2025/01/netbsd-graphics-wo-x11.html>refer back to my previous article</a> where I demonstrated how to drive graphics from the console without X11: in that post, we had to <code>open</code> the console device, but then we had to use <code>ioctl</code> to obtain the properties of the framebuffer, and then we had to <code>mmap</code> the device&rsquo;s content for direct access: no <code>read</code>s nor <code>write</code>s involved.</p><p>All the code I showed you in that earlier post was written in C to keep the graphics article to-the-point, but the code I&rsquo;m really working on is part of EndBASIC, and thus it is all Rust. And the thing is, <code>ioctl</code>s are not easy to issue from Rust. In fact, after 7 years of Rust-ing, it&rsquo;s the first time I&rsquo;ve had to reach for <code>unsafe</code> code blocks, and there was no good documentation on how to deal with <code>ioctl</code>. So this posts aims to fix that by presenting what ways there are to call <code>ioctl</code>s from Rust&mldr; and, of course, diving a bit deeper into what <code>ioctl</code>s actually <em>are</em>.</p><h1 id=our-target>Our target</h1><p>For all examples below, I&rsquo;ll be using a relatively simple <code>ioctl</code> from NetBSD&rsquo;s <a href=https://man.netbsd.org/wsdisplay.4>wsdisplay(4)</a> driver. This API is available via the console device file, typically <code>/dev/ttyE0</code>, and is named <code>WSDISPLAYIO_GINFO</code>. Here is what the manual page has to say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>The following ioctl(2) calls are provided by the wsdisplay driver or by
</span></span><span class=line><span class=cl>devices which use it.  Their definitions are found in
</span></span><span class=line><span class=cl>&lt;dev/wscons/wsconsio.h&gt;.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    WSDISPLAYIO_GINFO (struct wsdisplay_fbinfo)
</span></span><span class=line><span class=cl>        Retrieve basic information about a framebuffer display.
</span></span><span class=line><span class=cl>        The returned structure is as follows:
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>            struct wsdisplay_fbinfo {
</span></span><span class=line><span class=cl>                    u_int   height;
</span></span><span class=line><span class=cl>                    u_int   width;
</span></span><span class=line><span class=cl>                    u_int   depth;
</span></span><span class=line><span class=cl>                    u_int   cmsize;
</span></span><span class=line><span class=cl>            };
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        The height and width members are counted in pixels.  The
</span></span><span class=line><span class=cl>        depth member indicates the number of bits per pixel, and
</span></span><span class=line><span class=cl>        cmsize indicates the number of color map entries accessible
</span></span><span class=line><span class=cl>        through WSDISPLAYIO_GETCMAP and WSDISPLAYIO_PUTCMAP.  This
</span></span><span class=line><span class=cl>        call is likely to be unavailable on text-only displays.
</span></span></code></pre></div><p>Calling this API from a C program would be trivial and look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dev/wscons/wsconsio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// ... open `/dev/ttyE0` as fd ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>wsdisplay_fbinfo</span> <span class=n>fbi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>WSDISPLAYIO_GINFO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fbi</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fbi now contains the data returned by the kernel.
</span></span></span></code></pre></div><p>The reason I&rsquo;m picking <code>WSDISPLAYIO_GINFO</code> specifically to talk about <code>ioctl</code>s in this article is three-fold:</p><ul><li>it returns a small structure with <a href=/2024/10/x86-64-programming-models.html>platform-dependent integers</a>, so the sample code in the article will be relatively short;</li><li>it relies on platform-specific integer types, so we&rsquo;ll have to account for that in Rust; and</li><li>it is &ldquo;rare enough&rdquo; (we are talking about NetBSD after all) that it is not going to be supported by any of the common Rust crates like libc or nix, so we&rsquo;ll have to do extra work to call it.</li></ul><h1 id=what-is-an-ioctl-anyway>What is an ioctl anyway?</h1><p>The manual page helpfully provides us a copy of the data structure returned by the <code>ioctl</code>, and the BSD manual pages are typically <em>awesome</em>, but it&rsquo;s worth double-checking that the code snippet actually matches the code it documents. Peeking into <code>/usr/include/dev/wscons/wsconsio.h</code> as the manual page directs us, we find:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Basic display information.  Not applicable to all display types. */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>wsdisplay_fbinfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u_int</span>   <span class=n>height</span><span class=p>;</span>             <span class=cm>/* height in pixels */</span>
</span></span><span class=line><span class=cl>    <span class=n>u_int</span>   <span class=n>width</span><span class=p>;</span>              <span class=cm>/* width in pixels */</span>
</span></span><span class=line><span class=cl>    <span class=n>u_int</span>   <span class=n>depth</span><span class=p>;</span>              <span class=cm>/* bits per pixel */</span>
</span></span><span class=line><span class=cl>    <span class=n>u_int</span>   <span class=n>cmsize</span><span class=p>;</span>             <span class=cm>/* color map size (entries) */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#define WSDISPLAYIO_GINFO _IOR(&#39;W&#39;, 65, struct wsdisplay_fbinfo)
</span></span></span></code></pre></div><p>OK, great, the <code>wsdisplay_fbinfo</code> structure perfectly aligns with the manual page contents. But what&rsquo;s more interesting is the <code>#define</code>, which says that <code>WSDISPLAYIO_GINFO</code> is:</p><ul><li>an ioctl that <em>reads</em> from the kernel (<code>_IOR</code>),</li><li>that invokes function number 65 from the <code>W</code> class (which probably stands for &ldquo;the <em>W</em>scons device driver&rdquo;), and</li><li>that places the returned data into a structure of type <code>wsdisplay_fbinfo</code> (not to be confused with <code>wsdisplayio_fbinfo</code>).</li></ul><p>In a way, this is just like any other function or system call, except that it&rsquo;s not defined as such and is instead funneled through a single API. <code>ioctl</code> is, therefore, &ldquo;just&rdquo; a grab bag of arbitrary functionality, and what can be invoked on a given file descriptor depends on what the file descriptor represents.</p><p>The reasons for this design are historical and, of course, there could have been other options.</p><p>For example: you know how regular files have an internal structure, right? The vast majority of file formats out there contain a header, which then specifies various sections within the file, which then contain data. The same could have been done with device drivers: their virtual files could have predefined some internal format such that, e.g. the <code>wsdisplay_fbinfo</code> structure always appeared at offset 0x1000 of the virtual file. <code>read</code> and <code>write</code> would have been sufficient for this design, albeit you&rsquo;d almost-certainly wanted to combine it with <code>mmap</code> for more efficient access.</p><p>Or another example: device drivers could have used an RPC-like mechanism where each write to the file descriptor is a &ldquo;message&rdquo; that requests a specific function, and that the kernel responds to with an answer. <code>read</code> and <code>write</code> would have been sufficient for this design.</p><p>Or yet another example: the requests to the device driver could have been intermixed with the data, such that if the data contained a specific sequence, the kernel would invoke a function instead of processing data. Sounds crazy, right? But that&rsquo;s what pseudo-terminals do: all those <a href=https://en.wikipedia.org/wiki/ANSI_escape_code>control sequences</a> to change colors and the like are telling the terminal driver to do something special.</p><p>In any case, these are all alternate designs and&mldr; I&rsquo;m sure they all live in some form or another in current systems. There is no consistency in how <code>/dev</code> pseudo-files expose their behavior, and <code>ioctl</code>s are just one of the options we have to deal with. So without further ado, let&rsquo;s look at three different ways of calling these services from Rust.</p><h1 id=option-1-nix>Option 1: nix</h1><p>The first option to call an <code>ioctl</code> from Rust is to leverage the neat <a href=https://docs.rs/nix/>nix crate</a>, which provides idiomatic access to Unix primitives. This crate is not to be confused with NixOS, with which it has no relation.</p><p>To use nix to invoke <code>ioctl</code>s, we need to do two things.</p><p>First, we need to define the data structure used by the <code>ioctl</code>. In C, we would just <code>#include &lt;dev/wscons/wsconsio.h></code>, but in Rust we don&rsquo;t have access to the C-style headers. Instead, we have to do extra work to define the same memory layout of the C <code>wsdisplay_fbinfo</code> structure, but in Rust:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ffi</span>::<span class=n>c_uint</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>WsDisplayFbInfo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>depth</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cmsize</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>It is <em>very important</em> to declare the structure as having a C representation so that its memory layout matches what the C compiler produces for the same structure. The kernel expects C semantics in its system call boundary, and we must adhere to that. Additionally, we must ensure that the types of each field match the C definitions. Rust only has fixed-size integer types like <code>i16</code> and <code>u32</code>, but C provides platform-dependent integer types like <code>int</code> or <code>unsigned long</code> and these are sometimes used in public kernel interfaces (a mistake, if you ask me). Fear not, though: the <code>std::ffi</code> module provides aliases for those C types.</p><p>And second, we have to do something unique to the nix crate: we have to define a wrapper function for the <code>ioctl</code> so that we can invoke the <code>ioctl</code> as if it were any other function. nix makes this very easy by providing macros that mimic the syntax of the C <code>#define</code> we saw earlier on:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>nix</span>::<span class=n>ioctl_read</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>ioctl_read!</span><span class=p>(</span><span class=n>wsdisplayio_ginfo</span><span class=p>,</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;W&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>65</span><span class=p>,</span><span class=w> </span><span class=n>WsDisplayFbInfo</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>And with that, we are ready to put everything together in a fully-fledged program:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ffi</span>::<span class=n>c_uint</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>os</span>::<span class=n>fd</span>::<span class=p>{</span><span class=n>AsRawFd</span><span class=p>,</span><span class=w> </span><span class=n>FromRawFd</span><span class=p>,</span><span class=w> </span><span class=n>OwnedFd</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>nix</span>::<span class=n>fcntl</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>nix</span>::<span class=n>ioctl_read</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>nix</span>::<span class=n>sys</span>::<span class=n>stat</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[allow(unused)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>WsDisplayFbInfo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>depth</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cmsize</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>ioctl_read!</span><span class=p>(</span><span class=n>wsdisplayio_ginfo</span><span class=p>,</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;W&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>65</span><span class=p>,</span><span class=w> </span><span class=n>WsDisplayFbInfo</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>oflag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fcntl</span>::<span class=n>OFlag</span>::<span class=n>empty</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>oflag</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>fcntl</span>::<span class=n>OFlag</span>::<span class=no>O_RDWR</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>oflag</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>fcntl</span>::<span class=n>OFlag</span>::<span class=no>O_NONBLOCK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>oflag</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>fcntl</span>::<span class=n>OFlag</span>::<span class=no>O_EXCL</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>raw</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>fcntl</span>::<span class=n>open</span><span class=p>(</span><span class=s>&#34;/dev/ttyE0&#34;</span><span class=p>,</span><span class=w> </span><span class=n>oflag</span><span class=p>,</span><span class=w> </span><span class=n>stat</span>::<span class=n>Mode</span>::<span class=n>empty</span><span class=p>())</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>OwnedFd</span>::<span class=n>from_raw_fd</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>fbi</span>: <span class=nc>WsDisplayFbInfo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>fbi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mem</span>::<span class=n>zeroed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>wsdisplayio_ginfo</span><span class=p>(</span><span class=n>fd</span><span class=p>.</span><span class=n>as_raw_fd</span><span class=p>(),</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>fbi</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;fbinfo: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>fbi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=footer><div class=filename><a href=/src/ioctls-rust/nix/src/main.rs type=text/plain>nix/src/main.rs</a></div></div></div><p>There is one surprising detail in this code though: if we went through the hassle of defining a wrapper function for <code>WSDISPLAYIO_GINFO</code> via the idiomatic nix crate, and idiomatic nix usage doesn&rsquo;t require <code>unsafe</code> blocks&mldr; why did we have to wrap the call to <code>wsdisplayio_ginfo</code> in an <code>unsafe</code> block? The reason may be that <code>ioctl</code> can do <em>whatever</em> to the running process and Rust needs to be over-conservative.</p><p>In any case, the above is clean and it works. But&mldr; using nix comes with a cost:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ cargo build
</span></span><span class=line><span class=cl>   Compiling libc v0.2.169
</span></span><span class=line><span class=cl>   Compiling cfg_aliases v0.2.1
</span></span><span class=line><span class=cl>   Compiling bitflags v2.8.0
</span></span><span class=line><span class=cl>   Compiling cfg-if v1.0.0
</span></span><span class=line><span class=cl>   Compiling nix v0.29.0
</span></span><span class=line><span class=cl>   Compiling ioctls-rust-nix v0.1.0 (/home/jmmv/os/homepage/static/src/ioctls-rust/nix)
</span></span><span class=line><span class=cl>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.71s
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>We have pulled 5 crates into the project just to open a file and invoke an <code>ioctl</code>. Not a huge deal in this day and age but&mldr; this contributes to the perception that the Rust ecosystem is a mess of bloated dependencies. Can we do differently?</p><h1 id=option-2-libc>Option 2: libc</h1><p>What if we bypassed nix altogether and invoked libc directly? After all, we can see that nix <em>depends on</em> libc anyway, so we might as well use it at the expense of losing nix&rsquo;s idiomatic representation of Unix&rsquo;s interfaces.</p><p>Sure, we can do that: we can invoke the <code>libc::ioctl</code> function directly, which has this prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd</span>: <span class=nc>c_int</span><span class=p>,</span><span class=w> </span><span class=n>request</span>: <span class=nc>Ioctl</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=p>.)</span><span class=w> </span>-&gt; <span class=nc>c_int</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Alright then: we need a file descriptor as the first argument, which we have. And then we need an <code>Ioctl</code> as the second argument, which we&mldr; wait, what is this <code>Ioctl</code> type? If we look for its definition in the libc source code, we find that <code>Ioctl</code> is an alias for an integer type (<code>unsigned long</code> or <code>int</code> depending on the platform), and this matches the C definition of <code>ioctl</code>. OK, nothing special.</p><p>But then&mldr; what do we pass in this second argument? If we were writing C, we would use the <code>WSDISPLAY_GINFO</code> constant, but we don&rsquo;t have that in Rust because we don&rsquo;t get access to the C header files. So what <em>is</em> <code>WSDISPLAY_GINFO</code>? Remember that we previously saw that it is defined as such:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define WSDISPLAYIO_GINFO _IOR(&#39;W&#39;, 65, struct wsdisplay_fbinfo)
</span></span></span></code></pre></div><p>&mldr; which doesn&rsquo;t help us much at this point. But we can chase the definition of <code>_IOR</code>, end up in <code>/usr/include/sys/ioccom.h</code>, and see:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define _IOC(inout, group, num, len) \
</span></span></span><span class=line><span class=cl><span class=cp>    ((inout) | (((len) &amp; IOCPARM_MASK) &lt;&lt; IOCPARM_SHIFT) | \
</span></span></span><span class=line><span class=cl><span class=cp>    ((group) &lt;&lt; IOCGROUP_SHIFT) | (num))
</span></span></span><span class=line><span class=cl><span class=cp>#define _IOR(g,n,t)     _IOC(IOC_OUT,   (g), (n), sizeof(t))
</span></span></span></code></pre></div><p>Ugh. We are combining the various arguments to <code>_IOR</code> into a number. This is hard to decipher by just reading the code, so we can ask the compiler to tell us the actual value of the constant instead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dev/wscons/wsconsio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>WSDISPLAYIO_GINFO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And if we run the program, we get that <code>WSDISPLAYIO_GINFO</code> is <code>0x40105741</code>. Knowing that, it&rsquo;s <a href=https://en.wikipedia.org/wiki/Small_matter_of_programming>an SMOP</a> to call the <code>ioctl</code> using the <a href=https://docs.rs/libc/>libc crate</a> alone:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ffi</span>::<span class=p>{</span><span class=n>c_char</span><span class=p>,</span><span class=w> </span><span class=n>c_uint</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>os</span>::<span class=n>fd</span>::<span class=p>{</span><span class=n>AsRawFd</span><span class=p>,</span><span class=w> </span><span class=n>FromRawFd</span><span class=p>,</span><span class=w> </span><span class=n>OwnedFd</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=no>WSDISPLAYIO_GINFO</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mh>0x40105741</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[allow(unused)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>WsDisplayFbInfo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>depth</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cmsize</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>libc</span>::<span class=n>open</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=s>&#34;/dev/ttyE0</span><span class=se>\0</span><span class=s>&#34;</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=n>c_char</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>libc</span>::<span class=no>O_RDWR</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>libc</span>::<span class=no>O_NONBLOCK</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>libc</span>::<span class=no>O_EXCL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>last_os_error</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>OwnedFd</span>::<span class=n>from_raw_fd</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>fbi</span>: <span class=nc>WsDisplayFbInfo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>fbi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mem</span>::<span class=n>zeroed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>libc</span>::<span class=n>ioctl</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>fd</span><span class=p>.</span><span class=n>as_raw_fd</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=no>WSDISPLAYIO_GINFO</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>fbi</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>WsDisplayFbInfo</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>last_os_error</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;fbinfo: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>fbi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=footer><div class=filename><a href=/src/ioctls-rust/libc/src/main.rs type=text/plain>libc/src/main.rs</a></div></div></div><p>As you can see from this code snippet, we <em>also</em> have to define the <code>WsdisplayFbInfo</code> structure to match the kernel&rsquo;s, so avoiding nix didn&rsquo;t really make things simpler for us&mdash;and in fact, it made them uglier because now we have to deal with libc&rsquo;s oddities like raw C strings, global <code>errno</code> values, and an opaque constant for the <code>ioctl</code> number. Not great.</p><h1 id=option-3-ffi>Option 3: FFI</h1><p>Which makes one wonder&mldr; can we avoid replicating the C interfaces in Rust and instead leverage the system-provided header files? Yes we can. Instead of trying to invoke the <code>ioctl</code>s from Rust, we can invoke them via some custom C glue code. Rust is going to call into the system-provided libc <em>anyway</em> when we invoke a system call, so we might as well switch to C a bit &ldquo;earlier&rdquo;.</p><p>The idea in this case, as in any other computing problem, is to add a layer of abstraction: instead of dealing with the kernel-defined data structures from Rust, we define <em>our own</em> structures and APIs to detach the Rust world from the C world. Here, look:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dev/wscons/wsconsio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>my_ginfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>depth</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_ginfo</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>my_ginfo</span><span class=o>*</span> <span class=n>gi</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>wsdisplay_fbinfo</span> <span class=n>fbi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>WSDISPLAYIO_GINFO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fbi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>gi</span><span class=o>-&gt;</span><span class=n>height</span> <span class=o>=</span> <span class=n>fbi</span><span class=p>.</span><span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gi</span><span class=o>-&gt;</span><span class=n>width</span> <span class=o>=</span> <span class=n>fbi</span><span class=p>.</span><span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gi</span><span class=o>-&gt;</span><span class=n>depth</span> <span class=o>=</span> <span class=n>fbi</span><span class=p>.</span><span class=n>depth</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/ioctls-rust/ffi/src/ffi.c type=text/plain>ffi/src/ffi.c</a></div></div></div><p>We start by declaring our own version of <code>wsdisplay_ginfo</code>, which I&rsquo;ve called <code>my_ginfo</code>, that only includes the few fields we want to propagate to Rust. Yes, in this example the indirection is utterly pointless because we go from 4 to 3 fields so we haven&rsquo;t made our lives easier, but there are <code>ioctl</code>s that return larger structures from which we might only need a few values. Then we define a trivial function to wrap the <code>ioctl</code> and transform its return value into our own structure.</p><p>Then, we go to Rust, re-define our <code>my_ginfo</code> structure as <code>MyGinfo</code> (both of which we fully control so we can easily verify that they match) and we call the wrapping function:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ffi</span>::<span class=p>{</span><span class=n>c_char</span><span class=p>,</span><span class=w> </span><span class=n>c_int</span><span class=p>,</span><span class=w> </span><span class=n>c_uint</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>os</span>::<span class=n>fd</span>::<span class=p>{</span><span class=n>AsRawFd</span><span class=p>,</span><span class=w> </span><span class=n>FromRawFd</span><span class=p>,</span><span class=w> </span><span class=n>OwnedFd</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[allow(unused)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>MyGInfo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>depth</span>: <span class=nc>c_uint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>extern</span><span class=w> </span><span class=s>&#34;C&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>get_ginfo</span><span class=p>(</span><span class=n>fd</span>: <span class=nc>c_int</span><span class=p>,</span><span class=w> </span><span class=n>gi</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>MyGInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>c_int</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>fd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>libc</span>::<span class=n>open</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=s>&#34;/dev/ttyE0</span><span class=se>\0</span><span class=s>&#34;</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=n>c_char</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>libc</span>::<span class=no>O_RDWR</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>libc</span>::<span class=no>O_NONBLOCK</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>libc</span>::<span class=no>O_EXCL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>last_os_error</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>OwnedFd</span>::<span class=n>from_raw_fd</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>gi</span>: <span class=nc>MyGInfo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>gi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mem</span>::<span class=n>zeroed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_ginfo</span><span class=p>(</span><span class=n>fd</span><span class=p>.</span><span class=n>as_raw_fd</span><span class=p>(),</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>gi</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>MyGInfo</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>last_os_error</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;my_ginfo: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>gi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=footer><div class=filename><a href=/src/ioctls-rust/ffi/src/main.rs type=text/plain>ffi/src/main.rs</a></div></div></div><p>The trick now is to link the C code with the Rust code together, and for that, we create a <code>build.rs</code> script. In here, we leverage the <a href=https://docs.rs/cc/>cc crate</a> to put things together, which is an extra dependency that is only used at build time:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=fm>cfg!</span><span class=p>(</span><span class=n>target_os</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;netbsd&#34;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;cargo::rerun-if-changed=src/ffi.c&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cc</span>::<span class=n>Build</span>::<span class=n>new</span><span class=p>().</span><span class=n>file</span><span class=p>(</span><span class=s>&#34;src/ffi.c&#34;</span><span class=p>).</span><span class=n>compile</span><span class=p>(</span><span class=s>&#34;ffi&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;cargo::rerun-if-changed=src/dummy.c&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cc</span>::<span class=n>Build</span>::<span class=n>new</span><span class=p>().</span><span class=n>file</span><span class=p>(</span><span class=s>&#34;src/dummy.c&#34;</span><span class=p>).</span><span class=n>compile</span><span class=p>(</span><span class=s>&#34;ffi&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=footer><div class=filename><a href=/src/ioctls-rust/ffi/build.rs type=text/plain>ffi/build.rs</a></div></div></div><p>And with that, we are done.</p><h1 id=which-option-wins>Which option wins?</h1><p>Well, let&rsquo;s see:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ cargo build --release
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   Compiling ioctls-rust-ffi v0.1.0 (/home/jmmv/ioctls-rust/ffi)
</span></span><span class=line><span class=cl>   Compiling ioctls-rust-libc v0.1.0 (/home/jmmv/ioctls-rust/libc)
</span></span><span class=line><span class=cl>   Compiling ioctls-rust-nix v0.1.0 (/home/jmmv/ioctls-rust/nix)
</span></span><span class=line><span class=cl>    Finished `release` profile [optimized] target(s) in 1.89s
</span></span><span class=line><span class=cl>$ ls -lh target/release/ioctls-rust-* | grep -v \\.d
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 455K Feb 12 08:04 target/release/ioctls-rust-ffi
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 455K Feb 12 08:04 target/release/ioctls-rust-libc
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 464K Feb 12 08:04 target/release/ioctls-rust-nix
</span></span><span class=line><span class=cl>$ strip -s target/release/ioctls-rust-*
</span></span><span class=line><span class=cl>$ ls -lh target/release/ioctls-rust-* | grep -v \\.d
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 353K Feb 12 08:05 target/release/ioctls-rust-ffi
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 353K Feb 12 08:05 target/release/ioctls-rust-libc
</span></span><span class=line><span class=cl>-rwxr-xr-x 2 jmmv jmmv 358K Feb 12 08:05 target/release/ioctls-rust-nix
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>From a binary size perspective, there are no meaningful differences. As expected, the usage of the nix crate results in slightly more code than the other alternatives because nix has to do extra work to translate global <code>errno</code> values into Rust <code>Result</code> types and the like. But the libc and FFI alternatives seem identical.</p><p>At runtime, however, we should expect the FFI option to perform a teeny tiny bit worse (though good luck measuring that) than the libc option because we have to convert between the kernel structure and our own structure in the happy path&mldr; all for dubious benefit.</p><p>All in all, I&rsquo;ll take option 1. I do not like the fact of having to manually replicate the kernel structures in my own code so, if I had the time, I&rsquo;d try to upstream the definitions to the well-tested libc crate or write another reusable crate with just those. But, barring that, the idiomatic nix interfaces make calling Unix primitives a breeze.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2025/01/netbsd-graphics-wo-x11.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/02/hardware-autoconfiguration.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=ioctls+from+Rust&amp;url=https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fioctls-rust.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=ioctls+from+Rust&amp;u=https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fioctls-rust.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=ioctls+from+Rust+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2025%2F02%2Fioctls-rust.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>