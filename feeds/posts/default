<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julio Merino</title>
    <link>http://julio.meroh.net/</link>
    <description>Recent content on Julio Merino</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Feb 2019 15:30:00 -0500</lastBuildDate>
    
	<atom:link href="http://julio.meroh.net/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using setenv equals setting global variables</title>
      <link>http://julio.meroh.net/2019/02/setenv-and-global-variables.html</link>
      <pubDate>Fri, 22 Feb 2019 15:30:00 -0500</pubDate>
      
      <guid>http://julio.meroh.net/2019/02/setenv-and-global-variables.html</guid>
      <description>This is the tale of yet another Bazel bug, this time involving environment variables, global state, and gRPC. Through it, I&amp;rsquo;ll argue that you should never use setenv within a program unless you are doing so to execute something else (and even then with caveats). Before we start, I hope we can agree upfront that using global variables to pass state within a program is bad; can&amp;rsquo;t we?
Bazel is a build tool and, as such, is a program that runs on your computer&amp;mdash;quite likely as an interactive tool on the command line.</description>
    </item>
    
    <item>
      <title>Encode your assumptions</title>
      <link>http://julio.meroh.net/2019/02/encode-your-assumptions.html</link>
      <pubDate>Thu, 07 Feb 2019 07:00:00 -0500</pubDate>
      
      <guid>http://julio.meroh.net/2019/02/encode-your-assumptions.html</guid>
      <description>The point of this post is simple and I&amp;rsquo;ll spoil it from the get go: every time you make an assumption in a piece of code, make such assumption explicit in the form of an assertion or error check. If you cannot do that (are you sure?), then write a detailed comment.
In fact, I&amp;rsquo;m exceedingly convinced that the amount of assertion-like checks in a piece of code is a good indicator of the programmer&amp;rsquo;s expertise.</description>
    </item>
    
    <item>
      <title>Hello, sandboxfs 0.1.0</title>
      <link>http://julio.meroh.net/2019/02/hello-sandboxfs-0.1.0.html</link>
      <pubDate>Tue, 05 Feb 2019 09:00:00 -0500</pubDate>
      
      <guid>http://julio.meroh.net/2019/02/hello-sandboxfs-0.1.0.html</guid>
      <description>I am pleased to announce that the first release of sandboxfs, 0.1.0, is finally here! You can download the sources and prebuilt binaries from the 0.1.0 release page and you can read the installation instructions for more details.
The journey to this first release has been a long one. sandboxfs was first conceived over two years ago, was first announced in August 2017, showed its first promising results in April 2018, and has been undergoing a rewrite from Go to Rust.</description>
    </item>
    
    <item>
      <title>Open files limit, macOS, and the JVM</title>
      <link>http://julio.meroh.net/2019/01/open-files-limit-macos-and-the-jvm.html</link>
      <pubDate>Tue, 29 Jan 2019 17:15:00 -0500</pubDate>
      
      <guid>http://julio.meroh.net/2019/01/open-files-limit-macos-and-the-jvm.html</guid>
      <description>Bazel&amp;rsquo;s original raison d&amp;rsquo;etre was to support Google&amp;rsquo;s monorepo. A consequence of using a monorepo is that some builds will become very large. And large builds can be very resource hungry, especially when using a tool like Bazel that tries to parallelize as many actions as possible for efficiency reasons. There are many resource types in a system, but today I&amp;rsquo;d like to focus on the number of open files at any given time (nofiles).</description>
    </item>
    
    <item>
      <title>On smartphones and email procrastination</title>
      <link>http://julio.meroh.net/2019/01/smartphones-email-procrastination.html</link>
      <pubDate>Tue, 22 Jan 2019 06:30:00 -0500</pubDate>
      
      <guid>http://julio.meroh.net/2019/01/smartphones-email-procrastination.html</guid>
      <description>I used to be good at replying to emails on time.
When tens of emails came in every day, I would sort them out and I would reply right away to anything that needed or caught my attention. The so-called Inbox Zero wasn&amp;rsquo;t a specific goal that required effort: &amp;ldquo;it just was&amp;rdquo;.
Things have changed over the years and I am now quite awful at dealing with personal email. Some emails can go weeks (or, I confess, months) before getting a reply.</description>
    </item>
    
    <item>
      <title>The fallacy of forbidding assertions</title>
      <link>http://julio.meroh.net/2018/07/forbidden-assertions-fallacy.html</link>
      <pubDate>Tue, 24 Jul 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/07/forbidden-assertions-fallacy.html</guid>
      <description>There are two ways to handle abnormal conditions in a program: errors and assertions.
Errors are a controlled mechanism by which the program propagates details about a faulty condition up the call chain—be it with explicit error return statements or with exceptions. Errors must be used to validate all conditions that might be possible but aren&amp;rsquo;t valid given the context. Examples include: sanitizing any kind of input (as provided by the user or incoming from the network), and handling error codes from system calls or libraries.</description>
    </item>
    
    <item>
      <title>Rust vs. Go</title>
      <link>http://julio.meroh.net/2018/07/rust-vs-go.html</link>
      <pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate>
      
      <guid>http://julio.meroh.net/2018/07/rust-vs-go.html</guid>
      <description>Welcome to the Rust Review&amp;rsquo;s bonus post, which I had promised from the very beginning. I&amp;rsquo;m here to cover the big elephant in the room: Rust vs. Go. Which one is better?
There is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go.</description>
    </item>
    
    <item>
      <title>Rust review: Closing thoughts</title>
      <link>http://julio.meroh.net/2018/07/rust-review-closing-thoughts.html</link>
      <pubDate>Tue, 10 Jul 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/07/rust-review-closing-thoughts.html</guid>
      <description>Thought that the Rust review was over? Think again; I was just on vacation! I&amp;rsquo;m back now to conclude the series with a bunch of random thoughts and a surprise follow-up post.
The series is coming to an end. It&amp;rsquo;s time to summarize everything we have discussed so far and to cover a few more items that didn&amp;rsquo;t really deserve full posts of their own. Most of these miscellaneous items were thoughts that I jotted down while reading TRPL book.</description>
    </item>
    
    <item>
      <title>Rust review: The ecosystem</title>
      <link>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</link>
      <pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</guid>
      <description>In this part of the review, I would like to focus on Rust&amp;rsquo;s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust&amp;rsquo;s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let&amp;rsquo;s look at some.
The standard library The std library feels generally well-thought out and full of features.</description>
    </item>
    
    <item>
      <title>Rust review: The book</title>
      <link>http://julio.meroh.net/2018/06/rust-review-book.html</link>
      <pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-book.html</guid>
      <description>&amp;ldquo;The Rust Programming Language&amp;rdquo; is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let&amp;rsquo;s cover these, but first, some background.
A couple of years ago, right after getting started with Rust, I tried to go through the book&amp;rsquo;s first few chapters. It all sounded cool&amp;hellip; but the first edition of the book moved at a glacially slow pace because it covered things in excruciating detail.</description>
    </item>
    
    <item>
      <title>Rust review: The match keyword</title>
      <link>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</link>
      <pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</guid>
      <description>A commonly-acclaimed feature of Rust is its match keyword: a &amp;ldquo;conditional on steroids&amp;rdquo;. match lets you take the value of an expression and compare it against a bunch of values—or, more generally, patterns.
As you write and read Rust, you will notice that this keyword is used everywhere because it&amp;rsquo;s the way to access certain types, like Option values or error codes.
For example:
matchnode.get_parent(){// node is an Option&amp;lt;Something&amp;gt;. Some(parent)=&amp;gt;{// Do something with &amp;#34;parent&amp;#34;, which we know points to a node.</description>
    </item>
    
    <item>
      <title>Rust review: Expressions, expressions, expressions</title>
      <link>http://julio.meroh.net/2018/06/rust-review-expressions.html</link>
      <pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-expressions.html</guid>
      <description>Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a &amp;ldquo;pragmatic Haskell&amp;rdquo; or as a &amp;ldquo;well-balanced mixture between C++ and Haskell&amp;ldquo;.
One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.</description>
    </item>
    
    <item>
      <title>Rust review: Learning curve</title>
      <link>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</link>
      <pubDate>Fri, 08 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</guid>
      <description>Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I&amp;rsquo;ll try to convince you that the curve does feel steep, but it isn&amp;rsquo;t when taken into perspective.
Let&amp;rsquo;s first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.</description>
    </item>
    
    <item>
      <title>Rust review: Protect the data</title>
      <link>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</link>
      <pubDate>Tue, 05 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</guid>
      <description>The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.
I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil&amp;rsquo;s MutexLock) was the panacea. (I&amp;rsquo;m a fan of RAII in C++ by the way, in case you haven&amp;rsquo;t noticed.)</description>
    </item>
    
    <item>
      <title>Rust review: The borrow checker</title>
      <link>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</link>
      <pubDate>Fri, 01 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</guid>
      <description>Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that&amp;rsquo;s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality&amp;hellip; the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.</description>
    </item>
    
  </channel>
</rss>