<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/</link><description>Recent content on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 13 Mar 2023 06:45:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>Introducing III-IV</title><link>https://jmmv.dev/2023/03/introducing-iii-iv.html</link><pubDate>Mon, 13 Mar 2023 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2023/03/introducing-iii-iv.html</guid><description>&lt;p>Over the last couple of years, I have developed two small web services in Rust: &lt;a href="https://jmmv.dev/2021/07/endbasic-0.7.html">one for EndBASIC&lt;/a> and &lt;a href="https://jmmv.dev/2022/02/diy-web-analytics.html">one for this blog&lt;/a>. Those two web services contained significant copy/pasted helper code, which always bothered me because small bug fixes in one rarely propagated to the other. But because this only impacted two inconsequential side projects, the hinderance wasn&amp;rsquo;t a big deal.&lt;/p>
&lt;p>Until now. I now face the need to write two more web services (details TBA), and duplicating those foundations twice more felt just wrong. So I spent the last couple of weeks pulling the common code out of the existing services into a&amp;hellip; you guessed it&amp;hellip; framework, which I have called III-IV (&amp;quot;&lt;em>three four&lt;/em>&amp;quot; if you read it out loud) and am ready to announce.&lt;/p>
&lt;blockquote>
&lt;p>Find the code in &lt;a href="https://github.com/jmmv/iii-iv">https://github.com/jmmv/iii-iv&lt;/a>.&lt;/p>
&lt;/blockquote></description></item><item><title>BASIC parsing difficulties in EndBASIC</title><link>https://jmmv.dev/2023/01/endbasic-parsing-difficulties.html</link><pubDate>Fri, 13 Jan 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/01/endbasic-parsing-difficulties.html</guid><description>The original BASIC parser in EndBASIC 0.1 was very rudimentary and it stayed pretty much unmodified until the 0.10 release last month. This release brought major changes to the parser to support new features, but it wasn&amp;rsquo;t easy to implement them. In this post, I want to look into various difficulties that arose implementing certain BASIC constructs in EndBASIC. Overcoming these difficulties was difficult, but it was also fascinating because it gave me a glimpse of the design choices that the original BASIC designers must have faced. Capturing these ah-ha moments in a post is also tricky, but I&amp;rsquo;ll try anyway.</description></item><item><title>EndBASIC 0.10: Core language, evolved</title><link>https://jmmv.dev/2022/12/endbasic-0.10.html</link><pubDate>Tue, 27 Dec 2022 16:30:00 +0100</pubDate><guid>https://jmmv.dev/2022/12/endbasic-0.10.html</guid><description>After three months of early-morning hacking, I&amp;rsquo;m pleased to announce that EndBASIC 0.10 is now available&amp;mdash;right on time for some holiday-time experimentation!
This release marks a huge milestone because it makes the language usable for real-world development.
You see, when I started this project over two years ago, I wrote a rudimentary interpreter for something that resembled BASIC and then launched EndBASIC 0.1. Since then, I have been piling onto those insufficient foundations by adding flashy features such as a web interface, a cloud file sharing service, and a hybrid text/graphics console.</description></item><item><title>From AST to bytecode execution in EndBASIC</title><link>https://jmmv.dev/2022/11/endbasic-bytecode.html</link><pubDate>Tue, 22 Nov 2022 06:50:00 -0700</pubDate><guid>https://jmmv.dev/2022/11/endbasic-bytecode.html</guid><description>&lt;p>Since its inception two years ago, the EndBASIC interpreter has been using an AST-based execution
engine. And during all this time, people have mocked the language for not allowing &lt;code>10 GOTO 10&lt;/code>.
Well, fear not: the upcoming 0.10 release has full support for &lt;code>GOTO&lt;/code> and &lt;code>GOSUB&lt;/code>, features that
were made possible by moving to a bytecode-based interpreter. Let&amp;rsquo;s take a peek at what the
problems were and how I addressed them.&lt;/p></description></item><item><title>Farewell, Microsoft; hello, Snowflake!</title><link>https://jmmv.dev/2022/10/bye-microsoft-hi-snowflake.html</link><pubDate>Mon, 31 Oct 2022 07:25:00 -0700</pubDate><guid>https://jmmv.dev/2022/10/bye-microsoft-hi-snowflake.html</guid><description>After two years, it&amp;rsquo;s time for a change: I left Microsoft last week and I&amp;rsquo;m starting at Snowflake today. Read on for details on my stint in Azure Storage, why I ended up looking for a new role, and how I landed at this new company.</description></item><item><title>Tips on formatting Markdown lists</title><link>https://jmmv.dev/2022/07/markdown-lists.html</link><pubDate>Thu, 07 Jul 2022 07:00:00 -0700</pubDate><guid>https://jmmv.dev/2022/07/markdown-lists.html</guid><description>Lists are a very common construct in technical documents, which is the kind of material I most often write and &lt;em>review&lt;/em>. But getting complex lists to look right is tricky, especially when authoring them in Markdown. Let&amp;rsquo;s look at a couple of tips to ensure that any list you write will always be correctly formatted with ease.</description></item><item><title>Speeding up autoconf with caching</title><link>https://jmmv.dev/2022/06/autoconf-caching.html</link><pubDate>Fri, 17 Jun 2022 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2022/06/autoconf-caching.html</guid><description>&lt;p>In the recent &lt;a href="https://jmmv.dev/2022/05/remembering-buildtool.html">Remembering Buildtool&lt;/a> post, I described how setting up a cache of configuration checks was an important step in Buildtool&amp;rsquo;s installation process. The goal was to avoid pointless repetitive work on every build by performing such common checks once.&lt;/p>
&lt;p>&lt;a href="https://www.bsdnow.tv/457">Episode 457 of BSD Now&lt;/a> featured my post and Allan Jude wondered how much time would be saved in a bulk build of all FreeBSD packages if we could just do that same kind of caching with GNU Autoconf. And, you know what? It is indeed possible to do so. I had mentioned it en passing in my post but I guess I wasn&amp;rsquo;t clear enough, so let&amp;rsquo;s elaborate!&lt;/p></description></item><item><title>EndBASIC 0.9: Run shared demos easily</title><link>https://jmmv.dev/2022/06/endbasic-0.9.html</link><pubDate>Sun, 05 Jun 2022 17:20:00 -0700</pubDate><guid>https://jmmv.dev/2022/06/endbasic-0.9.html</guid><description>&lt;p>It is with great pleasure that I announce the release of EndBASIC 0.9.0 😎️.&lt;/p>
&lt;p>The major feature in this new release is the ability to &lt;strong>launch publicly-shared files via a click of a URL&lt;/strong> without having to create an account first. Here, try running my &lt;a href="https://repl.endbasic.dev/?run=jmmv/bounce.bas">&lt;code>jmmv/bounce.bas&lt;/code>&lt;/a> or &lt;a href="https://repl.endbasic.dev/?run=jmmv/paint.bas">&lt;code>jmmv/paint.bas&lt;/code>&lt;/a> demos in your browser, now!&lt;/p></description></item><item><title>Remembering Buildtool</title><link>https://jmmv.dev/2022/05/remembering-buildtool.html</link><pubDate>Fri, 13 May 2022 09:50:00 -0700</pubDate><guid>https://jmmv.dev/2022/05/remembering-buildtool.html</guid><description>Build systems are one of my favorite topics in software engineering. If I recall correctly, my interest in this area started when I got into NetBSD in 2002&amp;mdash;20 years ago&amp;mdash;and became a pkgsrc contributor. Packaging software for NetBSD made me fight various build systems and, in particular, experience the pains of debugging the GNU Autotools.
Around that same time, I was also writing small tools here and there. Out of inertia, I used the GNU Autotools for these and, the more I used them, the more I saw an opportunity for improvement.</description></item><item><title>Rust is hard, yes, but does it matter?</title><link>https://jmmv.dev/2022/05/rust-is-hard-but-does-it-matter.html</link><pubDate>Fri, 06 May 2022 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2022/05/rust-is-hard-but-does-it-matter.html</guid><description>Rust is infamous for having a steep learning curve. The borrow checker, preferred idioms and design patterns, the meaning of core traits&amp;hellip; these are all things one must learn before being proficient with the language and able to write code with ease. So, yes, Rust is hard, but does it matter in practical terms? Can we expect large-ish teams to succeed when adopting the language? I&amp;rsquo;d like to think that it does not matter much and that some initial difficulties in bringing people up to speed can pay off in the medium term.</description></item><item><title>Do Rust devs hate Go devs?</title><link>https://jmmv.dev/2022/04/do-rust-devs-hate-go-devs.html</link><pubDate>Fri, 29 Apr 2022 09:50:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/do-rust-devs-hate-go-devs.html</guid><description>&lt;p>Earlier this week, a 2-year old post titled &lt;a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">I want off Mr. Golang&amp;rsquo;s wild ride&lt;/a> by &lt;a href="https://fasterthanli.me/">@fasterthanlime&lt;/a> made the news rounds &lt;em>again&lt;/em>. This post raises a bunch of concerns on the Go language and is posted from the perspective of someone who prefers Rust. And, just yesterday, I noticed &lt;a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang">a comment on Twitter by @FiloSottile&lt;/a> that, paraphrased, reads &amp;ldquo;&lt;em>Why is there so much hatred towards Go, especially from Rust developers?&lt;/em>&amp;rdquo;.&lt;/p>
&lt;p>I wish I could answer this question with a &amp;ldquo;no, there isn&amp;rsquo;t&amp;rdquo;, but that would be a lie: in any large community, there will certainly be hateful people/opinions. If you have encountered such flamebait, I&amp;rsquo;m sorry, and I&amp;rsquo;m not here to defend it. What I&amp;rsquo;m here to do is look at the possible truth behind the claim that Rust developers dislike Go, and I wanted to elaborate on this based on my personal experience.&lt;/p></description></item><item><title>Rust traits and dependency injection</title><link>https://jmmv.dev/2022/04/rust-traits-and-dependency-injection.html</link><pubDate>Fri, 22 Apr 2022 09:30:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/rust-traits-and-dependency-injection.html</guid><description>Dependency injection is one of my favorite design patterns to develop highly-testable and modular code. Unfortunately, applying this pattern by taking Rust traits as arguments to public functions has unintended consequences on the visibility of private symbols. If you are not careful, most of your crate-internal APIs might need to become public just because you needed to parameterize a function with a trait. Let&amp;rsquo;s look at why this happens and what we can do about it.</description></item><item><title>QB64 Super Dark Blue color theme</title><link>https://jmmv.dev/2022/04/qb64-super-dark-blue.html</link><pubDate>Wed, 20 Apr 2022 19:00:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/qb64-super-dark-blue.html</guid><description>Towards the end of 2021, I was playing with QB64 and thought that its default color scheme&amp;mdash;called Super Dark Blue&amp;mdash;was quite neat. It reminded me of QuickBASIC, which is what the whole program is supposed to do, but the colors felt vivid and modern. Take a look:
QB64 with its default color configuration. &amp;ldquo;Naturally,&amp;rdquo; I wondered if I could adopt those colors in VSCode and Windows Terminal, as these are the apps I look at the most throughout a work day.</description></item><item><title>Introducing db_logger</title><link>https://jmmv.dev/2022/04/introducing-db-logger.html</link><pubDate>Tue, 12 Apr 2022 08:30:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/introducing-db-logger.html</guid><description>Over the last couple of weeks, I have been modernizing the codebase of the EndBASIC cloud service by applying many of the learnings I got from the development of EndTRACKER. The latter was a fork of the former and thus the foundations were the same, but as I iterated on the latter more recently, I got to refine my approach to writing a REST API in Rust.
During this refactoring process, there was a small piece of the system that routinely got in the way for various reasons.</description></item><item><title>Abandoning GAFYD</title><link>https://jmmv.dev/2022/03/abandoning-gafyd.html</link><pubDate>Mon, 28 Mar 2022 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2022/03/abandoning-gafyd.html</guid><description>&lt;p>If you know what GAFYD stands for and have felt that signing up for a free account years ago was a mistake, you know you are in trouble right now. Those accounts are shutting down. The time has come to either pay up or move out, and you should decide what to do ASAP. It took me weeks of active effort to move my and my family&amp;rsquo;s data out of GAFYD and put it back into Google consumer accounts and other non-Google services.&lt;/p>
&lt;p>This post is essentially a recollection of my lab notes on what I did. The text is long and haphazard due to the many things to cover. I&amp;rsquo;ll start with a brief explanation of what GAFYD was, what&amp;rsquo;s happening now, and what&amp;rsquo;s wrong with it. After that, I&amp;rsquo;ll sketch what my new setup is and how I succeeded in moving some of the more complex services. Here is the outline:&lt;/p></description></item></channel></rss>