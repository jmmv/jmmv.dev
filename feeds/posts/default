<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/</link><description>Recent content on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&#150;2025 Julio Merino</copyright><lastBuildDate>Sun, 23 Nov 2025 17:00:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>You are holding BUILD files wrong</title><link>https://jmmv.dev/2025/09/you-are-holding-build-files-wrong.html</link><pubDate>Fri, 26 Sep 2025 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/you-are-holding-build-files-wrong.html</guid><description>&lt;p>I&amp;rsquo;ve heard it from people new to Bazel but also from people very familiar with the Bazel ecosystem: BUILD files must go away. And they must go away because they are redundant: they just repeat the dependency information that&amp;rsquo;s already encoded in the in-code import/use statements.&lt;/p>
&lt;p>Hearing this from newcomers to Bazel isn&amp;rsquo;t surprising: after all, most newcomers are used to build tools that provide zero facilities to express dependencies across the sources of your own project. Hearing it from old-timers, however, is disappointing because it misses the point of what BUILD files can truly offer.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-26-you-are-holding-build-files-wrong.jpg" length="87330" type="image/jpeg"/></item><item><title>Bazel and glibc versions</title><link>https://jmmv.dev/2025/09/glibc-versions-bazel.html</link><pubDate>Fri, 19 Sep 2025 00:08:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/glibc-versions-bazel.html</guid><description>&lt;p>Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, gets a cache hit from the developer&amp;rsquo;s build, and produces a release artifact. Everything looks green. But when you deploy to production, the service crashes with a mysterious error: &lt;code>version 'GLIBC_2.28' not found&lt;/code>. What went wrong?&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-19-glibc-versions-bazel-cover-image.jpg" length="182393" type="image/jpeg"/></item><item><title>Trusting builds with Bazel remote execution</title><link>https://jmmv.dev/2025/09/bazel-remote-execution.html</link><pubDate>Fri, 12 Sep 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/bazel-remote-execution.html</guid><description>&lt;p>The previous article on &lt;a href="https://jmmv.dev/2025/09/bazel-remote-caching.html">Bazel remote caching&lt;/a> concluded that using &lt;em>just&lt;/em> a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The reason behind the restrictions was that it is impossible to safely reuse a cache across users. Or is it?&lt;/p>
&lt;p>In this article, we&amp;rsquo;ll see how leveraging remote execution in conjunction with a remote cache opens the door to safely sharing the cache across users. The reason is that remote execution provides a trusted execution environment for actions, and this opens the door to cross-user result sharing. Let&amp;rsquo;s see why and how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-12-bazel-remote-execution-cover-image.jpg" length="147776" type="image/jpeg"/></item><item><title>Understanding Bazel remote caching</title><link>https://jmmv.dev/2025/09/bazel-remote-caching.html</link><pubDate>Fri, 05 Sep 2025 08:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/bazel-remote-caching.html</guid><description>&lt;p>The previous article on &lt;a href="https://jmmv.dev/2025/07/bazel-action-determinism.html">Bazel action non-determinism&lt;/a> provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the article did not mention is that actions are &lt;em>also&lt;/em> the fundamental unit of caching during execution to avoid doing already-done work.&lt;/p>
&lt;p>In this second part of the series, I want to revisit the very basics of how Bazel runs actions and how remote caching (&lt;em>not&lt;/em> remote execution, because that&amp;rsquo;ll come later) works. The goal here is to introduce the &lt;strong>Action Cache (AC)&lt;/strong>, the &lt;strong>Content Addressable Storage (CAS)&lt;/strong>, how they play together, and then have some fun in describing the many ways in which it&amp;rsquo;s possible to poison such a cache in an accidental or malicious manner.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-05-bazel-remote-caching-cover-image.jpg" length="969844" type="image/jpeg"/></item><item><title>Bazel and action (non-) determinism</title><link>https://jmmv.dev/2025/07/bazel-action-determinism.html</link><pubDate>Mon, 21 Jul 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/07/bazel-action-determinism.html</guid><description>&lt;p>A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. For the most part, Bazel helps ensure that they are, but in the odd cases when they aren&amp;rsquo;t, builds can fail in subtle and frustrating ways, eroding trust in the build system.&lt;/p>
&lt;p>This article is the first in a series on Bazel&amp;rsquo;s execution model. Having explained these concepts many times, I want to provide a detailed reference before explaining a cool solution to a problem I recently developed at work. We will start with action non-determinism, then cover remote caching and execution, and finally, explore the security implications of these features.&lt;/p>
&lt;p>This first article explains what non-determinism is, how it manifests, and how you can diagnose and prevent it in your own builds. Let&amp;rsquo;s begin.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-07-21-bazel-action-determinism-cover.jpg" length="520669" type="image/jpeg"/></item><item><title>Lessons along the EndBOX journey</title><link>https://jmmv.dev/2025/06/endbox-journey-lessons.html</link><pubDate>Tue, 17 Jun 2025 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/06/endbox-journey-lessons.html</guid><description>&lt;p>About six months ago, during one of my long runs, I had a wild idea: what if I built an OS disk image that booted straight into EndBASIC, bundled it with a Raspberry Pi, a display, a custom 3D-printed case, and made a tiny, self-contained retro BASIC computer? Fast-forward to today and such an idea exists in the form of &amp;ldquo;the EndBOX prototype&amp;rdquo;!&lt;/p>
&lt;p>This article isn&amp;rsquo;t the product announcement though&amp;mdash;&lt;a href="https://www.endbasic.dev/2025/06/unveiling-the-endbox.html">that&amp;rsquo;s elsewhere&lt;/a>. What I want to do here is look back at the Blog System/5 articles I&amp;rsquo;ve written over the past months because what might have seemed like scattered topics were actually stepping stones toward the EndBOX.&lt;/p>
&lt;p>Let&amp;rsquo;s look at what I learned along the way and why, even though developing EndBASIC may sound like a &amp;ldquo;useless waste of time&amp;rdquo;, it&amp;rsquo;s a great playground and the source of inspiration for the articles you&amp;rsquo;ve come to appreciate here.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-06-17-endbox-journey-lessons.jpg" length="451795" type="image/jpeg"/></item><item><title>Whatever happened to sandboxfs?</title><link>https://jmmv.dev/2025/06/whatever-happened-to-sandboxfs.html</link><pubDate>Wed, 11 Jun 2025 10:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/06/whatever-happened-to-sandboxfs.html</guid><description>&lt;p>Back in 2017&amp;ndash;2020, while I was on the Blaze team at Google, I took on a 20% project that turned into a bit of an obsession: &lt;a href="https://github.com/bazelbuild/sandboxfs">sandboxfs&lt;/a>. Born out of my work supporting iOS development, it was my attempt to solve a persistent pain point that frustrated both internal teams and external users alike: Bazel&amp;rsquo;s &lt;a href="https://github.com/bazelbuild/bazel/issues/8230">poor sandboxing performance on macOS&lt;/a>.&lt;/p>
&lt;p>sandboxfs was a user-space file system designed to efficiently create virtual file hierarchies backed by real files&amp;mdash;a faster alternative to the &amp;ldquo;symlink forests&amp;rdquo; that Bazel uses to prepare per-action sandboxes. The idea was simple: if we could lower sandbox creation overhead, we could make Bazel&amp;rsquo;s sandboxing actually usable on macOS.&lt;/p>
&lt;p>Unfortunately, things didn&amp;rsquo;t play out as I dreamed. Today, sandboxfs is effectively abandoned, and macOS sandboxing performance remains an unsolved problem. In this post, I&amp;rsquo;ll walk you through why I built sandboxfs, what worked, what didn&amp;rsquo;t, and why&amp;mdash;despite its failure&amp;mdash;I still think the core idea holds promise.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-06-11-sandboxfs-cover-concept.png" length="7119929" type="image/jpeg"/></item><item><title>Beginning 3D printing</title><link>https://jmmv.dev/2025/05/beginning-3d-printing.html</link><pubDate>Wed, 28 May 2025 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/05/beginning-3d-printing.html</guid><description>&lt;p>Hello readers and sorry for the 2-month radio silence. I&amp;rsquo;ve been pretty busy at work, traveling during school breaks, hacking on EndBASIC when time permitted, and&amp;hellip; as of two weeks ago&amp;hellip; tinkering with 3D printing as a complete beginner. So, today, I&amp;rsquo;d like to walk you through the latter because it has been a really fun and rewarding journey, albeit frustrating at times.&lt;/p>
&lt;p>You&amp;rsquo;d think that to use a 3D printer, you&amp;rsquo;d design a 3D model and then&amp;hellip; just&amp;hellip; send it to the printer? That&amp;rsquo;s almost true, but it ignores the realities of producing a physical object from an &amp;ldquo;abstract&amp;rdquo; model: when designing such a model, you need to take into account the limitations of 3D printing and you need to translate your model into something the 3D printer can understand via a process called &lt;em>slicing&lt;/em>.&lt;/p>
&lt;p>Let&amp;rsquo;s take a brief peek at all of these steps. I&amp;rsquo;ll assume you are a complete beginner like I am. The pictures I&amp;rsquo;ll show are all for a &amp;ldquo;first project&amp;rdquo; I did to remake the bars of a bird cage I have, as the birds had fully destroyed the previous ones.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-05-28-prusa-box.jpg" length="3411105" type="image/jpeg"/></item><item><title>The next generation of Bazel builds</title><link>https://jmmv.dev/2025/03/bazel-next-generation.html</link><pubDate>Mon, 24 Mar 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/03/bazel-next-generation.html</guid><description>&lt;p>Today marks the 10th anniversary of &lt;a href="https://blog.engflow.com/2024/10/01/birth-of-the-bazel/">Bazel&amp;rsquo;s public announcement&lt;/a> so this is the perfect moment to reflect on what the next generation of build systems in the Bazel ecosystem may look like.&lt;/p>
&lt;p>I write this with the inspiration that comes from attending &lt;a href="https://www.linkedin.com/feed/update/urn:li:activity:7295871444343734272/">the first ever conference on Buildbarn&lt;/a>, one of the many remote execution systems for Bazel. In the conference, Ed Schouten, the creator of &lt;a href="https://github.com/buildbarn">Buildbarn&lt;/a>, presented Bonanza: a skunkworks reimagination of Bazel for truly large builds.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-03-24-laptop-vs-datacenter.jpg" length="525451" type="image/jpeg"/></item><item><title>Bazel at Snowflake two years in</title><link>https://jmmv.dev/2025/03/bazel-at-snowflake-two-years-in.html</link><pubDate>Fri, 14 Mar 2025 18:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/03/bazel-at-snowflake-two-years-in.html</guid><description>&lt;p>Two and a half years ago, I &lt;a href="https://jmmv.dev/2022/10/bye-microsoft-hi-snowflake.html">joined Snowflake&lt;/a> to help their mission of migrating to Bazel. I spent the first year of this period as an Individual Contributor (IC) diving deep into the migration tasks, and then I took over the Tech Lead (TL) role of the team to see the project through completion.&lt;/p>
&lt;p>This week, we publicly announced that we completed our migration to Bazel for the largest part of our codebase and we provided details on our journey. I did not publish that article here for obvious reasons, so&amp;hellip; today&amp;rsquo;s entry is going to be a light one: all I want to do is point you at our announcement as well as the various &lt;em>other&lt;/em> related articles that came before it.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-03-14-bazel-at-snowflake-cover.jpg" length="792369" type="image/jpeg"/></item><item><title>Hardware discovery: ACPI &amp; Device Tree</title><link>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</link><pubDate>Fri, 28 Feb 2025 16:15:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</guid><description>&lt;p>If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&amp;mdash;say a sound card or a network card&amp;mdash;had physical switches or jumpers in it. These switches configured the card&amp;rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.&lt;/p>
&lt;p>But that wasn&amp;rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software &lt;em>which&lt;/em> specific cards you had and how you had configured them. Remember &lt;code>SET BLASTER=A220 I5 D1 H5&lt;/code>? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.&lt;/p>
&lt;p>Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus &lt;a href="https://wiki.osdev.org/ISA">ISA &amp;ldquo;Plug and Play&amp;rdquo;&lt;/a>, or PnP for short, was born in the early 1990s&amp;mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&amp;rsquo;s scene where we just attach devices to external USB connectors and things &amp;ldquo;magically work&amp;rdquo;.&lt;/p>
&lt;p>But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-02-28-jumpers.jpg" length="89630" type="image/jpeg"/></item><item><title>ioctls from Rust</title><link>https://jmmv.dev/2025/02/ioctls-rust.html</link><pubDate>Thu, 13 Feb 2025 09:00:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/02/ioctls-rust.html</guid><description>&lt;p>In Unix-like systems, &amp;ldquo;everything is a file and a file is defined as a byte stream you can &lt;code>open&lt;/code>, &lt;code>read&lt;/code> from, &lt;code>write&lt;/code> to, and ultimately &lt;code>close&lt;/code>&amp;rdquo;&amp;hellip; right? &lt;em>Right?&lt;/em> Well, not quite. It&amp;rsquo;s better to say &lt;em>file descriptors&lt;/em> provide access to almost every system that the kernel provides, but not that they can all be manipulated with the same quartet of system calls, nor that they all behave as byte streams.&lt;/p>
&lt;p>Because you see: network connections are manipulated via file descriptors indeed, but you don&amp;rsquo;t &lt;code>open&lt;/code> them: you &lt;code>bind&lt;/code>, &lt;code>listen&lt;/code>/&lt;code>accept&lt;/code> and/or &lt;code>connect&lt;/code> to them. And then you don&amp;rsquo;t &lt;code>read&lt;/code> from and &lt;code>write&lt;/code> to network connections: you somehow &lt;code>send&lt;/code> to and &lt;code>recv&lt;/code> from them. Device drivers are similar: yes, hardware devices are represented as &amp;ldquo;virtual files&amp;rdquo; in the &lt;code>/dev&lt;/code> hierarchy and many support &lt;code>read&lt;/code> and &lt;code>write&lt;/code>&amp;hellip; but these two system calls are not sufficient to access the breath of functionality that the hardware drivers provide. No, you need &lt;code>ioctl&lt;/code>.&lt;/p>
&lt;p>&lt;code>ioctl&lt;/code> is the poster child of the system call that breaks Unix&amp;rsquo;s &amp;ldquo;everything is a file&amp;rdquo; paradigm. &lt;code>ioctl&lt;/code> is the API that allows out-of-band communication with the kernel side of an open file descriptor. To see cool examples, &lt;a href="https://jmmv.dev/2025/01/netbsd-graphics-wo-x11.html">refer back to my previous article&lt;/a> where I demonstrated how to drive graphics from the console without X11: in that post, we had to &lt;code>open&lt;/code> the console device, but then we had to use &lt;code>ioctl&lt;/code> to obtain the properties of the framebuffer, and then we had to &lt;code>mmap&lt;/code> the device&amp;rsquo;s content for direct access: no &lt;code>read&lt;/code>s nor &lt;code>write&lt;/code>s involved.&lt;/p>
&lt;p>All the code I showed you in that earlier post was written in C to keep the graphics article to-the-point, but the code I&amp;rsquo;m really working on is part of EndBASIC, and thus it is all Rust. And the thing is, &lt;code>ioctl&lt;/code>s are not easy to issue from Rust. In fact, after 7 years of Rust-ing, it&amp;rsquo;s the first time I&amp;rsquo;ve had to reach for &lt;code>unsafe&lt;/code> code blocks, and there was no good documentation on how to deal with &lt;code>ioctl&lt;/code>. So this posts aims to fix that by presenting what ways there are to call &lt;code>ioctl&lt;/code>s from Rust&amp;hellip; and, of course, diving a bit deeper into what &lt;code>ioctl&lt;/code>s actually &lt;em>are&lt;/em>.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-02-13-ioctls-rust-cover-image.jpg" length="440615" type="image/jpeg"/></item><item><title>Hands-on graphics without X11</title><link>https://jmmv.dev/2025/01/netbsd-graphics-wo-x11.html</link><pubDate>Fri, 17 Jan 2025 09:45:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/01/netbsd-graphics-wo-x11.html</guid><description>If you have been following the development of EndBASIC, you know its console can display both text and graphics at once. What you may not know is that, now, it can also achieve this feat on the NetBSD console without using X11 at all. This is done by directly rendering to the wsdisplay framebuffer, and this article presents a crash course on direct graphics and keyboard access via NetBSD&amp;rsquo;s wscons framework.</description><enclosure url="https://jmmv.dev/images/2025-01-17-cover-image.png" length="25978" type="image/jpeg"/></item><item><title>Self-documenting Makefiles</title><link>https://jmmv.dev/2025/01/make-help.html</link><pubDate>Fri, 10 Jan 2025 09:00:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/01/make-help.html</guid><description>&lt;p>Make, as arcane as a build tool can be, may still be a good first fit for certain scenarios. &amp;ldquo;Heresy!&amp;rdquo;, you say, as you hear a so-called &amp;ldquo;Bazel expert&amp;rdquo; utter these words.&lt;/p>
&lt;p>The specific problem I&amp;rsquo;m facing is that I need to glue together &lt;a href="https://jmmv.dev/2024/12/netbsd-build-system.html">the NetBSD build system&lt;/a>, &lt;a href="https://jmmv.dev/2013/11/patch-management-with-quilt.html">a quilt patch set&lt;/a>, EndBASIC&amp;rsquo;s Cargo-based Rust build, and a couple of QEMU invocations to produce a Frankenstein disk image for a Raspberry Pi. And the thing is: Make allows doing this sort of stitching with relative ease. Sure, Make is not the best option because the overall build performance is &amp;ldquo;meh&amp;rdquo; and because incremental builds are almost-impossible to get right&amp;hellip; but adopting Bazel for this project would be an almost-infinite time sink.&lt;/p>
&lt;p>Anyway. When using Make in this manner, you often end up with what&amp;rsquo;s essentially a &amp;ldquo;command dispatcher&amp;rdquo; and, over time, the number of commands grows and it&amp;rsquo;s hard to make sense of which one to use for what. Sure, you can write a &lt;code>README.md&lt;/code> with instructions, but I guarantee you that the text will get out of sync faster than you can read this article. There is a better way, though.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-01-10-make-help.png" length="110230" type="image/jpeg"/></item><item><title>Revisiting the NetBSD build system</title><link>https://jmmv.dev/2024/12/netbsd-build-system.html</link><pubDate>Sat, 28 Dec 2024 08:50:00 +0100</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2024/12/netbsd-build-system.html</guid><description>&lt;p>I recently picked up an embedded project in which I needed to build a highly customized full system image with minimal boot times. As I explored my options, I came to the conclusion that NetBSD, the often-forgotten BSD variant, was the best viable choice for my project.&lt;/p>
&lt;p>One reason for this choice is NetBSD&amp;rsquo;s build system. Once you look and get past the fact that it feels frozen in time since 2002, you realize it is still one of the most advanced build systems you can find for an OS. And it shows: the NetBSD build system allows you to build the full OS from scratch, on pretty much any host POSIX platform, while targeting any hardware architecture supported by NetBSD. All without root privileges.&lt;/p>
&lt;p>Another reason for this choice is that NetBSD was my daily workhorse for many years and I&amp;rsquo;m quite familiar with its internals, which is useful knowledge to quickly achieve the goals I have in mind. In fact, I was a NetBSD Developer with capital D: I had commit access to the project from about 2002 through 2012 or so, and I have just revived my account in service of this project. &lt;code>jmmv@&lt;/code> is back!&lt;/p>
&lt;p>So, strap onto your seats and let&amp;rsquo;s see how today&amp;rsquo;s NetBSD build system looks like and what makes it special. I&amp;rsquo;ll add my own critique at the end, because it ain&amp;rsquo;t perfect, but overall it continues to deliver on its design goals set in the late 1990s.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-12-28-cover-image.jpg" length="403124" type="image/jpeg"/></item></channel></rss>