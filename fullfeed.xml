<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/</link><description>Recent content on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Feb 2024 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>Beyond the 1 MB barrier in DOS</title><link>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</link><pubDate>Wed, 07 Feb 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</guid><description>&lt;p>In &lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">&amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;&lt;/a>, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.&lt;/p>
&lt;p>I know I promised that this follow-up article would be about DJGPP, but before getting into &lt;em>that&lt;/em> review, I realized I had to take another detour to cover three more topics. Namely: &lt;em>unreal mode&lt;/em>, which I intentionally ignored to not derail the post; &lt;em>LOADALL&lt;/em>, which I didn&amp;rsquo;t know about until you readers mentioned it; and &lt;em>DOS extenders&lt;/em>, which I was planning to describe in the DJGPP article but they are a better fit for this one.&lt;/p>
&lt;p>So&amp;hellip; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&amp;rsquo;ll go over assembly code for a step-by-step jump into unreal mode.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="what-is-unreal-mode-anyway">What is unreal mode anyway?&lt;/h1>
&lt;p>Having read the preceding post, you should know by now what the real, protected, and VM86 modes of the x86 processors are. But there is one extra unofficial mode I did not talk about, and that is the &lt;em>unreal mode&lt;/em>. The mode with the coolest name if you ask me.&lt;/p>
&lt;p>Unreal mode is a special state of the processor in which the CPU acts as if it was in real mode&amp;hellip; but with segment descriptors that allow it to reference memory above the 1 MB limit. These segments are impossible to define in real mode but, with different tricks for the 80286 and 80386, they become a possibility.&lt;/p>
&lt;p>To understand how unreal mode works, we need to go back to the diagram I presented earlier describing the address resolution process that the 80286&amp;rsquo;s MMU executes on every memory access:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-mmu-access.png" />
&lt;figcaption>Diagram representing the operations that the 80286 does, in hardware, to resolve a &lt;tt>segment:address&lt;/tt> memory reference.&lt;/figcaption>
&lt;/figure>
&lt;p>As you can see in the diagram, for every memory access of the form &lt;code>segment:offset&lt;/code>, the MMU:&lt;/p>
&lt;ol>
&lt;li>decodes the segment selector specified by &lt;code>segment&lt;/code> to determine whether to query the GDT or LDT and which segment descriptor to read,&lt;/li>
&lt;li>reads the determined segment descriptor by indexing into the GDT or LDT tables,&lt;/li>
&lt;li>decodes the segments&amp;rsquo; base address and limit as stored in the descriptor,&lt;/li>
&lt;li>checks the privileges of the executing code against the protections recorded in the descriptor,&lt;/li>
&lt;li>and ensures the &lt;code>offset&lt;/code> is within the segment limit defined in the descriptor.&lt;/li>
&lt;/ol>
&lt;p>Only after these steps complete successfully, the memory access is allowed; otherwise, the processor raises a General Protection Fault exception.&lt;/p>
&lt;p>This is all conceptually good until you realize that the GDT and LDT live in main memory&amp;hellip; and main memory is slow&amp;mdash;&lt;em>excruciatingly&lt;/em> so in processor time. Having to read from main memory to resolve &lt;em>every&lt;/em> memory access, even with a good L1 or L2 cache, would have a big performance impact on most applications.&lt;/p>
&lt;p>To resolve this inefficiency, the processor has a cache of segment descriptors. Instructions that update the segment registers, such as &lt;code>MOV DS, AX&lt;/code>, fetch descriptors from the GDT or LDT tables and store them in the cache. Instructions that reference memory, such as &lt;code>MOV AX, DS:1234h&lt;/code>, read the descriptors from the cache without ever reaching out to main memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-descriptor-cache.png" />
&lt;figcaption>Diagram representing how the instructions used to load a register like &lt;tt>DS&lt;/tt> are decoupled from the instructions that later consume the details about &lt;tt>DS&lt;/tt>. It is crucial to note how the segment descriptor cache completely shields the second instruction from accessing main memory to resolve the address.&lt;/figcaption>
&lt;/figure>
&lt;p>So far so good, but let&amp;rsquo;s add another twist. The diagram I presented earlier showing how the 80286 resolves a memory address does not only apply to protected mode: it applies to real mode too. In both modes, the processor accesses the descriptor cache to peek at the segment limits and protection settings. This means that, for real mode to work as 8086 code expects, the cache must contain values that are compatible with real mode: in particular, the limits must be set to 64 KB.&lt;/p>
&lt;p>But what if we could somehow load arbitrary segment descriptors into the processor&amp;rsquo;s cache and leverage those in real mode? If we could do that, we could increase the segment limits stored in the cache, and then any memory references that use those cached descriptors would be able to bypass the real mode rules and access extended memory directly.&lt;/p>
&lt;p>And this, dear reader, is what unreal mode is about. There is a ton of nuance about how this mode was discovered and how it got its name, and to learn more about that story, I&amp;rsquo;ll redirect you to &lt;a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">OS/2 Museum&amp;rsquo;s excellent history of the unreal mode&lt;/a>. But keep in mind that unreal mode is a clutch that DOS applications used to access memory above the 1 MB mark while avoiding expensive protected mode switches.&lt;/p>
&lt;h1 id="leveraging-unreal-mode">Leveraging unreal mode&lt;/h1>
&lt;p>Before describing how we can switch the processor to unreal mode, we must first look at how we can actually take advantage of this mode.&lt;/p>
&lt;p>In the 80286 case, unreal mode is annoying to use: the 80286 is a 16-bit CPU, which means that the &lt;code>offset&lt;/code> part of a memory reference is limited to 64 KB. We can configure segments whose base address lies beyond the 1 MB address space, allowing us to read extended memory from real mode, but we can only do so in 64 KB chunks at a time.&lt;/p>
&lt;p>The 80386 fares better due to it being a 32-bit CPU: the &lt;code>offset&lt;/code> part of a memory reference can be expressed as a 32-bit quantity. We can do both &lt;code>MOV AX, DS:[SI]&lt;/code> and &lt;code>MOV AX, DS:[ESI]&lt;/code>, which means that if &lt;code>DS&lt;/code> has a base of zero, we can reference any memory position in the 4 GB address space when using the &lt;code>ESI&lt;/code> offset. Crucially, and contrary to what some people think, we can issue these two variants from 16-bit real mode: 32-bit instructions are &lt;em>not&lt;/em> restricted to protected mode.&lt;/p>
&lt;p>The way the 80386 allows 32-bit instructions in 16-bit mode and vice versa is via two properties. The first is an instruction width setting at the code segment level: segment descriptors can indicate that the code they contain is 16-bit or 32-bit. The default for real mode is to assume that code segments are set to 16 bits, but in protected mode we can choose whatever we prefer. The second is the &lt;code>0x66&lt;/code> instruction prefix, which tells the processor that the following instruction operates in &lt;em>the opposite&lt;/em> mode of what is configured in the current code segment: e.g. if the current code segment is a 16-bit segment, the &lt;code>0x66&lt;/code> prefix marks 32-bit instructions.&lt;/p>
&lt;p>Knowing this, we can see that unreal mode is most useful in the 80386 because, once enabled, code can easily reference any extended memory address using 32-bit offsets and the &lt;code>0x66&lt;/code> prefix. But the 16-bit constraints of the 80286 don&amp;rsquo;t make unreal mode less useful given how much the DOS ecosystem needed to escape the real mode address space limitations and how difficult it was to leave protected mode in the 80286.&lt;/p>
&lt;p>With that out of the way, what we are missing in our discussion are the ways by which to enter unreal mode. There are at least two: the undocumented LOADALL instruction and an unsupported jump from protected mode to real mode. Let&amp;rsquo;s take a look at both.&lt;/p>
&lt;h1 id="loadall">LOADALL&lt;/h1>
&lt;p>LOADALL is an undocumented instruction of the 80286 and 80386 processors. This instruction has a long history and I&amp;rsquo;m not going to cover it in detail because &lt;a href="https://rep-lodsb.mataroa.blog/blog/intel-286-secrets-ice-mode-and-f1-0f-04/">others have done a much better job than I could&lt;/a>. I&amp;rsquo;ll restrict my explanation to what the instruction does and why it is useful to enter unreal mode.&lt;/p>
&lt;p>Simply put, all LOADALL does is, as its name implies, set all processor registers at once with values that come from a memory region. This is similar to the widely unused built-in task switching functionality of x86 processors, which reloads the processor state with register values stored in a &lt;a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment (TSS)&lt;/a> descriptor.&lt;/p>
&lt;p>But LOADALL has some quirks that the TSS descriptor doesn&amp;rsquo;t have, and those are what make it interesting. Witness the contents of the memory that LOADALL reads on an 80286:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">Physical Address CPU Register
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---------------- ------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0800h-0805h None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0806h-0807h MSW
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0808h-0815h None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0816h-0817h TR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0818h-0819h Flag word
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Ah-081Bh IP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Ch-081Dh LDT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Eh-081Fh DS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0820h-0821h SS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0822h-0823h CS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0824h-0825h ES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0826h-0827h DI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0828h-0829h SI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Ah-082Bh BP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Ch-082Dh SP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Eh-082Fh BX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0830h-0831h DX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0832h-0833h CX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0834h-0835h AX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0836h-083Bh ES descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">083Ch-0841h CS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0842h-0847h SS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0848h-084Dh DS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">084Eh-0853h GDTR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0854h-0859h LDT descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">085Ah-085Fh IDTR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0860h-0865h TSS descriptor cache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Registers, registers, more registers, descriptor cache&amp;hellip; Wait, what? Entries for the &lt;em>cached&lt;/em> segment descriptors? That&amp;rsquo;s interesting. These are the actual values for the segment descriptors that the processor stores in its internal cache. Which means that, by issuing a carefully-crafted LOADALL, we can tell the processor to set the cached descriptors to values that are nonsensical for the current operation mode&amp;mdash;and the processor does &lt;em>not&lt;/em> complain.&lt;/p>
&lt;p>In essence, with just one instruction, we can tell the processor that the cached descriptors have base addresses above the 1 MB limit and/or that they have limits larger than 64 KB. And the processor will just accept those into the cache and use them for future memory references.&lt;/p>
&lt;p>As it turns out, &lt;a href="https://www.os2museum.com/wp/himem-sys-unreal-mode-and-loadall/">&lt;code>HIMEM.SYS&lt;/code> did leverage LOADALL&lt;/a> and we can even find its &lt;a href="https://github.com/neozeed/himem.sys-2.06">original source code&lt;/a> to peek into &lt;a href="https://github.com/neozeed/himem.sys-2.06/blob/main/oemsrc/xm286.asm#L241">how it achieved&lt;/a> this feat. It&amp;rsquo;s not trivial to do, but the performance gains of such an undocumented instruction were too hard to pass on in order to implement efficient transfers between conventional and extended memory.&lt;/p>
&lt;p>This made me curious so I tried replicating LOADALL&amp;rsquo;s usage in &lt;a href="https://www.dosbox.com/">DOSBox&lt;/a> and&amp;hellip; failed because DOSBox does not implement this instruction&amp;mdash;which is understandable because it was not documented, it was very specific to two processors, and it apparently was not widely used outside of &lt;code>HIMEM.SYS&lt;/code>. Maybe more-accurate processor emulators supply it, but I didn&amp;rsquo;t bother trying.&lt;/p>
&lt;p>Which brings us to the other way to enter unreal mode: an unsupported jump from protected mode to real mode in the 80386.&lt;/p>
&lt;h1 id="real-to-protected-mode-and-back">Real to protected mode and back&lt;/h1>
&lt;p>Protected mode fascinated me as a child when I read about it in books that didn&amp;rsquo;t &amp;ldquo;belong&amp;rdquo; to my age. After having dipped my toes in 8086 assembly and having toyed around with boot sectors and the like, I fantasized about how protected mode &amp;ldquo;unlocked&amp;rdquo; enormous power. I knew I had to learn such black arts to write my own operating system and I remember writing code that tried to enter protected mode and always failed&amp;mdash;yet it sounded so easy from the books: just set bit 0 of &lt;code>CR0&lt;/code> to 1!&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-assembly-books.jpg" />
&lt;figcaption>The assembly and processor books I read once upon a time and that got me interested in all of this low-level systems programming.&lt;/figcaption>
&lt;/figure>
&lt;p>It wasn&amp;rsquo;t until many years later, around 2007, that I decided I wanted to fulfill my long-term dream to write an operating system. At that point, I invested some time to get protected mode to work&amp;mdash;and I finally did, with interrupts enabled and all. (Spoiler alert: I never got to write an OS though&amp;hellip; yet?) But even if that worked, getting into protected mode is always frustrating experience of having to get many teeny tiny details right just so that the machine doesn&amp;rsquo;t crash. You do it right and you see absolutely nothing; you do it wrong and you see absolutely nothing either.&lt;/p>
&lt;p>But wait. Why am I telling you all this? Ah yes, because another way of entering unreal mode is the following dance:&lt;/p>
&lt;ol>
&lt;li>Switch to protected mode.&lt;/li>
&lt;li>Set up segment registers to segment descriptors that provide access to the full address space, causing the cached descriptors to have a 4 GB limit.&lt;/li>
&lt;li>Switch back to real mode with the previous unsupported segment configuration in place.&lt;/li>
&lt;/ol>
&lt;p>Upon switching back to real mode, the properties of the segment descriptors that don&amp;rsquo;t make sense in real mode (those limits higher than 64 KB) are &lt;em>sticky&lt;/em>, meaning that no architectural operations such as &lt;code>MOV DS, AX&lt;/code> touch those bits of the cache. With that, it becomes possible to address extended memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-real-mode-load.png" />
&lt;figcaption>Diagram representing how a real mode segment descriptor load does &lt;i>not&lt;/i> modify the limit or flags already stored in the descriptor cache.&lt;/figcaption>
&lt;/figure>
&lt;p>Unfortunately, the 80286 did not have a mechanism to switch from protected mode back to real mode. Creative folks found ways to do this by triple-faulting the CPU and carefully setting registers to skip the BIOS POST code, but this process was extremely slow and thus unfeasible for frequent switches. At the time, the lack of this feature in the 80286 was a major complaint from OS vendors because it made it difficult to support running DOS programs from within a modern operating system.&lt;/p>
&lt;p>Intel addressed those concerns with the launch of the 80386 and its new VM86 mode. But&amp;hellip; that wasn&amp;rsquo;t the only change. The 80386 also added the ability to return to real mode from protected mode&amp;mdash;with a lot of caveats. Intel was prescriptive in how exactly to return to real mode and never described what would happen if you didn&amp;rsquo;t follow the rules to the letter&amp;hellip; which was essentially begging for someone to try and see what would happen when doing that.&lt;/p>
&lt;p>The answer, as we saw above, is unreal mode.&lt;/p>
&lt;h1 id="hands-on-unreal-mode">Hands-on unreal mode&lt;/h1>
&lt;p>All of the above research made me really curious so I got the urge to see unreal mode in action. So, in preparation for this article, I wrote a trivial DOS program that enters unreal mode and shows it working.&lt;/p>
&lt;p>As in the past, getting this demo to a functional state was a frustrating experience of fighting with carefully-crafted register values and memory offsets, DOSBox crashes, and &lt;a href="https://bochs.sourceforge.io/">Bochs&lt;/a> oddities. But in the end my demo ran successfully, and because I couldn&amp;rsquo;t find any trivial, readily-available sample piece of code online that did this, I concluded that I &lt;em>had to&lt;/em> present it to you here for posterity&amp;rsquo;s sake.&lt;/p>
&lt;p>So. Let&amp;rsquo;s get our hands dirty. All you need is &lt;a href="https://github.com/doomemacs/doomemacs">&lt;del>Doom Emacs&lt;/del>&lt;/a> a text editor, &lt;a href="https://www.nasm.org/">NASM&lt;/a>, and DOSBox. Our goal is to:&lt;/p>
&lt;ol>
&lt;li>write a flat COM executable,&lt;/li>
&lt;li>without sections (code and data mixed),&lt;/li>
&lt;li>all in 16-bit code with the occasional 32-bit operation override,&lt;/li>
&lt;li>that enters protected mode,&lt;/li>
&lt;li>that stores a string somewhere in extended memory far from the reach of real mode,&lt;/li>
&lt;li>that drops back to (un)real mode,&lt;/li>
&lt;li>that copies the string we stored in extended memory to conventional memory,&lt;/li>
&lt;li>that tells DOS to print the string we fetched,&lt;/li>
&lt;li>and that finally returns to DOS to prove that DOS still works.&lt;/li>
&lt;/ol>
&lt;p>Let&amp;rsquo;s begin.&lt;/p>
&lt;p>The first thing we have to do is set up the GDT. We&amp;rsquo;ll use statically-configured descriptors in the code, like these:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Null descriptor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">dq&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Code descriptor for this binary. The base address needs fixup at
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; runtime to point to the location where the code was loaded.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">CODE_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_low&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 16 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_mid&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10011110&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, exec, conforming, read allowed.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">00000000&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Not 4KB, 16-bit, no long mode, limit 00h.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_high&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Data/stack descriptor for this binary. The base address needs fixup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; at runtime to point to the location where the code was loaded.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">DATA_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_low&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 16 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_mid&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10010010&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, data, grows up, read-write.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">00000000&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Not 4KB, 16-bit, no long mode, limit 00h.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_high&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Linear data descriptor covering the full 4 GB address space. No fixup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; necessary.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">LINEAR_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10010010&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, data, grows up, read-write.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">11001111&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; 4KB, 16-bit, no long mode, limit=0fh.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The GDT presented above defines four descriptors:&lt;/p>
&lt;ol>
&lt;li>The null descriptor, which is unused but must be present.&lt;/li>
&lt;li>The code descriptor (&lt;code>CODE_DESC&lt;/code>) for our COM executable. This is configured to 16 bits so that we don&amp;rsquo;t have to mix 16-bit and 32-bit sections in the same source file (which is easy but I wanted to avoid). Note also that the base address is zero, but we&amp;rsquo;ll have to patch it up at runtime to point to the actual location where DOS loaded our executable. We cannot predict this and all the offsets built into the code must remain valid when in protected mode, so we must compute this dynamically.&lt;/li>
&lt;li>The data and stack descriptor (&lt;code>DATA_DESC&lt;/code>) for our COM executable. For the same reasons as the code descriptor, we must compute its base address at runtime.&lt;/li>
&lt;li>A linear data descriptor (&lt;code>LINEAR_DESC&lt;/code>) to be able to reference the whole 4 GB address space. We&amp;rsquo;ll use this one to set up the segments for unreal mode.&lt;/li>
&lt;/ol>
&lt;p>Next up, we need to define the descriptor for the GDT itself right after the GDT data section:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">gdt_desc&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="no">$-gdt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">gdt_base&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Easy, but again, note how &lt;code>gdt_base&lt;/code> is zero. The address to the GDT needs to be a linear address, and because we don&amp;rsquo;t know where the COM file will be loaded, we have to compute this address at runtime.&lt;/p>
&lt;p>After this, it&amp;rsquo;s time to start the code section. The first thing we do is fix up all of the base addresses we left blank in the GDT itself and the GDT descriptor. Note that, because we target a COM binary (or a boot sector if you are so inclined), we can assume that &lt;code>CS&lt;/code>, &lt;code>DS&lt;/code>, &lt;code>ES&lt;/code>, and &lt;code>SS&lt;/code> all point to the same place, which makes things significantly easier:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Assume CS = DS = ES = SS (COM file or boot sector).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">real_cs&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Populate the GDT code and data descriptors with our actual base address
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; so that the built-in code offsets work once we enter protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shl&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_low&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_low&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shr&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_high&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ah&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Populate the GDT descriptor with the linear address of the GDT.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ds&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shl&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">add&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gdt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">gdt_base&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we do preparatory work to enter protected mode: namely, we disable the &lt;a href="https://wiki.osdev.org/Non_Maskable_Interrupt">Non-Maskable Interrupt (NMI)&lt;/a> and interrupts in general, and we enable the A20 gate:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Disable the Non-Maskable Interrupt (NMI) and interrupts.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">71&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cli&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Enable the A20 gate.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">92&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">92&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then, we can finally do the magic to enter protected mode by loading the GDT descriptor, updating the &lt;code>PE&lt;/code> (0th) bit in the &lt;code>CR0&lt;/code> register, and doing a long jump:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Load the GDT.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">lgdt&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">gdt_desc&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Enable protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cr0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cr0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Flush out the processor pipeline and reload CS.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">jmp&lt;/span> &lt;span class="no">CODE_DESC&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="no">protected_mode&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s it. We have reached the protected mode realm! How exciting is &lt;em>that&lt;/em>? We are now in a 16-bit code segment but the machine state is mostly &amp;ldquo;unusable&amp;rdquo;. None of the segment registers except &lt;code>CS&lt;/code> are valid and interrupts are disabled (because we didn&amp;rsquo;t bother to set up the IDT&amp;mdash;and we don&amp;rsquo;t have to for this simple experiment). So let&amp;rsquo;s do the minimum set up that we need:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">protected_mode:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Set up the data and stack segments.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DATA_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ss&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now that the basic segments are configured, let&amp;rsquo;s copy the &lt;code>msg&lt;/code> string built into the binary into extended memory. We do this by pointing &lt;code>ES&lt;/code> to our linear segment and using the &lt;code>EXTENDED_ADDR&lt;/code> offset, which I set to an arbitrary 4 MB:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Store a message in extended memory. We are in protected mode so this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; works by design.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">LINEAR_DESC&lt;/span> &lt;span class="c1">; Load the linear address space in ES.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">esi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msg&lt;/span> &lt;span class="c1">; Point DS:[ESI] to our message.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">edi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">EXTENDED_ADDR&lt;/span> &lt;span class="c1">; Point ES:[EDI] to extended memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ecx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">o32&lt;/span> &lt;span class="no">rep&lt;/span> &lt;span class="no">movsb&lt;/span> &lt;span class="c1">; Must use 32-bit addressing.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this is done, we prepare the &lt;code>FS&lt;/code> segment with a large limit so that we can use it from unreal mode and restore &lt;code>ES&lt;/code> to the conventional values:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Set up FS as an &amp;#34;unreal mode&amp;#34; segment.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">LINEAR_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">fs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; ... but restore ES to have standard real mode limits. Not strictly
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; necessary but helps to prove our example.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DATA_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And, with that, we are ready to pivot back to real mode&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Disable protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cr0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">and&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">~&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cr0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; And now return to real mode with a far jump.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pushf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">push&lt;/span> &lt;span class="no">word&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">real_cs&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">push&lt;/span> &lt;span class="no">unreal_mode&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">iret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; except that it isn&amp;rsquo;t &amp;ldquo;valid&amp;rdquo; real mode! Remember that we left &lt;code>FS&lt;/code> configured with a high, non-standard limit of 4 GB? Such non-standard limit remains in the segment cache. But before leveraging that, let&amp;rsquo;s make our new machine state functional to continue executing the COM binary:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">unreal_mode:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Reload real mode COM segment layout.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">bx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ss&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can now also reenable interrupts, which we must do before we decide to return to DOS:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Reenable the NMI and interrupts.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">sti&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">and&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="no">fh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">71&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But, crucially, we keep the A20 enabled in order to correctly reference extended memory later on!&lt;/p>
&lt;p>And after all of this dance, that&amp;rsquo;s really it. We are in unreal mode. Any memory references we make through the &lt;code>FS&lt;/code> segment register can use offsets beyond the 1 MB limit no matter what its segment base is and no matter if the segment base &lt;em>changes&lt;/em>.&lt;/p>
&lt;p>Easy to say, hard to believe. Let&amp;rsquo;s prove that this is true. Let&amp;rsquo;s first fetch the message we stored in extended memory by copying it to conventional memory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Fetch the message from extended memory by using a large offset. This
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; would not work in real mode or VM86 (even with 32-bit addressing), but
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; does because we are actually in unreal mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span> &lt;span class="c1">; Clear FS to show its high limits remain.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">fs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">esi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">EXTENDED_ADDR&lt;/span> &lt;span class="c1">; Point FS:[ESI] to extended memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">edi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msgcopy&lt;/span> &lt;span class="c1">; Point ES:[EDI] to our buffer.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ecx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">o32&lt;/span> &lt;span class="no">fs&lt;/span> &lt;span class="no">rep&lt;/span> &lt;span class="no">movsb&lt;/span> &lt;span class="c1">; Must use 32-bit addressing.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now that we got it copied, let&amp;rsquo;s call into DOS to print the message and return control to DOS:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Print the message we fetched from extended mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ah&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">bx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">dx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msgcopy&lt;/span> &lt;span class="c1">; Remember this was all ... at first!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">int&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; And jump back to DOS.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="no">c00h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">int&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If all goes well, you should see &lt;code>Hello, unreal mode!&lt;/code> in the console and the usual &lt;code>C:\&amp;gt;&lt;/code> prompt should greet you again.&lt;/p>
&lt;p>But, wait, there is more! If you happen to be running this under Bochs&amp;mdash;and I recommend that you do because it offers much better debugging facilities than DOSBox&amp;mdash;you can pause the simulation with &lt;code>CTRL+C&lt;/code> and dump the segment registers with &lt;code>sreg&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">&amp;lt;bochs:2&amp;gt; sreg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">es:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cs:0x000f, dh=0x00009300, dl=0x00f0ffff, valid=3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000000f0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ss:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ds:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fs:0x0000, dh=0x00cf9300, dl=0x0000ffff, valid=11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gdtr:base=0x0000000000011c72, limit=0x20
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">idtr:base=0x0000000000000000, limit=0x3ff
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pay attention to the details for the &lt;code>limit&lt;/code> field of all the segment registers. You can see how the value is &lt;code>0x0000ffff&lt;/code> for all of them as you&amp;rsquo;d expect in real mode&amp;hellip; but &lt;code>FS&lt;/code>&amp;rsquo;s limit is the non-standard &lt;code>0xffffffff&lt;/code>. We did it. We are in unreal mode and DOS still runs fine. (In fact, remember that &lt;code>HIMEM.SYS&lt;/code> itself &lt;em>does&lt;/em> leverage unreal mode and this driver was active almost all the time in a DOS installation.)&lt;/p>
&lt;p>IMPORTANT: You can download the full source code by clicking on &lt;a href="/src/unreal-mode/unreal.asm">&lt;code>unreal.asm&lt;/code>&lt;/a>.&lt;/p>
&lt;p>Once you download the source code, you can build it with:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">nasm -o unreal.com unreal.asm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And once built, you can run it within DOSBox by copying the binary into a directory you mount within the emulator or use &lt;a href="https://www.gnu.org/software/mtools/">mtools&lt;/a> to copy it into a DOS boot disk image for Bochs.&lt;/p>
&lt;h1 id="dos-extenders">DOS extenders&lt;/h1>
&lt;p>If you resisted the urge to keep toying with the example code presented above and are still reading, great! We can continue onto our final topic: &lt;a href="https://en.wikipedia.org/wiki/DOS_extender">DOS extenders&lt;/a>. These programs are what truly set DOS free from the 1 MB address space limitations and thus are the right way to conclude this article.&lt;/p>
&lt;p>A DOS extender, in rough terms, is a wrapper for your code that enters protected mode and transfers control back to you. This is very useful because, by running in protected mode, your &lt;em>code&lt;/em> segment can span more than 640 KB, finally letting you run large binaries without resorting to ancient spells like &lt;a href="https://en.wikipedia.org/wiki/Overlay_(programming)">overlays&lt;/a>. But if that was the only thing that a DOS extender did, it would be too simple of a thing and not make it a DOS-anything.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-dos-extender.png" />
&lt;figcaption>Representation of the structure of a DOS-extended application and how it relates to a DOS extender, DOS drivers, and raw hardware access.&lt;/figcaption>
&lt;/figure>
&lt;p>The crucial feature that DOS extenders provide is a mechanism to call &lt;em>back&lt;/em> into the BIOS and DOS to access the services these provide. In particular, this means accessing &lt;em>drivers&lt;/em> and &lt;em>the file system&lt;/em>. They do so by exposing the same &lt;a href="https://en.wikipedia.org/wiki/DOS_API">DOS API&lt;/a> of the real mode host in protected mode, and they do this so that they can transparently service it in an efficient manner.&lt;/p>
&lt;p>The general mechanics behind DOS extenders are very similar to what I described earlier: they enter protected mode to use extended memory and run your code, but they &lt;em>temporarily&lt;/em> return to real mode to issue BIOS and DOS service calls. Unfortunately, this naive implementation would be quite inefficient, so DOS extenders actually service various APIs in protected mode to avoid returning to real mode, and they optimize large buffer transfers to minimize the number of switches when they &lt;em>do&lt;/em> have to switch modes. In other words, DOS extenders are their own mini OS on top of DOS.&lt;/p>
&lt;p>DOS extenders were widely used in games, and you may well remember the iconic message that DOOM printed on startup:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">C:\&amp;gt;DOOM
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DOS/4GW Protected Mode Run-time Version 1.97
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Copyright (c) Rational Systems, Inc. 1990-1994
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>These messages came from &lt;a href="https://en.wikipedia.org/wiki/DOS/4G">DOS/4G&lt;/a>, the most common DOS extender of all. The reason it was so common is because the &amp;ldquo;W version&amp;rdquo; was the free (but limited) edition of DOS/4G, and it shipped with the popular &lt;a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">Watcom&lt;/a> C compiler that produced protected mode binaries. But pay attention to &amp;ldquo;run-time&amp;rdquo; in that message. Why run-time?&lt;/p>
&lt;p>DOS extenders were not the only system component that entered protected mode. By the time DOS extenders became popular, Windows was already a thing and Windows likes protected mode too. And as we saw in the previous post, DOS itself came with &lt;code>EMM386.EXE&lt;/code>, another mini hypervisor that put DOS inside a VM86 instance so that it could easily reference extended memory. So what if you wanted to run a popular DOS-extended program, say DOOM, inside one of these also-popular protected mode environments?&lt;/p>
&lt;p>Tough luck. Nesting protected modes was impossible until &lt;a href="https://en.wikipedia.org/wiki/X86_virtualization">virtualization appeared&lt;/a>. VM86 was close to what was necessary but it didn&amp;rsquo;t allow running protected mode programs from within it. So, how did this work? How could you run a DOS-extended program inside Windows or while &lt;code>EMM386.EXE&lt;/code> was running?&lt;/p>
&lt;p>Like in any computing problem, the answer is simple: by means of an abstraction layer! To support this flow, Microsoft defined the &lt;a href="https://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface">DOS Protected Mode Interface (DPMI)&lt;/a>, an API to abstract the core services to interact with protected mode. DPMI is &lt;em>not&lt;/em> a replacement for a DOS extender though: DPMI is an API that DOS extenders themselves use to deal with protected mode operations.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-dpmi.png" />
&lt;figcaption>Simple representation of the role that DPMI plays in DOS-extended applications and different host operating systems.&lt;/figcaption>
&lt;/figure>
&lt;p>In the case of DOS-extended programs, the first thing that they do at startup is check if a DPMI kernel is present. If one exists, such as when the DOS program runs within Windows, then the DOS extender leverages Windows&amp;rsquo; DPMI services and delegates all operations to Windows. But if such a provider isn&amp;rsquo;t running, the DOS extender starts the DPMI kernel typically built into itself.&lt;/p>
&lt;p>If you want to see even more code in action, I refer you to skim through the sources of the free &lt;a href="https://sourceforge.net/projects/dos32a/">DOS/32&lt;/a> extender and the free &lt;a href="https://en.wikipedia.org/wiki/CWSDPMI">CWSDPMI&lt;/a> host.&lt;/p>
&lt;p>And with that, I&amp;rsquo;m hoping that the next article will finally be the one talking about DJGPP and everything else it had to do to make Unix applications run semi-seamlessly on DOS&amp;hellip; unless some other preparatory essay becomes necessary!&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-07-80386-dos.jpg" length="152971" type="image/jpeg"/></item><item><title>Links: January 2024 edition</title><link>https://jmmv.dev/2024/01/links-january-2024-edition.html</link><pubDate>Wed, 31 Jan 2024 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/01/links-january-2024-edition.html</guid><description>&lt;p>It is hard to believe but we are already one month into 2024. January has flown by for me and I haven&amp;rsquo;t done a good job at keeping up with news sites&amp;hellip; but I have been reading them on and off and I have collected a small set of interesting articles.&lt;/p>
&lt;p>To everyone new around here, hello and thanks for subscribing! For some context, what follows is my manual selection of cool articles, videos, and projects I stumbled upon during this time period. However, this is not just a dump of links: each link is accompanied by a short commentary to justifies why I thought the material was interesting, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading the source.&lt;/p>
&lt;p>Let&amp;rsquo;s get to it.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://twitter.com/luciascarlet/status/1742156794611310610">&amp;ldquo;On Microsoft&amp;rsquo;s vision for Windows&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By @luciascarlet on January 2nd, 2024&lt;/em>&lt;/p>
&lt;p>This little Twitter rant aligns well with my own views of Windows: I have come to &lt;em>like&lt;/em> Windows 10 and 11 as you can see from my previous &lt;a href="/2022/03/a-year-on-windows-intro.html">lengthy review of the OS&lt;/a> and my &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">review of its history book&lt;/a>, and I &lt;em>do&lt;/em> think there are very interesting technical feats within this system. However, I do &lt;em>not&lt;/em> like where the platform is headed with the constant &lt;a href="https://en.wikipedia.org/wiki/Enshittification">enshittification&lt;/a> due to the increased coupling with Microsoft&amp;rsquo;s own cloud services and the recent AI push.&lt;/p>
&lt;p>The same applies to macOS by the way: the problems aren&amp;rsquo;t as pronounced as on Windows, but its progressive iOSification removes freedoms in you can use your own machine. These issues combined have actually pushed me back into the Linux desktop&amp;hellip; and it&amp;rsquo;s a relief to not see a constant stream of attention-grabbing notifications and ads, and to have regained full control of my machine.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="http://fqa.9front.org/fqa0.html">&amp;ldquo;Introduction to Plan 9 &amp;ldquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By the 9front project&lt;/em>&lt;/p>
&lt;p>Plan 9 is an interesting creature. It&amp;rsquo;s the OS that should have succeeded Unix but never did: it was a little too different a little too late. This document provides an explanation of what Plan 9 is, why it never &amp;ldquo;evolved&amp;rdquo;, and why you should (not) use it.&lt;/p>
&lt;p>But do you want to see something cool? Parts of Plan 9 are still with us &lt;em>today&lt;/em>. If you happen to be on a Windows desktop running WSL 2, go type this right now and behold:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ ps ax | grep [p]lan9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4 hvc0 Sl+ 0:01 plan9 --control-socket 5 --log-level 4 --server-fd 6 --pipe-fd 8 --log-truncate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s right. WSL leverages the Plan 9 file server to let Windows access files within the WSL 2 virtual machine. Oh wait, is this an idea for a future Blog System/5 article? You bet!&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://utcc.utoronto.ca/~cks/space/blog/unix/LseekWhyNamedThat">&amp;ldquo;Why Unix&amp;rsquo;s lseek() has that name instead of seek()&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Chris Siebenmann on January 2nd, 2024&lt;/em>&lt;/p>
&lt;p>System calls are sometimes oddly named&amp;mdash;like the well-known mistake of dropping the &lt;code>e&lt;/code> from the &lt;code>creat&lt;/code> syscall. But why is the naming of &lt;code>fstat&lt;/code>/&lt;code>lstat&lt;/code> not consistent with &lt;code>fseek&lt;/code>/&lt;code>lseek&lt;/code>? Read on for an interesting history review to reveal the answer.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://orlp.net/blog/when-random-isnt/">&amp;ldquo;When random isn&amp;rsquo;t&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Orson R. L. Peters on January 10th, 2024&lt;/em>&lt;/p>
&lt;p>Generating random numbers on deterministic machines&amp;mdash;like computers are&amp;mdash;is an interesting problem. While it is possible to come up with a good random number generator, most &lt;code>rand&lt;/code>-like functions in most languages use a pseudo random number generator. What this means is that the numbers they produce is deterministic given a specific seed.&lt;/p>
&lt;p>In this article, the author explains how they used this deficiency to break the communication barrier between the sandbox that World of Warcraft uses to run untrusted code and the user-provided add-ons that run under said sandbox. There is &amp;ldquo;some math&amp;rdquo; in there, but you can skip over it and still understand the basis of this sandbox exploit.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://zolutal.github.io/understanding-paging/">&amp;ldquo;Understanding x86_64 Paging&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Justin Miller on December 27th, 2023&lt;/em>&lt;/p>
&lt;p>Knowing the mechanics of virtual memory is a necessity for any systems engineer. Knowing the internals of paging, however, is optional but still a very useful piece of knowledge to carry around. This article equips you with that.&lt;/p>
&lt;p>Myself, I knew how 32-bit paging worked but never bothered to learn how it did in 64-bit x86 chips. The fact is that there are some important differences because the approach that works for a 32-bit address space just doesn&amp;rsquo;t with a 64-bit address space: the page tables would take way too much memory!&lt;/p>
&lt;p>So, read this article for more details. I found the text somewhat hard to read, but it&amp;rsquo;s full of diagrams and detailed information so it&amp;rsquo;s worth a glance.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://davidben.net/2024/01/15/empty-slices.html">&amp;ldquo;Passing nothing is surprisingly difficult&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By David Benjamin on January 175h, 2024&lt;/em>&lt;/p>
&lt;p>Slices are partial views into an existing array: instead of performing a costly copy of a part of the array into a smaller array, you represent the &amp;ldquo;slice&amp;rdquo; as an address of a first element and a length specifying how many elements follow. Slices are traditionally represented as a &amp;ldquo;start pointer + count&amp;rdquo; pair but there are other representations possible.&lt;/p>
&lt;p>So, the question is: how do you represent empty slices? There are different choices, and different languages pick differently. This post dives into how C, C++, and Rust represent slices, and how Rust&amp;rsquo;s choices make it impossible to pass those slices to C and C++ without runtime checks and conversions.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">&amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on January 17th, 2024&lt;/em>&lt;/p>
&lt;p>Last month I wrote a pretty successful article reminiscing the IDEs we had in the DOS days 30 years ago, and that article made me want to play with and write about DJGPP. However, while writing that &lt;em>other&lt;/em> draft, I realized I needed to clarify some concepts first for my own knowledge.&lt;/p>
&lt;p>Those concepts were around how DOS managed memory back in the day and what all the EMS, XMS, HMA and other acronyms meant. I spent various hours researching the topic and then wrote a summary describing the many ways DOS programs squeezed the most of the first megabyte of the address space. By the way, I discovered &lt;a href="https://www.draw.io/">draw.io&lt;/a> along the way and I regret not having tried it much before; it&amp;rsquo;s great.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://qr.blinry.org/">&amp;ldquo;Reading QR codes without a computer!&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Piko and blinry sometime in December 2023&lt;/em>&lt;/p>
&lt;p>I remember learning how to read barcodes and, I think, QR codes back in school in the early 2000s&amp;hellip; but obviously I had forgotten everything about it. This article is a work of art that explains how QR codes work. I&amp;rsquo;m&amp;hellip; horrified by how long the authors must have spent preparing all the beautiful diagrams that accompany the article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://experimentalworks.net/posts/2024-01-22-simple-phantom-types/">&amp;ldquo;Nominal types&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By David Soria Parra on January 22nd, 2024&lt;/em>&lt;/p>
&lt;p>I am a fan of leveraging the type system to narrowly model the different concepts in a problem domain. Passing around integers or strings that mean different things as raw types has caused serious production outages in the past, and in my software I like to prevent against those. Traditionally I&amp;rsquo;ve used &lt;a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">Rust&amp;rsquo;s &amp;ldquo;new type&amp;rdquo; idiom&lt;/a>, but this article presents a neat trick that seems easier to maintain than that one. If anything, it helps keep all of your types consistent with each other from an API perspective.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://danluu.com/why-video/">&amp;ldquo;Why do people post on [bad platform] instead of [good platform]?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Dan Luu on January 28th, 2024&lt;/em>&lt;/p>
&lt;p>Deciding &lt;em>where&lt;/em> to publish content is something I&amp;rsquo;ve struggled (and I&amp;rsquo;m still struggling) with. No matter the medium, there is a trade off between convenience, familiarity and/or personal preference vs. audience. For example, while I&amp;rsquo;m enjoying my move to Substack from a self-hosted blog because of the sustained subscriber growth, I&amp;rsquo;m also well-aware that some of my past readers may not like this. Or as another example, whenever I have posted a Twitter thread, I&amp;rsquo;ve had to go through great lengths to &lt;em>also&lt;/em> post the same content here to avoid it being slurped into &amp;ldquo;thread reader&amp;rdquo; apps.&lt;/p>
&lt;p>This article does a nice job at diving into why people may be choosing certain publishing mediums and why it&amp;rsquo;s impossible to please everyone. I still don&amp;rsquo;t like the trend to move to video though.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://pong-wars.vercel.app/">&amp;ldquo;Pong wars&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Koen van Glist on January 28th, 2024&lt;/em>&lt;/p>
&lt;p>A mesmerizing 2-player pong-like game where the board is divided in two territories and the bouncing balls try to gain the opposite territory by bouncing onto it.&lt;/p>
&lt;p>I found this so neat that I hacked a very quick&amp;rsquo;n&amp;rsquo;dirty clone with EndBASIC. Launch it in your browser by clicking on &lt;a href="https://repl.endbasic.dev/?run=jmmv/pongwars.bas">jmmv/pongwars.bas&lt;/a> and press any key to drop into the interpreter and explore!&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>From 0 to 1 MB in DOS</title><link>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</link><pubDate>Wed, 17 Jan 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</guid><description>&lt;p>Since the last article on &lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">the text-based IDEs of old&lt;/a>, I&amp;rsquo;ve been meaning to write about the GCC port to DOS, namely &lt;a href="https://www.delorie.com/djgpp/">DJGPP&lt;/a>. As I worked on the draft for that topic, I realized that there is a ton of ground to cover to set the stage so I took most of the content on memory management out and wrote this separate post.&lt;/p>
&lt;p>This article is a deep dive on how DOS had to pull out tricks to maximize the use of the very limited 1 MB address space of the 8086. Those tricks could exist because of the features later introduced by the 80286 and the 80386, but these were just clutches to paper over the fact that DOS could not leverage the real improvements provided by protected mode.&lt;/p>
&lt;p>This detour is long but I hope you&amp;rsquo;ll enjoy it as much as I enjoyed researching the topic. I&amp;rsquo;ll walk you through the changes in the x86 architecture over time, starting with the 8086 and ending in the 80386, and how DOS kept up along the way. I&amp;rsquo;ll conclude with a peek into DOS&amp;rsquo; own &lt;tt>MEM&lt;/tt> and MemMaker utilities. I must omit details to keep the text manageable in size though, so please excuse the lack of detail in some areas; just follow the links to external documentation to learn more.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>&lt;em>Before we begin, I&amp;rsquo;d like to thank neozeed from &lt;a href="https://virtuallyfun.com/">Virtually Fun&lt;/a> for his in-depth review of this article. Head to his blog for a lot of interesting and related content!&lt;/em>&lt;/p>
&lt;h1 id="the-8086-and-real-mode">The 8086 and real mode&lt;/h1>
&lt;p>Back in the 1980s, the &lt;a href="https://en.wikipedia.org/wiki/Intel_8086">Intel 8086&lt;/a> was &lt;em>the&lt;/em> processor for PCs (along with its crippled sibling 8088 which I&amp;rsquo;ll ignore throughout this post). The 8086 was a simple chip with significant limitations, but it was incredibly successful and is the foundation of the x86 architecture that we still use today. Because the 8086 powered PCs, and DOS was the operating system that IBM chose for the PC, DOS was designed to work for the 8086.&lt;/p>
&lt;p>For the purposes of our article, let&amp;rsquo;s focus on two details: the 8086 CPU had a 20-bit address bus, which means it could only address 1 MB of memory, and it was a 16-bit CPU, which means that its internal registers were all 16-bit long. Which begs the question: if registers could only represent &lt;code>2^16 = 64K&lt;/code> different values, how could code reference a 20-bit address space?&lt;/p>
&lt;p>The answer is &lt;em>segmentation&lt;/em>. In the 8086, every instruction that references memory does so by specifying an address as two separate 16-bit quantities: a &lt;em>segment&lt;/em> and an &lt;em>offset&lt;/em> within the segment. Because segments are 16-bit long, there can be up to 64KB segments&amp;mdash;and if we take the 1 MB total address space and divide it by 64KB, we deduce that segments are offset from each other by 16 bytes.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-segments.png" />
&lt;figcaption>Representation of the way segmentation slices the 8086 1 MB address space into 64KB overlapping segments offset by 16 bytes from each other.&lt;/figcaption>
&lt;/figure>
&lt;p>There are two things of note in the diagram. First, segments overlap, meaning that a single memory location can be referenced by many different segment/offset combinations. And, second, all segments after &lt;code>0xF000&lt;/code> reference memory positions above the 1 MB address space that don&amp;rsquo;t exist, which the 8086 chose to wrap around by ignoring the 21st bit of an address. After all, there is no 21st line in the address bus.&lt;/p>
&lt;p>When accessing a piece of memory with an address of the form &lt;code>segment:offset&lt;/code>, say &lt;code>81DA:72C3&lt;/code>, the 8086 multiplies &lt;code>0x81DA&lt;/code> by 16 (a simple 4-bit shift to the left) and adds the &lt;code>0x72C3&lt;/code> offset to the result to obtain address &lt;code>0x89063&lt;/code>. From there on, the 8086 reads from or writes to that memory location and calls it a day. There is no &lt;a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit (MMU)&lt;/a>: every memory access can reference any address, and all accesses are legal (including those that wrap around!) which means null or dangling pointer dereferences don&amp;rsquo;t cause any sort of crash.&lt;/p>
&lt;p>This type of MMU-less segmented addressing is known as &lt;em>real mode&lt;/em>, but this name didn&amp;rsquo;t appear until the 80286 had to give it a name to distinguish it from &lt;em>protected mode&lt;/em>. But before introducing the latter, let&amp;rsquo;s talk about memory maps for a second.&lt;/p>
&lt;h1 id="conventional-and-upper-memory">Conventional and upper memory&lt;/h1>
&lt;p>Just because the 8086 processor can reference 1 MB of memory does not mean that 8086 machines came equipped with 1 full MB of RAM. Machines typically included &lt;em>less&lt;/em> than that for cost reasons, so it&amp;rsquo;s critical to understand that the &lt;em>address space&lt;/em>&amp;mdash;that is, the set of addresses that can be &lt;em>referenced&lt;/em>&amp;mdash;is different from the amount of memory installed. No surprise there: the same is true today of modern 64-bit CPUs.&lt;/p>
&lt;p>This fact was advantageous because certain system devices prefer to expose themselves as part of the address space. For example: the BIOS ROM is accessible via a range of addresses in upper memory. Or another example: video cards tend to expose their framebuffer as a memory-mapped device so that applications can directly write to well-known addresses to manipulate video memory&amp;mdash;bypassing the separate I/O bus and instruction set.&lt;/p>
&lt;p>The question is: where do such devices live within the address space? The choice is pretty much arbitrary, so what IBM did was split the &lt;a href="https://wiki.osdev.org/Memory_Map_(x86)">address space of the original PC&lt;/a> in two parts. The first 640 KB, known as &lt;em>conventional memory&lt;/em>, were mapped to available RAM and were readily usable by applications. The upper 384 KB, known as &lt;em>upper memory&lt;/em> or the &lt;em>Upper Memory Area (UMA)&lt;/em>, were reserved for memory-mapped devices. This assignment of &lt;em>meaning&lt;/em> to portions of the address space for specific purposes is what&amp;rsquo;s called a &lt;em>memory map&lt;/em>, and this was the memory map of the original PC.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-memory-map.png" />
&lt;figcaption>Representation of the 8086 PC memory map. Solid blocks correspond to mapped memory and dashed parts correspond to unmapped memory.&lt;/figcaption>
&lt;/figure>
&lt;p>Note how conventional memory may not be fully usable: as shocking as it may sound today, PCs could have even less than 640 KB of installed RAM. More importantly for our purposes, the upper memory is &lt;em>sparse&lt;/em>: certain address ranges are assigned to devices, but there may be gaps between devices. What happens when reading from or writing to unmapped addresses is hard to tell as this depends on the chipset&amp;mdash;not the CPU&amp;mdash;but remember that all accesses had to be valid in some form.&lt;/p>
&lt;p>And by the way, there is one teeny tiny exception to the &amp;ldquo;all first 640 KB are free to use to applications&amp;rdquo;: the very first 1 KB of RAM is reserved for the Interrupt Vector Table, which is what the 8086 uses to look for interrupt handlers when it receives an interrupt, and a few more bytes after that are used by the BIOS to map volatile data. We can ignore these.&lt;/p>
&lt;h1 id="expanded-memory-specification-ems">Expanded Memory Specification (EMS)&lt;/h1>
&lt;p>As you can imagine, 640 KB of RAM were soon &lt;em>not&lt;/em> enough for many programs. Applications needed access to more memory, but the limitations of the 8086 20-bit address bus made it difficult. Yet there was a need for an immediate solution. The &lt;a href="https://en.wikipedia.org/wiki/Expanded_memory">Expanded Memory Specification (EMS)&lt;/a> was one of those first solutions and was originally designed by Lotus in order to support their star application &lt;a href="https://en.wikipedia.org/wiki/Lotus_1-2-3">1-2-3&lt;/a>.&lt;/p>
&lt;p>The idea is simple. Remember how upper memory is &lt;em>sparse&lt;/em>? What if we could map a window in that address space to a different portion of memory? And what if we could control, via software, which portion of memory was exposed through such window at any given time?&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-ems.png" />
&lt;figcaption>Representation of the 8086 PC memory map and an EMS window in upper memory mapped to a portion of memory provided by an external ISA card.&lt;/figcaption>
&lt;/figure>
&lt;p>This is precisely what EMS did. EMS brought the idea of having a software API that allowed applications to select views into &amp;ldquo;other&amp;rdquo; memory by mapping a 64 KB window in upper memory to another memory chip. Originally, this other memory was supplied by expansion ISA cards like the one below, which means that EMS required hardware support and hardware-specific drivers to perform the window remappings. This also means, by the way, that this memory could be much slower than standard RAM.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-emulex-persyst-4mb-isa.jpg" />
&lt;figcaption>An Emulex Persyst ISA card providing 4 MB of additional memory. It's notable how huge this was. Photo taken from the Wikipedia; &lt;a href="https://en.wikipedia.org/wiki/File:EmulexPersyst_4M_ISA.jpeg">see original&lt;/a>.&lt;/figcaption>
&lt;/figure>
&lt;p>As you can imagine, this trick offered the theoretical ability to access &lt;em>any&lt;/em> amount of extra RAM on a machine&amp;hellip; at the expense of having to structure your application so that it explicitly (re)configured the window. Implementing such applications is difficult and is also insufficient when applications need a larger address space to function comfortably. EMS was a useful kludge, but still a kludge.&lt;/p>
&lt;h1 id="the-80286-and-protected-mode">The 80286 and protected mode&lt;/h1>
&lt;p>As the needs of programs and operating systems grew, processors themselves needed to grow more advanced features as well. In particular, they needed to gain the ability to access much more than just 1 MB of memory, and they needed to offer memory protection features to isolate programs from each other.&lt;/p>
&lt;p>The 80286, still a 16-bit CPU, grew the address space to 24 bits to support up to 16 MB of RAM. It introduced a MMU to offer memory isolation. But there was a problem here: the 8086 memory addressing mode of 16-bit &lt;code>segment:offset&lt;/code> pairs did not permit addressing memory beyond the first 1 MB. Thus the 80286 had to find a different way to reference the RAM beyond 1 MB, also known as &lt;em>extended memory&lt;/em>, and it did so by introducing a completely different operation mode known as &lt;em>protected mode&lt;/em>.&lt;/p>
&lt;p>Once in protected mode, all memory access rules change. For one, the MMU takes charge of all memory accesses, ensuring that they are valid according to predefined protections. For another, the &lt;code>segment:offset&lt;/code> addresses change their semantics. The segment portion of an address stops being a scaled down memory address, and instead becomes an &lt;em>index&lt;/em> &lt;a href="https://wiki.osdev.org/Global_Descriptor_Table">into a table&lt;/a> (the GDT or LDT) of segment descriptors. Each segment descriptor describes the base address of a segment as a 32-bit quantity, the size of the segment as a 20-bit quantity, the access protections of the segment, and a bunch of flags.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-mmu-access.png" />
&lt;figcaption>Diagram representing the operations that the 80286 does, in hardware, to resolve a &lt;tt>segment:address&lt;/tt> memory reference.&lt;/figcaption>
&lt;/figure>
&lt;p>Under this model, instead of having an address like &lt;code>81DA:72C3&lt;/code>, we might see &lt;code>13:72C3&lt;/code>. To access this address, the MMU looks up entry 13 in the GDT, finds a descriptor that says that the segment starts at address &lt;code>0x81DA&lt;/code> and that it is &lt;code>0x7200&lt;/code> bytes long, and concludes that the &lt;code>13:72C3&lt;/code> reference is out of bounds, raising a &lt;a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault&lt;/a> hardware exception (your dreaded &lt;a href="https://en.wikipedia.org/wiki/Segmentation_fault">&amp;ldquo;Segmentation fault&amp;rdquo;&lt;/a> error these days).&lt;/p>
&lt;p>But this access model is really different from what DOS applications were used to in real mode, and DOS itself was only designed to run in real mode. So DOS and all of its ecosystem were stuck in the real mode world, limited to addressing just 1 MB of memory without the ability to access extended memory&amp;hellip; or were they?&lt;/p>
&lt;h1 id="the-high-memory-area-hma">The High Memory Area (HMA)&lt;/h1>
&lt;p>Avid readers might have noticed in a previous picture that, in real mode, there are a few segments that could, in theory, allow access to addresses above the 1 MB mark. Take &lt;code>FFFF:0010&lt;/code>, which is &lt;code>0xFFFF * 0x10 + 0x10 = 0x100000 = 2^20&lt;/code> or 1 followed by 20 zeroes in binary form. This is the first address into extended memory. The 8086 was able to produce such addresses, but they would wrap around because the 8086 had no way to issue the 21st bit to the memory bus.&lt;/p>
&lt;p>For compatibility reasons, the 80286 had to truncate these addresses in real mode, and it did so by wiring the 21st line of the address bus (the A20) to zero. But what if the addresses &lt;em>didn&amp;rsquo;t&lt;/em> wrap around? What if we told the 80286 to &lt;em>not&lt;/em> truncate them? This can, in fact, be done by enabling the &lt;a href="https://en.wikipedia.org/wiki/A20_line#A20_gate">A20 gate&lt;/a>&amp;mdash;a task achieved via the keyboard controller, mind you. Enabling the A20 is a prerequisite for entering protected mode, but if done in real mode, it becomes possible to access an extra 64 KB of memory. This extra memory is known as the &lt;a href="https://en.wikipedia.org/wiki/High_memory_area">High Memory Area (HMA)&lt;/a>.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-hma.png" />
&lt;figcaption>Representation of the way segmentation slices the 80286 real mode 1 MB address space into 64KB overlapping segments offset by 16 bytes from each other, and how the last few segments can be made to spill into extended memory.&lt;/figcaption>
&lt;/figure>
&lt;p>The HMA isn&amp;rsquo;t big by any means, but conventional memory was so limited that any tricks to gain extra memory were welcome and DOS did precisely that. By loading the &lt;code>HIMEM.SYS&lt;/code> driver and by specifying &lt;code>DOS=HIGH&lt;/code> in the &lt;code>CONFIG.SYS&lt;/code> file, DOS would relocate parts of itself into the HMA to free up to 64 KB of conventional memory.&lt;/p>
&lt;p>Unfortunately, 64 KB of extra memory really aren&amp;rsquo;t that much. This is a nice trick, but applications really needed access to more memory.&lt;/p>
&lt;h1 id="extended-memory-specification-xms">eXtended Memory Specification (XMS)&lt;/h1>
&lt;p>Another technique to access extended memory (the memory visible beyond the first 1 MB) came in the form of the &lt;a href="https://en.wikipedia.org/wiki/Extended_memory#Extended_Memory_Specification_(XMS)">eXtended Memory Specification (XMS)&lt;/a>.&lt;/p>
&lt;p>The idea of XMS is to provide an API that real mode applications can use to allocate chunks of extended memory and to copy data from/to those chunks via explicit calls. This is different from EMS because we aren&amp;rsquo;t talking about a fixed window of the address space referencing some external memory: we are talking about an API that is able to allocate arbitrary chunks of memory and return references to them, much like &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> do. Applications then use extra APIs to copy memory from/to those extended memory chunks into conventional memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80386-xms.png" />
&lt;figcaption>Representation of the 80286 memory map with a block of extended memory copied into conventional memory by means of XMS.&lt;/figcaption>
&lt;/figure>
&lt;p>To implement the &lt;a href="http://www.phatcode.net/res/219/files/xms30.txt">XMS API&lt;/a>, a driver such as &lt;code>HIMEM.SYS&lt;/code> uses protected mode to manipulate the extended memory blocks, but the real mode applications never have to. Because XMS requires protected mode, this feature is only available in the 80286 and above processors, whereas EMS could be used by the 8086 with the right hardware assistance.&lt;/p>
&lt;p>Much like EMS, XMS provided the theoretical ability to access an unlimited amount of extended memory from real mode at the expense of having to manually transfer small pieces of it into the limited 1 MB address space. This is not a trivial difficulty and is why even modern architectures like the &lt;a href="https://en.wikipedia.org/wiki/Cell_(processor)">Cell processor&lt;/a> and its &lt;a href="https://en.wikipedia.org/wiki/Cell_(processor)#Synergistic_Processing_Elements_(SPE)">SPEs&lt;/a> with a separate and limited address space didn&amp;rsquo;t succeed.&lt;/p>
&lt;p>So far so good, but&amp;hellip; we can still squeeze some extra memory out of the real mode segmented address space. In particular, we still have some gaps in upper memory that we haven&amp;rsquo;t put to use.&lt;/p>
&lt;h1 id="the-80386-and-vm86-mode">The 80386 and VM86 mode&lt;/h1>
&lt;p>To make further improvements possible, we need the additional processor features that came with the 80386. Compared to the 80286, the 80386 was a 32-bit processor capable of addressing up to 4 GB of RAM. More interesting for our discussion, however, were the addition of pagination&amp;mdash;which is the foundation of any modern operating system&amp;mdash;and a new execution mode known as &lt;a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">&lt;em>Virtual 8086&lt;/em>&lt;/a> or VM86 for short.&lt;/p>
&lt;p>VM86 was originally envisioned to fix a major deficiency in the 80286: that is, the ability to run &lt;em>multiple&lt;/em> concurrent real mode applications from within a protected mode operating system because that&amp;rsquo;s what Windows and OS/2 wanted to provide. In today&amp;rsquo;s terms, VM86 acts as virtual machine hypervisor, providing the processor with a mechanism to enter a mode that behaves like real mode but that is backed by the protected mode MMU. All memory accesses are subject to translation via pagination and all privileged operations trap into protected mode, meaning that a hypervisor process can place VM86 tasks anywhere in the 4 GB memory address space and can context-switch between them.&lt;/p>
&lt;p>But what if our hypervisor only spawned a single VM86 task to run DOS in? What if, then, the hypervisor leveraged the MMU to relocate portions of the real mode address space into portions of extended memory? That way, we could emulate EMS without dedicated hardware, providing applications a trivial way to peek into extended memory via 64 KB windows, or we could play other tricks&amp;hellip; like UMBs.&lt;/p>
&lt;h1 id="upper-memory-blocks-umbs">Upper Memory Blocks (UMBs)&lt;/h1>
&lt;p>Remember the sparse upper memory area? Those 384 KB of memory wired to hardware devices but with gaps in them? What if we could take those gaps in upper memory and map them to some extended memory so that they were directly addressable from real mode? This is precisely what &lt;a href="https://en.wikipedia.org/wiki/Upper_memory_area">Upper Memory Blocks (UMBs)&lt;/a> are: portions of the upper memory area remapped to extended memory by means of VM86, transparently offering access to more memory from real mode.&lt;/p>
&lt;p>As an example, think about the video memory mappings in the original PC specification. The memory map reserved two chunks of the address space for video: one for monochrome displays and one for color displays. But only one of them can be in use at any given time. So whichever video mode is selected leaves the address space of the other mode unused, and thus such address space can be leveraged by the system as an UMB into which to load drivers or place user data.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80386-umb.png" />
&lt;figcaption>Representation of the 80386 VM86 memory map with two UMBs in upper memory mapped to extended memory by means of the MMU and its pagination features.&lt;/figcaption>
&lt;/figure>
&lt;p>In DOS, the &lt;code>EMM386.EXE&lt;/code> driver is in charge of providing UMBs. In principle, the chipset could also implement them in older processors, but the 80386 made this all possible in software by entering VM86 and then leveraging pagination to map pages of extended memory in the upper memory area.&lt;/p>
&lt;p>When UMBs are available, DOS offered ways to move load drivers and &lt;a href="https://en.wikipedia.org/wiki/Terminate-and-stay-resident_program">TSR programs&lt;/a> into UMBs by specifying &lt;code>DOS=UMB&lt;/code> in the &lt;code>CONFIG.SYS&lt;/code> file and then using the &lt;code>DEVICEHIGH&lt;/code> and &lt;code>LOADHIGH&lt;/code> commands.&lt;/p>
&lt;h1 id="putting-it-all-together">Putting it all together&lt;/h1>
&lt;p>In summary, we have seen four different techniques that evolved over time to squeeze the most memory out of the incredibly limited 1 MB address space of the 8086. These limitations haunted the PC ecosystem until Windows took over and it can be argued that Windows &amp;ldquo;won&amp;rdquo; because it made it much easier to take advantage of the larger address space of the 80386. Until that happened, however, users had to live with the EMS, XMS, HMA, and UMB mess.&lt;/p>
&lt;p>And a mess it was, and it was so pervasive that it leaked to users. Let&amp;rsquo;s take a look at the output of the &lt;code>MEM&lt;/code> command, which was a very common utility to run when trying to maximize free conventional memory. In one of its simplest forms, &lt;code>MEM /C&lt;/code>, the command shows a summary of the memory usage per program and whether they are loaded in conventional or upper memory:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-c-1.png" />
&lt;figcaption>First page of the output of the &lt;tt>MEM /C /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;code>MEM /D&lt;/code>, which I did not know about back in the day, is more interesting. I have to show you its output as three separate images due to console size limitations:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-1.png" />
&lt;figcaption>First page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-2.png" />
&lt;figcaption>Second page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-3.png" />
&lt;figcaption>Third page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;code>MEM /D&lt;/code> shows us the memory map of the machine along with details about the location of each program. We can also see mentions of the conventional vs. upper address space, whether the HMA is in use, and consumption of XMS memory.&lt;/p>
&lt;p>But in all of these outputs, we see that upper memory is not in use &lt;em>at all&lt;/em>. Why is that? Well, because MS-DOS out of the box doesn&amp;rsquo;t attempt to load drivers into it. For that, we have to manually modify &lt;code>CONFIG.SYS&lt;/code> and &lt;code>AUTOEXEC.BAT&lt;/code> with special commands and reorder entries to maximize the usage of the upper memory and the HMA. A black art.&lt;/p>
&lt;p>Which brings me to MemMaker, a tool that debuted with MS-DOS 6. This tool attempted to automatically reconfigure all drivers and TSRs loaded during boot so that the largest/majority of them fit in upper memory, leaving as much conventional memory free for application usage.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-intro.png" />
&lt;figcaption>Welcome page to the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>As automated as it was, however, I&amp;rsquo;d say that MemMaker was an experts-only tool. Take a look at its advanced configuration options page, which I had to fiddle with to make the tool work in a KVM virtual machine running MS-DOS 6.22. You really need to understand the intricate details of real mode memory management to know what each of these options is about.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-options.png" />
&lt;figcaption>Advanced options in the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>But if you made MemMaker run successfully, it would then greet you with a pretty cool page after a reboot. This page showed a breakdown of the changes made by MemMaker and how it was able to reclaim conventional memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-results.png" />
&lt;figcaption>Final report of the changes made by the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>After that, we can look at the changes that MemMaker applied to the &lt;code>CONFIG.SYS&lt;/code> and &lt;code>AUTOEXEC.BAT&lt;/code> files. I never truly understood what all of these magic numbers meant, but now that I went through the hassle of researching and writing this article, I finally do. Just 30 years after I regularly used MemMaker to be able to play games in my multimedia 80386.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-changes.png" />
&lt;figcaption>Content of the &lt;tt>CONFIG.SYS&lt;/tt> and &lt;tt>AUTOEXEC.BAT&lt;/tt> files after MemMaker is done making changes.&lt;/figcaption>
&lt;/figure>
&lt;p>You can much read more in Microsoft&amp;rsquo;s own now-archived &lt;a href="https://jeffpar.github.io/kbarchive/kb/095/Q95555/">KB-Q9555 article&lt;/a> or the &lt;a href="https://archive.org/details/DOS_Beyond_640K_2nd_edition">DOS Beyond 640KB book&lt;/a>.&lt;/p>
&lt;p>And that&amp;rsquo;s it for today folks. I intentionally did &lt;em>not&lt;/em> touch on DPMI&amp;mdash;the technology that truly allowed DOS applications to break free from the 1 MB memory limitation&amp;mdash;because I&amp;rsquo;m saving that for the next article. So, make sure to come back for more!&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-01-17-8086-dos.jpg" length="220943" type="image/jpeg"/></item><item><title>Links: December 2023 edition</title><link>https://jmmv.dev/2023/12/links-december-2023-edition.html</link><pubDate>Sun, 31 Dec 2023 09:40:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/links-december-2023-edition.html</guid><description>&lt;p>December draws to a close as does 2023, which means it&amp;rsquo;s time for yet another monthly links recap.&lt;/p>
&lt;p>For context to everyone new around here, what follows is my manual curation of cool articles, videos, and projects I stumbled upon during this time period. But this is not &lt;em>just&lt;/em> a dump of links: &lt;em>each link is accompanied by a short commentary&lt;/em> that justifies why I thought the material was interesting, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading it.&lt;/p>
&lt;p>December has been a slow month though. During the first half, only a handful of articles caught my attention; and during the second half, I&amp;rsquo;ve been traveling so I haven&amp;rsquo;t paid much attention to news sites. In any case, there is some good content to enjoy this month. Read on and have a good entry to 2024!&lt;/p>
&lt;p>Happy new year!&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://dudemanguy.github.io/blog/posts/2022-06-10-wayland-xorg/wayland-xorg.html">&amp;ldquo;Wayland Isn&amp;rsquo;t Going to Save The Linux Desktop&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By dudemanguy on June 10, 2022&lt;/em>&lt;/p>
&lt;p>Do you know how Wayland works, how it differs from X.org, and how it has some architectural limitations that prevent it from solving some problems that X11 does not have? If not, this one is for you. This article is from 2022 but recently surfaced as a timely rant because Fedora is planning to drop X.org in the upcoming Fedora 40 release.&lt;/p>
&lt;p>Things will be&amp;hellip; &amp;ldquo;fun&amp;rdquo; for some of us soon. In my case, I use Fedora 39 and Wayland recently decided to stop working on my Mac Pro 2013 and fell back to X.org. And on my Surface Go 2, on which I need to use &amp;ldquo;bounce keys&amp;rdquo; to prevent repeated input due to some issues with the keyboard, the feature only works with X.org and not Wayland.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/strings-encodings-nuls-and-bazel.html">&amp;ldquo;Strings, encodings, NULs and Bazel&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 3rd, 2023&lt;/em>&lt;/p>
&lt;p>I came across a random tweet that suggested newcomers to C to represent strings as an array plus a length, without the traditional NUL terminator. The slightly-inflammatory tweet prompted me to write about why doing this is a bad idea and showed an example of the inefficiencies that arise from choosing to go your own way.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://virtuallyfun.com/2023/12/08/bsd-on-windows-things-i-wish-i-knew-existed/">&amp;ldquo;BSD on Windows: Things I wish I knew existed&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By neozeed on December 8th, 2023&lt;/em>&lt;/p>
&lt;p>Here is a thing from 1995 that I didn&amp;rsquo;t know existed: a BSD Unix distribution that ran on Windows 3.x. I wonder why this didn&amp;rsquo;t catch on but the likes of Cygwin did. By the way, this post made me remember &lt;strong>&lt;a href="https://www.delorie.com/djgpp/">DJGPP&lt;/a>&lt;/strong>, a distribution of GCC for DOS, and it&amp;rsquo;s something I&amp;rsquo;m considering to analyze and write about in an upcoming article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/a-cli-text-editor-in-my-windows.html">&amp;ldquo;A CLI text editor? In my Windows?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 8th, 2023&lt;/em>&lt;/p>
&lt;p>The Windows Terminal team at Microsoft is considering the addition of a command-line text editor by default in Windows. The thing is: Windows used to ship with one (&lt;code>EDIT.COM&lt;/code>) until they dropped the editor when moving to 64-bit editions&amp;hellip; and I&amp;rsquo;m kinda proposing that they bring something like the old editor back.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://github.com/TobyLobster/multiply_test">&amp;ldquo;6502 Integer Multiplication - which is best?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Toby Nelson&lt;/em>&lt;/p>
&lt;p>Discovered via a &lt;a href="https://news.ycombinator.com/item?id=38598940">discussion in HN&lt;/a>, this is a project that collects more than 120 multiplication algorithms and analyzes their behavior in detail on the 6502 8-bit processor. I barely knew this processor existed before seeing this article so I don&amp;rsquo;t particularly care for it, but the analysis is just mesmerizing and worth a read.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://www.whizzy.org/2023-12-14-bricked-xmas/">&amp;ldquo;Bricked Xmas&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Will Cooke on December 14th, 2023&lt;/em>&lt;/p>
&lt;p>An article on how to reverse-engineer Christmas LED lights that use Bluetooth to control the flashing patterns and how this process resulted in the bricking of said lights. The most interesting content in the article is the very foundations of reverse engineering a binary protocol when all you can do is see packets flow through the wire.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/hard-disk-leds-and-noisy-machines.html">&amp;ldquo;Hard disk LEDs and noisy machines&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 15th, 2023&lt;/em>&lt;/p>
&lt;p>While looking at yet another unexplained performance inefficiency that I observed, I wondered how many of these slip through because the machines we have today are &amp;ldquo;so powerful and quiet&amp;rdquo; that they absorb such abuse of resources without making a big fuss. I wrote a Twitter thread that explains how useful it was to have flashing LEDs for disk activity and loud fans during heavy CPU load, with a suggestion on what to do these days instead on your silent laptops.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://belkadan.com/blog/2022/10/Swift-in-the-OS/">&amp;ldquo;Swift was always going to be part of the OS&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Jordan Rose on October 9th, 2022&lt;/em>&lt;/p>
&lt;p>Using a language as part of an OS poses challenges on how the language and the OS can evolve, if at all, while preserving backwards compatibility. This article explains such difficulties in the context of Swift and justifies the choices that Apple made to allow using Swift for its own frameworks. The same challenges are not unique as they also apply to e.g. .NET in Windows, which Microsoft chose to solve in different ways.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://tim.siosm.fr/blog/2023/12/19/ssh-over-unix-socket/">&amp;ldquo;sudo without a setuid binary or SSH over a UNIX socket&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Timothée Ravier on December 19th, 2023&lt;/em>&lt;/p>
&lt;p>Have you ever considered using SSH as a replacement for &lt;code>sudo&lt;/code> by leveraging a Unix socket and file permissions to protect access? I hadn&amp;rsquo;t, but after reading the title, this interesting solution sounded obvious. There is a lot of nuance though, so make sure to read on.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/bazel-interview-at-software-engineering.html">&amp;ldquo;Bazel interview at Software Engineering Daily&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 21st, 2023&lt;/em>&lt;/p>
&lt;p>Two months ago, Jordi Mon Companys interviewed me about various Bazel topics and the podcast episode finally came out this month. I wrote a detailed summary of the 45-minute recording so that you can know what to expect and where exactly to fast-forward to if you want to skip certain topics.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://arne.me/articles/emacs-from-scratch-part-one-foundations">&amp;ldquo;Emacs From Scratch, Part 1: Foundations&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Arne Bahlo on December 22nd, 2023&lt;/em>&lt;/p>
&lt;p>Doom Emacs is my go-to editor. This Emacs &amp;ldquo;distribution&amp;rdquo; is great because its configuration files are trivial to read and edit, but I still feel a bit uncomfortable due to the many abstractions in between those files and the &amp;ldquo;real Emacs&amp;rdquo;&amp;mdash;particularly when Doom Emacs greets me with &amp;ldquo;loaded 200 packages&amp;rdquo; that I know little about. In that regard, this article series seems promising and I might go back to configuring a minimal setup at some point. (The second part is already out at the time of this writing, by the way.)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://retrofun.pl/2023/12/18/was-basic-that-horrible-or-better/">&amp;ldquo;Was BASIC that horrible or&amp;hellip; better?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Ikari on December 18th, 2023&lt;/em>&lt;/p>
&lt;p>BASIC has received a lot of hatred throughout the years, with Dijkstra claiming &amp;ldquo;It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.&amp;rdquo; Which, OK, fine. I can see that happening if you look at the original Dartmouth BASIC from the 1970s&amp;hellip; but later editions of BASIC included proper flow control to make these criticisms unfounded. Much more on this topic in the referenced article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">&amp;ldquo;The IDEs we had 30 years ago&amp;hellip; and we lost&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 25th, 2023&lt;/em>&lt;/p>
&lt;p>My Christmas gift to you all: a tour of the text-based IDEs we had about 30 years ago in DOS land to show how powerful and tiny they were at the time. The article contrasts them with the huge beasts we have nowadays and how they aren&amp;rsquo;t really that novel. And I write this as a &amp;ldquo;Unix convert&amp;rdquo; for many years.&lt;/p>
&lt;p>This is one of my most popular articles and further proves that my experiment with the move to Substack is worthwhile to gain an audience. Previous similarly-successful articles in my blog only brought in a handful of new subscribers, but this one has already raked tens in.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://github.com/minimaxir/hacker-news-undocumented/blob/master/README.md">&amp;ldquo;A List of Hacker News&amp;rsquo;s Undocumented Features and Behaviors&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Max Woolf&lt;/em>&lt;/p>
&lt;p>If you are an avid Hacker News user like I am, this living guide is a must read. You&amp;rsquo;ll learn many of the ways in which content moderation works, a bunch of hidden endpoints, and the kinds of features that karma points enable.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory">&amp;ldquo;How x86_64 addresses memory&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By William Woodruff on June 13th, 2020&lt;/em>&lt;/p>
&lt;p>&lt;code>mov&lt;/code> is &lt;em>the&lt;/em> x86 instruction, and this article does a good job at looking at all possible memory addressing modes. The reason this is interesting is because the article also looks at &lt;em>why&lt;/em> each addressing mode is useful by mapping it to a C construct that benefits from it.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>The IDEs we had 30 years ago... and we lost</title><link>https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html</link><pubDate>Mon, 25 Dec 2023 10:40:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html</guid><description>&lt;p>I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we had. Having gained more knowledge throughout the years, it is now really fun to pick up DOSBox to re-experience those programs and compare them with our current state of affairs.&lt;/p>
&lt;p>This time around, I want to look at the pure text-based IDEs that we had in that era before Windows eclipsed the PC industry. I want to do this because those IDEs had little to envy from the IDEs of today&amp;mdash;yet it feels as if we went through a dark era where we lost most of those features for years and they are only resurfacing now.&lt;/p>
&lt;p>If anything, stay for a nostalgic ride back in time and a little rant on &amp;ldquo;bloat&amp;rdquo;. But, more importantly, read on to gain perspective on what existed before so that you can evaluate future feature launches more critically.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="first-editors-and-tuis">First editors and TUIs&lt;/h1>
&lt;p>In the 1990s, almost every DOS program you ran had a full-screen Text User Interface (TUI) which sported text-based windows, drop shadows, colors, and mouse support. Here is just one example:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-edit-com-colors.png" class="with-border">
&lt;figcaption>The MS-DOS Editor (aka &lt;tt>EDIT.COM&lt;/tt>) with one of its settings dialog open. Note the menu bar, the rich dialog with list selectors and buttons, and the status bar documenting navigation shortcuts.&lt;/figcaption>
&lt;/figure>
&lt;p>Each program was its own island because its interface was unique to the program. However, they were all so similar in how they looked like&amp;mdash;80x25 characters didn&amp;rsquo;t leave much room for uniqueness&amp;mdash;and how they worked that the differences didn&amp;rsquo;t really get in the way of usability and discoverability. Once you learned that the Alt key opened the menus and that Tab moved across input fields and buttons, you could navigate almost any program with ease.&lt;/p>
&lt;p>But let&amp;rsquo;s talk about editors. MS-DOS shipped with a TUI text editor since version 5 (1991), which &lt;a href="/2023/12/a-cli-text-editor-in-my-windows.html">I previously covered in a recent article&lt;/a> and is shown above. This editor &amp;ldquo;worked&amp;rdquo;, but it was really inconvenient for coding: you needed to exit the editor to compile and run your code, and when you re-ran the editor, you&amp;rsquo;d have to navigate back to where you were before.&lt;/p>
&lt;p>&amp;ldquo;In my house&amp;rdquo;, we used something called &lt;a href="https://en.wikipedia.org/wiki/Borland_Sidekick">SideKick Plus&lt;/a> (1984), which wasn&amp;rsquo;t really a code editor: it was more of a Personal Information Management (PIM) system with a built-in notepad. The cool thing about it, however, was that it was a Terminate and Stay Resident (TSR) program, which meant that it loaded in the background and you could bring it up at any time by pressing Ctrl+Alt.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-sidekick-plus.png" class="with-border">
&lt;figcaption>SideKick Plus' main screen after pressing Ctrl+Alt to bring it up. Note how DOS remains in the background.&lt;/figcaption>
&lt;/figure>
&lt;p>Think of this TSR feature as rudimentary multitasking for an OS that did &lt;em>not&lt;/em> have multitasking. This was really effective because quickly switching between code editing and building is critical for an efficient inner development loop. (And by the way, this past experience explains the design of the &lt;a href="https://www.endbasic.dev/docs.html#intro-first">code editing flow in EndBASIC&lt;/a>. I did not implement the equivalent of Ctrl+Alt, but I&amp;rsquo;ve considered it many times.)&lt;/p>
&lt;p>By this point, however, real IDEs had already existed for a few years. Turbo Pascal 1.0 (1983) shows the beginning of an integrated experience, although it did not feature its iconic TUI yet. QuickBASIC 2.0 (1986) shows more of a &amp;ldquo;traditional&amp;rdquo; TUI (the same as &lt;code>EDIT.COM&lt;/code>, because they are the same editor), and MS-DOS 5 came with QBasic, a reduced version of QuickBASIC that didn&amp;rsquo;t allow compiling to native code but that had the same look.&lt;/p>
&lt;h1 id="the-borland-turbo-series">The Borland Turbo series&lt;/h1>
&lt;p>The crown jewel of IDEs, in my opinion, were the later Borland Turbo series, which included Turbo C++ (1990), Turbo Assembler and Turbo Pascal. These IDEs were language specific, but they had full-screen TUIs and were extremely powerful.&lt;/p>
&lt;p>Here, take a look at what we had. Syntax highlighting:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-syntax-highlighting.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing a "Hello World" program to demonstrate syntax highlighting.&lt;/figcaption>
&lt;/figure>
&lt;p>Compiler integration and diagnostics:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-warnings.png" class="with-border">
&lt;figcaption>Borland Turbo C++ after compiling a program, showing a warning because I did not return a value from &lt;tt>main()&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Integrated project and build system management:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-project.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing its project management and multi-window features. In the picture, you can see two C++ source files, with one depending on the other, and the project window listing all files that need to be compiled together.&lt;/figcaption>
&lt;/figure>
&lt;p>A debugger with breakpoints, stack traces, and the like:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-debugger.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing a debugging session with a program that contains multiple functions, a breakpoint, and the current call stack.&lt;/figcaption>
&lt;/figure>
&lt;p>And even a full reference manual:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-help.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing its integrated help system, with the "Hello World" program in the background and the help for &lt;tt>printf&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Remember: all of this in the early 1990s&amp;mdash;a little over 30 years ago at the time of this writing.&lt;/p>
&lt;p>I was an avid user of Turbo C++, with which I learned a lot. I remember using their &lt;code>conio.h&lt;/code> libraries to implement TUIs of my own, and then their builtin &lt;code>graphics.h&lt;/code> libraries to play with implementing GUIs. And note: this was &lt;em>without the Internet&lt;/em>. There was no option for many to just &amp;ldquo;look up how things worked&amp;rdquo; in Stack Overflow: the IDE had to be discoverable right away (which it was) and self-contained to offer you a complete development experience.&lt;/p>
&lt;h1 id="what-about-linux-back-then">What about Linux back then?&lt;/h1>
&lt;p>Now take a moment to compare this scene with Linux in the early 1990s.&lt;/p>
&lt;p>In Linux, almost every program was &lt;em>also&lt;/em> text based, but those programs did not come with a full-screen TUI. It just wasn&amp;rsquo;t &amp;ldquo;the Unix way&amp;rdquo;. I remember watching the X11 configuration tool (&lt;a href="https://www.xfree86.org/3.3.6/QuickStart3.html">&lt;code>XF86Setup&lt;/code>&lt;/a>) or the OpenBSD installer and feeling shocked by how simplistic those were: me, a young teenager with barely any &amp;ldquo;real&amp;rdquo; coding experience, had written better-looking programs already.&lt;/p>
&lt;p>In any case, this didn&amp;rsquo;t stop me from my quest to &lt;em>not&lt;/em> use Windows. I continued to learn the ways of Linux and soon faced the &amp;ldquo;best&amp;rdquo; editors recommended by every book and community online: Vim and Emacs. And I could not understand why they were praised. Using these was like stepping back into the past. They were full-screen programs indeed, but they seemed pretty arcane. Vim did have syntax highlighting but it was far from being an IDE. Emacs could be configured to integrate with some code assisting features and the like, but it was far from being &amp;ldquo;fire and forget&amp;rdquo; like the Turbo family of IDEs.&lt;/p>
&lt;p>Just look at the default Emacs configuration &lt;em>today&lt;/em>, which hasn&amp;rsquo;t changed much (if at all) since then. It does have windows, but they aren&amp;rsquo;t decorated. It didn&amp;rsquo;t have colors (and now barely has), because why? It didn&amp;rsquo;t use to have mouse support. It &lt;em>does&lt;/em> have a menu bar though, but it is just a gimmick? If you press &lt;tt>M-`&lt;/tt> as the instructions tell you, you face a truly strange interface to navigate the menu&amp;mdash;which makes one wonder why they even bothered to waste a full line of screen real state to show a menu bar that does nothing.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-emacs-menubar.png" class="with-border">
&lt;figcaption>A fresh installation of Emacs in the console, with the standard welcome screen in the background and the "menu" open after pressing &lt;tt>M-`&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Now try giving this to anyone with little coding experience and getting them to create, compile, and debug a program. They will have trouble just navigating the editor, and they won&amp;rsquo;t find any of the features that would allow for project management or compiler integration.&lt;/p>
&lt;p>For comparison, in writing this post, I fired up Turbo C++ in DOSBox and I was able to create a &amp;ldquo;hello world&amp;rdquo; project and navigate the environment in minutes&amp;mdash;all without prior knowledge (everything I had known has been forgotten by now). The environment is intuitive and, as an IDE, integrated all around.&lt;/p>
&lt;h1 id="contemporary-tui-ides">Contemporary TUI IDEs&lt;/h1>
&lt;p>Anyhow. Let&amp;rsquo;s forget about the past and look at what we have today in TUI-land. I don&amp;rsquo;t want to look at GUIs because&amp;hellip; well, Visual Basic was the pinnacle of graphics programming and we don&amp;rsquo;t have that either anymore&amp;mdash;which is also a topic for another day. (Well, OK, you have &lt;a href="https://gambas.sourceforge.net/">Gambas&lt;/a>&amp;hellip; but who knows about it?)&lt;/p>
&lt;p>The closest more-modern equivalent to the Borland Turbo C++ environment is &lt;a href="https://directory.fsf.org/wiki/RHIDE">RHIDE&lt;/a>. As you can see in the picture below, it looks incredibly similar&amp;mdash;and you&amp;rsquo;d be forgiven if you thought this &lt;em>is&lt;/em> Turbo C++. Unfortunately, it is DOS-only and seems to be mostly abandoned by now with its latest release dated 7 years ago.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-rhide.png" class="with-border">
&lt;figcaption>The RHIDE IDE showing the same "hello world" program as before, with no errors nor warnings after compilation.&lt;/figcaption>
&lt;/figure>
&lt;p>Then we have &lt;a href="https://www.freepascal.org/">Free Pascal&lt;/a>. This is the closest you&amp;rsquo;ll get to the old experience but with a modern codebase, running natively on Unix systems and leveraging terminals of any size.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-free-pascal.png" class="with-border">
&lt;figcaption>The Free Pascal IDE with a trivial "hello world" program and overlapping windows for a built-in ASCII table and a calculator.&lt;/figcaption>
&lt;/figure>
&lt;p>And lastly we have &lt;a href="https://qb64.com/">QB64&lt;/a>. This closely resembles Microsoft QuickBasic but&amp;hellip; don&amp;rsquo;t let it trick you: even though it looks like a TUI, it is actually a GUI application that simulates a TUI. You cannot run QB64 in a terminal.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-qb64.png" class="with-border">
&lt;figcaption>The QB64 IDE, which looks textual but is actually a graphical program.&lt;/figcaption>
&lt;/figure>
&lt;p>Both Free Pascal and QB64 are maintained and under relatively-active development, with their most recent releases in 2021&amp;hellip; but they are mostly ignored because they expose arcane languages that most people have no interest in these days.&lt;/p>
&lt;h1 id="real-contemporary-console-ides">&amp;ldquo;Real&amp;rdquo; contemporary console IDEs&lt;/h1>
&lt;p>So what are we left with for &lt;em>modern&lt;/em> languages today?&lt;/p>
&lt;p>The state of the art seems to be &lt;a href="https://neovim.io/">Neovim&lt;/a>, &lt;a href="https://github.com/doomemacs/doomemacs">Doom Emacs&lt;/a>, or even &lt;a href="https://helix-editor.com/">Helix&lt;/a>. These editors are very powerful and, thanks to various plugins, offer reasonable IDE-like experiences. That said, if you ask me, none of these provide the same kind of experience that the previous Borland products offered: their interfaces are obscure and, due to their multi-language nature, they work OK for almost everything but they aren&amp;rsquo;t great for anything. &amp;ldquo;Jack of all trades, master of none&amp;rdquo; if you will.&lt;/p>
&lt;p>In any case, the preferred &amp;ldquo;simple&amp;rdquo; TUI editor, based on what I observed in the deranged &lt;a href="https://github.com/microsoft/terminal/discussions/16440">microsoft/terminal#16440&lt;/a> discussion, seems to be&amp;hellip; &lt;a href="https://www.nano-editor.org/">GNU Nano&lt;/a>&amp;hellip; which OK, it works, but first: it&amp;rsquo;s no IDE, and second, to me this looks like WordStar. Yeah, I know it isn&amp;rsquo;t WordStar: if you want WordStar, the closest you&amp;rsquo;ll find is &lt;a href="https://joe-editor.sourceforge.io/">Joe&lt;/a>, but the &lt;em>looks&lt;/em> of Nano remind me of my first experiences with a word processor back in the CP/M days. Here, look:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-nano.png" class="with-border">
&lt;figcaption>The GNU Nano editor in its default setup, with an empty file open.&lt;/figcaption>
&lt;/figure>
&lt;p>So even though we &lt;em>do&lt;/em> have powerful console editors these days, they don&amp;rsquo;t quite offer the same usable experience we had 30 years ago. In fact, it feels like during these 30 years, we regressed in many ways, and only now are reaching feature parity with some of the features we used to have.&lt;/p>
&lt;p>It is natural that TUIs diminished in popularity once graphical OSes gained traction, and it is somewhat interesting that they are making a comeback just now. As for why, I think we have to thank the invention of &lt;a href="https://microsoft.github.io/language-server-protocol/">LSP&lt;/a> for most of the recent progress in this area. TUI editors were &amp;ldquo;on hold&amp;rdquo; for many years because building IDE features for them was a lot of effort and their small maintainer base could not afford to implement them. LSP unlocked access to existing language-specific integrations and reinfused interest in the old-and-trusty Vim and Emacs. Hopefully, the upcoming &lt;a href="https://build-server-protocol.github.io/">BSP&lt;/a> will do even more to make these TUIs more IDE-like.&lt;/p>
&lt;h1 id="why-tui-ides-anyway">Why TUI IDEs anyway?&lt;/h1>
&lt;p>It is fair to ask &amp;ldquo;Who cares? Every desktop and laptop runs a graphical OS now!&amp;rdquo;&lt;/p>
&lt;p>And it&amp;rsquo;s a good question. In general, you probably &lt;em>don&amp;rsquo;t&lt;/em> want a TUI IDE. If VSCode is your jam, its remoting abilities are superb and VSCode has a reasonably good graphical interface without being a full-blown IDE. But there are a few things that VSCode doesn&amp;rsquo;t give us.&lt;/p>
&lt;p>The first is that a TUI IDE is excellent for work on remote machines&amp;mdash;even better than VSCode. You can SSH into &lt;em>any&lt;/em> machine with ease and launch the IDE. &lt;a href="/2015/09/my-coding-workflow.html">Combine it with tmux and you get &amp;ldquo;full&amp;rdquo; multitasking.&lt;/a> Yes, you could instead use a remote desktop client instead of SSH, but I&amp;rsquo;ve always found them clunky due to lag and the improper integration with the local desktop shortcuts.&lt;/p>
&lt;p>The second is that &lt;a href="https://code.visualstudio.com/docs/remote/faq#_why-arent-the-remote-development-extensions-or-their-components-open-source">VSCode&amp;rsquo;s remote extensions are &lt;em>not&lt;/em> open source&lt;/a>, which isn&amp;rsquo;t a major problem&amp;hellip; except for the fact that they don&amp;rsquo;t work on, say, FreeBSD and there is no way to fix them. So this makes it impossible for me to remote into my primary development server with VSCode.&lt;/p>
&lt;p>And the third is&amp;hellip; reduced resource consumption.&lt;/p>
&lt;h1 id="bloat-everywhere">Bloat everywhere&lt;/h1>
&lt;p>I can&amp;rsquo;t leave without ranting about &amp;ldquo;bloat&amp;rdquo; for a little bit. Borland Turbo C++, with all its bells and whistles (the UI, the C++ toolchain, the integrated manuals&amp;hellip;), is less than 9 MB after installation and ran within 640kb of RAM.&lt;/p>
&lt;p>For comparison, Helix is 16 MB on disk, which is pretty impressive (and honestly unexpected), but Doom Emacs is about 500 MBs and consumes many MBs of RAM. Note, however, that none of these numbers account for the language toolchains or help systems, and toolchains nowadays rank in the GBs of disk space.&lt;/p>
&lt;p>To get &amp;ldquo;real&amp;rdquo; IDEs, we have to jump to graphical programs like IntelliJ or VSCode. VSCode, for example, is about 350 MBs on disk (surprisingly less than Doom Emacs) but it will eat your computer for lunch: it&amp;rsquo;s Electron after all. I have noticed very significant savings in laptop battery life by dropping VSCode and moving to Doom Emacs.&lt;/p>
&lt;p>So the question I want to part with is: have we advanced &lt;em>much&lt;/em> in 30 years? Modern IDEs have some better refactoring tools, better features, and support more languages, but fundamentally&amp;hellip; they haven&amp;rsquo;t changed much. The only major difference that we are &lt;em>starting&lt;/em> to see might be AI-assisted coding, but this is a feature mostly provided by a remote service, not even by the installed code!&lt;/p>
&lt;p>And that&amp;rsquo;s all for today. On my side, I&amp;rsquo;ll happily continue using &lt;em>all of&lt;/em> Doom Emacs, Vim, VSCode, and IntelliJ depending on the situation. Merry Christmas if this is your thing!&lt;/p></description></item><item><title>Bazel interview at Software Engineering Daily</title><link>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</link><pubDate>Thu, 21 Dec 2023 09:50:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</guid><description>&lt;p>Just a bit over 2 months ago, on October 5th, 2023, Jordi Mon Companys interviewed me about Bazel for an episode in the &lt;a href="https://softwareengineeringdaily.com/">Software Engineering Daily&lt;/a> podcast. The episode finally came out on December 18th, 2023, so here is your announcement to stop by and listen to it!&lt;/p>
&lt;figure>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
&lt;img src="/images/2023-12-21-bazel-interview-cover.jpg" class="with-border" />
&lt;/a>
&lt;figcaption>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
Cover image (and link) to the Bazel interview in Software Engineering Daily.
&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;p>If you don&amp;rsquo;t have time to listen to the whole 45 minutes, or if you want to get a sense of what you will get out of it, here is a recap of everything we touched on. Every paragraph is annotated with the rough time where the discussion starts so that you can jump right in to whatever interests you the most.&lt;/p>
&lt;h1 id="my-background">My background&lt;/h1>
&lt;p>&lt;strong>[01:10]&lt;/strong> Introduction about myself. Really brief overview about my roles and the companies I&amp;rsquo;ve been at throughout the years.&lt;/p>
&lt;p>&lt;strong>[01:58]&lt;/strong> A retrospective about how I got into computers and why I think things were much easier to dive into years ago. In other words, a plug for &lt;a href="https://www.endbasic.dev/">EndBASIC&lt;/a>.&lt;/p>
&lt;p>&lt;strong>[03:34]&lt;/strong> My history with open source projects and how I got into Linux, the BSDs, and why I ended up as a contributor to NetBSD.&lt;/p>
&lt;p>&lt;strong>[05:05]&lt;/strong> How my background helped me join Google as a Site Reliability Engineer (SRE), even if I did not have much experience in systems administration. SRE is a really cool position because of the many paths that lead into it!&lt;/p>
&lt;p>&lt;strong>[05:51]&lt;/strong> Why I moved years later to the Bazel team as a software engineer while remaining at Google.&lt;/p>
&lt;h1 id="introduction-to-bazel">Introduction to Bazel&lt;/h1>
&lt;p>&lt;strong>[06:57]&lt;/strong> Google and internal tools. Why Google invented &amp;ldquo;everything&amp;rdquo; in house, including Bazel and the distributed build services it relies on.&lt;/p>
&lt;p>&lt;strong>[08:35]&lt;/strong> Brief introduction to what Bazel is: a polyglot build system.&lt;/p>
&lt;p>&lt;strong>[10:11]&lt;/strong> Thoughts on the distinction&amp;mdash;or rather, lack thereof&amp;mdash;between build systems and CI systems. While they have been traditionally thought of as separate, they are pretty intertwined and you need your CI system to be as aware of the build process as possible to be maximally efficient.&lt;/p>
&lt;p>&lt;strong>[10:56]&lt;/strong> Brief introduction to what the Starlark language is, why it exists, and how it is used to define Bazel rules. Includes a brief explanation of major Bazel concepts such as targets, rules, and actions.&lt;/p>
&lt;p>&lt;strong>[13:28]&lt;/strong> Thoughts on why Bazel is a good fit for a monorepo.&lt;/p>
&lt;h1 id="build-incrementality">Build incrementality&lt;/h1>
&lt;p>&lt;strong>[14:45]&lt;/strong> Description of how build incrementality works and how Bazel determines which parts of the build graph to rebuild. Covers how traditional file systems use timestamps, how Bazel tries to do something better, and how you can do even fancier stuff if you have the right support from the file system.&lt;/p>
&lt;p>&lt;strong>[17:36]&lt;/strong> Deeper dive into Skyframe: the component within Bazel that tracks the build graph and helps decide which parts need to be rebuilt every time.&lt;/p>
&lt;p>&lt;strong>[19:02]&lt;/strong> Separation of local machine vs. remote machine resources: what parts of the build happen where? Is the build graph &amp;ldquo;in the cloud&amp;rdquo; too?&lt;/p>
&lt;p>&lt;strong>[20:06]&lt;/strong> Notes on how Bazel decides how to behave (spolier alert: manual configuration) and a mini-rant about Bazel having too many flags.&lt;/p>
&lt;h1 id="dependency-management">Dependency management&lt;/h1>
&lt;p>&lt;strong>[21:12]&lt;/strong> Exploring dependency management for third-party packages, focusing on how Google had traditionally done this in their monorepo.&lt;/p>
&lt;p>&lt;strong>[22:16]&lt;/strong> Deeper dive into the history of dependency management by looking into how the workspace file came to be and why it has limitations.&lt;/p>
&lt;p>&lt;strong>[24:01]&lt;/strong> Extending Bazel, or rather the difference between the Java core vs. the Starlark ecosystem, and how the Build API bridges the gap between the two.&lt;/p>
&lt;p>&lt;strong>[25:34]&lt;/strong> Brief digression into the newly-released &lt;a href="https://buck2.build/">Buck2&lt;/a>.&lt;/p>
&lt;h1 id="bazel-migrations">Bazel migrations&lt;/h1>
&lt;p>&lt;strong>[26:23]&lt;/strong> Migrating to Bazel at a company like Snowflake. Exploration of where the difficulties arise.&lt;/p>
&lt;p>&lt;strong>[28:50]&lt;/strong> Discussion on how platform engineering is becoming its own thing, with the goal of building developer tools and experiences as company-internal products.&lt;/p>
&lt;p>&lt;strong>[30:44]&lt;/strong> Highlights of the primary (positive) benefits for the users after a Bazel migration: fast builds and &lt;a href="/2020/12/google-no-clean-builds.html">no more &amp;ldquo;make clean&amp;rdquo;&lt;/a>.&lt;/p>
&lt;h1 id="remote-execution">Remote execution&lt;/h1>
&lt;p>&lt;strong>[32:59]&lt;/strong> Integration of Bazel with remote services. Differences between remote caching and remote execution, and an exploration of different implementations of each.&lt;/p>
&lt;p>&lt;strong>[34:25]&lt;/strong> Brief discussion on generating SBOMs and how Bazel&amp;rsquo;s dependency tracking is perfectly aligned to provide these.&lt;/p>
&lt;p>&lt;strong>[35:26]&lt;/strong> Sandboxing. A discussion on the different levels of what you can restrict per platform and the trade-offs in complexity and performance. In other words: sandboxing is a spectrum.&lt;/p>
&lt;h1 id="forward-looking-plans">Forward-looking plans&lt;/h1>
&lt;p>&lt;strong>[37:15]&lt;/strong> Bazel&amp;rsquo;s future plans. Not my plans nor predictions, but rather what&amp;rsquo;s coming up in Bazel 7. (&lt;a href="https://blog.bazel.build/2023/12/11/bazel-7-release.html">Already released&lt;/a> at the time of this writing.)&lt;/p>
&lt;p>&lt;strong>[38:14]&lt;/strong> My wishlist for Bazel, which is basically &lt;a href="/2015/04/on-bazel-and-open-source.html">what I brought up back in 2015&lt;/a>: it&amp;rsquo;d be awesome if it was smaller so that it could be usable in the smaller projects that lie in the foundations of the Unix systems we use today.&lt;/p>
&lt;p>&lt;strong>[38:49]&lt;/strong> Thoughts on the upcoming BazelCon. (It was awesome. See &lt;a href="/2023/10/bazelcon-2023-et-al-trip-report.html">my attendance report&lt;/a>!)&lt;/p>
&lt;h1 id="source-control">Source control&lt;/h1>
&lt;p>&lt;strong>[39:30]&lt;/strong> Digression on source control, how Git is not great for monorepos, and how Google ended up building their own thing after using Perforce for many years. Also a brief explanation on how Bazel can leverage source control system integrations for better performance.&lt;/p>
&lt;p>&lt;strong>[42:28]&lt;/strong> And a related follow-up topic: test selection strategies in a massive monorepo, starting with how unit tests are easy to handle but doing something smart about integration tests requires heurisitics or maybe some sort of AI.&lt;/p>
&lt;p>And that&amp;rsquo;s about it. Hope you enjoy this episode!&lt;/p></description></item><item><title>Hard disk LEDs and noisy machines</title><link>https://jmmv.dev/2023/12/hard-disk-leds-and-noisy-machines.html</link><pubDate>Fri, 15 Dec 2023 09:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/12/hard-disk-leds-and-noisy-machines.html</guid><description>&lt;p>The computers of yesteryear had this little feature known as blinking LED lights 🔆. They also had this other feature called noisy disks 💾 and loud fans 🪭. Uh wait. Features? Why &amp;ldquo;features&amp;rdquo; and not &amp;ldquo;annoyances&amp;rdquo;?! 🧵👇&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-15-retro-pc-leds.jpg" class="with-border">
&lt;figcaption>Front panel of a common PC case in the late 1990s. My Pentium MMX 166 was hosted in one of these.&lt;/figcaption>
&lt;/figure>
&lt;p>You see, these bright lights and loud noises acted as canaries 🐦 in a performance mine. They gave developers a chance to notice when things were off performance-wise. If your code abused the CPU or the hard disk by mistake, you could tell right away.&lt;/p>
&lt;p>Nowadays, developer machines tend to be quiet under heavy load, and the vast majority of laptops don&amp;rsquo;t even have lights anymore. The obvious example are Macs: they haven&amp;rsquo;t had hard disk LEDs for a really long time, and since the M1, they are silent and cold too.&lt;/p>
&lt;p>These characteristics are nice from a usability perspective. Unfortunately, as a developer, you now need to first &lt;em>imagine&lt;/em> that something is wrong before even deciding to look for a problem. If the thought never crosses your mind, then you may never look.&lt;/p>
&lt;p>Let me give you a few examples of the kinds of inefficiencies that I&amp;rsquo;m talking about. These would have been trivially noticed by the presence of indicators. These are all based on real-world situations I faced at some point in the (recent) past.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>🪵 In a project I worked on, our development builds started writing about 80 MB of log messages &lt;em>per second&lt;/em> to disk. No matter how you look at it, that&amp;rsquo;s &lt;em>a lot&lt;/em> of disk traffic, and yet&amp;hellip; the problematic code passed code review and was merged into the main branch.&lt;/p>
&lt;p>The only indication that something was wrong was when &lt;em>other&lt;/em> developers came asking for help because their local disk space was running out faster than usual. There was no other symptom behind the problem.&lt;/p>
&lt;p>You&amp;rsquo;d hope that this inefficiency would be caught while qualifying the new release for production because, in theory, such logging waste would translate in an increase in CPU consumption or network bandwidth. But&amp;hellip; I&amp;rsquo;m not so sure the issue would have been noticed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>🌐 In another project I worked on, I noticed that Bazel took an incredibly long time to complete some actions. It wasn&amp;rsquo;t until I looked in detail that I saw it stuck in a loop fetching the same remote artifact over and over again due to connection resets.&lt;/p>
&lt;p>The build completed successfully after many minutes once Bazel gave up on the downloads and fell back local execution. There was no reason to suspect that something was wrong other than &amp;ldquo;these actions are just huge&amp;rdquo;. In reality, though, there was a bug somewhere.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>🧱 Just today, I was in a video call and noticed that my laptop was reading 100MB/s from disk non-stop. I concluded the meeting but the disk reads didn&amp;rsquo;t stop. A quick peek at &lt;code>top&lt;/code> showed something called &lt;code>WallpaperVideoExtension&lt;/code> that seemed to have gone rogue.&lt;/p>
&lt;p>This background process was consuming one full CPU, but such load wasn&amp;rsquo;t enough to make the system feel slower nor noisier. I suppose I would eventually have noticed that the battery was running out quicker than usual, but maybe not.&lt;/p>
&lt;p>Killing the process made the problem go away and the constant disk reads stopped. Looking online, I find other instances of &lt;code>WallpaperVideoExtension&lt;/code> consuming lots of CPU and memory, so this seems to be a bug. But if it&amp;rsquo;s common, why wasn&amp;rsquo;t it noticed in the first place?&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In any case, this last scenario gives you a hint 🔍 as to where I&amp;rsquo;m going: how did I even notice this last problem? After all, my M1 Mac was working just fine: it was just slightly warmer than usual but there was no loud fan noise nor lights to tell me about disk activity.&lt;/p>
&lt;p>The answer is simple: I have an omnipresent performance monitor in my screen that shows CPU load, memory pressure, disk I/O throughput, and network traffic. This monitor is always visible, taking little space in the menu bar or the task bar.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-15-istat-menus.png" class="with-border">
&lt;figcaption>iStat Menus on the macOS menu bar, with the panel for CPU usage tracking open.&lt;/figcaption>
&lt;/figure>
&lt;p>Every time I sense something is a tiny bit off, I glance 👀 at the monitor. You cannot imagine how many times I&amp;rsquo;ve gone &amp;ldquo;huh, that&amp;rsquo;s interesting&amp;rdquo; by seeing unexpected activity and then went on to discover big performance problems somewhere in the system.&lt;/p>
&lt;p>My recommendation is that you stop what you are doing and go and install such a performance monitor &lt;em>right now&lt;/em>. I&amp;rsquo;d even argue that having one always visible should be a hard requirement for any development machine and corp IT departments should preinstall one.&lt;/p>
&lt;p>Personally, I&amp;rsquo;m a huge fan of &lt;a href="https://bjango.com/mac/istatmenus/">iStat Menus&lt;/a> for macOS and have been using it for years. But if macOS is not your thing, you can find similar tools for other platforms like &lt;a href="https://extensions.gnome.org/extension/3010/system-monitor-next/">system-monitor-next&lt;/a> for Gnome.&lt;/p>
&lt;p>Unfortunately, these monitors only help if you develop on your local machine&amp;mdash;a workflow that&amp;rsquo;s becoming exceedingly rare. If, instead, you SSH into remote virtual machines to do your development or use VSCode&amp;rsquo;s remote features, you&amp;rsquo;ll need a different answer.&lt;/p>
&lt;p>This is a situation I face right now. The modern ThinkStation I have in the garage is well-equipped with useful lights&amp;hellip; but I only access it over SSH for development so those lights and its disk noises are kinda useless from where I sit.&lt;/p>
&lt;p>And I&amp;rsquo;m not sure what the right answer here is. If you have been around for a while, you may remember &lt;a href="http://gkrellm.srcbox.net">GKrellM&lt;/a>, which I was an avid user of. This system monitor had the ability to display &lt;em>remote&lt;/em> machine activity and I&amp;rsquo;d love to have that again.&lt;/p></description></item><item><title>A CLI text editor? In my Windows?</title><link>https://jmmv.dev/2023/12/a-cli-text-editor-in-my-windows.html</link><pubDate>Fri, 08 Dec 2023 14:45:00 -0800</pubDate><guid>https://jmmv.dev/2023/12/a-cli-text-editor-in-my-windows.html</guid><description>&lt;p>&lt;em>It&amp;rsquo;s more likely than you think!&lt;/em>&lt;/p>
&lt;p>In a surprising twist of events, Microsoft is &lt;a href="https://twitter.com/plante_msft/status/1732857615997132834">exploring the addition of a command-line (CLI) text editor to Windows&lt;/a>. If you ask me, &lt;em>not&lt;/em> having a CLI text editor on Windows is mind-boggling: you can access a Windows machine via SSH these days, so not having an editor that works in the console is a big handicap for remote system administration. So, should Windows bundle a CLI text editor? Of course it should.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-windows-95-edit-com.png" class="with-border">
&lt;figcaption>Windows 95 running an MS-DOS Prompt with the &lt;tt>EDIT.COM&lt;/tt> that shipped with it.&lt;/figcaption>
&lt;/figure>
&lt;p>But&amp;hellip; wait as second. Didn&amp;rsquo;t Windows use to ship with a CLI text editor? The one inherited from MS-DOS? Yes it did. So what happened? How was the editor lost? Let&amp;rsquo;s take a peek at the history and let&amp;rsquo;s see if you agree with me that Microsoft should revive the old editor instead of bundling modern-yet-alien Vim or Emacs.&lt;/p>
&lt;p>By the way, this post is brought to you by the inspiration provided by my first paid subscriber. Thank you very much, K., for taking this step and supporting my work.&lt;/p>
&lt;h1 id="in-the-beginning-there-was-edlin">In the beginning, there was Edlin&lt;/h1>
&lt;p>Early versions of DOS (1980) all the way through MS-DOS 5.0 (1990) included a &amp;ldquo;line editor&amp;rdquo; called &lt;a href="https://en.wikipedia.org/wiki/Edlin">Edlin&lt;/a> and nothing else. You may have never heard of or used a line editor, so let me show you how they look like and work. Here is a sample session with Edlin:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">C:\&amp;gt;EDLIN TEST.TXT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">New file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*I
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1:*second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3:*[Ctrl+Z followed by Enter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*L
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1: second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2: delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*1I
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1:*first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*[Ctrl+Z followed by Enter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*L
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1: first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3: delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*3D
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*W
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*E
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">C:\&amp;gt;TYPE TEST.TXT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">C:\&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see from the above, a line editor does not have a full-screen UI. Instead, the editor works by letting you issue textual commands that affect the contents of a file. You can insert new lines, delete existing ones, modify their content, and list what the file has in it&amp;mdash;much like how you enter programs in a line-oriented BASIC interpreter or how you interact with the files on your machine via the shell.&lt;/p>
&lt;p>Needless to say, and while line editors work and are truly amenable to scripting, they are not particularly intuitive nor user-friendly. I have to wonder why MS-DOS shipped with &lt;em>just&lt;/em> Edlin until 1990. After all, by the time Edlin was created in 1980, full-screen editors like &lt;code>vi(1)&lt;/code> had already existed for 4 years so it&amp;rsquo;s not like they were impossible to create. However, it&amp;rsquo;s plausible that the limitations of DOS and the machines that DOS ran on made it much more difficult to recreate an editor like &lt;code>vi(1)&lt;/code>, which was made for Unix systems that ran on more powerful hardware.&lt;/p>
&lt;p>As an aside: &lt;code>ed(1)&lt;/code> and &lt;code>ex(1)&lt;/code> are similar to Edlin and you have both &lt;em>today&lt;/em> on pretty much any Unix or Linux system you access. And the &lt;code>vi(1)&lt;/code> that you like is &amp;ldquo;just&amp;rdquo; a facade over &lt;code>ex(1)&lt;/code>. When you use the &lt;code>:&lt;/code> command to get to the &lt;code>vi(1)&lt;/code> prompt to type a command, what you are typing are &lt;code>ex(1)&lt;/code> commands. Keep that in mind if you ever face a situation where the terminal doesn&amp;rsquo;t work and all you can use are the line editors: previous &lt;code>vi(1)&lt;/code> knowledge could come in handy.&lt;/p>
&lt;h1 id="and-microsoft-said-let-there-be-editcom">And Microsoft said, &amp;ldquo;Let there be EDIT.COM&amp;rdquo;&lt;/h1>
&lt;p>In 1990, Microsoft launched MS-DOS 5.0 and, with it, a full-screen text editor called &lt;a href="https://en.wikipedia.org/wiki/MS-DOS_Editor">MS-DOS Editor&lt;/a>, or &lt;code>EDIT.COM&lt;/code> for short. This editor was built on QBasic and it featured a full-screen interactive UI. The latest version of the editor, which was included with Windows 9x (MS-DOS 7.x), looked like this:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-dosbox-edit-com.png" class="with-border">
&lt;figcaption>The original &lt;tt>EDIT.COM&lt;/tt> from Windows 9x running in DOSBox.&lt;/figcaption>
&lt;/figure>
&lt;p>This new version of the editor was obviously much more usable and welcoming than Edlin. As you can see from the picture, &lt;code>EDIT.COM&lt;/code> featured a full-screen windowed textual interface with support for multiple files (in its Windows 9x versions), drop down menus, and even mouse integration. These interfaces were extremely common back in the day in DOS: almost every program you ran launched a full-screen UI with textual windows and menus.&lt;/p>
&lt;p>Interestingly, interfaces like these were never a thing on Unix systems and I must confess I was shocked when I first moved from DOS to Linux. I was used to Borland Turbo C++ and WordPerfect 5.1, so when I faced &lt;code>vi(1)&lt;/code> on Linux for the first time, I couldn&amp;rsquo;t believe my eyes: what was this barren interface with its awkward commands? I eventually learned the &lt;code>vi(1)&lt;/code> and Emacs ways, but it&amp;rsquo;s a pity that those interfaces have been lost. They were really intuitive and powerful, and they would be wonderful to have in these days of cloud computing where we access remote computers over SSH all the time.&lt;/p>
&lt;h1 id="but-then-darkness-settled-in">But then&amp;hellip; darkness settled in&lt;/h1>
&lt;p>Unfortunately, both Edlin and &lt;code>EDIT.COM&lt;/code> were 16-bit DOS applications and they were never ported to 32-bit Windows. They were able to stay bundled with all 32-bit x86 Windows editions up to Windows 10 because Windows could run such ancient binaries via &lt;a href="https://en.wikipedia.org/wiki/Virtual_DOS_machine">NT&amp;rsquo;s Virtual DOS Machines&lt;/a>&amp;hellip; but the two editors were scraped in the x64 editions. Yes, this means that all 64-bit Windows editions have been devoid of a CLI text editor from the beginning.&lt;/p>
&lt;p>You could say that this is not a big deal because Windows still includes Notepad and Notepad is similar to &lt;code>EDIT.COM&lt;/code> in its feature set. And yes, they are similar&amp;hellip; but with a critical and obvious difference: Notepad cannot be used on a remote machine via SSH. For someone that has grown up routinely accessing other machines to do work on them via SSH, this sounded like a ridiculous move and further perpetuated the feeling that administering a Windows machine from the shell was a joke&amp;mdash;even with all effort that the PowerShell developers have put to make this possible.&lt;/p>
&lt;h1 id="and-in-the-end-there-may-be-light">And in the end, there may be light&lt;/h1>
&lt;p>But hey, it seems like Microsoft may be correcting course here thanks to, and this is the big surprise, the Windows Terminal team. In discussion &lt;a href="https://github.com/microsoft/terminal/discussions/16440">#16440&lt;/a>, the team is exploring (re)adding a CLI text editor to Windows. As the discussion says: &lt;em>&amp;ldquo;A CLI editor is a core tool for system admins, developers, and power users.&amp;rdquo;&lt;/em> Well, yes, no kidding. I&amp;rsquo;m just surprised it took this long to reach this conclusion.&lt;/p>
&lt;p>Now, what would &lt;em>you&lt;/em> pick as the default text editor for the Windows textual console?&lt;/p>
&lt;p>Personally, and while I&amp;rsquo;d quickly say &amp;ldquo;just bundle Vim&amp;rdquo; like many others have&amp;hellip; I acknowledge it would feel out of place. Vim, Emacs, or even Nano are &lt;em>not&lt;/em> Windows applications. Yes, they work on Windows, but they don&amp;rsquo;t embody the traditional way things have worked on this platform. I feel that integrating any of these editors into Windows would further perpetuate the impression that Windows is just trying to copy Linux without actually being Linux.&lt;/p>
&lt;p>So, if you ask me, I&amp;rsquo;d vote for the re-addition of &lt;code>EDIT.COM&lt;/code>. Obviously not a verbatim copy of what it was because it&amp;rsquo;d be nice to have one or two extra features added to it: I&amp;rsquo;d personally welcome making the editor respect indentation when inserting lines and maybe having some sort of syntax highlighting (without going all the way with LSP support). The key would be to preserve the simple, full-screen UI.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-yori-yedit.png" class="with-border">
&lt;figcaption>YEdit running in a Yori Windows Terminal session on Windows 11.&lt;/figcaption>
&lt;/figure>
&lt;p>And as it turns out, the foundations for this already exist in &lt;a href="http://www.malsmith.net/edit/">YEdit&lt;/a>, a modern free reimplementation of the old editor for Windows. It has even been brought up in the discussion, so it seems I&amp;rsquo;m not the only one thinking this way.&lt;/p>
&lt;p>In any case, I encourage you to leave your thoughts in the comments section below or, even better, join the official discussion at &lt;a href="https://github.com/microsoft/terminal/discussions/16440">microsoft/terminal#16440&lt;/a>.&lt;/p></description></item><item><title>Strings, encodings, NULs and Bazel</title><link>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</link><pubDate>Sun, 03 Dec 2023 10:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</guid><description>&lt;p>Just yesterday, &lt;a href="https://twitter.com/vkrajacic/status/1730891609191981305">Twitter user @vkrajacic wrote&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Advice for new C programmers: &amp;ldquo;Avoid null-terminated strings; they&amp;rsquo;re outdated, inefficient and impractical.&amp;rdquo;&lt;/p>
&lt;p>Create your own type with basic functions. It&amp;rsquo;s not that hard, and it goes a long way. One of the benefits of this approach, among others, is slicing without copying.&lt;/p>
&lt;/blockquote>
&lt;p>This suggestion has its merits and I understand where it is coming from: &lt;em>performance&lt;/em>. You see: the traditional way to represent strings in C is to use &lt;a href="https://en.wikipedia.org/wiki/Null_character">NUL-terminated byte arrays&lt;/a>. Yet&amp;hellip; this has deemed to be &lt;a href="https://queue.acm.org/detail.cfm?id=2010365">the most expensive one-byte mistake&lt;/a> because of the adverse performance implications that this carries. (NUL, &lt;em>not&lt;/em> NULL, is the better name for the &lt;code>\0&lt;/code> byte by the way.)&lt;/p>
&lt;p>It is of course possible to do differently. Pascal, for example, used a 1-byte prefix to indicate how long strings are. This representation takes the same space as a NUL terminator and fixes the performance problems, but it carries the downside of limiting strings to 255 bytes in length. And you can do as the original author said: amend your strings with a (larger) size field so you do not suffer from this limitation.&lt;/p>
&lt;p>So, yes, it &lt;em>is&lt;/em> possible to use strings without NUL terminators. Unfortunately, you are in for pain if you do so for one simple reason: interop. Your code does not run in a vacuum: it runs in the context of an existing operating system, and it probably uses one or more libraries. Almost all operating systems to date, if not all, expose a C API (libc and system calls), which means that they expect strings to be NUL-terminated. And the same is true for all interesting libraries out there.&lt;/p>
&lt;p>And for this reason, I want to tell you a little story about how I found this painful problem when I was working on Bazel a few years ago.&lt;/p>
&lt;hr>
&lt;p>Bazel is primarily a Java program. Bazel also has a bunch of C and C++ code integrated via JNI, which is used to reach certain system calls and libraries that are only available in C. For &lt;a href="https://www.oracle.com/technical-resources/articles/javase/supplementary.html">historical reasons&lt;/a>, Java uses UTF-16 to represent strings but&amp;hellip; most operating systems out there &lt;em>do not&lt;/em>. As a consequence, every JNI call has to start with a conversion from UTF-16 into whatever the operating system may accept, which typically is Latin-1 or UTF-8. This is a costly, unavoidable step.&lt;/p>
&lt;p>Fortunately, Java 9 introduced a new feature called &lt;a href="https://openjdk.org/jeps/254">&lt;em>compact strings&lt;/em>&lt;/a>. When this feature is enabled, the JVM represents strings as Latin-1 wherever possible: as long as the string&amp;rsquo;s characters can be represented with this encoding, UTF-16 doesn&amp;rsquo;t enter the picture. This is great because most strings that Bazel handles are file paths&amp;mdash;it handles &lt;em>a lot&lt;/em> of paths&amp;mdash;and these can typically be represented in Latin-1. With this feature, we could modify &lt;a href="https://cs.opensource.google/bazel/bazel/+/master:src/main/native/latin1_jni_path.cc;drc=26c7e10739907332e70d31e68d2bd2ff2e9a84fb">the JNI shims&lt;/a> to reuse the in-memory bytes &lt;em>as is&lt;/em>, without a costly conversion in the common case.&lt;/p>
&lt;p>But there is an unfortunate twist. The Latin-1 compact strings that the JVM creates are &lt;em>not&lt;/em> NUL-terminated. This means that, even if the string bytes that Java hands to C are exactly as we need them in memory to call some other API, they are not directly usable. As a result, the JNI code is forced to make a &lt;em>copy&lt;/em> of the string just so that it can pad it with a NUL terminator.&lt;/p>
&lt;p>Which is&amp;hellip; sad and wasteful. As I mentioned, Bazel handles a ton of paths. Most of the memory bloat in the Bazel server process comes from the need to track file paths and command line arguments, and when you have many of these strings amounting to GBs of RAM, you can imagine that processing and copying them is costly too. I think I did measure a not-insignificant runtime penalty from these unnecessary copies back in the day, but I forget the details now.&lt;/p>
&lt;p>So, be careful: it&amp;rsquo;s entirely reasonable to annotate string representations with their size, and you should do so where possible because of the performance gains that come with it. But when you do this, don&amp;rsquo;t forget to pad the strings with a NUL character for the cases where you need interop. You don&amp;rsquo;t want to be making unnecessary string copies just because of this, and you don&amp;rsquo;t know when you&amp;rsquo;ll need the interop.&lt;/p>
&lt;p>C++&amp;rsquo;s &lt;code>std::string&lt;/code>, for example, uses a combination of a NUL terminator and a size length, which allows it to be efficient for manipulation but also allows passing the &amp;ldquo;raw bytes&amp;rdquo; to C interfaces. I suppose Go and Rust do the same, but I haven&amp;rsquo;t looked. &lt;a href="https://www.brandons.me/blog/why-rust-strings-seem-hard">Strings are hard though&lt;/a> and some languages do better than others in handling them.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-12-03-threads.jpg" length="588993" type="image/jpeg"/></item><item><title>Links: November 2023 edition</title><link>https://jmmv.dev/2023/11/links-november-2023-edition.html</link><pubDate>Thu, 30 Nov 2023 10:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/links-november-2023-edition.html</guid><description>&lt;p>Welcome to the second edition of my &amp;ldquo;interesting links&amp;rdquo; recap, this time covering the month of November 2023.&lt;/p>
&lt;p>For context, what follows is my manual curation of cool articles, videos, and projects I stumbled upon during this time period. But this is not &lt;em>just&lt;/em> a dump of links: &lt;em>each link is accompanied by a 1-paragraph commentary&lt;/em> that justifies why I thought the material was cool, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading it.&lt;/p>
&lt;p>Before we dive in, two quick things. First: I want to explicitly acknowledge all the new subscribers that have joined us since &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">the last post on Windows NT&lt;/a> landed on some major news sites. Thank you; I hope you find this interesting and a good reason to stick around. And, second: the &lt;a href="/2023/10/links-october-2023-edition.html">first edition&lt;/a> of this recap didn&amp;rsquo;t get any real traction, so let&amp;rsquo;s see if this one fares better. You can help by liking and resharing this post &lt;em>wink&lt;/em> &lt;em>wink&lt;/em> or&amp;hellip; as usual, by subscribing.&lt;/p>
&lt;h1 id="articles">Articles&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.notebookcheck.net/Lenovo-ThinkPad-T14s-G4-review-Business-laptop-is-better-with-AMD-Zen4.763581.0.html">&amp;ldquo;Lenovo ThinkPad T14s G4 review: Business laptop is better with AMD Zen4&amp;rdquo;&lt;/a> by Andreas Osthoff on November 1st, 2023.&lt;/strong>&lt;/p>
&lt;p>I have been eyeing the T14s that Costco has on sale for a while and, while I&amp;rsquo;m not going to get it because of the &amp;ldquo;low&amp;rdquo; screen resolution, I had to read through this review. And oh wow, what an amazing, in-depth description of the device. I&amp;rsquo;m now waiting for the X1 Nano to be in stock again&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://mjg59.dreamwidth.org/68350.html">&amp;ldquo;Why ACPI?&amp;rdquo;&lt;/a> by Matthew Garrett on October 31st, 2023.&lt;/strong>&lt;/p>
&lt;p>A high-level overview of what ACPI is, why it was needed to replace APM, and how computers would look like in a world without ACPI.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://quick-lint-js.com/blog/bug-journey/">&amp;ldquo;Sometimes, it &lt;em>is&lt;/em> a compiler bug&amp;rdquo;&lt;/a> by strager on May 25th, 2022.&lt;/strong>&lt;/p>
&lt;p>Great debugging story of an obscure problem that the author hit when seeing someone else write a bug in their code, suggesting that they install a VSCode extension that would have highlighted the bug, and watching in real time how the extension then pointed at a non-existent bug. I recall hitting some compiler bugs myself (a similar issue with Rust&amp;rsquo;s incremental compilation, and various ICEs) but I have never had the patience to dig for an answer.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.xtof.info/intel80386.html">&amp;ldquo;Intel 80386, a revolutionary CPU&amp;rdquo;&lt;/a> by Christophe Meneboeuf on September 2nd, 2023.&lt;/strong>&lt;/p>
&lt;p>A good story on how the 80386 came to be and why it was important at the time. I recall reading a book (&lt;a href="https://twitter.com/jmmv/status/1721531589635813396">that I still have&lt;/a>) that described the 8086, the 80286, and the 80386 in great depth and how they differed among each other. All of the details about memory and task management felt fascinating to me at the time, and I&amp;rsquo;ve always found it weird that almost none of the features that the chips provided (segmentation instead of pagination; 4 protection levels; task, interrupt, and call gates; hardware-assisted task switching&amp;hellip;) were put to use by operating systems. Sure, their original implementation might have sucked and been slow, but if they had been used, Intel would have improved those over time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.vidarholen.net/contents/blog/?p=1035">&amp;ldquo;What exactly was the point of [ “x$var” = “xval” ]?&amp;rdquo;&lt;/a> by Vidar on April 12th, 2021.&lt;/strong>&lt;/p>
&lt;p>One more oddity that you&amp;rsquo;ll find in shell scripts. And not just ancient ones: this still shows up regularly in auto-generated &lt;code>configure&lt;/code> scripts, or even in their &lt;code>configure.ac&lt;/code> originals because people copy/paste code snippets without thinking about them much.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://devblogs.microsoft.com/oldnewthing/20231103-00/?p=108966">&amp;ldquo;Why does unsafe multithreaded use of an &lt;code>std::unordered_map&lt;/code> crash more often than unsafe multithreaded use of a &lt;code>std::map&lt;/code>?&amp;rdquo;&lt;/a> by Raymond Chen on November 3rd, 2023.&lt;/strong>&lt;/p>
&lt;p>I always enjoy Raymond&amp;rsquo;s posts, and to be honest, his blog is what drove me into writing mine and changing the way I looked at Microsoft and Windows 9x. In this one, he entertains a question of the type &amp;ldquo;this thing is broken, but why does it look more broken in this case than in this other one?&amp;rdquo;. Obviously, The Internet cannot read subtlety.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="end-to-end-tool-testing-with-bazel.md">&amp;ldquo;End-to-end testing with Bazel and shtk&amp;rdquo;&lt;/a> by yours truly on November 4th, 2023.&lt;/strong>&lt;/p>
&lt;p>Last month, and for reasons that are not interesting, I revived an old project of mine: &lt;a href="https://shtk.jmmv.dev">shtk&lt;/a>. This, combined with my trip to BazelCon 2023, made me want to create a new ruleset to integrate shtk with Bazel builds because I know the shell is a great language to write integration tests for tools. So I ended up creating &lt;a href="https://github.com/jmmv/rules_shtk/">rules_shtk&lt;/a> and wrote this post to explain how to use it and how it can help you write better tools.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://blog.rust-lang.org/2023/11/09/parallel-rustc.html">&amp;ldquo;Faster compilation with the parallel (Rust) front-end in nightly&amp;rdquo;&lt;/a> by Nicholas Nethercote on behalf of The Parallel Rustc Working Group on November 9th, 2023.&lt;/strong>&lt;/p>
&lt;p>This is exciting work. I have an overkill server in the garage with 72 cores where I remote into for development and, most of the time, it goes vastly unused. I doubt the Rust compiler will be able to use that many cores, at least for the kind of projects I work on&amp;mdash;they aren&amp;rsquo;t &lt;em>that&lt;/em> large&amp;mdash;but still, this is exciting.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://flak.tedunangst.com/post/write-your-own-terminal">&amp;ldquo;Write your own terminal&amp;rdquo;&lt;/a> by Ted Unangst on November 10th, 2023.&lt;/strong>&lt;/p>
&lt;p>Writing a terminal is surely rewarding: as the author says, you have to do very little to get it to a functional state, but then can iterate endlessly on the details and on performance. And I know it&amp;rsquo;s fun because I had to do this for the &lt;a href="https://www.endbasic.dev/">EndBASIC&lt;/a> console. Replacing the use of Xterm.js with my own implementation showed results quickly, and I was then able to mix text and graphics seamlessly.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="why-do-i-know-shell-and-how-can-you.md">&amp;ldquo;Why do I know shell, and how can you?&amp;rdquo;&lt;/a> by yours truly on November 10th, 2023.&lt;/strong>&lt;/p>
&lt;p>I spent some time last month and this month writing more shell than usual, and people at work often ask me &amp;ldquo;why I know so many ancient incantations&amp;rdquo;. So I decided to explain how the constraints of &lt;a href="http://www.NetBSD.org/">NetBSD&lt;/a>, an open-source OS project I contributed to for many years, guided me down this path.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://virtuallyfun.com/2023/11/12/dont-waste-money-on-a-math-coprocessor-they-said/">&amp;ldquo;Don&amp;rsquo;t waste money on a math coprocessor they said&amp;rdquo;&lt;/a> by neozeed on November 12th, 2023.&lt;/strong>&lt;/p>
&lt;p>Did you know that CPUs did not use to have floating point operations and that there were optional chips you could buy to supplement the CPU with those? Say hi to the FPUs. This article dives into history and shows how installing an 80287 along an 80286 fixed a mysterious crashing bug in a game and in OS/2&amp;mdash;even when none of this code was using floating point. If you are into retro stuff, this one (and &lt;a href="https://virtuallyfun.com/">the whole blog&lt;/a> it seems!) is for you&amp;hellip; but I only wish the author came up with a precise explanation of what went wrong here.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://wingolog.org/archives/2023/11/13/i-accidentally-a-scheme">&amp;ldquo;i accidentally a scheme&amp;rdquo;&lt;/a> by wingo on November 13th, 2023.&lt;/strong>&lt;/p>
&lt;p>This article is short and not very detailed, but it contains a bunch of interesting references to programming language implementation topics and is entertaining to read. You must read the intro, though; it is just great. Plus I learned a new meme&amp;hellip; and several new words.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://yorickpeterse.com/articles/a-decade-of-developing-a-programming-language/">&amp;ldquo;A decade of developing a programming language&amp;rdquo;&lt;/a> by Yorick Peterse on November 14th, 2023.&lt;/strong>&lt;/p>
&lt;p>An easy-to-read reflection on the challenges of building a new programming language, along with some suggestions on how to approach doing so.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://lock.cmpxchg8b.com/reptar.html">&amp;ldquo;Reptar&amp;rdquo;&lt;/a> by Tavis Ormandy on November 14th, 2023.&lt;/strong>&lt;/p>
&lt;p>An article from Google&amp;rsquo;s Project Zero team describing a glitch in instruction processing that makes certain modern x86 processors enter an invalid state. Whether this can be used for privilege escalation is still unknown, but assume the worst.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="ssh-agent-forwarding-and-tmux-done.md">&amp;ldquo;SSH agent forwarding and tmux done right&amp;rdquo;&lt;/a> by yours truly on November 17th, 2023.&lt;/strong>&lt;/p>
&lt;p>If you have ever used SSH agent forwarding and you keep long-running tmux sessions on the remote machine, you know you are in for trouble. This article covers why agent forwarding breaks in this case, describes various solutions, and presents a prototype I quickly wrote (the &lt;a href="https://github.com/jmmv/ssh-agent-switcher/">ssh-agent-switcher&lt;/a>) to fix the problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.evanjones.ca/setenv-is-not-thread-safe.html">&amp;ldquo;Setenv is not Thread Safe and C Doesn&amp;rsquo;t Want to Fix It&amp;rdquo;&lt;/a> by Evan Jones on November 19th, 2023.&lt;/strong>&lt;/p>
&lt;p>Well, yes, it is not thread safe&amp;mdash;but you should &lt;em>not&lt;/em> be modifying the environment of your own process, except right before &lt;code>exec&lt;/code>. Environment variables &lt;em>are&lt;/em> global, untyped, not-thread-safe variables.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://pikuma.com/blog/what-is-dos4gw-protected-mode">&amp;ldquo;DOS/4GW and Protected Mode&amp;rdquo;&lt;/a> by Gustavo Pezzi on December 12th, 2021.&lt;/strong>&lt;/p>
&lt;p>Ah, the memories. Learn more about how DOS games could unleash the power of 32 bits and more than 1 MB (yes, MB) of memory by using an &amp;ldquo;extender&amp;rdquo; while running on an &amp;ldquo;OS&amp;rdquo; that was 16-bit real mode.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="code-reviews-a-success-story.md">&amp;ldquo;Code reviews: A success story&amp;rdquo;&lt;/a> by yours truly on November 21st, 2023.&lt;/strong>&lt;/p>
&lt;p>If you ask people what they think about the Pull Request process to get code merged into a project, you&amp;rsquo;ll find critics. I do think PR reviews, and in particular code reviews, are a good process that can increase the quality of the software you ship&amp;mdash;but it&amp;rsquo;s important for the people involved to understand the limitations of the process and when they need to take a different route. This Twitter thread presents a success story that I was personally involved in.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.10stripe.com/articles/why-is-56k-the-fastest-dialup-modem-speed.php">&amp;ldquo;Why is 56k the fastest dialup modem speed?&amp;rdquo;&lt;/a> by Alex Freeman probably pre-2008.&lt;/strong>&lt;/p>
&lt;p>I can hear this article. A good technical explanation on why the maximum transmission speed for dial-up connections is 56k, a number that seems pulled out of thin air, and how it&amp;rsquo;s not possible to achieve it in practice.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://devblogs.microsoft.com/oldnewthing/20231124-00/?p=109059">&amp;ldquo;On harmful overuse of &lt;code>std::move&lt;/code>&amp;rdquo;&lt;/a> by Raymond Chen on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>So using &lt;code>std::move&lt;/code> can hurt? Thanks, C++. The article touches upon optimizations that the compiler can perform and how move construction can hamper them. Also, this reminds me how the NRVO (described in the article too) masked a bug in code I wrote long ago, and how I do not want to ever write C++ again if I can avoid it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="windows-nt-peeking-into-the-cradle.md">&amp;ldquo;Windows NT: Peeking into the cradle&amp;rdquo;&lt;/a> by yours truly on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>A review of the &amp;ldquo;Showstopper!&amp;rdquo; book combined with my own commentary on how exciting (and tiresome) it must have been to live through the development of Windows NT: the OS that still powers most PCs in the world, more than 30 years after its inception.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://tedium.co/2023/11/24/weird-html-hacks-history/">&amp;ldquo;10 Weird HTML Hacks That Shaped The Internet&amp;rdquo;&lt;/a> by Ernie Smith on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>This article gets my vote if only for its retro photos of Netscape 4. But, in any case, the article is a neat summary of weird things that people did (and still do!) with HTML to format their websites. The article is long, but each of the 10 entries has a very brief what/how/why summary at the top which makes it easy to decide what you want to read.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ShellsAndCurrentDirectory">&amp;ldquo;Unix shells and the current directory&amp;rdquo;&lt;/a> by Chris Siebenmann on November 25th, 2023.&lt;/strong>&lt;/p>
&lt;p>It&amp;rsquo;s interesting to think about how the &amp;ldquo;current directory&amp;rdquo; is represented in the kernel and how, depending on the choices, the kernel may not be able to provide a &lt;code>getcwd(2)&lt;/code> system call. When that happens, how does &lt;code>pwd(1)&lt;/code> work? This article answers these questions, and more.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://muxup.com/2023q4/storing-data-in-pointers">&amp;ldquo;Storing data in pointers&amp;rdquo;&lt;/a> by Alex Bradbury on November 27th, 2023.&lt;/strong>&lt;/p>
&lt;p>Pointers are really wide, but addressable memory isn&amp;rsquo;t yet&amp;mdash;so pointers have enough room to carry data in them. This article describes how, but the more interesting part is the list at the end covering the many real-world use cases where this is done.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="other">Other&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://retrocomputing.stackexchange.com/questions/27926/who-invented-file-extensions-in-file-names">&amp;ldquo;Who invented file extensions in file names?&amp;rdquo;&lt;/a> StackExchange discussion on November 1st, 2023.&lt;/strong>&lt;/p>
&lt;p>We take file extensions as part of file names for granted today, but looking into their history, we discover that extensions were a separate metadata field in the file system, much like timestamps are. It wasn&amp;rsquo;t until Unix and its flat approach to file names that extensions became part of the file names. This is why on MS-DOS you can refer to files without specifying their extension (again, just like you can refer to files without specifying the time they were modified).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Caldera_OpenLinux">&amp;ldquo;Caldera OpenLinux&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>The very first Linux distribution I ever tried. I recall that this came with the PC Actual magazine and remember how the installation instructions in the corresponding article described a workaround for a bug in the mounting of the CD. I also remember not achieving a resolution larger than 320x200 with X11. Not a great first impression&amp;hellip; but this hooked me into the Unix world forever.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=qbKGw8MQ0i8">&amp;ldquo;NTFS really isn&amp;rsquo;t that bad [video]&amp;rdquo;&lt;/a> by Robert Collins on January 16th, 2020.&lt;/strong>&lt;/p>
&lt;p>A conference presentation that describes how the speaker optimized Rust&amp;rsquo;s installation from 3 and a half minutes to just 14 seconds on Windows. NTFS isn&amp;rsquo;t the problem: it&amp;rsquo;s the applications assuming that the whole world is like Linux.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.nasm.us/">&amp;ldquo;The Netwide Assembler (NASM)&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>Brought to memory by &lt;a href="https://news.ycombinator.com/item?id=38203553">a Hacker News discussion&lt;/a>. It&amp;rsquo;s interesting to me to see people disregard the AT&amp;amp;T syntax as unusable, which makes me feel better about never learning it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=TbZ3HzvFEto">&amp;ldquo;Half-Life: 25th anniversary documentary [video]&amp;rdquo;&lt;/a> by Valve on November 17th, 2023.&lt;/strong>&lt;/p>
&lt;p>A documentary on my favorite game of all times. Well worth the watch, even for the whole family.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://effective-rust.com/">&amp;ldquo;Effective Rust&amp;rdquo;&lt;/a> online book.&lt;/strong>&lt;/p>
&lt;p>Inspired by Scott Meyer&amp;rsquo;s famous Effective C++ book, this online book takes a similar approach to show more than 30 different scenarios in how to better apply Rust. I haven&amp;rsquo;t read it cover to cover, but the few items I skimmed through seem solid. Worth a read and, as with any programming guidelines, lots of what you can find here apply to any language.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.freebsd.org/releases/14.0R/announce/">&amp;ldquo;FreeBSD 14.0-RELEASE Announcement&amp;rdquo;&lt;/a> on November 20th, 2023.&lt;/strong>&lt;/p>
&lt;p>It&amp;rsquo;s here! Go grab it while it&amp;rsquo;s hot. There are claims to significant performance improvements, so I&amp;rsquo;m eagerly awaiting to have a few spare hours to upgrade my server in the garage. I suspect I&amp;rsquo;ll only need a few minutes&amp;hellip; but need to plan for the worst case scenario.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://tmpout.sh/3/">&amp;ldquo;tmp0ut.sh #003&amp;rdquo;&lt;/a> by multiple authors on November, 2023.&lt;/strong>&lt;/p>
&lt;p>A new edition of an online underground ezine talking about security and exploits. The content is super-interesting, but the looks of this are frigging awesome too.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.xbox.com/en-US/power-on">&amp;ldquo;Power On: The Story of Xbox [video series]&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>A 6-part documentary on how the Xbox came to be, and how it almost didn&amp;rsquo;t launch. I&amp;rsquo;ve only been able to watch the first episode so far, but it was engaging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=xi1Lq79mLeE">&amp;ldquo;The mind behind Windows: Dave Cutler&amp;rdquo;&lt;/a> by Dave&amp;rsquo;s Garage on October 21st, 2023.&lt;/strong>&lt;/p>
&lt;p>A 3-hour long interview with Dave Cutler on the creation of Windows NT. Having just written a &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">detailed article on this part of history&lt;/a>, this looks very interesting to watch.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://infinitemac.org/">&amp;ldquo;Infinite Mac&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>Pick any version of System Software/Mac OS from the 1980s or 1990s and run it right in your browser. I wasn&amp;rsquo;t a Mac user until Mac OS X Tiger, so these are systems I never experienced&amp;mdash;except for System 7.5, I think, which I had to use to bootstrap a NetBSD/mac68k system. But if you did, this is a good toy to recreate memories.&lt;/p>
&lt;/li>
&lt;/ul></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>Windows NT: Peeking into the cradle</title><link>https://jmmv.dev/2023/11/windows-nt-peeking-into-the-cradle.html</link><pubDate>Fri, 24 Nov 2023 09:40:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/windows-nt-peeking-into-the-cradle.html</guid><description>&lt;p>It&amp;rsquo;s strange&amp;hellip; but I&amp;rsquo;ve been able to finish reading a book cover-to-cover that&amp;rsquo;s not a book for my kids. It&amp;rsquo;s hard for me to get hooked into books and find the time to read them. I think the one I finished before this might have been &amp;ldquo;&lt;a href="https://www.amazon.com/10-PRINT-CHR-205-5-RND/dp/0262018462?&amp;amp;_encoding=UTF8&amp;amp;tag=blogsystem503-20&amp;amp;linkCode=ur2&amp;amp;linkId=c3ddd9f1db5ead180ea40a44f495092b&amp;amp;camp=1789&amp;amp;creative=9325">10 PRINT&lt;/a>&amp;rdquo;, and that was over a year ago. This time, though, I completed the book on the story behind the creation of Windows NT: namely, &amp;ldquo;Showstopper!&amp;rdquo; in its short form, written by G. Pascal Zachary.&lt;/p>
&lt;p>Reading the story of how Windows NT came to be was entertaining, as it is a story of the system itself and the dynamics between Dave Cutler, the original designer and lead for NT, and the other people involved in the project. I was shy of being 10 years old when Windows NT launched and I didn&amp;rsquo;t comprehend what was going on in the operating systems world and why this release was such a big deal. Reading the book made me learn various new things about the development process, the role of Microsoft in that era, and allowed me to settle some questions I&amp;rsquo;ve had over the years.&lt;/p>
&lt;p>This article is a mixture of a book review and a collection of thoughts and reflections that the book evoked. Let&amp;rsquo;s begin because we have a lot of ground to cover.&lt;/p>
&lt;h1 id="lets-create-a-brand-new-os">Let&amp;rsquo;s create a brand new OS&lt;/h1>
&lt;p>Operating systems are pretty much a commodity these days&amp;mdash;but you couldn&amp;rsquo;t take them for granted before. There was a time during the 1980s and 1990s when a multitude of computer architectures and operating systems thrived, each offering vastly different feature sets and levels of stability than the others. Yes, DOS and Windows were the most popular choices for personal computers, but there were other contenders such as OS/2, BeOS, QNX&amp;hellip; as well as the myriad different commercial Unix derivatives. The open-source BSDs and Linux had just seen the light of day.&lt;/p>
&lt;p>Microsoft&amp;rsquo;s bet to build NT in 1988, a brand new OS from scratch, was bold. There were good reasons for taking the risk, which centered around the desire to modernize DOS and to have first-class support for networks, but investing multiple years of R&amp;amp;D on a massive project like this was risky: others had tried and failed.&lt;/p>
&lt;p>At the end of the day, Microsoft succeeded with NT. The development process took longer than anticipated, but the system finally shipped in 1993. Now, more than 30 years later, NT is behind almost all desktop and laptop computers in the world. The book claims that Cutler repeatedly told his team that they&amp;rsquo;d remember this time period as &amp;ldquo;the good old days&amp;rdquo;, and I think he was well damn right. As tough as that period must have been for everyone involved, they were writing history and setting the direction of personal computing for years to come.&lt;/p>
&lt;h1 id="development-pressure">Development pressure&lt;/h1>
&lt;p>Contrast this to the open-source BSDs and Linux, which were already a reality by NT&amp;rsquo;s launch in 1993. Linux and the original 386BSD were &amp;ldquo;hobby projects&amp;rdquo; for their creators. I&amp;rsquo;m convinced that, at the time, these people and their contributors didn&amp;rsquo;t imagine their toys as anything that would influence the world&amp;mdash;even if, in retrospect, they kinda have: Linux is the basis for almost all mobile devices and servers, and macOS is derived from those original BSDs.&lt;/p>
&lt;p>What I&amp;rsquo;m trying to get at is that there is something to be said about the different thrill of working on these projects. On the one hand, NT was in a race to ship the next revolutionary OS to power all personal computers, with intense pressure from OS/2 and other contenders, and with a design that went against established practice. On the other hand, Linux was in no such rush: its developers worked on it for their own entertainment, probably not grasping what was ahead of them.&lt;/p>
&lt;p>Having been part of the NT team and of that era of computing must have been incredibly exciting. However, it was not all roses for this team. Even though the work of the team was exciting and the potential for impact was massive, the book also shows a clear picture of a really toxic culture: leaders screaming to their peers and reports; normalized long hours and destroyed families; cross-team distrust and shaming&amp;hellip; not something you&amp;rsquo;d probably want to be involved in.&lt;/p>
&lt;h1 id="dogfooding">Dogfooding&lt;/h1>
&lt;p>Creating a new OS is fun but, unless you use the OS regularly, you will have little incentive to discover and fix sharp usability edges or certain classes of bugs. This is where dogfooding, or the practice of &lt;del>eating your own dog food&lt;/del> using your own creations, becomes key. And due to the importance of this, the book has a whole chapter on dogfooding NT.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-31-boot.png" class="with-border">
&lt;figcaption>Windows NT 3.1 boot screen. &lt;a href="https://winworldpc.com/product/windows-3/31">Courtesy of WinWorld.&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>The mandate to dogfood NT after it passed a certain functionality threshold comes from Cutler himself and sounds awesome&amp;hellip; and frustrating at the same time. I&amp;rsquo;ve previously dogfooded operating systems&amp;mdash;I ran NetBSD and FreeBSD CURRENT for years while I was a contributor&amp;mdash;and the infrequent crashes were annoying. Note, however, that these two systems were already past a certain stability point by the time I used them so, in general, they worked. I wonder what level of functionality the first dogfood versions of NT had but, based on what I grasp from the book, the answer is &amp;ldquo;not a lot&amp;rdquo;, which means the experience may have been quite a nightmare.&lt;/p>
&lt;p>Note that these days, it seems silly to talk about &amp;ldquo;how this OS is more stable than this other one&amp;rdquo; because all modern OSes implement similar process and file protections, but stability couldn&amp;rsquo;t be taken for granted back then. The DOS-based Windows editions really were quite unstable, and OS/2 and Unix systems put them to shame. The design of NT was going to fix these issues for the Windows world, but it had to be stabilized first too.&lt;/p>
&lt;h1 id="the-build-lab">The build lab&lt;/h1>
&lt;p>Windows releases are often referred to by specific build numbers, which always sounded weird to me: as a regular FreeBSD and NetBSD &lt;em>user&lt;/em>, I churned out multiple new builds of these whole OS &lt;em>per day&lt;/em>, and doing so was trivial and inconsequential. What was so special about Windows that individual build numbers were important? Was it really true that Windows NT 3.51, numbered build 1057, was the 1057th time that the codebase had been assembled together? And the answer is&amp;hellip; yes.&lt;/p>
&lt;p>The book talks a lot about the build lab: the &lt;em>place&lt;/em>&amp;mdash;laptops and remote work were &lt;em>definitely&lt;/em> not a thing in the early 1990s&amp;mdash;where a few engineers took the changes that everyone else made and assembled the whole system into something that could boot. This system was then distributed to the whole team for dogfooding on a daily basis.&lt;/p>
&lt;p>This sounds ridiculous, right? Why wasn&amp;rsquo;t there a CI/CD pipeline to build the system every few hours and publish the resulting image to a place where engineers could download it? Ha, ha. Things weren&amp;rsquo;t this rosy back then. Having automated tests, reproducible builds, a CI/CD system, unattended nightly builds, or even version control&amp;hellip; these are all a pretty new &amp;ldquo;inventions&amp;rdquo;. Quality control had to be done by hand, as did integrating the various pieces that formed the system.&lt;/p>
&lt;p>Regardless, even if you think about having to design a CI/CD system for an OS today, it isn&amp;rsquo;t as trivial as what you need for your run-of-the-mill GitHub project. Validating the built OS against different hardware, assessing the behavior of fundamental system components like the process scheduler, and accepting that any validation can crash the machine and require a physical power cycle&amp;hellip; is not trivial. Even relying on VMs like we do today isn&amp;rsquo;t sufficient, because you &lt;em>do&lt;/em> want to test the OS against real hardware.&lt;/p>
&lt;h1 id="portability-and-design-cleanliness">Portability and design cleanliness&lt;/h1>
&lt;p>These days we take x86-based personal computers as the one and only possibility, which wasn&amp;rsquo;t true back in the day&amp;mdash;and may not be true in the near future either. As I mentioned earlier, the computer world was full of different architectures during the 1980s and early 1990s.&lt;/p>
&lt;p>In my journey to move away from Windows, which &lt;a href="/2020/08/os2-memory-lane.html">started with OS/2 Warp 3&lt;/a> and was followed by Linux and the BSDs, I was lured by NetBSD and stuck with it for years. The main reason I ended up settling on NetBSD was its claims of being &amp;ldquo;cleanly designed&amp;rdquo;, and a big reason for needing &lt;em>and&lt;/em> having a clean design was supporting tens of different architectures out of the same codebase.&lt;/p>
&lt;p>Which is interesting because this is precisely how NT started. From reading the book, I learned that Cutler had the same mentality for his OS and, in fact, the system wasn&amp;rsquo;t ported to x86 until late in its development. He wanted developers to target non-x86 machines &lt;em>first&lt;/em> to prevent sloppy non-portable coding, because x86 machines were already the primary desktops that developers had. In fact, even as x86 increasingly became the primary target platform for NT, the team maintained a MIPS build at all times, and having most tests passing in this platform was a requirement for launching.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-351-powerpc.png" class="with-border">
&lt;figcaption>Windows NT 3.51 running on a PowerPC machine. From the &lt;a href="https://virtuallyfun.com/2020/08/02/the-lost-history-of-prep-windows-nt-3-5x-and-the-rs-6000-40p/">"The lost history of PReP: Windows NT 3.5x and the RS/6000 40p"&lt;/a> article at Virtually Fun.&lt;/figcaption>
&lt;/figure>
&lt;p>On this topic, I briefly remember some contemporary news articles in computer magazines describing how the PowerPC was going to be &amp;ldquo;the next big thing&amp;rdquo; and how NT ran on it. I did not grasp what a big deal this was at the time because based on the screenshots that they printed, Windows NT on PowerPC looked exactly the same as Windows 3.11 on my i386 PC. Well, I guess I really just didn&amp;rsquo;t understand what PowerPC nor NT were at all.&lt;/p>
&lt;h1 id="dialing-difficulty-up-to-11-with-ntfs">Dialing difficulty up to 11 with NTFS&lt;/h1>
&lt;p>This golden era also saw the creation of many new file systems. If you were on DOS and Windows 3.x land, your choices were limited, but if you were playing with Linux, you saw new file systems pop up &amp;ldquo;every week&amp;rdquo;. Things settled around the early/mid 2010s, except maybe for the uneventful launch of &lt;a href="https://en.wikipedia.org/wiki/Apple_File_System">APFS&lt;/a> in 2017.&lt;/p>
&lt;p>Creating a new OS from scratch is no easy feat, but wanting to create a brand new file system to go with it is making things difficult just because. While writing a file system is already tricky enough, &lt;em>stabilizing&lt;/em> it is a whole different story. But, as the book describes, the team felt that they needed a new file system to support the reliability and networking needs of NT, so it had to be done. FAT was nowhere close to offer them.&lt;/p>
&lt;p>And NTFS is very interesting. NTFS was a really advanced file system for its time thanks to journaling, support for multi-TB volumes, optional per-directory and per-file compression, detailed ACLs&amp;hellip; none of the Unix file systems of the era had these features. For example, ext3, which extended ext2 with journaling support, did not exist until 2001, and it has been replaced by ext4 and btrfs since. But NTFS is still chugging along in Windows 11, so it is impressive that they could make it happen on time for the OS release. (The same cannot be said about &lt;a href="https://en.wikipedia.org/wiki/WinFS">WinFS&lt;/a>&amp;hellip; which was supposed to ship with Vista and didn&amp;rsquo;t.)&lt;/p>
&lt;p>Now, I know you will complain that NTFS is slow&amp;hellip; but you know what? It almost-certainly is not. Most of the problems with NTFS performance stem from file system filters, which intercept all I/O operations to do heavy stuff like virus scanning. &lt;a href="https://www.youtube.com/watch?v=qbKGw8MQ0i8">NTFS on its own is fine&lt;/a>, but you need to write your applications with knowledge of the system you target: if you treat something as Unix when it isn&amp;rsquo;t, then bad things happen.&lt;/p>
&lt;h1 id="correctness-first-performance-second">Correctness first, performance second&lt;/h1>
&lt;p>Speaking of NTFS performance, the book also touches upon system performance. Unsurprisingly, Cutler wanted to make the system stable and well-designed first, leaving performance for later. Performance was pushed to the side for a while, but the team was confident that they could improve performance and resource consumption later. This was a good strategy, although it didn&amp;rsquo;t play out well for a while.&lt;/p>
&lt;p>What I found interesting is that the book claims that Bill Gates was obsessed with performance and routinely asked about it, because the prospective user base of NT did not have the means to buy high-end computers. Which is great&amp;hellip; but then, I just don&amp;rsquo;t know where &lt;a href="/2023/06/fast-machines-slow-machines.html">performance has gone wrong&lt;/a> at Microsoft because that doesn&amp;rsquo;t seem to be the focus anymore.&lt;/p>
&lt;p>Regardless, and even after performance work, NT was not the fastest at its launch. As the initial reviews published, the system was deemed &amp;ldquo;too big, too slow&amp;rdquo; and requiring too high hardware requirements. This seemed to affect Cutler. Right after the initial 3.1 launch, when the team deserved a break, they were back at work right away to improve these topics in preparation for the 3.51 launch.&lt;/p>
&lt;h1 id="huge-migrations-at-microsoft">Huge migrations at Microsoft&lt;/h1>
&lt;p>Apple is touted as the expert in huge migrations: they moved their hardware lineup from 68k to PowerPC, from PowerPC to x86 and, most recently, from x86 to &lt;a href="https://en.wikipedia.org/wiki/Apple_silicon">Apple Silicon&lt;/a> (ARM). They also moved from 32 bits to 64 bits, dropping 32-bit support later, and from Mac OS Classic to Mac OS X. Apple has indeed executed these huge migrations well, but at each step, they have left apps and developers behind because Apple has never been big on backwards compatibility. Somehow its customers have accepted that.&lt;/p>
&lt;p>If we peek under the covers, Microsoft has also pushed similar humongous migrations. At each step, however, Microsoft has preserved backwards compatibility as much as possible, and I think this is why these migrations seem less of a big deal than they really were.&lt;/p>
&lt;p>What am I talking about? For starters: the jump from the DOS / Windows 3.x world to Windows 95. Windows 95 unified these two systems by making DOS applications work well under Windows&amp;mdash;something that wasn&amp;rsquo;t true in 3.x. To make this possible, Windows 95 carried tons of application-specific tweaks to remain bug-for-bug compatible and, while gross, that&amp;rsquo;s what users needed. We know how big of a splash Windows 95 made.&lt;/p>
&lt;p>But the other huge migration was the jump from Windows 9x to Windows NT. Maintaining two separate operating systems with the same UI for a few years with support for roughly the same apps is a big feat, but it&amp;rsquo;s an even bigger feat to unify these two tracks into one with Windows XP. And, with that release, they were finally able to drop the Windows 9x line for good.&lt;/p>
&lt;h1 id="putting-the-windows-in-nt">Putting the Windows in NT&lt;/h1>
&lt;p>NT started as a joint project between Microsoft and IBM. The goal was to create the next OS for PC systems, named OS/2. So, while NT was designed from the ground up to support multiple personalities (or&amp;hellip; &lt;a href="/2020/11/wsl-lost-potential.html">subsystems, like WSL 1&lt;/a>), the original plan was to make NT support DOS and OS/2 applications.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-microsoft-os2-logo.png" class="with-border">
&lt;figcaption>Microsoft OS/2 1.3 logo. &lt;a href="https://www.os2world.com/wiki/index.php/Microsoft_OS/2_1.3">Courtesy of OS/2 World.&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>The Windows personality&amp;mdash;the thing that gives NT its ability to run Windows applications&amp;mdash;wasn&amp;rsquo;t in the cards at first. As the book explains, the project was originally called NT, not Windows NT, and was supposed to become OS/2. It wasn&amp;rsquo;t until later that it became clear within Microsoft that NT had to run Windows applications to not be dead on arrival, and thus Gates pushed for NT to prioritize compatibility with Windows applications. Later on, the system was renamed to Windows NT to emphasize this point, and all ties with IBM broke.&lt;/p>
&lt;p>One thing that struck as interesting was how the team struggled to fix compatibility bugs late in the development cycle, because each fixed bug resulted in a new batch of compatibility issues. It wasn&amp;rsquo;t until later in the project that a key developer had the insight to create a tracer that recorded the system/library calls an app made. This recording could then be used by developers, without the help of testers, to trivially observe the behavior of a sequence of operations on NT and adjust them. This was the magic piece that provided a path towards stability and being able to ship.&lt;/p>
&lt;p>From this work, NT also gained the ability to define &amp;ldquo;compatibility flags&amp;rdquo; for certain applications. This was necessary to work around cases where the applications did the wrong thing&amp;mdash;yet compatibility had to be kept. And this is why Windows 9x and NT had (and still have) such a great compatibility story: the system is full of levers to appease weird behaviors in random apps, even if the apps themselves do something &amp;ldquo;wrong&amp;rdquo;. Most developers would go against the latter, claiming that those are bugs in the apps and they deserve to break. Apple has taken this path. Open source tries to take this path. &lt;a href="https://www.amazon.com/Old-New-Thing-Development-Throughout/dp/0321440307?&amp;amp;_encoding=UTF8&amp;amp;tag=blogsystem503-20&amp;amp;linkCode=ur2&amp;amp;linkId=b373dc6d4f2a06aac4cfec48134f4d71&amp;amp;camp=1789&amp;amp;creative=9325">Microsoft didn&amp;rsquo;t.&lt;/a>&lt;/p>
&lt;h1 id="the-ui-matters">The UI matters&lt;/h1>
&lt;p>Another topic that the book touches upon was the animosity between Cutler and the graphics team. Cutler did not think that graphics were important, which means they were neglected for a long while. And even when a UI team was put together, Cutler was not particularly happy or impressed by them.&lt;/p>
&lt;p>However, graphics are critical and they were difficult to get right. Performance was a problem, as were the many bugs that plagued the primary UI apps of the OS. And&amp;hellip; you might have the fastest, most portable, best designed OS in the world, but if its shell is not usable nor stable&amp;hellip; nobody will care. The UI makes the OS as much as the kernel makes the OS.&lt;/p>
&lt;p>Eventually, due to the desire to support primarily Windows applications in NT, the team adopted the UI that had been developed for OS/2 and for Windows 3.x. This was critical to make the OS seem familiar, although as I briefly touched upon earlier, this also made it difficult to see how 3.x and NT differed to the untrained eye. Later in life, I had a hard time seeing how the Windows NT 4 that ran in our high school computer lab differed from the Windows 95 I had at home: to me, it just seemed slower and heavier.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-4-desktop.png" class="with-border">
&lt;figcaption>Windows NT 4 initial desktop to emphasize how it looks exactly the same as Windows 95.&lt;/figcaption>
&lt;/figure>
&lt;p>In any case, the UI is crucial to the way people appreciate an OS. And, for NT specifically, I&amp;rsquo;m sad that there is no choice: Microsoft keeps &amp;ldquo;advancing&amp;rdquo; the UI in ways that seem detrimental. In particular, modern versions of Windows feel incredibly slow in hardware barely 10 years old&amp;hellip; which is sad because you can&amp;rsquo;t do anything about it other than stay in the hardware upgrade treadmill. I want to like Windows, but recent UI changes have slowly pushed me away.&lt;/p>
&lt;h1 id="and-finally-about-the-book">And finally, about the book&lt;/h1>
&lt;p>To conclude this look into the past, let&amp;rsquo;s actually talk a tiny bit about the book that sparkled it.&lt;/p>
&lt;p>The book is definitely entertaining to read; I guess the fact that I now live in the area where this all happened helped a tiny bit make it more so. It&amp;rsquo;s easy to read. It&amp;rsquo;s fun. It makes me wish I had been born just a few years earlier to understand everything that was going on in more detail&amp;mdash;and maybe to have had a chance to become part of it. And as I mentioned in the introduction, it is engaging enough that I was able to stick with it for about three months.&lt;/p>
&lt;p>But one thing that surprised me is that the book carries a handful of really obvious, painful editing mistakes. A couple of paragraphs are completely unreadable due to broken grammar, punctuation, and capitaliazation. I&amp;rsquo;m not sure how that happened. Luckily, the unreadable parts are reduced to one or two pages&amp;hellip; so you don&amp;rsquo;t miss much.&lt;/p>
&lt;p>Hope you enjoyed this article. And if you did, I&amp;rsquo;m sure you&amp;rsquo;ll enjoy the book much more. Click on the picture to buy and read it!&lt;/p>
&lt;blockquote>
&lt;a target="_blank" href="https://www.amazon.com/Showstopper-Breakneck-Windows-Generation-Microsoft-ebook/dp/B00J5X5E9U?&amp;_encoding=UTF8&amp;tag=blogsystem503-20&amp;linkCode=ur2&amp;linkId=b3bfada207b7929529132de33861f4e3&amp;camp=1789&amp;creative=9325">
&lt;figure>
&lt;img src="/images/2023-11-24-showstopper-alone.jpg"/>
&lt;figcaption>
"Showstopper!: The Breakneck Race to Create Windows NT and the Next Generation at Microsoft", by G. Pascal Zachary.
&lt;/figcaption>
&lt;/figure>
&lt;/a>
&lt;/blockquote></description><enclosure url="https://jmmv.dev/images/2023-11-24-showstopper-pile.jpg" length="180641" type="image/jpeg"/></item><item><title>Code reviews: A success story</title><link>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</link><pubDate>Tue, 21 Nov 2023 13:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</guid><description>&lt;p>Code reviews have a bad rep: they are antagonistic in nature and, sometimes, pure red tape. Some argue that they are bad practice; others say that peer programming is better. And while these &lt;em>may&lt;/em> be true, I want to tell you a story about a case where code reviews worked well!&lt;/p>
&lt;p>Meet X: a junior engineer in the Bazel team circa 2018, tasked to implement two features: A and B. As you may know, Google is big into code reviews&amp;mdash;and their tooling for this is awesome; believe me&amp;mdash;so this was the standard process for X to get his code checked in.&lt;/p>
&lt;p>For Feature A, X was working with two engineers in his same office: Y and Z. Engineer Y was a junior engineer as well but with more coding experience than X. Y wrote code really fast and didn&amp;rsquo;t like process. Y rubber-stamped long code reviews with little care about the details.&lt;/p>
&lt;p>Engineer Z was a high-level tech lead in the team. Z had a lot of experience and knew the product top-to-bottom, but didn&amp;rsquo;t have much time for code reviews. Worse yet, Z didn&amp;rsquo;t have enough spare time to closely mentor X or Y.&lt;/p>
&lt;p>For Feature B, X was working with me, who was 6000 km away and with a 6-hour time difference between us. I was known for tough code reviews. I also pushed for breaking large changes into smaller commits, because it is impossible to do a thorough review otherwise.&lt;/p>
&lt;p>And I also pushed for writing unit and integration tests in each change, guiding X into a good testing approach for feature B at each small step. You might say that this is important but isn&amp;rsquo;t part of a code review, but this is where the issues surfaced.&lt;/p>
&lt;p>My review comments were copious, so I classified them in three categories: nits, which were inconsequential style changes; optional suggestions, which X could ignore; and important comments, which required X to change code or for us to have a detailed discussion.&lt;/p>
&lt;p>Importantly, I always justified my review comments, &lt;em>especially&lt;/em> if they were personal opinions or optional suggestions. Most of the time, X took my advice and addressed nits and optional suggestions, because he was convinced by my explanations.&lt;/p>
&lt;p>Other times, X pushed back. Maybe I hadn&amp;rsquo;t understood the change or maybe I was just simply wrong. These cases needed further discussion and often resulted in side 1:1 conversations or even the request to write a mini design doc to flush out unclear ideas.&lt;/p>
&lt;p>The time to ship came. For context, Bazel used to be released once every two weeks within Google. New features were gated behind feature flags, which minimized risk in the release process. And if something went wrong, the two-week release cadence allowed addressing bugs quickly.&lt;/p>
&lt;p>Feature A was ready before feature B&amp;hellip; or was it? The overhead of the reviews in A had been minimal so the code shipped quickly. However&amp;hellip; feature A did not work. X needed multiple release cycles to address bugs, all under pressure because the feature &amp;ldquo;had already launched&amp;rdquo;.&lt;/p>
&lt;p>Feature B, on the other hand&amp;hellip; took longer to ship. But once it did, it worked &lt;em>on the first try&lt;/em>. Sure, it wasn&amp;rsquo;t perfect and needed some iteration to address small issues, but the bulk of the code just worked. This made X proud and understood why I had been thorough.&lt;/p>
&lt;p>To this day, X still remembers shipping these two features. He has told the story above multiple times and praised the process we followed for feature B. For me, it was mostly &amp;ldquo;business as usual&amp;rdquo; and didn&amp;rsquo;t really notice the (positive) impact it had on him.&lt;/p>
&lt;p>X also claims to have learned a lot just by reading my comments, thinking about them, and having to do the tricky work to write small, well-tested changes. And you know what? He has recently earned the title of CTO at an exciting startup.&lt;/p>
&lt;p>Anyhow. I realize this whole story shows flaws in various places. Z should probably have paid more attention to X and Y. Maybe X should have written more-detailed design docs upfront. Maybe we should all have pair-programmed. No team is perfect.&lt;/p>
&lt;p>But code reviews do work. Yes, they can be problematic, but I don&amp;rsquo;t think that code reviews are intrinsically antagonistic: it&amp;rsquo;s the people involved. Code reviews are just &lt;em>a tool&lt;/em> to achieve the goals of quality and mentoring, and as a tool, it has to be used wisely.&lt;/p>
&lt;p>And one last thing: code reviews are truly async-friendly. This may be why they are popular in open source, and in this particular case, they truly helped X and I due to the physical distance between us. Q.E.D.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-21-code-review.png" length="134980" type="image/jpeg"/></item><item><title>SSH agent forwarding and tmux done right</title><link>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</link><pubDate>Fri, 17 Nov 2023 08:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</guid><description>&lt;p>The &lt;a href="https://man.openbsd.org/ssh-agent">SSH agent&lt;/a> is a little daemon that holds your private keys in memory. This is particularly handy when your keys are protected by a passphrase: you can unlock and add your keys to the agent once and, from then on, any SSH client such as &lt;code>ssh(1)&lt;/code> can interact with the keys without asking you for the passphrase again.&lt;/p>
&lt;p>The SSH agent becomes even handier when you primarily work on a remote workstation over SSH. Under these circumstances, you will often need the remote workstation to establish SSH connections to &lt;em>other&lt;/em> remote machines (e.g. to contact GitHub). In those situations, you can: copy your private keys to the remote workstation; generate different private keys on the remote workstation; or forward your SSH agent so that the remote workstation can leverage the keys from your client machine without them ever traveling over the network.&lt;/p>
&lt;p>Anyway. This article isn&amp;rsquo;t a tutorial on what the SSH agent &lt;em>is&lt;/em> or how to &lt;em>use&lt;/em> it; that&amp;rsquo;s already &lt;a href="https://www.ssh.com/academy/ssh/agent">well-documented elsewhere&lt;/a>. What this article does is dig deeper into how the forwarding feature works, how it becomes problematic for long-lived processes such as tmux, and what you can do about it.&lt;/p>
&lt;h1 id="agent-forwarding-101">Agent forwarding 101&lt;/h1>
&lt;p>When you connect to an SSH host, the &lt;code>sshd&lt;/code> server process receives the connection, forks itself, lowers its privileges to the user requesting the connection, creates a pseudo-terminal to host the requested program (typically a shell), and spawns such program &amp;ldquo;inside&amp;rdquo; the pseudo-terminal.&lt;/p>
&lt;p>Take a look at this process table, which shows the &lt;code>sshd&lt;/code> processes running on the server I&amp;rsquo;m typing this on:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ ps -ax -o user,pid,command | grep ssh[d]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root 3617 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startups (sshd)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root 82202 sshd: jmmv [priv] (sshd)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jmmv 82204 sshd: jmmv@pts/1 (sshd)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What you can see in the output above is: the listener process with PID 3617 accepting connections on port 22; a &amp;ldquo;privsep&amp;rdquo; controlling process owned by root for my session with PID 82202, &lt;a href="https://security.stackexchange.com/questions/115896/can-someone-explain-how-sshd-does-privilege-separation">responsible for doing authentication&lt;/a>; and the process serving my session on the pseudo-terminal &lt;code>pts/1&lt;/code> and owned by myself with PID 82204.&lt;/p>
&lt;p>The user-owned &lt;code>sshd&lt;/code> instance on PID 82204 is what hosts the shell that you interact with on the client when connecting to an SSH server. This process is in charge of receiving your keystrokes from the network, sending them to the pseudo-terminal, and then ferrying back the pseudo-terminal&amp;rsquo;s &amp;ldquo;output&amp;rdquo; to the terminal window where your client runs. Pseudo-terminals are fascinating by the way; go read &lt;a href="https://man.netbsd.org/openpty.3">&lt;code>openpty(3)&lt;/code>&lt;/a>.&lt;/p>
&lt;p>But when you enable SSH agent forwarding with an &lt;code>ssh -A&lt;/code> invocation, something else happens. The user-owned &lt;code>sshd&lt;/code> server process creates a Unix domain socket on the remote machine and starts &lt;em>serving&lt;/em> on it. Whenever an SSH process on the remote machine connects to this local socket and sends a request to it, the &lt;code>sshd&lt;/code> process proxies the request &lt;em>back&lt;/em> to the client machine and, in turn, the client machine&amp;rsquo;s &lt;code>ssh&lt;/code> process contacts the client machine&amp;rsquo;s &lt;code>ssh-agent&lt;/code> to perform key-related operations.&lt;/p>
&lt;p>This path to the socket on the remote machine is exposed by the &lt;code>SSH_AUTH_SOCK&lt;/code> environment variable, and all SSH commands know how to access it. Here, look:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">client$ ssh -A server
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">server$ env | grep SSH_AUTH_SOCK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SSH_AUTH_SOCK=/tmp/ssh-jewlWIz1jC/agent.82204
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">server$ ls -l &amp;#34;${SSH_AUTH_SOCK}&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">srwxr-xr-x 1 jmmv wheel 0 Nov 17 05:30 /tmp/ssh-jewlWIz1jC/agent.82204
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Because a picture is worth a thousand words, here is the same idea in a diagram&amp;hellip; and this picture starts hinting at the problem I want to analyze:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-17-ssh-agent-1.png">
&lt;figcaption>Representation of a client machine (left) connecting to an SSH server. The SSH server (large box on the right) contains an sshd process and a tmux instance. The tmux instance shows the value of &lt;tt>SSH_AUTH_SOCK&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;h1 id="problems-with-long-lived-processes">Problems with long-lived processes&lt;/h1>
&lt;p>Pay close attention to what I described above: the path to the local socket created by the remote &lt;code>sshd&lt;/code> instance is specific to the (unprivileged) &lt;code>sshd&lt;/code> process handling the connection. The fact that the socket&amp;rsquo;s name contains the PID gives this away, but if you want to double-check:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">server$ sudo lsof | grep &amp;#34;${SSH_AUTH_SOCK}&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sshd 82204 jmmv 7u unix 0xfffff80f6a50fb10 0t0 /tmp/ssh-jewlWIz1jC/agent.82204
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I did not say it explicitly, but you can guess what happens: when you disconnect from the remote session, the &lt;code>sshd&lt;/code> instance for the connection terminates and deletes its local socket on the way out. Which is normal because that process was the one in charge of proxying SSH agent connections back to the SSH client, so with the process gone, the socket becomes useless.&lt;/p>
&lt;p>Unfortunately, the fact that this is normal doesn&amp;rsquo;t make it less problematic. The path to the forwarding socket is exposed to processes via the &lt;code>SSH_AUTH_SOCK&lt;/code> environment variable, so every process started within the remote SSH session gets and &lt;em>caches&lt;/em> a copy of this path in its environment. If you have long-lived process such as &lt;code>tmux&lt;/code> that can survive &lt;em>across&lt;/em> sessions, then all of a sudden the value of &lt;code>SSH_AUTH_SOCK&lt;/code> that they cached at startup time ends up pointing to a non-existing file, breaking all future SSH agent interactions. Look:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-17-ssh-agent-2.png">
&lt;figcaption>Representation of a client machine (left) re-connecting to an SSH server after an earlier connection drops. The SSH server (large box on the right) shows how the tmux instance from the first connection "moves" to the second connection, and how the value that tmux displayed in &lt;tt>SSH_AUTH_SOCK&lt;/tt> now points to an invalid file.&lt;/figcaption>
&lt;/figure>
&lt;p>The specific sequence of events represented in the diagram above and that leads to the problem is this:&lt;/p>
&lt;ol>
&lt;li>Connect to an SSH server with SSH agent forwarding.&lt;/li>
&lt;li>Start a tmux session in the SSH server.&lt;/li>
&lt;li>Detach the tmux session.&lt;/li>
&lt;li>Log out of the SSH server.&lt;/li>
&lt;li>Reconnect to the SSH server with SSH agent forwarding.&lt;/li>
&lt;li>Attach to the existing tmux session.&lt;/li>
&lt;li>Run an SSH command.&lt;/li>
&lt;li>See the command fail to communicate with the forwarded agent.&lt;/li>
&lt;/ol>
&lt;p>So, what can we do about it?&lt;/p>
&lt;h1 id="usual-broken-solutions">Usual broken solutions&lt;/h1>
&lt;p>&lt;a href="https://blog.testdouble.com/posts/2016-11-18-reconciling-tmux-and-ssh-agent-forwarding/">Most&lt;/a> &lt;a href="https://werat.dev/blog/happy-ssh-agent-forwarding/">&amp;ldquo;solutions&amp;rdquo;&lt;/a> &lt;a href="https://without-brains.net/2020/08/05/tmux-and-ssh-agent-forwarding/">I&lt;/a> &lt;a href="https://stackoverflow.com/questions/21378569/how-to-auto-update-ssh-agent-environment-variables-when-attaching-to-existing-tm">find&lt;/a> &lt;a href="https://www.jwon.me/ssh-agent-forwarding-with-tmux/">online&lt;/a> to this problem are hyper-focused on propagating new values of &lt;code>SSH_AUTH_SOCK&lt;/code> to impacted processes. These articles present how to re-inject a fresh value of this variable into tmux. Some of them go to a greater extent by showing you how to propagate the variable&amp;rsquo;s value to the &lt;em>shells&lt;/em> already running inside tmux sessions, because obviously the shells outlast SSH sessions too and they &lt;em>also&lt;/em> have their own copy of &lt;code>SSH_AUTH_SOCK&lt;/code>.&lt;/p>
&lt;p>This mostly works but it has two problems:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It&amp;rsquo;s a pile of hacks and a whack-a-mole battle you will not win. You can patch tmux. You can patch the shell. But what else do you run inside tmux that outlives SSH sessions? Emacs? Vim? A &amp;ldquo;transitive&amp;rdquo; outbound SSH connection? These all have their own copies of &lt;code>SSH_AUTH_SOCK&lt;/code>. You just can&amp;rsquo;t monkey-patch all possible long-lived processes that cached an ephemeral path in their environment when they started.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It&amp;rsquo;s insufficient. Some of the solutions linked to above leverage a symlink to keep the socket&amp;rsquo;s name stable. Those solutions refresh the symlink every time you log into the remote machine and then point &lt;code>SSH_AUTH_SOCK&lt;/code> to the symlink. This is good because it solves the problem of having to monkey-patch all possible long-lived processes. Unfortunately, this breaks as soon as the &lt;em>latest&lt;/em> connection to the server disconnects: once that happens, the symlink will be dangling until you establish a new session to update it.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Can we do better?&lt;/p>
&lt;h1 id="better-working-solutions">Better working solutions&lt;/h1>
&lt;p>&lt;em>Of course&lt;/em> we can do better, and in various different ways actually. I&amp;rsquo;m surprised I haven&amp;rsquo;t found any of them online with ease&amp;hellip;&lt;/p>
&lt;p>Here are some ideas:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We can refine the symlinks approach described earlier by adding a &lt;em>logout&lt;/em> script to accompany the login script. The goal of this pair would be to keep track of all possible valid sockets and, when a session disconnects, refresh the symlink to point to a still-valid one. This can work in the common case but breaks if SSH sessions die suddenly, which is pretty normal: think putting your laptop to sleep with an open SSH session and resuming it after commuting. So&amp;hellip; this is better, but not awesome.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We can use &lt;code>LD_PRELOAD&lt;/code> to hijack calls that open a socket, check if they seem to refer to an SSH agent socket, and then redirect those to any &lt;em>other&lt;/em> alive SSH agent socket we can find on the machine. This possibly works well, but leveraging &lt;code>LD_PRELOAD&lt;/code> is a pretty heavy thing to do because it impacts &lt;em>all&lt;/em> processes. Furthermore, this variable is pretty sensitive so it is probably cleared by many programs at startup time&amp;hellip; which means it can be ineffective.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We can supplant the SSH agent with our own daemon that serves a local socket on a well-known path. This daemon then redirects all SSH agent requests to a working SSH agent socket. The &amp;ldquo;working&amp;rdquo; socket is determined by searching &lt;code>/tmp/&lt;/code> for &lt;em>any&lt;/em> agent socket that the calling user has permissions to open, and using the first one that works. We can start this daemon when the user firsts connects to the remote server, and we can fix up the &lt;code>SSH_AUTH_SOCK&lt;/code> value at login time&amp;mdash;well before any process can cache the wrong value.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>This last solution is what I prototyped in &lt;strong>&lt;a href="https://github.com/jmmv/ssh-agent-switcher/">ssh-agent-switcher&lt;/a>&lt;/strong>. It took me about an hour of evening coding to get this to work, an extra hour to write integration tests and refine the implementation, and a final half hour to set up the GitHub project. It works for me, but don&amp;rsquo;t expect it to be perfect.&lt;/p>
&lt;p>As a side note, I wrote this program in Go&amp;hellip; not because I wanted to, but because it is a necessity due to the context in which I&amp;rsquo;ll probably use this. And you know what, writing Go for this was really fun due to easy APIs, quick iteration, and simple tooling&amp;hellip; But I could only tolerate Go because I had no need to model any kind of structured data: I still find Go to be a bad choice for anything larger in scope where correctness matters.&lt;/p>
&lt;p>Now the question is: is this safe? And the answer is: I think so? The ssh-agent-switcher daemon runs in the context of your user account so it can only access sockets you already have access to. The only risk comes from the creation of the daemon&amp;rsquo;s own Unix socket: if the socket is accessible to anyone else on the remote machine, then that person would be able to access your forwarded agent and leverage the credentials that live on your client machine. I&amp;rsquo;ve taken care to create the socket with tight permissions, but the question remains: is the default location under &lt;code>/tmp/&lt;/code> good-enough? Creating temporary files with predictable names &lt;a href="https://www.netmeister.org/blog/mktemp.html">is generally unsound&lt;/a> because that leaves them subject to hijacking via symlinks&amp;hellip; but in this case, the daemon is creating a Unix domain socket, not a regular file, and I&amp;rsquo;ve not succeeded at stealing it.&lt;/p>
&lt;p>Oh, and by the way, this all explains the warning in the &lt;a href="https://man.openbsd.org/ssh">&lt;code>sshd(1)&lt;/code> manual page&lt;/a> about the use of agent forwarding:&lt;/p>
&lt;blockquote>
&lt;p>Agent forwarding should be enabled with caution. Users with the ability to bypass file permissions on the remote host (for the agent&amp;rsquo;s UNIX-domain socket) can access the local agent through the forwarded connection. An attacker cannot obtain key material from the agent, however they can perform operations on the keys that enable them to authenticate using the identities loaded into the agent. A safer alternative may be to use a jump host (see -J).&lt;/p>
&lt;/blockquote>
&lt;p>If you do not trust the administrator of a remote machine, SSHing into it and forwarding your agent will allow the remote administrator to send requests to your local agent. Be careful out there.&lt;/p></description></item><item><title>Why do I know shell, and how can you?</title><link>https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html</link><pubDate>Fri, 10 Nov 2023 08:00:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html</guid><description>&lt;p>&lt;em>&amp;ldquo;Why do you know so much shell?&amp;rdquo;&lt;/em> is a question I&amp;rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I was &amp;ldquo;forced&amp;rdquo; to write tools in it for a while and, because of that, I made a conscious effort to learn the language and get better at it.&lt;/p>
&lt;p>You see, most people that write shell don&amp;rsquo;t want to deal with it. They stitch together whatever works into a script and call it a day, making a bunch of spaghetti even if it goes against the coding best practices they already know. And when they encounter some odd syntax they don&amp;rsquo;t recognize, their reaction is to say &amp;ldquo;this has to be rewritten in Python!&amp;rdquo; instead of taking a breath and trying to really understand what&amp;rsquo;s going on. It doesn&amp;rsquo;t help that plenty of senior engineers scoff at shell scripts.&lt;/p>
&lt;p>And it is true: the shell is arcane and has many flaws as a programming language. I don&amp;rsquo;t want to convince you to start writing new tools in it. But the shell is also an incredible rapid prototyping language, and you can use it to solve business problems really quickly and with surprisingly little code. If you pause for a second to learn it, you&amp;rsquo;ll realize that you can bend tradition and write maintainable shell code too. Hear out how I got into writing so much shell and how you can get better at it too.&lt;/p>
&lt;h1 id="the-constraints-of-the-bsd-systems">The constraints of the BSD systems&lt;/h1>
&lt;p>In the late 1990s, I discovered Linux and, soon after, the BSDs. I had a brief stint with OpenBSD and FreeBSD at first, but by the early 2000s, I had settled on &lt;a href="https://www.NetBSD.org/">NetBSD&lt;/a> as my daily driver. My dream had always been to create my own operating system, but the more I learned and tried to write one, the more I realized I wasn&amp;rsquo;t up to the task yet. Thus NetBSD was the perfect fit for me: all my hardware worked on it, but the system had enough rough edges that I saw the opportunity to become a contributor to a real operating system.&lt;/p>
&lt;p>NetBSD&amp;mdash;and all the BSDs really&amp;mdash;are full operating system distributions. Unlike Linux, the source code for their kernel, user space tools, and documentation lives in a single source tree (monorepo!) maintained by a single group of developers. This source tree is known as &lt;em>the base system&lt;/em> and every other third-party app comes via the ports system&amp;mdash;or &lt;a href="https://www.pkgsrc.org/">pkgsrc&lt;/a> in NetBSD-specific parlance. If this is hard to imagine, visualize your typical Windows installation: when you perform a fresh install of Windows 7 (not 10 or 11 because these get random junk auto-added), what you get is a collection of software that Microsoft has itself developed and chosen to be the basis to form Windows; everything you add to it later on, be it from Microsoft or other vendors, is not part of that base installation.&lt;/p>
&lt;p>A constraint of this arrangement is that the code in a BSD base system is self-hosting: i.e. the base system must be able to build itself so it must &lt;a href="/2015/10/compilers-in-the-bsd-base-system.html">include the compilers&lt;/a> and interpreters required to build and run its code. In NetBSD during the early 2000s, this meant choosing between C, C++, and shell. Lua has been added as a fourth choice since.&lt;/p>
&lt;p>It is of course possible to write tools for a BSD system in any language that&amp;rsquo;s not in the base system, but doing so means that the tool is relegated to live in the ports system. To make matters worse, the common practice in the BSDs was to build everything from source&amp;mdash;pre-built binary packages existed but were inflexible and usually stale&amp;mdash;and thus users frowned upon heavy dependencies. If your tiny tool required Perl or Python, for example, it would be dead on arrival because of the heavy tax imposed by the interpreter: if I recall correctly, building Perl on my Pentium II took something like 15 minutes, and building it on a 68k Mac I had took hours.&lt;/p>
&lt;h1 id="contributing-tools-to-netbsd">Contributing tools to NetBSD&lt;/h1>
&lt;p>See where this is going? I was the primary maintainer of Gnome 2.x on NetBSD and, as part of this work, I ended writing all sorts of tools to simplify the maintenance of the packages and the system as a whole. I wrote things like &lt;a href="/software/sysbuild.html">sysbuild&lt;/a>, &lt;a href="/software/pkg_comp.html">pkg_comp&lt;/a>, &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/pkgtools/pkg_alternatives/">pkg_alternatives&lt;/a>, &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/pkgtools/dfdisk/">dfdisk&lt;/a>, &lt;a href="/2022/06/autoconf-caching.html">autoswc&lt;/a>, &lt;a href="/software/etcutils.html">etcutils&lt;/a>&amp;hellip; and even &lt;a href="/2022/05/remembering-buildtool.html">my own build system&lt;/a>.&lt;/p>
&lt;p>And to write such tools&amp;hellip; which language could I use? I wanted my tools to feel part of the base system and I didn&amp;rsquo;t want to have to pay the heavy price of Perl or Python. I could have used C, but&amp;hellip; well, let&amp;rsquo;s just say that C is a terrible choice for automation tools. I could have used C++, but people &lt;em>also&lt;/em> hated it for its long compile times and the fact that, back in the pre-C++11 era, it wasn&amp;rsquo;t much better than C and compilers were really bad at supporting standards. And I could use the shell which, as ugly as it was, made programs immediately installable under any of the tens of hardware platforms that NetBSD supported, no matter how slow they were.&lt;/p>
&lt;p>So that&amp;rsquo;s how I ended up writing shell. The shell was the only realistic option I had to write the tools I wanted to write. And you know what? My scripts were bad at first, full of the problems I opened this article with. But with practice, a principled approach to writing shell &lt;del>scripts&lt;/del> programs, and an open mind to see the shell as &amp;ldquo;yet another programming language&amp;rdquo;, it turned out to be not a terrible idea in retrospect.&lt;/p>
&lt;p>My biggest shell program today is probably &lt;a href="/2017/02/introducing-pkg_comp-2.0.html">pkg_comp2&lt;/a>. If I count the lines of its source code plus its two dependencies (&lt;a href="/software/sandboxctl.html">sandboxctl&lt;/a> and &lt;a href="https://shtk.jmmv.dev/">shtk&lt;/a>), it comes to about 15,000 SLOC. More than half of those are unit and integration tests, just as commonly happens in &amp;ldquo;real software&amp;rdquo;, which shows that shell programs can mimic the good development practices of other languages. Just take a moment and skim through &lt;a href="https://github.com/jmmv/pkg_comp/blob/28dc346ade09bd620f1ec3c6ad43b98f412deaa9/pkg_comp.sh">pkg_comp.sh&lt;/a>. Does this look like your regular spaghetti shell code to you?&lt;/p>
&lt;h1 id="how-you-can-get-better-at-the-shell">How you can get better at the shell&lt;/h1>
&lt;p>I could probably write a whole book on this topic&amp;mdash;and I&amp;rsquo;ve thought about doing so&amp;hellip; would you read it?&amp;mdash;but all I can do right now is give you some ideas:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Read about the language.&lt;/strong> The shell is small. Once I decided I wanted to get better at the shell, I just opened the &lt;a href="https://man.netbsd.org/sh.1">&lt;code>sh(1)&lt;/code> manual page&lt;/a> and read it. It will take you less than 1 hour to go through the whole document. You might choose to &lt;em>also&lt;/em> read the Bash manual page&amp;mdash;and you probably should, particularly to become aware of its many &lt;a href="/2021/08/useless-use-of-gnu.html">unnecessary non-standard features&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Familiarize yourself with the Unix toolchain.&lt;/strong> Yes, the shell language is really simple, but that comes at a price: many of the things you want to do will require invoking tools like &lt;code>grep&lt;/code>, &lt;code>sed&lt;/code>, &lt;code>find&lt;/code>&amp;hellip; Which is fine because that&amp;rsquo;s the core idea behind the Unix toolchain&amp;mdash;small, composable tools&amp;mdash;but that means you need to know those tools too. The more tools you know about, the better your scripts will be. Think of these tools as the &amp;ldquo;standard library&amp;rdquo; for the shell. Manual pages are not in fashion&amp;hellip; but getting comfortable in navigating them will prove to be a useful skill.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Understand how process creation (&lt;code>fork&lt;/code> vs. &lt;code>exec&lt;/code>) and &lt;a href="/2020/11/cmdline-args-unix-vs-windows.html">argument passing&lt;/a> work in Unix.&lt;/strong> The shell is primarily designed to interact with subprocesses, so knowing these topics in detail is &lt;em>crucial&lt;/em> to truly understand how quoting, globs, redirections, and pipelines work, and also to understand the difference between built-in and external commands. For example, do you know &lt;a href="/2020/03/test-bracket.html">how &lt;code>test&lt;/code>, &lt;code>[&lt;/code> and &lt;code>[[&lt;/code> differ&lt;/a>?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Write shell scripts following the good programming practices you already know.&lt;/strong> Avoid global variables. Factor code into functions. Minimize side-effects. &lt;a href="/2023/10/unit-testing-with-shtk.html">Write unit and/or integration tests.&lt;/a> And be unconditionally strict: e.g. double-quote all variable expansions to correctly handle whitespace characters, even if in most cases you may not need to do so.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Think in terms of data flow.&lt;/strong> The shell is about combining tools as pipelines, not writing your usual imperative for loops. The more you can reason about solving problems with pipelines, the simpler and more performant your scripts will be. Functional programming FTW!&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Read Google&amp;rsquo;s &lt;a href="https://google.github.io/styleguide/shellguide.html">Shell Style Guide&lt;/a>.&lt;/strong> While I don&amp;rsquo;t necessarily agree with everything it has to say, especially around stylistic details, the &amp;ldquo;Features and bugs&amp;rdquo; and &amp;ldquo;Calling commands&amp;rdquo; sections are particularly interesting.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use &lt;a href="https://www.shellcheck.net/">ShellCheck&lt;/a>.&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>And finally, &lt;strong>take a look at my &lt;a href="/2018/02/shell-readability-main.html">short readability series on the shell&lt;/a> from 2013.&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol></description><enclosure url="https://jmmv.dev/images/2023-11-10-sh-manpage.jpg" length="425378" type="image/jpeg"/></item><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p>
&lt;h1 id="scenario">Scenario&lt;/h1>
&lt;p>To put things in perspective, we&amp;rsquo;ll be adding tests to a trivial demo tool written in C (&lt;em>not&lt;/em> shell) that simply adds two numbers and prints the result to the standard output. You can find all of the code for this scenario under &lt;a href="https://github.com/jmmv/rules_shtk/tree/d490cc9fc43cff3db83d12b5dc1a1c6b90ed50c3/examples/test">&lt;code>rules_shtk/examples/test&lt;/code>&lt;/a>.&lt;/p>
&lt;p>Here is how the demo tool behaves after we build the &lt;code>//:adder&lt;/code> target:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="gp">$&lt;/span> ./bazel-bin/adder &lt;span class="m">123&lt;/span> &lt;span class="m">456&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">The sum of 123 and 456 is 579
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="gp">$&lt;/span> ./bazel-bin/adder
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder: Requires two integer arguments
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="gp">$&lt;/span> ./bazel-bin/adder &lt;span class="m">10000000&lt;/span> &lt;span class="m">345&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder: Invalid first operand: out of range
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Our mission is to add an &lt;code>//:adder_test&lt;/code> target that depends on &lt;code>//:adder&lt;/code> and that exercises the tool &lt;em>exactly as when a user runs it by hand&lt;/em>. We&amp;rsquo;ll create an &lt;code>adder_test.sh&lt;/code> file that uses the &lt;a href="/2023/10/unit-testing-with-shtk.html">shtk testing library&lt;/a> and hook it into the build as an &lt;code>shtk_test&lt;/code> target.&lt;/p>
&lt;h1 id="depending-on-rules_shtk">Depending on rules_shtk&lt;/h1>
&lt;p>&lt;code>rules_shtk&lt;/code> is a shiny new ruleset (released just yesterday) and because Bazel 7 is around the corner, I&amp;rsquo;ve opted to go all in for &lt;a href="https://bazel.build/external/overview#bzlmod">bzlmod&lt;/a>. Thanks to bzlmod, setting up a project to use these rules is trivial. All you need is to add the following line to your &lt;code>MODULE.bazel&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Add this to MODULE.bazel.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">bazel_dep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;rules_shtk&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;1.7&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; but you&amp;rsquo;ll need to wait until &lt;a href="https://github.com/bazelbuild/bazel-central-registry/pull/1095">bazelbuild/bazel-central-registry#1095&lt;/a> is reviewed and merged. (I don&amp;rsquo;t understand why this choke point exists in the new bzlmod ecosystem; Rust&amp;rsquo;s crates.io doesn&amp;rsquo;t have it, for example.)&lt;/p>
&lt;p>In the meantime, or if you are not yet ready to upgrade to bzlmod, you can obviously use the old-fashioned and yucky &lt;code>WORKSPACE.bazel&lt;/code> file to pull &lt;code>rules_shtk&lt;/code> in:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Add this to WORKSPACE or WORKSPACE.bazel if you don&amp;#39;t use bzlmod yet.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;@bazel_tools//tools/build_defs/repo:http.bzl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;http_archive&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_archive&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;bazel_skylib&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sha256&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;66ffd9315665bfaafc96b52278f57c7e2dd09f5ede279ea6d39b2be471e7e3aa&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.4.2/bazel-skylib-1.4.2.tar.gz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;https://github.com/bazelbuild/bazel-skylib/releases/download/1.4.2/bazel-skylib-1.4.2.tar.gz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;@bazel_skylib//:workspace.bzl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;bazel_skylib_workspace&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">bazel_skylib_workspace&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_archive&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;rules_shtk&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sha256&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;fa47891f27d8d59609732b34dc88020331b81b9767cbd72094fec1be8af4adfc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;https://github.com/jmmv/rules_shtk/releases/download/rules_shtk-1.7.0/rules_shtk-1.7.0.tar.gz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">strip_prefix&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;rules_shtk-1.7.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="requesting-an-shtk-toolchain">Requesting an shtk toolchain&lt;/h1>
&lt;p>Once you have added &lt;code>rules_shtk&lt;/code> to your project, either via bzlmod or the &lt;code>WORKSPACE.bazel&lt;/code>, you need to tell Bazel which shtk toolchain to use:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Add this to WORKSPACE or WORKSPACE.bazel.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;@rules_shtk//:repositories.bzl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;shtk_dist&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">shtk_dist&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The parameterless &lt;code>shtk_dist&lt;/code> macro makes Bazel download &lt;a href="https://github.com/jmmv/shtk/releases/tag/shtk-1.7">shtk 1.7&lt;/a> (because we requested the 1.7.x rules) and puts it to use for all tests that we later build. You cannot configure which version of shtk to download because, so far, all shtk versions are backwards-compatible and this won&amp;rsquo;t change in the 1.x series.&lt;/p>
&lt;p>There is also an &lt;code>shtk_sytem&lt;/code> macro that makes Bazel discover the shtk toolchain installed in the system, say via your local package manager. This does not make sense for our use case (because we are only running tests within Bazel), but it can be useful if you want to build a script with &lt;code>shtk_binary&lt;/code> that can later be taken out of &lt;code>bazel-bin&lt;/code> and installed into the host system.&lt;/p>
&lt;h1 id="writing-the-test-rule">Writing the test rule&lt;/h1>
&lt;p>We now have the rules and a toolchain in place so we can proceed to add an &lt;code>shtk_test&lt;/code> target. Our goal is to test &lt;code>adder.c&lt;/code> with a new &lt;code>adder_test.sh&lt;/code> sibling file, so we can put the test target next to the binary target:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;@rules_shtk//:rules.bzl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;shtk_test&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cc_binary&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;adder&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;adder.c&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">shtk_test&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;adder_test&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">src&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;adder_test.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;:adder&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are different opinions on where tests should live but, personally, I want them as close to the code they test as possible. This makes tests discoverable when editing code, which increases the odds that developers will remember to update them. Also, nobody likes dealing with parallel deep directory hierarchies when working on a piece of code&amp;hellip; thank you, &lt;code>java&lt;/code> and &lt;code>javatests&lt;/code>.&lt;/p>
&lt;h1 id="writing-the-test-program">Writing the test program&lt;/h1>
&lt;p>All that&amp;rsquo;s left to do is an &lt;a href="https://en.wikipedia.org/wiki/Small_matter_of_programming">SMOP&lt;/a>. We need to write the tests in &lt;code>adder_test.sh&lt;/code>. Here are just a couple of examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># This is a portion of adder_test.sh.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">shtk_import unittest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">shtk_unittest_add_test addition_works
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">addition_works_test&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expect_command &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -o inline:&lt;span class="s2">&amp;#34;The sum of 2 and 3 is 5\n&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> ../adder &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">shtk_unittest_add_test bad_arguments
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bad_arguments_test&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expect_command &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -s &lt;span class="m">1&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -e inline:&lt;span class="s2">&amp;#34;adder: Requires two integer arguments\n&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> ../adder
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I don&amp;rsquo;t want to dive into the shtk APIs too much, but I want to highlight the &lt;code>expect_command&lt;/code> calls in here. This assertion is the salient feature of shtk&amp;rsquo;s unit-testing module and is what makes testing tools a breeze. Take a look at the &lt;a href="https://shtk.jmmv.dev/shtk_unittest_assert_command.3.html">&lt;code>assert_command&lt;/code>&lt;/a> and &lt;a href="https://shtk.jmmv.dev/shtk_unittest_assert_file.3.html">&lt;code>assert_file&lt;/code>&lt;/a> documentation to demystify the &lt;code>-s&lt;/code>, &lt;code>-o&lt;/code>, and &lt;code>-e&lt;/code> flags shown above.&lt;/p>
&lt;p>One thing that needs explaining is the &lt;code>../adder&lt;/code> reference to the tool. If we look at the runfiles tree that Bazel creates when building the &lt;code>//:adder_test&lt;/code> target, we see:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="gp">$&lt;/span> ls -l bazel-bin/adder_test.runfiles/_main/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">total 8K
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">lrwxrwxrwx. 1 jmmv jmmv 116 Nov 4 06:17 adder -&amp;gt; /home/jmmv/.cache/bazel/_bazel_jmmv/916b9cbf147e00ff01b88519fdb0f294/execroot/_main/bazel-out/k8-fastbuild/bin/adder
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">lrwxrwxrwx. 1 jmmv jmmv 121 Nov 4 06:17 adder_test -&amp;gt; /home/jmmv/.cache/bazel/_bazel_jmmv/916b9cbf147e00ff01b88519fdb0f294/execroot/_main/bazel-out/k8-fastbuild/bin/adder_test
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are no directories in there. So, where does that &lt;code>..&lt;/code> come from in the &lt;code>../adder&lt;/code> reference? Well&amp;hellip; shtk&amp;rsquo;s unit-testing execution engine creates a disposable subdirectory for each test it runs. The reason for this is that, when writing shell tests, it is extremely common to have to create auxiliary files, and shtk accounts for that by cleaning up whichever files you create in the current directory of a test. This is a little oddity you&amp;rsquo;ll have to keep in mind.&lt;/p>
&lt;h1 id="running-the-test">Running the test&lt;/h1>
&lt;p>All done. We can finally run the end-to-end test for our demo tool:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="gp">$&lt;/span> bazel &lt;span class="nb">test&lt;/span> --nocache_test_results --test_output&lt;span class="o">=&lt;/span>streamed //:adder_test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">WARNING: Streamed test output requested. All tests will be run locally, without sharding, one at a time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">INFO: Analyzed target //:adder_test (0 packages loaded, 139 targets configured).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">INFO: Found 1 test target...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing addition_works...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 2 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder -12345 12345
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing addition_works... PASSED
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_first_operand...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 123456789 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 123x 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder -123456789 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_first_operand... PASSED
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_second_operand...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 0 123456789
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 0 123x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 0 -123456789
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_second_operand... PASSED
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_arguments...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Running checked command: ../adder 1 2 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Testing bad_arguments... PASSED
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">adder_test: I: Ran 4 tests; ALL PASSED
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">Target //:adder_test up-to-date:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go"> bazel-bin/adder_test
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">INFO: Elapsed time: 0.504s, Critical Path: 0.33s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">INFO: 2 processes: 2 linux-sandbox.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">INFO: Build completed successfully, 2 total actions
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">//:adder_test PASSED in 0.2s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="go">Executed 1 out of 1 test: 1 test passes.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>As much hate as &amp;ldquo;large&amp;rdquo; shell scripts get, the shell is a uniquely-positioned language to help you write end-to-end tests for your tools. After all, the shell is what you use to &lt;em>run&lt;/em> those precious tools, so the shell is also what you should use to run them in an automated fashion for testing purposes.&lt;/p>
&lt;p>It&amp;rsquo;s your turn now. Go read the &lt;a href="https://shtk.jmmv.dev">online documentation&lt;/a> for shtk, the previous introductory blog post, and get testing! Your users will be much happier if your tools offer excellent interfaces. And if you need ideas on what to test or how to improve the interface of your tools, take a look at the &lt;a href="/series.html#CLI design">CLI design series&lt;/a> from 2013.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item></channel></rss>