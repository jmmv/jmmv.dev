<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/</link><description>Recent content on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 09 Mar 2024 09:50:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>How "new type" helps avoid production outages</title><link>https://jmmv.dev/2024/03/new-type-and-production-outages.html</link><pubDate>Sat, 09 Mar 2024 09:50:00 -0700</pubDate><guid>https://jmmv.dev/2024/03/new-type-and-production-outages.html</guid><description>&lt;p>My &lt;a href="/2024/01/links-january-2024-edition.html">January links recap&lt;/a> included the &lt;a href="https://experimentalworks.net/posts/2024-01-22-simple-phantom-types/">&amp;ldquo;Phantom Types&amp;rdquo;&lt;/a> article by David Soria Parra. In it, the author briefly touches upon the &amp;ldquo;new type&amp;rdquo; idiom, its typical implementation in Rust, and then proceeds to propose a better alternative. But the question arises: why should you care?&lt;/p>
&lt;p>To answer why this idiom is useful, I want to present you with a real production problem we faced in the Storage Infrastructure team at Google circa 2010. That issue made me a convert and I&amp;rsquo;ve kept it in mind when designing APIs since then.&lt;/p>
&lt;h1 id="what-is-new-type-anyway">What is &amp;ldquo;new type&amp;rdquo; anyway?&lt;/h1>
&lt;p>The &lt;a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html">&amp;ldquo;new type&amp;rdquo; idiom&lt;/a> is a programming pattern whereby you define domain-specific types to wrap native types. Then, you use those types in your code and only &amp;ldquo;lower&amp;rdquo; them to their underlying types when passing the values to any external APIs.&lt;/p>
&lt;p>More specifically, your public interfaces&amp;mdash;but also private methods and functions&amp;mdash;should never receive primitive types like integers or strings. A function like &lt;code>allow_write(username: String, size: usize)&lt;/code> should not exist in your code base.&lt;/p>
&lt;p>Instead, what you&amp;rsquo;d do is define two new types, &lt;code>Username&lt;/code> and &lt;code>Size&lt;/code>, that wrap the string and integer values. These types are trivial wrappers over the native types (e.g. &lt;code>struct Username(String)&lt;/code> and &lt;code>struct Size(usize)&lt;/code>) with the goal of making them zero-cost abstractions.&lt;/p>
&lt;p>However, as David&amp;rsquo;s article describes, this simplistic way to implement the pattern lends itself to code duplication for every type. And, as you know, code duplication leads to slight inconsistencies over time, which may increase maintenance costs.&lt;/p>
&lt;p>But this is not relevant now. &amp;ldquo;New type&amp;rdquo; is &amp;ldquo;new type&amp;rdquo; no matter how you implement it and no matter which language you choose. What I want to showcase here is &lt;em>why&lt;/em> adopting this pattern helps at all. And, for that, it&amp;rsquo;s time to dive into the story.&lt;/p>
&lt;h1 id="quota-management-outage">Quota management outage&lt;/h1>
&lt;p>Back in the early days of the Storage Infrastructure at Google, we the SRE team managed tens of shared file system deployments (aka &lt;em>cells&lt;/em>). Those file systems were multi-user and had support for quotas&amp;mdash;like pretty much any file system worthy of consideration.&lt;/p>
&lt;p>Storage quotas are typically expressed as two quantities: a &lt;em>bytes quota&lt;/em>, which says how much disk space a user can use; and a &lt;em>files quota&lt;/em>, which says how many files a user can store. Tracking byte usage limits disk usage and tracking file usage limits metadata overhead.&lt;/p>
&lt;p>Now, even with the replicated and zonal system that Google had, it was convenient to &lt;em>manage&lt;/em> user quotas in a centralized way. So that&amp;rsquo;s what we also had: the equivalent of a MySQL database tracking how much quota each user had allocated in which cell, world-wide.&lt;/p>
&lt;p>So far so good. But how do you keep the decentralized storage cells decoupled from the quota database? Easy! Via a cron job that reads the quotas and pushes them to cluster-local &amp;ldquo;configuration&amp;rdquo; files so that each cell doesn&amp;rsquo;t need to know about the central database.&lt;/p>
&lt;p>Of course, this cron job is code. And code has bugs. So here is what happened: there was some function somewhere that looked like this: &lt;code>set_quota(user: String, bytes: usize, files: usize)&lt;/code>. And, for whatever reason, a caller invoked it as &lt;code>set_quota(user, files, bytes)&lt;/code>.&lt;/p>
&lt;p>Notice the problem? The caller swapped the arguments but the language did not flag this issue and&amp;hellip; the tests didn&amp;rsquo;t catch it either! It&amp;rsquo;s unfortunately too common for people to write the same sentinel values (&lt;code>set_quota(&amp;quot;foo&amp;quot;, 100, 100)&lt;/code>) for different test arguments.&lt;/p>
&lt;p>Soon after this change was checked in, the code rolled out to production and&amp;hellip; of course, the moment it touched the first canary deployment, things went south. Users started receiving out of quota alerts even when they should have had, in theory, plenty of available quota.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="the-aftermath">The aftermath&lt;/h1>
&lt;p>The fix to the above was trivial: swap the arguments in the problematic caller and call it a day. But that&amp;rsquo;s a naÃ¯ve fix. It just corrects the immediate problem but does not minimize the chances of it happening again. That is: this change is a &lt;em>mitigation&lt;/em>, not a &lt;em>fix&lt;/em>.&lt;/p>
&lt;p>In good SRE fashion, the team went a bit further to prevent this issue from ever recurring. They adopted the &amp;ldquo;new type&amp;rdquo; pattern, created two separate types&amp;mdash;&lt;code>BytesQuota&lt;/code> and &lt;code>FilesQuota&lt;/code>&amp;mdash;and plumbed them through the whole program. And note: Rust wasn&amp;rsquo;t really a thing in 2010.&lt;/p>
&lt;p>Furthermore, the team contributed an entry to the &lt;a href="https://testing.googleblog.com/2007/01/introducing-testing-on-toilet.html">Testing on the Toilet blog&lt;/a>, describing the issue and how this same problem had &lt;em>just&lt;/em> bitten a major financial company and had made them lose millions of dollars.&lt;/p>
&lt;p>And that&amp;rsquo;s the simple story of the day. Please adopt the new type pattern. Future-you will be happy that you did when the compiler or language interpreter yells at you about something that&amp;rsquo;s obviously wrong.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-03-09-new-types-store.jpg" length="552435" type="image/jpeg"/></item><item><title>Links: February 2024 edition</title><link>https://jmmv.dev/2024/02/links-february-2024-edition.html</link><pubDate>Thu, 29 Feb 2024 08:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/links-february-2024-edition.html</guid><description>&lt;p>Hi folks! Another month has passed so it&amp;rsquo;s time for a brief recap of the main news, articles, and projects that made the rounds during this period and are on topic for Blog System/5.&lt;/p>
&lt;p>As usual, this is not just a list: every entry is accompanied by a short blurb detailing why I found the content interesting, which is meant to nudge you into reading it! Also, the list is ordered by when the links made it my way, not chronologically, and some items are &lt;em>not&lt;/em> from this time period.&lt;/p>
&lt;p>Let&amp;rsquo;s get to it.&lt;/p>
&lt;h1 id="the-links">The links&lt;/h1>
&lt;p>&lt;strong>&lt;a href="https://theretroweb.com/">&amp;ldquo;The Retro Web&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>&lt;/p>
&lt;p>An impressive database of old hardware with tons of details about motherboards, processors, chipsets, hard disks&amp;hellip; Even more impressive, but not unexpectedly, is that this is entirely maintained by volunteers. Be careful to not get lost.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://developers.redhat.com/blog/2021/01/05/building-red-hat-enterprise-linux-9-for-the-x86-64-v2-microarchitecture-level#">&amp;ldquo;Building Red Hat Enterprise Linux 9 for the x86-64-v2 microarchitecture level&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Florian Weimer on January 5th, 2021&lt;/em>&lt;/p>
&lt;p>The &lt;a href="https://news.ycombinator.com/item?id=39250609">Hacker News thread&lt;/a> discussing the &lt;a href="https://www.gentoo.org/news/2024/02/04/x86-64-v3.html">&amp;ldquo;Gentoo x86-64-v3 binary packages available&amp;rdquo;&lt;/a> article made me wonder what exactly the &lt;code>v3&lt;/code> suffix after the &lt;code>x86-64&lt;/code> architecture name was about. Fortunately, a helpful reply from &lt;code>dtech&lt;/code> pointed to this other article that explains where these version suffixes came from.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://www.abortretry.fail/p/the-berkley-software-distribution">&amp;ldquo;The Berkley Software Distribution&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Bradford Morgan White on February 4th, 2024&lt;/em>&lt;/p>
&lt;p>Unix has a long story and, if you are interested in it at all, this is a great piece describing how BSD came to be. Most of the text is focused on the pre-FreeBSD and pre-NetBSD days though, so we are talking about some really old history here!&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2024/02/beyond-the-1-mb-barrier-in-dos.html">&amp;ldquo;Beyond the 1 MB barrier in DOS&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on February 7th, 2024&lt;/em>&lt;/p>
&lt;p>Last month, I gave you a detailed explanation of how DOS applications pulled &lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">all sorts of tricks&lt;/a> to maximize the usage of the first MB of the 80286+ address space. In this one, I continue the exploration to see how some DOS apps (particularly games) broke free from those limitations and moved into external memory.&lt;/p>
&lt;p>For a richer discussion, you can see the coverage in &lt;a href="https://www.osnews.com/story/138541/beyond-the-1-mb-barrier-in-dos/">OSNews&lt;/a> and &lt;a href="https://hackaday.com/2024/02/09/breaking-through-the-1-mb-barrier-in-dos-with-unreal-mode-and-more/">Hackaday&lt;/a> among the other usual places. That said, it looks like I pretty much drained the pool of people interested in this topic: the discussions are pretty quiet on this second post and the number of subscribers to Blog System/5 got a bump, but a small one.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://cep.dev/posts/every-infrastructure-decision-i-endorse-or-regret-after-4-years-running-infrastructure-at-a-startup/">&amp;quot;(Almost) Every infrastructure decision I endorse or regret after 4 years running infrastructure at a startup&amp;quot;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Jack Lindamood on February 1st, 2024&lt;/em>&lt;/p>
&lt;p>Good reflections on the technical decisions made at a start up and how they turned up after four years. We need more of these sorts of introspective posts: many times, people in tech make decisions, stick around for a year or two, and then leave for &lt;del>greener pastures&lt;/del> higher comp without witnessing the impact that their choices had long-term. I&amp;rsquo;ve seen this play out repeatedly and&amp;hellip; I&amp;rsquo;m probably at fault too.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://spectrum.ieee.org/lean-software-development">&amp;ldquo;A 2024 plea for lean software&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Bert Hubert on February 8th, 2024&lt;/em>&lt;/p>
&lt;p>It is easy to dunk on the bloat of modern software&amp;mdash;and you &lt;em>should&lt;/em> dunk on it because the current state of affairs is &lt;em>terrible&lt;/em>&amp;mdash;but this article takes an interesting look at the problem by focusing on security. Or, rather, lack thereof&amp;hellip; because the massive amounts of code we have to run even for the simplest tasks leave us open to unpredictable security holes.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://ounapuu.ee/posts/2024/02/12/fosdem-2024/">&amp;ldquo;FOSDEM 2024: my experience, some notes and tech tips&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Herman Ãunapuu on February 12th, 2024&lt;/em>&lt;/p>
&lt;p>Very detailed trip report to FOSDEM from a first timer. It&amp;rsquo;s really long but it&amp;rsquo;ll make you feel like you missed out for not going. A lot of the advice in it &lt;a href="/2020/02/fosdem-navigation-101.html">matches what I wrote&lt;/a> back in 2020 during my first (and only so far) time there as well.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://chimera-linux.org/">&amp;ldquo;Chimera Linux&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>&lt;/p>
&lt;p>This Linux distribution sounds very appealing because it is very non-conformant&amp;mdash;no glibc, GCC nor systemd&amp;mdash;and leverages core system components from FreeBSD. A tweet from @unixterminal shows &lt;a href="https://twitter.com/unixterminal/status/1756782019663606070">how to set it up under WSL&lt;/a>, which means it&amp;rsquo;s super-easy to test-run it if you happen to be on Windows. I haven&amp;rsquo;t tried yet, but if you have some time, there goes an idea.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://antithesis.com/blog/is_something_bugging_you/">&amp;ldquo;Is something bugging you?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Will Wilson on February 13th, 2024&lt;/em>&lt;/p>
&lt;p>I&amp;rsquo;m a believer in automated and comprehensive testing. I often hear that you should &lt;em>not&lt;/em> write tests for short-lived projects or during quick initial growth&amp;mdash;and I think such advice is just plain wrong. Tests &lt;em>do&lt;/em> slow you down at the very beginning of a greenfield project, but they pay dividends after just two weeks of full-time coding.&lt;/p>
&lt;p>This article describes how the creators of FoundationDB reached the same conclusion because they developed and leveraged a solid infrastructure to run their software in a reproducible manner. They, in turn, turned this idea into a product&amp;mdash;which means that the article is an ad, but it won&amp;rsquo;t feel like it. Promise.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://blog.jgc.org/2024/02/the-original-www-proposal-is-word-for.html">&amp;ldquo;The original WWW proposal is a Word for Macintosh 4.0 file from 1990, can we open it?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By John Graham-Cumming on February 13th, 2024&lt;/em>&lt;/p>
&lt;p>An interesting story in trying to open an old document from 1990 and render it in its original format. Contemporary tools like LibreOffice or Word are still able to open it, but they don&amp;rsquo;t load diagrams properly.&lt;/p>
&lt;p>This is why I &lt;a href="/2016/01/medium-experiment-wrapup.html">made the choice&lt;/a> a long time ago to avoid Blogger and Medium and, even if you are now reading this in Substack, why I still author the originals in Markdown and store them in a Git repository.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2024/02/djgpp.html">&amp;ldquo;Running GNU on DOS with DJGPP&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on February 14th, 2024&lt;/em>&lt;/p>
&lt;p>Following up on the earlier two articles describing how DOS apps managed memory and dealt with the limitations of real mode, I was finally able to write about how DJGPP achieves those goals &lt;em>and also&lt;/em> makes GNU programs run on DOS. If you picture DJGPP as the &amp;ldquo;WSL for DOS&amp;rdquo;&amp;hellip; you aren&amp;rsquo;t too far off. Mind you, the article will show you bash running on DOS, but the content is primarily about the internals on how DJ achieved such feat.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://github.com/Speykious/cve-rs">&amp;ldquo;cve-rs: Blazingly ð¥ fast ð memory vulnerabilities, written in 100% safe Rust&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Speykious on February 15th, 2024&lt;/em>&lt;/p>
&lt;p>Big news everyone! Rust is finally able to replace C and C++ because, thanks to this little library, you can now implement memory vulnerabilities too! Don&amp;rsquo;t miss out on the new GLWTSPL license either, which you&amp;rsquo;ll have to assess for compatibility with your own before you can incorporate the code.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2024/02/to-c-or-not-to-c.html">&amp;ldquo;To C or not to C&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on February 21st, 2024&lt;/em>&lt;/p>
&lt;p>An article disguised as a Twitter thread where I joined the ongoing &lt;del>discussion&lt;/del> argument in the platform on whether knowing C is a prerequisite for being called a &amp;ldquo;good programmer&amp;rdquo;. Spoiler alert: it is &lt;em>not&lt;/em>, but what C teaches you is very useful no matter what language you use.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://twitter.com/awesomekling/status/1761305126604550496">&amp;ldquo;Ladybird browser can load VSCode&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Andreas Kling on February 24th, 2024&lt;/em>&lt;/p>
&lt;p>This is not an article but a mere comment from Andreas showing how the &lt;a href="https://ladybird.dev/">Ladybird&lt;/a> browser, a from-scratch implementation of the web, can now load VSCode. Most of it doesn&amp;rsquo;t work, but some does.&lt;/p>
&lt;p>The reason I find this interesting is that it shows how much a small group of motivated developers can achieve in a short amount of time. &amp;ldquo;Nobody&amp;rdquo; believed that it was possible to implement a modern web browser from scratch in this day and age&amp;hellip; and Ladybird is proving that wrong. Back in my time in the Bazel team, I always said that Bazel&amp;rsquo;s demise would be a motivated grad student with lots of free time creating a truly open and small build system written in a systems language. The reason I believe this is possible is because I almost had that going on years before Bazel even existed&amp;hellip; but I lacked the expertise to push it forward. Check out &lt;a href="/2022/05/remembering-buildtool.html">the Buildtool rememberance article&lt;/a> for context.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://freebsdfoundation.org/blog/the-january-february-2024-issue-of-the-freebsd-journal-is-here/">&amp;ldquo;The January/February 2024 Issue of the FreeBSD Journal is Here!&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>On February 28th, 2024&lt;/em>&lt;/p>
&lt;p>This is fresh off the press so I haven&amp;rsquo;t had a chance to read through it yet (other than for the opening Foundation Letter). However, I still hold FreeBSD and NetBSD close to my heart and felt that this deserves a shout out. In particular because the content is now free and they dropped that weird web/mobile app they were using in favor of publishing directly as HTML and PDF.&lt;/p>
&lt;p>Maybe someday I&amp;rsquo;ll have time to go back to contributing to the BSDs&amp;hellip; but I do have some exciting news coming up about ATF and Kyua. Stay tuned.&lt;/p>
&lt;h1 id="parting-words">Parting words&lt;/h1>
&lt;p>And that&amp;rsquo;s all for this month. I know the list is shorter this time around, in part because the noise around AI has eclipsed everything else and in part because I do want to focus on other projects. I&amp;rsquo;m happy to have picked up &lt;a href="https://www.endbasic.dev/">EndBASIC&lt;/a> again and some goodies are coming up soon:&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">One last demo before I throw all the prototype console code away and rewrite it âcorrectlyâ. Itâll take âjustâ a bit more than the 2 hours I spent this morning on this, but itâs the only way to properly implement all necessary features with the right performance. &lt;a href="https://t.co/a2RihbE87U">pic.twitter.com/a2RihbE87U&lt;/a>&lt;/p>&amp;mdash; Julio Merino (@jmmv) &lt;a href="https://twitter.com/jmmv/status/1762305223891267627?ref_src=twsrc%5Etfw">February 27, 2024&lt;/a>&lt;/blockquote> &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>But don&amp;rsquo;t worry. Anything that comes up from this work will definitely deserve some article in Blog System/5. So don&amp;rsquo;t forget to subscribe and have fun reading all of the above!&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description><enclosure url="https://jmmv.dev/images/2024-02-29-links.jpg" length="243606" type="image/jpeg"/></item><item><title>To C or not to C</title><link>https://jmmv.dev/2024/02/to-c-or-not-to-c.html</link><pubDate>Wed, 21 Feb 2024 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/to-c-or-not-to-c.html</guid><description>&lt;p>Over the last few days, there has been this&amp;hellip; debate over at Twitter sparked by a claim that you cannot be a good programmer without knowing C. You obviously can be one, but there is some nuance in what &amp;ldquo;knowing&amp;rdquo; C is truly about. Here is my take on the matter.&lt;/p>
&lt;p>Let me repeat this first: of course you can be a perfectly good programmer without knowing C. Knowing &lt;em>a language&lt;/em> doesn&amp;rsquo;t make or break a programmer, and there are great programmers out there that don&amp;rsquo;t touch C. &lt;em>However&lt;/em>, knowing C says something about your &lt;em>journey&lt;/em>.&lt;/p>
&lt;p>If you know C well, it means you&amp;rsquo;ve dealt with pointers and managed memory by hand. It probably also means you know the difference between system calls and library calls. And it might also mean that you know about FFI. Let&amp;rsquo;s look at this trinity and why these are important.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>ð§  First, memory.&lt;/strong> When learning C, you must deal with pointers, &lt;code>malloc&lt;/code>, and &lt;code>free&lt;/code>, and you must learn how these are put to use. You also may learn how to debug a segfault and probably use tools like Valgrind to find memory errors.&lt;/p>
&lt;p>None of this is trivial. Saying that &amp;ldquo;a pointer is just a memory address; what&amp;rsquo;s difficult in that!?&amp;rdquo; misses the point (get it?). Knowing what a thing &lt;em>is&lt;/em> is really different from knowing how to &lt;em>use&lt;/em> that thing. I covered something similar back in &lt;a href="/2020/04/rust-into-trait.html">my post about Rust&amp;rsquo;s Into trait&lt;/a>.&lt;/p>
&lt;p>But more importantly, pointers and memory management are not a &amp;ldquo;C thing&amp;rdquo;. These concepts show up in pretty much &lt;em>any&lt;/em> language. For example, both Java and Python differentiate primitive types from objects&amp;hellip; and, guess what, object references are essentially pointers.&lt;/p>
&lt;p>Without knowing pointers, it&amp;rsquo;s hard to reason about pass-by-value vs. pass-by-reference semantics. Without knowing memory management, you can&amp;rsquo;t easily tell whether your code makes a reasonable use of memory.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>ð£ Second, system calls vs. library functions.&lt;/strong> For example, how do &lt;code>read&lt;/code> and &lt;code>fread&lt;/code> differ? They are &lt;em>not&lt;/em> the same thing and using them interchangeably can lead to performance problems. Reading bytes one by one with &lt;code>read&lt;/code> is very inefficient but isn&amp;rsquo;t with &lt;code>fread&lt;/code>.&lt;/p>
&lt;p>When learning C, you often have to read manpages because they are the primary source of documentation for the C APIs. In doing so, you probably have noticed that certain manpages are in section 2 (system calls) and others are in section 3 (library functions).&lt;/p>
&lt;p>Every language must issue system calls but not all languages expose them as clearly as C does. The distinction exists in higher level languages but it is more subtle. If you aren&amp;rsquo;t careful, you can introduce performance problems like the one in &lt;a href="/2019/03/optimizing-tree-deletions.html">my post on deleting directory hierarchies&lt;/a>.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>âï¸ Third, the Foreign Function Interface (FFI).&lt;/strong> Almost every language in your system has to end up calling into the C library to execute system calls. If you have learned C, you have probably also learned about stack frames and how a binary (ELF or whatnot) is put together.&lt;/p>
&lt;p>This knowledge is useful because, as I said, every language&amp;mdash;except for the stubborn Go&amp;mdash;has to talk to C for certain operations. And this interface &lt;a href="/2023/12/strings-encodings-nuls-and-bazel.html">isn&amp;rsquo;t always zero cost&lt;/a>. Knowing the costs helps write more efficient code.&lt;/p>
&lt;hr>
&lt;p>ð¡ So there they are. The three major topics that you are likely familiar with just by knowing C well. Of course you can be a good programmer without knowing these topics deeply, but being familiar with these will help you engineer better systems.&lt;/p>
&lt;p>Paraphrasing Joel Spolksy&amp;rsquo;s article titled &lt;a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">&amp;ldquo;The perils of JavaSchools&amp;rdquo;&lt;/a> from 2005: there are only two types of programmers: those that know pointers (and recursion), and those that don&amp;rsquo;t.&lt;/p>
&lt;p>This aligns with my experience after interviewing 100+ candidates: there is a stark contrast between those that don&amp;rsquo;t known anything about memory management and those that do. I couldn&amp;rsquo;t care less about what language you choose, but I want to see if you know how things work.&lt;/p>
&lt;p>Because, remember: these three topics have nothing to do with C per se: they are concepts that apply to almost any language. For example, you also deal with memory in Rust via &lt;code>Box&lt;/code>, but a &lt;code>Box&lt;/code> is is more opaque than explicit &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> calls.&lt;/p>
&lt;p>So: don&amp;rsquo;t be worried if you don&amp;rsquo;t know C, but also don&amp;rsquo;t be afraid to learn it! Just, please, don&amp;rsquo;t use it to start any new project. Keep C to yourself as a learning exercise, or leverage it as a tool to deal with legacy codebases.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-21-to-c-or-not-to-c.png" length="326255" type="image/jpeg"/></item><item><title>Running GNU on DOS with DJGPP</title><link>https://jmmv.dev/2024/02/djgpp.html</link><pubDate>Wed, 14 Feb 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/djgpp.html</guid><description>&lt;p>The recent deep dive into &lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">the IDEs of the DOS times 30 years ago&lt;/a> made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.&lt;/p>
&lt;p>I remember using DJGPP back in the 1990s before I had been exposed to Linux and feeling that it was a strange beast. Compared to the Microsoft C Compiler and Turbo C++, the tooling was bloated and alien to DOS, and the resulting binaries were huge. But DJGPP provided a complete development environment &lt;em>for free&lt;/em>, which I got from a monthly magazine, and I could even look at its source code if I wished. You can&amp;rsquo;t imagine what a big deal that was at the time.&lt;/p>
&lt;p>But even if I could look under the cover, I never did. I never really understood why was DJGPP so strange, slow, and huge, or why it even existed. Until now. As I&amp;rsquo;m in the mood of looking back, I&amp;rsquo;ve spent the last couple of months figuring out what the foundations of this software were and how it actually worked. Part of this research has resulted in the previous two posts on DOS memory management. And part of this research is this article. Let&amp;rsquo;s take a look!&lt;/p>
&lt;p>&lt;em>Special thanks go to DJ Delorie himself for reviewing a draft of this article. Make sure to &lt;a href="https://delorie.com/">visit his website&lt;/a> for DJGPP and a lot more cool stuff!&lt;/em>&lt;/p>
&lt;h1 id="what-is-djgpp">What is DJGPP?&lt;/h1>
&lt;p>Simply put, DJGPP is a port of the GNU development tools to DOS. You would think that this was an easy feat to achieve given that other compilers did exist for DOS. However&amp;hellip; you should know that Richard Stallman (RMS)&amp;mdash;the creator of GNU and GCC&amp;mdash;thought that GCC, a 32-bit compiler, was too big to run on a 16-bit operating system restricted to 1 MB of memory. DJ Delorie took this as a challenge in 1989 and, with all the contortions that we shall see below, made GCC and other tools like GDB and Emacs work on DOS.&lt;/p>
&lt;p>To a DOS and Windows user, DJGPP was, and still is, an alien development environment: the tools&amp;rsquo; behavior is strange compared to other DOS compilers, and that&amp;rsquo;s primarily due to their Unix heritage. For example, as soon as you start using DJGPP, you realize that flags are prefixed by a dash instead of a slash, paths use forward slashes instead of backward slashes, and the files don&amp;rsquo;t ship in a flat directory structure like most other programs did. But hey, all the tools worked and, best of all, they were free!&lt;/p>
&lt;p>In fact, from reading about &lt;a href="https://www.delorie.com/djgpp/doc/eli-m17n99.html#Introduction">the historical goals of the project&lt;/a>, I gather that a secondary goal was for DJ to evangelize free software to as many people as possible, meeting them where they already were: PC users with a not-very-powerful machine that ran DOS. Mind you, this plan worked on some of us as we ended up moving to Linux and the free software movement later on.&lt;/p>
&lt;p>In any case, being a free alien development environment doesn&amp;rsquo;t explain why it had to be huge and slow compared to other others. To explain this, we need to look at the &amp;ldquo;32-bit compiler&amp;rdquo; part.&lt;/p>
&lt;h1 id="dos-and-hardware-constraints">DOS and hardware constraints&lt;/h1>
&lt;p>As we saw in &lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">a previous article&lt;/a>, Intel PCs based on the 80386 have two main modes of operation: real mode and protected mode. In real mode, the processor behaves like a fast 16-bit 8086, limiting programs to a 1 MB address space and with free reign to access memory and hardware peripherals. In protected mode, programs are 32-bit, have access to a 4 GB address space, and there are protection rules in place to access memory and hardware.&lt;/p>
&lt;p>DOS was a 16-bit operating system that ran in real mode. Applications that ran on DOS leveraged DOS&amp;rsquo; services for things like disk access, were limited to addressing 1 MB of memory, and had complete control of the computer. Contrary to that, GCC was a 32-bit program that had been designed to run on Unix (oops sorry, &lt;a href="https://www.gnu.org/gnu/about-gnu.html">GNU is Not Unix&lt;/a>) &lt;em>and&lt;/em> produce binaries for Unix, and Unix required virtual memory from the ground up to support multiprocessing. (I know that&amp;rsquo;s &lt;a href="https://unix.stackexchange.com/questions/332699/how-the-original-unix-kernel-adressed-memory">not totally accurate&lt;/a> but it&amp;rsquo;s easier to think about it that way.)&lt;/p>
&lt;p>Intel-native compilers for DOS, such as the Microsoft C compiler and Turbo C++, targeted the 8086&amp;rsquo;s weird segmented architecture and generated code accordingly. Those compilers had to deal with short, near, and far jumps&amp;mdash;which is to say I have extra research to do and write &lt;em>another&lt;/em> article on ancient DOS memory models. GCC, on the other hand, assumes the full address space is available to programs and generates code making such assumptions.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>GCC was not &lt;em>only&lt;/em> a 32-bit program, though: it was also &lt;em>big&lt;/em>. In order to compile itself and other programs, GCC needed more physical memory than PCs had back then. This means that, in order to port GCC to DOS, GCC needed virtual memory. In turn, this means that GCC had to run in protected mode. Yet&amp;hellip; DOS is a real mode operating system, and calling into DOS services to access files and the like requires the processor to be in real mode.&lt;/p>
&lt;p>To address this conundrum, DJ had to find a way to make GCC &lt;em>and the programs it compiles&lt;/em> integrate with DOS. After all, if you have a C program that opens a file and you compile said program with GCC, you want the program to open the file via the DOS file system for interoperability reasons.&lt;/p>
&lt;p>Here, witness this. The following silly program, &lt;code>headself.c&lt;/code>, goes out of its way to allocate a buffer above the 2 MB mark and then uses said buffer to read itself into it, printing the very first line of its source code:&lt;/p>
&lt;div class="src">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;inttypes.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define BUFMINBASE 2 * 1024 * 1024
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define BUFSIZE 1 * 1024 * 1024
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Allocate a buffer until its base address is past the 2MB boundary.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">BUFMINBASE&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">buf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">BUFSIZE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Read buffer base is at %zd KB&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">intptr_t&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Open this source file and print its first line. Really unsafe.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;headself.c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BUFSIZE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;\0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">EXIT_SUCCESS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="footer">
&lt;div class="filename">
&lt;a href="/src/djgpp/headself.c" type="text/plain">headself.c&lt;/a>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>Yes, yes, I know the above code is really unsafe and lacks error handling throughout. But that&amp;rsquo;s not important here. Watch out what happens when we compile and run this program with DJGPP on DOS:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-headself.png"/>
&lt;/figure>
&lt;p>Note two things. The first is that the program &lt;em>has to&lt;/em> have run in protected mode because it successfully allocated a buffer above the 1 MB mark and &lt;em>used&lt;/em> it without extraneous API calls. The second is that the program is invoking file operations, and those operations interact with files managed by DOS.&lt;/p>
&lt;p>And here is where the &lt;em>really cool&lt;/em> stuff begins. On the one hand, we have DOS as a real mode operating system. On the other hand, we have programs that want to interoperate with DOS but they also want to take advantage of protected mode to leverage the larger address space and virtual memory. Unfortunately, protected mode cannot call DOS services because those require real mode.&lt;/p>
&lt;p>The accepted solution to this issue is the use of a DOS Extender as we already saw &lt;a href="/2024/02/beyond-the-1-mb-barrier-in-dos.html">in the previous article&lt;/a> but such technology was in its infancy. DJ actually went through &lt;em>three&lt;/em> different iterations to fully resolve this problem in DJGPP:&lt;/p>
&lt;ol>
&lt;li>The first prototype used Phar Lap&amp;rsquo;s DOS Extender but it didn&amp;rsquo;t get very far because it didn&amp;rsquo;t support virtual memory.&lt;/li>
&lt;li>Then, the first real version of DJGPP used DJ&amp;rsquo;s own DOS Extender called go32, a big hack that I&amp;rsquo;m not going to talk about here.&lt;/li>
&lt;li>And then, the second major version of DJGPP&amp;mdash;almost a full rewrite of the first one&amp;mdash;switched to using the DOS Protected Mode Interface (DPMI).&lt;/li>
&lt;/ol>
&lt;p>At this point, DJGPP was able to run inside existing DPMI hosts such as Windows or the many memory managers that already existed for DOS and it didn&amp;rsquo;t have to carry the hacks that previously existed in go32 (although the go32 code went on to live inside &lt;a href="https://en.wikipedia.org/wiki/CWSDPMI">&lt;code>CWSDPMI&lt;/code>&lt;/a>). The remainder of this article only talks about the latter of these versions.&lt;/p>
&lt;h1 id="large-buffers">Large buffers&lt;/h1>
&lt;p>One thing you may have noticed in the code of the &lt;code>headself.c&lt;/code> example above is that I&amp;rsquo;m using a buffer for the file read that&amp;rsquo;s 1 MB-long. That&amp;rsquo;s not unintentional: for such a large buffer to even exist (no matter our attempts to push it above 2 MBs), the buffer must be allocated in extended memory. But if it is allocated in extended memory, how can the file read operations that we send to DOS actually address such memory? After all, even if we used unreal mode, the DOS APIs wouldn&amp;rsquo;t understand it.&lt;/p>
&lt;p>The answer is the &lt;em>transfer buffer&lt;/em>. The transfer buffer is a small and static piece of memory that DJGPP-built programs allocate at startup time below the 1 MB mark. With that in mind, and taking a file read as an example, DJGPP&amp;rsquo;s C library does something akin to the following:&lt;/p>
&lt;ol>
&lt;li>The protected-mode &lt;code>read&lt;/code> stub starts executing.&lt;/li>
&lt;li>The stub issues a DPMI read call (which is to say, it executes the DOS read file API but uses the DPMI trampoline) onto the transfer buffer.&lt;/li>
&lt;li>The DPMI host switches to real mode and calls the DOS read file API.&lt;/li>
&lt;li>The real-mode DOS read places the data in the transfer buffer.&lt;/li>
&lt;li>The real-mode DPMI host switches back to protected mode and returns control to the protected-mode stub.&lt;/li>
&lt;li>The protected-mode &lt;code>read&lt;/code> stub copies the data from the transfer buffer into the user-supplied buffer.&lt;/li>
&lt;/ol>
&lt;p>This is all good and dandy but&amp;hellip; take a close look at &lt;a href="https://www.ctyme.com/intr/rb-2783.htm">DOS&amp;rsquo;s file read API&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">Request:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">INT 21h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AH -&amp;gt; 3Fh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BX -&amp;gt; file handle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CX -&amp;gt; number of bytes to read
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DS:DX -&amp;gt; buffer for data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Return:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CF -&amp;gt; clear if successful
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AX -&amp;gt; number of bytes actually read (0 if at EOF before call)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CF -&amp;gt; set on error
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AX -&amp;gt; error code (05h,06h) (see #01680 at AH=59h/BX=0000h)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s right: file read and write operations are restricted to 64 KB at a time because the number of bytes to process is specified in the 16-bit &lt;code>CX&lt;/code> register. Which means that, in order to perform large file operations, we need to go through the dance above multiple times in a loop. And that&amp;rsquo;s why DJGPP is slow: if the DPMI host has to switch to real mode and back for every system call, the overhead of each system call is significant.&lt;/p>
&lt;p>Now is a good time to take a short break and &lt;a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/io/_read.c?rev=1.4">peek into DJGPP&amp;rsquo;s &lt;code>read&lt;/code> implementation&lt;/a>. It&amp;rsquo;s succinct and clearly illustrates what I described just above. And with that done, let&amp;rsquo;s switch gears.&lt;/p>
&lt;h1 id="globs-without-a-unix-shell">Globs without a Unix shell&lt;/h1>
&lt;p>Leveraging protected mode and a large memory address space are just two important but small parts of the DJGPP puzzle. The other interesting pieces of DJGPP are those that make Unix programs run semi-seamlessly on DOS, and there are many such pieces. I won&amp;rsquo;t cover them all here because &lt;a href="http://www.delorie.com/djgpp/doc/eli-m17n99.html">Eli Zarateskii&amp;rsquo;s presentation&lt;/a> did an excellent job at that. So want I to do instead is look at a subset of them apart and show them in action.&lt;/p>
&lt;p>To begin, let&amp;rsquo;s try to answer this question: how do you &lt;em>interact&lt;/em> with a program originally designed for Unix on a DOS system? The Unix shell is &lt;a href="/2020/11/cmdline-args-unix-vs-windows.html">a big part of such interaction&lt;/a> and &lt;code>COMMAND.COM&lt;/code> is no Unix shell. To summarize the linked article: the API to invoke an executable on Unix takes a list of arguments while on DOS and Windows it takes a flat string. Partially because of this, the Unix shell is responsible for expanding globs and dealing with quotation characters, while on DOS and Windows each program is responsible for tokenizing the command line.&lt;/p>
&lt;p>Leaving aside the fact that the DOS API is&amp;hellip; ehem&amp;hellip; bad, this fundamental difference means that any Unix program ported to DOS has a usability problem: you cannot use globs anymore when invoking it! Something as simple and common as &lt;code>gcc -o program.exe *.c&lt;/code> would just not work. So then&amp;hellip; how can we explain the following output from the &lt;a href="/src/djgpp/showargs.c">&lt;code>showargs.c&lt;/code>&lt;/a> program, a little piece of code that prints &lt;code>argv&lt;/code>?&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-showargs-glob-expansion-gcc.png"/>
&lt;/figure>
&lt;p>In the picture above, you can see how I ran the &lt;tt>showargs.c&lt;/tt> program with &lt;tt>*.c&lt;/tt> as its own argument and somehow it worked as you would expect. But if we build it with a standard DOS compiler we get different results:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-showargs-glob-expansion-gcc-tcc.png"/>
&lt;/figure>
&lt;p>GCC is actually doing &lt;em>something&lt;/em> to make glob expansion work&amp;mdash;and it &lt;em>has&lt;/em> to, because remember that DJGPP was not just about porting GCC: it was about porting many more GNU developer tools to DOS. Having had to patch them one by one to work with DOS&amp;rsquo; &lt;code>COMMAND.COM&lt;/code> semantics would have been a sad state of affairs.&lt;/p>
&lt;p>To understand what&amp;rsquo;s happening here, know that all C programs compiled by &lt;em>any&lt;/em> compiler include a prelude: &lt;code>main&lt;/code> is &lt;em>not&lt;/em> the program&amp;rsquo;s true entry point. All compilers wrap &lt;code>main&lt;/code> with some code of their own to set up the process and the C library, and DJGPP is no different. Such code is often known as the &lt;code>crt&lt;/code> (or C Runtime) and it comes in two phases: &lt;code>crt0&lt;/code>, written in assembly for early bootstrapping, and &lt;code>crt1&lt;/code>, written in C.&lt;/p>
&lt;p>As you can imagine, this is where the magic lives. DJGPP&amp;rsquo;s &lt;code>crt1&lt;/code> is in charge of processing the flat command line that it receives from DOS and transforming it into the &lt;code>argv&lt;/code> that POSIX C programs expect, following common Unix semantics. In a way, this code performs the job of a Unix shell.&lt;/p>
&lt;p>Once again, take a break to inspect the &lt;a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/crt0/">&lt;code>crt0&lt;/code> sources&lt;/a> and, in particular, the contents of the &lt;a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/crt0/c1args.c?rev=1.11">&lt;code>c1args.c&lt;/code> file&lt;/a>. Pay attention to file reads and the &amp;ldquo;proxy&amp;rdquo; thing, both of which bring us to the next section.&lt;/p>
&lt;h1 id="long-command-lines">Long command lines&lt;/h1>
&lt;p>Unix command lines aren&amp;rsquo;t different just because of glob expansion. They are also different because they are usually &lt;em>long&lt;/em>, and they are long in part because of glob expansion and in part because Unix has supported long file names for much longer than DOS.&lt;/p>
&lt;p>Unfortunately&amp;hellip; DOS restricted command lines to a maximum of 126 characters&amp;mdash;fewer characters than you can fit in a Tweet or an SMS&amp;mdash;and this posed a problem because the build process of most GNU developer tools, if not all, required using long command lines. To resolve these issues, DJGPP provides two features.&lt;/p>
&lt;p>The first is support for response files. Response files are text files that contain the full command line. These files are then passed to a process with the &lt;code>@file.txt&lt;/code> syntax, which then causes DJGPP&amp;rsquo;s &lt;code>crt1&lt;/code> code to load the response files and construct the long command line in extended memory.&lt;/p>
&lt;p>Let&amp;rsquo;s take a look. If we reuse our previous &lt;code>showargs.c&lt;/code> program that prints the command line arguments, we can observe how the behavior differs between building this program with a standard DOS compiler and with DJGPP:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-showargs-response-files-gcc-tcc.png"/>
&lt;/figure>
&lt;p>Response files are easy to implement and they are sufficient to support long command lines: even if they require special handling on the caller side to write the arguments to disk and then place the response file as an argument, this could all be hidden inside the &lt;code>exec&lt;/code> family of system calls. Unfortunately, using response files is slow because, in order to invoke a program, you need to write the command line to a file&amp;mdash;only to load it immediately afterwards. And disk I/O used to be really slow.&lt;/p>
&lt;p>For this reason, DJGPP provides a different mechanism to pass long command lines around, and this is via the transfer buffer described earlier. This mechanism involves putting the command line in the transfer buffer and telling the executed command where its command line lives. This mechanism obviously only works when executing a DJGPP program from another DJGPP program, because no matter what, process executions are still routed through DOS and thus are bound by DOS&amp;rsquo; 126 character limit.&lt;/p>
&lt;p>Let&amp;rsquo;s try this too. For this experiment, we&amp;rsquo;ll play with two programs: one that prints the length of the received command line and another one that produces a long command line and executes the former.&lt;/p>
&lt;p>The first program is &lt;code>longcmd1.c&lt;/code> and is depicted below. All this program does is allocate a command line longer than DOS&amp;rsquo; maximum length of 126 characters and, once it has built the command line, invokes &lt;code>longcmd2.exe&lt;/code> with said long command line:&lt;/p>
&lt;div class="src">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifdef __GNUC__
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;process.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">longcmd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Generate a command line that exceeds DOS&amp;#39; limits.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">longcmd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">longcmd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">31&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">longcmd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">strdup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;one-argument&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">longcmd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute the second stage of this demo to print the received
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// command line.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">execv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;.&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">longcmd2.exe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">longcmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">perror&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;execv failed&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">EXIT_FAILURE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">EXIT_SUCCESS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="footer">
&lt;div class="filename">
&lt;a href="/src/djgpp/longcmd1.c" type="text/plain">longcmd1.c&lt;/a>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>The second program is &lt;code>longcmd2.c&lt;/code> and is depicted below. This program prints the number of arguments it received and also computes the length of the command line (assuming all arguments were separated by just one space character):&lt;/p>
&lt;div class="src">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">total&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// Assume 1 space between arguments.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nf">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;argc after re-exec: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;textual length: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">EXIT_SUCCESS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="footer">
&lt;div class="filename">
&lt;a href="/src/djgpp/longcmd2.c" type="text/plain">longcmd2.c&lt;/a>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>Now let&amp;rsquo;s see what happens when we compile these two programs with Turbo C++ and with DJGPP. First, let&amp;rsquo;s build both with Turbo C++ and run the &lt;code>longcmd1.exe&lt;/code> entry point:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-longcmd-both-tcc.png"/>
&lt;/figure>
&lt;p>Running &lt;code>longcmd1.exe&lt;/code> fails because the command line is too long and &lt;code>execv&lt;/code> cannot process it. (I&amp;rsquo;m not exactly sure why &lt;code>execv&lt;/code> returns &lt;code>ENOMEM&lt;/code> because the Turbo C++ documentation claims that this function should return &lt;code>E2BIG&lt;/code> on this condition, but alas.)&lt;/p>
&lt;p>Now, let&amp;rsquo;s build &lt;em>just&lt;/em> &lt;code>longcmd1.c&lt;/code> with DJGPP and run it:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-longcmd-1gcc-2tcc.png"/>
&lt;/figure>
&lt;p>We get a bit further now! &lt;code>longcmd1.exe&lt;/code> runs successfully and executes &lt;code>longcmd2.exe&lt;/code>&amp;hellip; but &lt;code>longcmd2.exe&lt;/code> claims that the command line is shorter than we expect. This is because DJGPP&amp;rsquo;s &lt;code>execv&lt;/code> implementation knew that it was running a standard DOS application &lt;em>not&lt;/em> built by DJGPP, so it had to place a truncated command line in the system call issued to DOS. (As a detail also note that this shows 141 and not 126: the reason for this is that DOS does &lt;em>not&lt;/em> place &lt;code>argv[0]&lt;/code> on the command line, but the C runtime has to synthesize this value.)&lt;/p>
&lt;p>But now look at what happens when we &lt;em>also&lt;/em> compile &lt;code>longcmd2.c&lt;/code> with DJGPP:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-longcmd-both-gcc.png"/>
&lt;/figure>
&lt;p>Ta-da! When &lt;code>longcmd2.exe&lt;/code> runs, it now sees the full command line. This is because &lt;code>longcmd1.exe&lt;/code> now knows that &lt;code>longcmd2.exe&lt;/code> understands the transfer buffer arrangement and can send the command line to it this way.&lt;/p>
&lt;p>You can read more about this in the &lt;a href="https://www.delorie.com/djgpp/doc/libc/libc_736.html">spawn documentation&lt;/a> from DJGPP&amp;rsquo;s libc and peek at the &lt;a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/process/dosexec.c?rev=1.29">&lt;code>dosexec.c&lt;/code> sources&lt;/a>.&lt;/p>
&lt;h1 id="unix-style-paths">Unix-style paths&lt;/h1>
&lt;p>Let&amp;rsquo;s move on to one more Unix-y thing that DJGPP has to deal with, which is paths and file names. You see, paths are paths in both DOS and Unix: a sequence of directory names (like &lt;code>/usr/bin/&lt;/code>) followed by an optional file name (like &lt;code>/usr/bin/gcc&lt;/code>). Unfortunately, DOS and Unix paths differ in two aspects.&lt;/p>
&lt;p>The first is that DOS paths separate directory components with a backslash, not a forward slash. This is a historical artifact of the early CP/M and DOS days, where command-line flags used the forward slash (&lt;code>DIR /P&lt;/code>) instead of Unix&amp;rsquo;s dash (&lt;code>ls -l&lt;/code>). When DOS gained support for directories in its 2.0 release, it had to pick a different character to separate directories, and it picked the backslash. Dealing with this duality in DJGPP-built programs seems easy: just make DJGPP&amp;rsquo;s libc functions allow both and call it a day. And for the most part, this works&amp;mdash;and in fact even PowerShell does this on Windows today.&lt;/p>
&lt;p>The second is that DOS paths may include an optional drive name such as &lt;code>C:&lt;/code> and&amp;hellip; the drive name has the colon character in it. While Unix uses the colon character to separate multiple components of the search &lt;code>PATH&lt;/code>, DOS could not do that: it had to pick a different character, and it picked the semicolon. Take a look:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">C:\&amp;gt;path
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PATH=Z:\;C:\DEVEL\BIN;C:\DEVEL\DJGPP\BIN;C:\DEVEL\TC\BIN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The problem here is that many Unix applications, particularly shell scripts like &lt;code>configure&lt;/code>&amp;mdash;especially &lt;code>configure&lt;/code>&amp;mdash;read the value of the &lt;code>PATH&lt;/code> variable and split it at colon separators or append to it by adding a colon. But if we do these textual manipulations on a DOS-style &lt;code>PATH&lt;/code> like the one shown above&amp;hellip; we&amp;rsquo;ll get the wrong behavior because of the drive names&amp;mdash;and Unix programs don&amp;rsquo;t know they have to split on the semicolon instead and we cannot be expected to fix them all.&lt;/p>
&lt;p>The way DJGPP deals with this is by faking the &lt;code>/dev/&lt;/code> device tree. While DJGPP provides implementations of things like &lt;code>/dev/null&lt;/code>, it also exposes DOS drives via their corresponding &lt;code>/dev/[a-z]/&lt;/code> virtual &lt;em>directory&lt;/em>. So, if you wanted to run applications that parse or modify the &lt;code>PATH&lt;/code>, you could rewrite the above as this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">PATH=/dev/z:/dev/c/devel/bin:/dev/c/devel/djgpp/bin:/dev/c/devel/tc/bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This would allow any application reading the &lt;code>PATH&lt;/code> to continue to work. But note that this value doesn&amp;rsquo;t seem to leave the realm of the current process, which is interesting:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-bash-path.png"/>
&lt;/figure>
&lt;p>The picture above shows how bash sees a DOS-style &lt;code>PATH&lt;/code> after it starts. Manually setting it to a Unix path keeps the Unix path in the current process (as shown by the built-in &lt;code>echo&lt;/code> calls), but when we spawn a different one (&lt;code>env&lt;/code> is a separate executable), the value is reset. This makes sense because, if we are running a regular DOS program from within a DJGPP one, we want to export a DOS-compatible environment. Which means the Unix variants probably only stick within shell scripts. You can also see how this works by peeking at &lt;a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/process/dosexec.c">&lt;code>dosexec.c&lt;/code>&lt;/a> again.&lt;/p>
&lt;p>But wait a minute&amp;hellip; did I just show you bash?! On DOS? Oh yes, yes I did&amp;hellip;&lt;/p>
&lt;h1 id="trying-it-out-yourself">Trying it out yourself&lt;/h1>
&lt;p>It&amp;rsquo;s time to get our hands dirty, try this out, and reminisce the old days! Or, actually, not &lt;em>so&lt;/em> old. You should know that DJGPP is &lt;em>still&lt;/em> available in this day and age and that it is quite up to date with GCC 12.3&amp;mdash;released less than a year ago.&lt;/p>
&lt;p>First off, start by installing DOSBox. You can use the &lt;a href="https://www.dosbox.com/download.php?main=1">standard DOSBox version&lt;/a>, but it&amp;rsquo;s probably better to go the &lt;a href="https://dosbox-x.com/">DOSBox-X route&lt;/a> so that you can get Long File Name (LFN) support by setting the &lt;code>ver=7.1&lt;/code> configuration option. Otherwise, beware that running Bash later on will create &lt;code>.bash_history&lt;/code> under &lt;code>C:\&lt;/code> but the file will be named &lt;code>.BAS&lt;/code> due to some odd truncation, and this will later confuse Bash on a second start and assume that &lt;code>.BAS&lt;/code> is actually &lt;code>.bash_login&lt;/code>.&lt;/p>
&lt;p>Now, &lt;a href="https://www.delorie.com/djgpp/getting.html">pick a mirror&lt;/a> for your downloads. You&amp;rsquo;ll see various uses of FTP in the list but don&amp;rsquo;t be surprised if clicking on those doesn&amp;rsquo;t work: major browsers have unfortunately dropped their FTP client so you&amp;rsquo;ll have to &amp;ldquo;fall back&amp;rdquo; to an HTTP mirror.&lt;/p>
&lt;p>From there, you can use the &lt;a href="https://www.delorie.com/djgpp/zip-picker.html">Zip Picker&lt;/a> to help you choose what you need or you can download the same files I did:&lt;/p>
&lt;ul>
&lt;li>&lt;code>v2apps/csdpmi7b.zip&lt;/code>: The &lt;code>CWSDPMI&lt;/code> free DPMI host.&lt;/li>
&lt;li>&lt;code>v2apps/rhid15ab.zip&lt;/code>: The RHIDE &lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">console IDE&lt;/a> akin to Turbo C++.&lt;/li>
&lt;li>&lt;code>v2/djdev205.zip&lt;/code>: Base DJGPP tools.&lt;/li>
&lt;li>&lt;code>v2gnu/bnu2351b.zip&lt;/code>: GNU Binutils (tools like &lt;code>gas&lt;/code> and &lt;code>objdump&lt;/code>).&lt;/li>
&lt;li>&lt;code>v2gnu/bsh4253b.zip&lt;/code>: GNU Bash.&lt;/li>
&lt;li>&lt;code>v2gnu/em2802b.zip&lt;/code>: GNU Emacs.&lt;/li>
&lt;li>&lt;code>v2gnu/fil41br3.zip&lt;/code>: GNU coreutils (tools like &lt;code>ls&lt;/code> and &lt;code>cp&lt;/code>).&lt;/li>
&lt;li>&lt;code>v2gnu/gcc930b.zip&lt;/code>: GCC itself.&lt;/li>
&lt;li>&lt;code>v2gnu/gdb801b.zip&lt;/code>: GDB because why not.&lt;/li>
&lt;li>&lt;code>v2gnu/gpp930b.zip&lt;/code>: G++.&lt;/li>
&lt;li>&lt;code>v2gnu/grep228b.zip&lt;/code>: grep because I find it very handy.&lt;/li>
&lt;li>&lt;code>v2gnu/mak44b.zip&lt;/code>: GNU Make.&lt;/li>
&lt;li>&lt;code>v2gnu/shl2011br3.zip&lt;/code>: Various shell utilities (like &lt;code>basename&lt;/code> and &lt;code>dirname&lt;/code>) that you&amp;rsquo;ll almost-certainly need to run shell scripts.&lt;/li>
&lt;li>&lt;code>v2gnu/txt20br3.zip&lt;/code>: GNU textutils (tools like &lt;code>cat&lt;/code> and &lt;code>cut&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>Once you have those files, create the &amp;ldquo;root&amp;rdquo; directory for what will be the &lt;code>C:&lt;/code> drive in DOSBox. I keep this under &lt;code>~/dos/&lt;/code> and it is much easier to prepare this directory from &lt;em>outside&lt;/em> of DOSBox. Within that location, create a &lt;code>djgpp&lt;/code> subdirectory and unpack &lt;em>all&lt;/em> the zip files you downloaded into it. If there are any file conflicts, just tell unzip to overwrite them.&lt;/p>
&lt;p>Once the unpacking finishes, go to your DOSBox configuration. If you are on Windows, you should have a start menu entry called &amp;ldquo;DOSBox 0.74-3 Options&amp;rdquo; or similar which opens the configuration file in Notepad. If you are on Linux or any other reasonable OS, you can find the configuration file under &lt;code>~/.dosbox/&lt;/code>. In the configuration, you&amp;rsquo;ll want to set up the &lt;code>C:&lt;/code> drive at the very bottom of the file where the &lt;code>[autoexec]&lt;/code> section is. Here is what I do:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">[autoexec]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MOUNT C C:\Users\jmmv\dos
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET PATH=%PATH%;C:\DJGPP\BIN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET DJGPP=C:\DJGPP\DJGPP.ENV
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">C:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Launch DOSBox and you are set. Enter full-screen by pressing &lt;code>Alt+Enter&lt;/code> for the full retro experience and then&amp;hellip; launch &lt;code>bash&lt;/code>:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-14-dosbox-djgpp.png"/>
&lt;/figure>
&lt;p>Pretty neat stuff, huh?&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-14-djgpp-cover-image.png" length="253620" type="image/jpeg"/></item><item><title>Beyond the 1 MB barrier in DOS</title><link>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</link><pubDate>Wed, 07 Feb 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</guid><description>&lt;p>In &lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">&amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;&lt;/a>, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.&lt;/p>
&lt;p>I know I promised that this follow-up article would be about DJGPP, but before getting into &lt;em>that&lt;/em> review, I realized I had to take another detour to cover three more topics. Namely: &lt;em>unreal mode&lt;/em>, which I intentionally ignored to not derail the post; &lt;em>LOADALL&lt;/em>, which I didn&amp;rsquo;t know about until you readers mentioned it; and &lt;em>DOS extenders&lt;/em>, which I was planning to describe in the DJGPP article but they are a better fit for this one.&lt;/p>
&lt;p>So&amp;hellip; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&amp;rsquo;ll go over assembly code for a step-by-step jump into unreal mode.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="what-is-unreal-mode-anyway">What is unreal mode anyway?&lt;/h1>
&lt;p>Having read the preceding post, you should know by now what the real, protected, and VM86 modes of the x86 processors are. But there is one extra unofficial mode I did not talk about, and that is the &lt;em>unreal mode&lt;/em>. The mode with the coolest name if you ask me.&lt;/p>
&lt;p>Unreal mode is a special state of the processor in which the CPU acts as if it was in real mode&amp;hellip; but with segment descriptors that allow it to reference memory above the 1 MB limit. These segments are impossible to define in real mode but, with different tricks for the 80286 and 80386, they become a possibility.&lt;/p>
&lt;p>To understand how unreal mode works, we need to go back to the diagram I presented earlier describing the address resolution process that the 80286&amp;rsquo;s MMU executes on every memory access:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-mmu-access.png" />
&lt;figcaption>Diagram representing the operations that the 80286 does, in hardware, to resolve a &lt;tt>segment:address&lt;/tt> memory reference.&lt;/figcaption>
&lt;/figure>
&lt;p>As you can see in the diagram, for every memory access of the form &lt;code>segment:offset&lt;/code>, the MMU:&lt;/p>
&lt;ol>
&lt;li>decodes the segment selector specified by &lt;code>segment&lt;/code> to determine whether to query the GDT or LDT and which segment descriptor to read,&lt;/li>
&lt;li>reads the determined segment descriptor by indexing into the GDT or LDT tables,&lt;/li>
&lt;li>decodes the segments&amp;rsquo; base address and limit as stored in the descriptor,&lt;/li>
&lt;li>checks the privileges of the executing code against the protections recorded in the descriptor,&lt;/li>
&lt;li>and ensures the &lt;code>offset&lt;/code> is within the segment limit defined in the descriptor.&lt;/li>
&lt;/ol>
&lt;p>Only after these steps complete successfully, the memory access is allowed; otherwise, the processor raises a General Protection Fault exception.&lt;/p>
&lt;p>This is all conceptually good until you realize that the GDT and LDT live in main memory&amp;hellip; and main memory is slow&amp;mdash;&lt;em>excruciatingly&lt;/em> so in processor time. Having to read from main memory to resolve &lt;em>every&lt;/em> memory access, even with a good L1 or L2 cache, would have a big performance impact on most applications.&lt;/p>
&lt;p>To resolve this inefficiency, the processor has a cache of segment descriptors. Instructions that update the segment registers, such as &lt;code>MOV DS, AX&lt;/code>, fetch descriptors from the GDT or LDT tables and store them in the cache. Instructions that reference memory, such as &lt;code>MOV AX, DS:1234h&lt;/code>, read the descriptors from the cache without ever reaching out to main memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-descriptor-cache.png" />
&lt;figcaption>Diagram representing how the instructions used to load a register like &lt;tt>DS&lt;/tt> are decoupled from the instructions that later consume the details about &lt;tt>DS&lt;/tt>. It is crucial to note how the segment descriptor cache completely shields the second instruction from accessing main memory to resolve the address.&lt;/figcaption>
&lt;/figure>
&lt;p>So far so good, but let&amp;rsquo;s add another twist. The diagram I presented earlier showing how the 80286 resolves a memory address does not only apply to protected mode: it applies to real mode too. In both modes, the processor accesses the descriptor cache to peek at the segment limits and protection settings. This means that, for real mode to work as 8086 code expects, the cache must contain values that are compatible with real mode: in particular, the limits must be set to 64 KB.&lt;/p>
&lt;p>But what if we could somehow load arbitrary segment descriptors into the processor&amp;rsquo;s cache and leverage those in real mode? If we could do that, we could increase the segment limits stored in the cache, and then any memory references that use those cached descriptors would be able to bypass the real mode rules and access extended memory directly.&lt;/p>
&lt;p>And this, dear reader, is what unreal mode is about. There is a ton of nuance about how this mode was discovered and how it got its name, and to learn more about that story, I&amp;rsquo;ll redirect you to &lt;a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">OS/2 Museum&amp;rsquo;s excellent history of the unreal mode&lt;/a>. But keep in mind that unreal mode is a clutch that DOS applications used to access memory above the 1 MB mark while avoiding expensive protected mode switches.&lt;/p>
&lt;h1 id="leveraging-unreal-mode">Leveraging unreal mode&lt;/h1>
&lt;p>Before describing how we can switch the processor to unreal mode, we must first look at how we can actually take advantage of this mode.&lt;/p>
&lt;p>In the 80286 case, unreal mode is annoying to use: the 80286 is a 16-bit CPU, which means that the &lt;code>offset&lt;/code> part of a memory reference is limited to 64 KB. We can configure segments whose base address lies beyond the 1 MB address space, allowing us to read extended memory from real mode, but we can only do so in 64 KB chunks at a time.&lt;/p>
&lt;p>The 80386 fares better due to it being a 32-bit CPU: the &lt;code>offset&lt;/code> part of a memory reference can be expressed as a 32-bit quantity. We can do both &lt;code>MOV AX, DS:[SI]&lt;/code> and &lt;code>MOV AX, DS:[ESI]&lt;/code>, which means that if &lt;code>DS&lt;/code> has a base of zero, we can reference any memory position in the 4 GB address space when using the &lt;code>ESI&lt;/code> offset. Crucially, and contrary to what some people think, we can issue these two variants from 16-bit real mode: 32-bit instructions are &lt;em>not&lt;/em> restricted to protected mode.&lt;/p>
&lt;p>The way the 80386 allows 32-bit instructions in 16-bit mode and vice versa is via two properties. The first is an instruction width setting at the code segment level: segment descriptors can indicate that the code they contain is 16-bit or 32-bit. The default for real mode is to assume that code segments are set to 16 bits, but in protected mode we can choose whatever we prefer. The second is the &lt;code>0x66&lt;/code> instruction prefix, which tells the processor that the following instruction operates in &lt;em>the opposite&lt;/em> mode of what is configured in the current code segment: e.g. if the current code segment is a 16-bit segment, the &lt;code>0x66&lt;/code> prefix marks 32-bit instructions.&lt;/p>
&lt;p>Knowing this, we can see that unreal mode is most useful in the 80386 because, once enabled, code can easily reference any extended memory address using 32-bit offsets and the &lt;code>0x66&lt;/code> prefix. But the 16-bit constraints of the 80286 don&amp;rsquo;t make unreal mode less useful given how much the DOS ecosystem needed to escape the real mode address space limitations and how difficult it was to leave protected mode in the 80286.&lt;/p>
&lt;p>With that out of the way, what we are missing in our discussion are the ways by which to enter unreal mode. There are at least two: the undocumented LOADALL instruction and an unsupported jump from protected mode to real mode. Let&amp;rsquo;s take a look at both.&lt;/p>
&lt;h1 id="loadall">LOADALL&lt;/h1>
&lt;p>LOADALL is an undocumented instruction of the 80286 and 80386 processors. This instruction has a long history and I&amp;rsquo;m not going to cover it in detail because &lt;a href="https://rep-lodsb.mataroa.blog/blog/intel-286-secrets-ice-mode-and-f1-0f-04/">others have done a much better job than I could&lt;/a>. I&amp;rsquo;ll restrict my explanation to what the instruction does and why it is useful to enter unreal mode.&lt;/p>
&lt;p>Simply put, all LOADALL does is, as its name implies, set all processor registers at once with values that come from a memory region. This is similar to the widely unused built-in task switching functionality of x86 processors, which reloads the processor state with register values stored in a &lt;a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment (TSS)&lt;/a> descriptor.&lt;/p>
&lt;p>But LOADALL has some quirks that the TSS descriptor doesn&amp;rsquo;t have, and those are what make it interesting. Witness the contents of the memory that LOADALL reads on an 80286:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">Physical Address CPU Register
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">---------------- ------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0800h-0805h None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0806h-0807h MSW
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0808h-0815h None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0816h-0817h TR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0818h-0819h Flag word
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Ah-081Bh IP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Ch-081Dh LDT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">081Eh-081Fh DS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0820h-0821h SS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0822h-0823h CS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0824h-0825h ES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0826h-0827h DI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0828h-0829h SI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Ah-082Bh BP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Ch-082Dh SP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">082Eh-082Fh BX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0830h-0831h DX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0832h-0833h CX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0834h-0835h AX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0836h-083Bh ES descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">083Ch-0841h CS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0842h-0847h SS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0848h-084Dh DS descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">084Eh-0853h GDTR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0854h-0859h LDT descriptor cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">085Ah-085Fh IDTR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0860h-0865h TSS descriptor cache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Registers, registers, more registers, descriptor cache&amp;hellip; Wait, what? Entries for the &lt;em>cached&lt;/em> segment descriptors? That&amp;rsquo;s interesting. These are the actual values for the segment descriptors that the processor stores in its internal cache. Which means that, by issuing a carefully-crafted LOADALL, we can tell the processor to set the cached descriptors to values that are nonsensical for the current operation mode&amp;mdash;and the processor does &lt;em>not&lt;/em> complain.&lt;/p>
&lt;p>In essence, with just one instruction, we can tell the processor that the cached descriptors have base addresses above the 1 MB limit and/or that they have limits larger than 64 KB. And the processor will just accept those into the cache and use them for future memory references.&lt;/p>
&lt;p>As it turns out, &lt;a href="https://www.os2museum.com/wp/himem-sys-unreal-mode-and-loadall/">&lt;code>HIMEM.SYS&lt;/code> did leverage LOADALL&lt;/a> and we can even find its &lt;a href="https://github.com/neozeed/himem.sys-2.06">original source code&lt;/a> to peek into &lt;a href="https://github.com/neozeed/himem.sys-2.06/blob/main/oemsrc/xm286.asm#L241">how it achieved&lt;/a> this feat. It&amp;rsquo;s not trivial to do, but the performance gains of such an undocumented instruction were too hard to pass on in order to implement efficient transfers between conventional and extended memory.&lt;/p>
&lt;p>This made me curious so I tried replicating LOADALL&amp;rsquo;s usage in &lt;a href="https://www.dosbox.com/">DOSBox&lt;/a> and&amp;hellip; failed because DOSBox does not implement this instruction&amp;mdash;which is understandable because it was not documented, it was very specific to two processors, and it apparently was not widely used outside of &lt;code>HIMEM.SYS&lt;/code>. Maybe more-accurate processor emulators supply it, but I didn&amp;rsquo;t bother trying.&lt;/p>
&lt;p>Which brings us to the other way to enter unreal mode: an unsupported jump from protected mode to real mode in the 80386.&lt;/p>
&lt;h1 id="real-to-protected-mode-and-back">Real to protected mode and back&lt;/h1>
&lt;p>Protected mode fascinated me as a child when I read about it in books that didn&amp;rsquo;t &amp;ldquo;belong&amp;rdquo; to my age. After having dipped my toes in 8086 assembly and having toyed around with boot sectors and the like, I fantasized about how protected mode &amp;ldquo;unlocked&amp;rdquo; enormous power. I knew I had to learn such black arts to write my own operating system and I remember writing code that tried to enter protected mode and always failed&amp;mdash;yet it sounded so easy from the books: just set bit 0 of &lt;code>CR0&lt;/code> to 1!&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-assembly-books.jpg" />
&lt;figcaption>The assembly and processor books I read once upon a time and that got me interested in all of this low-level systems programming.&lt;/figcaption>
&lt;/figure>
&lt;p>It wasn&amp;rsquo;t until many years later, around 2007, that I decided I wanted to fulfill my long-term dream to write an operating system. At that point, I invested some time to get protected mode to work&amp;mdash;and I finally did, with interrupts enabled and all. (Spoiler alert: I never got to write an OS though&amp;hellip; yet?) But even if that worked, getting into protected mode is always a frustrating experience of having to get many teeny tiny details right just so that the machine doesn&amp;rsquo;t crash. You do it right and you see absolutely nothing; you do it wrong and you see absolutely nothing either.&lt;/p>
&lt;p>But wait. Why am I telling you all this? Ah yes, because another way of entering unreal mode is the following dance:&lt;/p>
&lt;ol>
&lt;li>Switch to protected mode.&lt;/li>
&lt;li>Set up segment registers to segment descriptors that provide access to the full address space, causing the cached descriptors to have a 4 GB limit.&lt;/li>
&lt;li>Switch back to real mode with the previous unsupported segment configuration in place.&lt;/li>
&lt;/ol>
&lt;p>Upon switching back to real mode, the properties of the segment descriptors that don&amp;rsquo;t make sense in real mode (those limits higher than 64 KB) are &lt;em>sticky&lt;/em>, meaning that no architectural operations such as &lt;code>MOV DS, AX&lt;/code> touch those bits of the cache. With that, it becomes possible to address extended memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-real-mode-load.png" />
&lt;figcaption>Diagram representing how a real mode segment descriptor load does &lt;i>not&lt;/i> modify the limit or flags already stored in the descriptor cache.&lt;/figcaption>
&lt;/figure>
&lt;p>Unfortunately, the 80286 did not have a mechanism to switch from protected mode back to real mode. Creative folks found ways to do this by triple-faulting the CPU and carefully setting registers to skip the BIOS POST code, but this process was extremely slow and thus unfeasible for frequent switches. At the time, the lack of this feature in the 80286 was a major complaint from OS vendors because it made it difficult to support running DOS programs from within a modern operating system.&lt;/p>
&lt;p>Intel addressed those concerns with the launch of the 80386 and its new VM86 mode. But&amp;hellip; that wasn&amp;rsquo;t the only change. The 80386 also added the ability to return to real mode from protected mode&amp;mdash;with a lot of caveats. Intel was prescriptive in how exactly to return to real mode and never described what would happen if you didn&amp;rsquo;t follow the rules to the letter&amp;hellip; which was essentially begging for someone to try and see what would happen when doing that.&lt;/p>
&lt;p>The answer, as we saw above, is unreal mode.&lt;/p>
&lt;h1 id="hands-on-unreal-mode">Hands-on unreal mode&lt;/h1>
&lt;p>All of the above research made me really curious so I got the urge to see unreal mode in action. So, in preparation for this article, I wrote a trivial DOS program that enters unreal mode and shows it working.&lt;/p>
&lt;p>As in the past, getting this demo to a functional state was a frustrating experience of fighting with carefully-crafted register values and memory offsets, DOSBox crashes, and &lt;a href="https://bochs.sourceforge.io/">Bochs&lt;/a> oddities. But in the end my demo ran successfully, and because I couldn&amp;rsquo;t find any trivial, readily-available sample piece of code online that did this, I concluded that I &lt;em>had to&lt;/em> present it to you here for posterity&amp;rsquo;s sake.&lt;/p>
&lt;p>So. Let&amp;rsquo;s get our hands dirty. All you need is &lt;a href="https://github.com/doomemacs/doomemacs">&lt;del>Doom Emacs&lt;/del>&lt;/a> a text editor, &lt;a href="https://www.nasm.org/">NASM&lt;/a>, and DOSBox. Our goal is to:&lt;/p>
&lt;ol>
&lt;li>write a flat COM executable,&lt;/li>
&lt;li>without sections (code and data mixed),&lt;/li>
&lt;li>all in 16-bit code with the occasional 32-bit operation override,&lt;/li>
&lt;li>that enters protected mode,&lt;/li>
&lt;li>that stores a string somewhere in extended memory far from the reach of real mode,&lt;/li>
&lt;li>that drops back to (un)real mode,&lt;/li>
&lt;li>that copies the string we stored in extended memory to conventional memory,&lt;/li>
&lt;li>that tells DOS to print the string we fetched,&lt;/li>
&lt;li>and that finally returns to DOS to prove that DOS still works.&lt;/li>
&lt;/ol>
&lt;p>Let&amp;rsquo;s begin.&lt;/p>
&lt;p>The first thing we have to do is set up the GDT. We&amp;rsquo;ll use statically-configured descriptors in the code, like these:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Null descriptor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">dq&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Code descriptor for this binary. The base address needs fixup at
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; runtime to point to the location where the code was loaded.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">CODE_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_low&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 16 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_mid&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10011110&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, exec, conforming, read allowed.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">00000000&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Not 4KB, 16-bit, no long mode, limit 00h.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">code_base_high&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Data/stack descriptor for this binary. The base address needs fixup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; at runtime to point to the location where the code was loaded.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">DATA_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_low&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 16 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_mid&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10010010&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, data, grows up, read-write.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">00000000&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Not 4KB, 16-bit, no long mode, limit 00h.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">data_base_high&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; Linear data descriptor covering the full 4 GB address space. No fixup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;;; necessary.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">LINEAR_DESC&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">ffffh&lt;/span> &lt;span class="c1">; Low 16 bits of the limit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Low 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; Middle 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">10010010&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; Code/data, data, grows up, read-write.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">11001111&lt;/span>&lt;span class="no">b&lt;/span> &lt;span class="c1">; 4KB, 16-bit, no long mode, limit=0fh.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; High 8 bits of the base address.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The GDT presented above defines four descriptors:&lt;/p>
&lt;ol>
&lt;li>The null descriptor, which is unused but must be present.&lt;/li>
&lt;li>The code descriptor (&lt;code>CODE_DESC&lt;/code>) for our COM executable. This is configured to 16 bits so that we don&amp;rsquo;t have to mix 16-bit and 32-bit sections in the same source file (which is easy but I wanted to avoid). Note also that the base address is zero, but we&amp;rsquo;ll have to patch it up at runtime to point to the actual location where DOS loaded our executable. We cannot predict this and all the offsets built into the code must remain valid when in protected mode, so we must compute this dynamically.&lt;/li>
&lt;li>The data and stack descriptor (&lt;code>DATA_DESC&lt;/code>) for our COM executable. For the same reasons as the code descriptor, we must compute its base address at runtime.&lt;/li>
&lt;li>A linear data descriptor (&lt;code>LINEAR_DESC&lt;/code>) to be able to reference the whole 4 GB address space. We&amp;rsquo;ll use this one to set up the segments for unreal mode.&lt;/li>
&lt;/ol>
&lt;p>Next up, we need to define the descriptor for the GDT itself right after the GDT data section:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">gdt_desc&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="no">$-gdt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">gdt_base&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Easy, but again, note how &lt;code>gdt_base&lt;/code> is zero. The address to the GDT needs to be a linear address, and because we don&amp;rsquo;t know where the COM file will be loaded, we have to compute this address at runtime.&lt;/p>
&lt;p>After this, it&amp;rsquo;s time to start the code section. The first thing we do is fix up all of the base addresses we left blank in the GDT itself and the GDT descriptor. Note that, because we target a COM binary (or a boot sector if you are so inclined), we can assume that &lt;code>CS&lt;/code>, &lt;code>DS&lt;/code>, &lt;code>ES&lt;/code>, and &lt;code>SS&lt;/code> all point to the same place, which makes things significantly easier:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Assume CS = DS = ES = SS (COM file or boot sector).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">real_cs&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Populate the GDT code and data descriptors with our actual base address
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; so that the built-in code offsets work once we enter protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shl&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_low&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_low&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shr&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">code_base_high&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">ah&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">data_base_mid&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Populate the GDT descriptor with the linear address of the GDT.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ds&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">shl&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">add&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gdt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">gdt_base&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we do preparatory work to enter protected mode: namely, we disable the &lt;a href="https://wiki.osdev.org/Non_Maskable_Interrupt">Non-Maskable Interrupt (NMI)&lt;/a> and interrupts in general, and we enable the A20 gate:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Disable the Non-Maskable Interrupt (NMI) and interrupts.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">71&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cli&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Enable the A20 gate.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">92&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">92&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then, we can finally do the magic to enter protected mode by loading the GDT descriptor, updating the &lt;code>PE&lt;/code> (0th) bit in the &lt;code>CR0&lt;/code> register, and doing a long jump:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Load the GDT.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">lgdt&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">gdt_desc&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Enable protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cr0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">or&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cr0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Flush out the processor pipeline and reload CS.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">jmp&lt;/span> &lt;span class="no">CODE_DESC&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="no">protected_mode&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s it. We have reached the protected mode realm! How exciting is &lt;em>that&lt;/em>? We are now in a 16-bit code segment but the machine state is mostly &amp;ldquo;unusable&amp;rdquo;. None of the segment registers except &lt;code>CS&lt;/code> are valid and interrupts are disabled (because we didn&amp;rsquo;t bother to set up the IDT&amp;mdash;and we don&amp;rsquo;t have to for this simple experiment). So let&amp;rsquo;s do the minimum set up that we need:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">protected_mode:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Set up the data and stack segments.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DATA_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ss&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now that the basic segments are configured, let&amp;rsquo;s copy the &lt;code>msg&lt;/code> string built into the binary into extended memory. We do this by pointing &lt;code>ES&lt;/code> to our linear segment and using the &lt;code>EXTENDED_ADDR&lt;/code> offset, which I set to an arbitrary 4 MB:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Store a message in extended memory. We are in protected mode so this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; works by design.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">LINEAR_DESC&lt;/span> &lt;span class="c1">; Load the linear address space in ES.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">esi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msg&lt;/span> &lt;span class="c1">; Point DS:[ESI] to our message.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">edi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">EXTENDED_ADDR&lt;/span> &lt;span class="c1">; Point ES:[EDI] to extended memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ecx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">o32&lt;/span> &lt;span class="no">rep&lt;/span> &lt;span class="no">movsb&lt;/span> &lt;span class="c1">; Must use 32-bit addressing.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once this is done, we prepare the &lt;code>FS&lt;/code> segment with a large limit so that we can use it from unreal mode and restore &lt;code>ES&lt;/code> to the conventional values:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Set up FS as an &amp;#34;unreal mode&amp;#34; segment.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">LINEAR_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">fs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; ... but restore ES to have standard real mode limits. Not strictly
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; necessary but helps to prove our example.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DATA_DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And, with that, we are ready to pivot back to real mode&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Disable protected mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cr0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">and&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">~&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cr0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; And now return to real mode with a far jump.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pushf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">push&lt;/span> &lt;span class="no">word&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">real_cs&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">push&lt;/span> &lt;span class="no">unreal_mode&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">iret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; except that it isn&amp;rsquo;t &amp;ldquo;valid&amp;rdquo; real mode! Remember that we left &lt;code>FS&lt;/code> configured with a high, non-standard limit of 4 GB? Such non-standard limit remains in the segment cache. But before leveraging that, let&amp;rsquo;s make our new machine state functional to continue executing the COM binary:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">unreal_mode:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Reload real mode COM segment layout.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">bx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">cs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">es&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ss&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">bx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can now also reenable interrupts, which we must do before we decide to return to DOS:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Reenable the NMI and interrupts.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">sti&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">and&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="no">fh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">out&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">al&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">in&lt;/span> &lt;span class="no">al&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">71&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But, crucially, we keep the A20 enabled in order to correctly reference extended memory later on!&lt;/p>
&lt;p>And after all of this dance, that&amp;rsquo;s really it. We are in unreal mode. Any memory references we make through the &lt;code>FS&lt;/code> segment register can use offsets beyond the 1 MB limit no matter what its segment base is and no matter if the segment base &lt;em>changes&lt;/em>.&lt;/p>
&lt;p>Easy to say, hard to believe. Let&amp;rsquo;s prove that this is true. Let&amp;rsquo;s first fetch the message we stored in extended memory by copying it to conventional memory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Fetch the message from extended memory by using a large offset. This
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; would not work in real mode or VM86 (even with 32-bit addressing), but
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">;; does because we are actually in unreal mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">xor&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span> &lt;span class="c1">; Clear FS to show its high limits remain.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">fs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">ax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">esi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">EXTENDED_ADDR&lt;/span> &lt;span class="c1">; Point FS:[ESI] to extended memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">edi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msgcopy&lt;/span> &lt;span class="c1">; Point ES:[EDI] to our buffer.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ecx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">o32&lt;/span> &lt;span class="no">fs&lt;/span> &lt;span class="no">rep&lt;/span> &lt;span class="no">movsb&lt;/span> &lt;span class="c1">; Must use 32-bit addressing.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now that we got it copied, let&amp;rsquo;s call into DOS to print the message and return control to DOS:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; Print the message we fetched from extended mode.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ah&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">bx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">cx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">MSGLEN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mov&lt;/span> &lt;span class="no">dx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">msgcopy&lt;/span> &lt;span class="c1">; Remember this was all ... at first!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">int&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">;; And jump back to DOS.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="no">c00h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">int&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="no">h&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If all goes well, you should see &lt;code>Hello, unreal mode!&lt;/code> in the console and the usual &lt;code>C:\&amp;gt;&lt;/code> prompt should greet you again.&lt;/p>
&lt;p>But, wait, there is more! If you happen to be running this under Bochs&amp;mdash;and I recommend that you do because it offers much better debugging facilities than DOSBox&amp;mdash;you can pause the simulation with &lt;code>CTRL+C&lt;/code> and dump the segment registers with &lt;code>sreg&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">&amp;lt;bochs:2&amp;gt; sreg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">es:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cs:0x000f, dh=0x00009300, dl=0x00f0ffff, valid=3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000000f0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ss:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ds:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fs:0x0000, dh=0x00cf9300, dl=0x0000ffff, valid=11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gdtr:base=0x0000000000011c72, limit=0x20
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">idtr:base=0x0000000000000000, limit=0x3ff
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pay attention to the details for the &lt;code>limit&lt;/code> field of all the segment registers. You can see how the value is &lt;code>0x0000ffff&lt;/code> for all of them as you&amp;rsquo;d expect in real mode&amp;hellip; but &lt;code>FS&lt;/code>&amp;rsquo;s limit is the non-standard &lt;code>0xffffffff&lt;/code>. We did it. We are in unreal mode and DOS still runs fine. (In fact, remember that &lt;code>HIMEM.SYS&lt;/code> itself &lt;em>does&lt;/em> leverage unreal mode and this driver was active almost all the time in a DOS installation.)&lt;/p>
&lt;p>IMPORTANT: You can download the full source code by clicking on &lt;a href="/src/unreal-mode/unreal.asm">&lt;code>unreal.asm&lt;/code>&lt;/a>.&lt;/p>
&lt;p>Once you download the source code, you can build it with:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">nasm -o unreal.com unreal.asm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And once built, you can run it within DOSBox by copying the binary into a directory you mount within the emulator or use &lt;a href="https://www.gnu.org/software/mtools/">mtools&lt;/a> to copy it into a DOS boot disk image for Bochs.&lt;/p>
&lt;h1 id="dos-extenders">DOS extenders&lt;/h1>
&lt;p>If you resisted the urge to keep toying with the example code presented above and are still reading, great! We can continue onto our final topic: &lt;a href="https://en.wikipedia.org/wiki/DOS_extender">DOS extenders&lt;/a>. These programs are what truly set DOS free from the 1 MB address space limitations and thus are the right way to conclude this article.&lt;/p>
&lt;p>A DOS extender, in rough terms, is a wrapper for your code that enters protected mode and transfers control back to you. This is very useful because, by running in protected mode, your &lt;em>code&lt;/em> segment can span more than 640 KB, finally letting you run large binaries without resorting to ancient spells like &lt;a href="https://en.wikipedia.org/wiki/Overlay_(programming)">overlays&lt;/a>. But if that was the only thing that a DOS extender did, it would be too simple of a thing and not make it a DOS-anything.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-dos-extender.png" />
&lt;figcaption>Representation of the structure of a DOS-extended application and how it relates to a DOS extender, DOS drivers, and raw hardware access.&lt;/figcaption>
&lt;/figure>
&lt;p>The crucial feature that DOS extenders provide is a mechanism to call &lt;em>back&lt;/em> into the BIOS and DOS to access the services these provide. In particular, this means accessing &lt;em>drivers&lt;/em> and &lt;em>the file system&lt;/em>. They do so by exposing the same &lt;a href="https://en.wikipedia.org/wiki/DOS_API">DOS API&lt;/a> of the real mode host in protected mode, and they do this so that they can transparently service it in an efficient manner.&lt;/p>
&lt;p>The general mechanics behind DOS extenders are very similar to what I described earlier: they enter protected mode to use extended memory and run your code, but they &lt;em>temporarily&lt;/em> return to real mode to issue BIOS and DOS service calls. Unfortunately, this naive implementation would be quite inefficient, so DOS extenders actually service various APIs in protected mode to avoid returning to real mode, and they optimize large buffer transfers to minimize the number of switches when they &lt;em>do&lt;/em> have to switch modes. In other words, DOS extenders are their own mini OS on top of DOS.&lt;/p>
&lt;p>DOS extenders were widely used in games, and you may well remember the iconic message that DOOM printed on startup:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">C:\&amp;gt;DOOM
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DOS/4GW Protected Mode Run-time Version 1.97
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Copyright (c) Rational Systems, Inc. 1990-1994
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>These messages came from &lt;a href="https://en.wikipedia.org/wiki/DOS/4G">DOS/4G&lt;/a>, the most common DOS extender of all. The reason it was so common is because the &amp;ldquo;W version&amp;rdquo; was the free (but limited) edition of DOS/4G, and it shipped with the popular &lt;a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">Watcom&lt;/a> C compiler that produced protected mode binaries. But pay attention to &amp;ldquo;run-time&amp;rdquo; in that message. Why run-time?&lt;/p>
&lt;p>DOS extenders were not the only system component that entered protected mode. By the time DOS extenders became popular, Windows was already a thing and Windows likes protected mode too. And as we saw in the previous post, DOS itself came with &lt;code>EMM386.EXE&lt;/code>, another mini hypervisor that put DOS inside a VM86 instance so that it could easily reference extended memory. So what if you wanted to run a popular DOS-extended program, say DOOM, inside one of these also-popular protected mode environments?&lt;/p>
&lt;p>Tough luck. Nesting protected modes was impossible until &lt;a href="https://en.wikipedia.org/wiki/X86_virtualization">virtualization appeared&lt;/a>. VM86 was close to what was necessary but it didn&amp;rsquo;t allow running protected mode programs from within it. So, how did this work? How could you run a DOS-extended program inside Windows or while &lt;code>EMM386.EXE&lt;/code> was running?&lt;/p>
&lt;p>Like in any computing problem, the answer is simple: by means of an abstraction layer! To support this flow, Microsoft defined the &lt;a href="https://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface">DOS Protected Mode Interface (DPMI)&lt;/a>, an API to abstract the core services to interact with protected mode. DPMI is &lt;em>not&lt;/em> a replacement for a DOS extender though: DPMI is an API that DOS extenders themselves use to deal with protected mode operations.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-02-07-dpmi.png" />
&lt;figcaption>Simple representation of the role that DPMI plays in DOS-extended applications and different host operating systems.&lt;/figcaption>
&lt;/figure>
&lt;p>In the case of DOS-extended programs, the first thing that they do at startup is check if a DPMI kernel is present. If one exists, such as when the DOS program runs within Windows, then the DOS extender leverages Windows&amp;rsquo; DPMI services and delegates all operations to Windows. But if such a provider isn&amp;rsquo;t running, the DOS extender starts the DPMI kernel typically built into itself.&lt;/p>
&lt;p>If you want to see even more code in action, I refer you to skim through the sources of the free &lt;a href="https://sourceforge.net/projects/dos32a/">DOS/32&lt;/a> extender and the free &lt;a href="https://en.wikipedia.org/wiki/CWSDPMI">CWSDPMI&lt;/a> host.&lt;/p>
&lt;p>And with that, I&amp;rsquo;m hoping that the next article will finally be the one talking about DJGPP and everything else it had to do to make Unix applications run semi-seamlessly on DOS&amp;hellip; unless some other preparatory essay becomes necessary!&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-07-80386-dos.jpg" length="152971" type="image/jpeg"/></item><item><title>Links: January 2024 edition</title><link>https://jmmv.dev/2024/01/links-january-2024-edition.html</link><pubDate>Wed, 31 Jan 2024 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/01/links-january-2024-edition.html</guid><description>&lt;p>It is hard to believe but we are already one month into 2024. January has flown by for me and I haven&amp;rsquo;t done a good job at keeping up with news sites&amp;hellip; but I have been reading them on and off and I have collected a small set of interesting articles.&lt;/p>
&lt;p>To everyone new around here, hello and thanks for subscribing! For some context, what follows is my manual selection of cool articles, videos, and projects I stumbled upon during this time period. However, this is not just a dump of links: each link is accompanied by a short commentary to justifies why I thought the material was interesting, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading the source.&lt;/p>
&lt;p>Let&amp;rsquo;s get to it.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://twitter.com/luciascarlet/status/1742156794611310610">&amp;ldquo;On Microsoft&amp;rsquo;s vision for Windows&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By @luciascarlet on January 2nd, 2024&lt;/em>&lt;/p>
&lt;p>This little Twitter rant aligns well with my own views of Windows: I have come to &lt;em>like&lt;/em> Windows 10 and 11 as you can see from my previous &lt;a href="/2022/03/a-year-on-windows-intro.html">lengthy review of the OS&lt;/a> and my &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">review of its history book&lt;/a>, and I &lt;em>do&lt;/em> think there are very interesting technical feats within this system. However, I do &lt;em>not&lt;/em> like where the platform is headed with the constant &lt;a href="https://en.wikipedia.org/wiki/Enshittification">enshittification&lt;/a> due to the increased coupling with Microsoft&amp;rsquo;s own cloud services and the recent AI push.&lt;/p>
&lt;p>The same applies to macOS by the way: the problems aren&amp;rsquo;t as pronounced as on Windows, but its progressive iOSification removes freedoms in you can use your own machine. These issues combined have actually pushed me back into the Linux desktop&amp;hellip; and it&amp;rsquo;s a relief to not see a constant stream of attention-grabbing notifications and ads, and to have regained full control of my machine.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="http://fqa.9front.org/fqa0.html">&amp;ldquo;Introduction to Plan 9 &amp;ldquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By the 9front project&lt;/em>&lt;/p>
&lt;p>Plan 9 is an interesting creature. It&amp;rsquo;s the OS that should have succeeded Unix but never did: it was a little too different a little too late. This document provides an explanation of what Plan 9 is, why it never &amp;ldquo;evolved&amp;rdquo;, and why you should (not) use it.&lt;/p>
&lt;p>But do you want to see something cool? Parts of Plan 9 are still with us &lt;em>today&lt;/em>. If you happen to be on a Windows desktop running WSL 2, go type this right now and behold:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ ps ax | grep [p]lan9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4 hvc0 Sl+ 0:01 plan9 --control-socket 5 --log-level 4 --server-fd 6 --pipe-fd 8 --log-truncate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s right. WSL leverages the Plan 9 file server to let Windows access files within the WSL 2 virtual machine. Oh wait, is this an idea for a future Blog System/5 article? You bet!&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://utcc.utoronto.ca/~cks/space/blog/unix/LseekWhyNamedThat">&amp;ldquo;Why Unix&amp;rsquo;s lseek() has that name instead of seek()&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Chris Siebenmann on January 2nd, 2024&lt;/em>&lt;/p>
&lt;p>System calls are sometimes oddly named&amp;mdash;like the well-known mistake of dropping the &lt;code>e&lt;/code> from the &lt;code>creat&lt;/code> syscall. But why is the naming of &lt;code>fstat&lt;/code>/&lt;code>lstat&lt;/code> not consistent with &lt;code>fseek&lt;/code>/&lt;code>lseek&lt;/code>? Read on for an interesting history review to reveal the answer.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://orlp.net/blog/when-random-isnt/">&amp;ldquo;When random isn&amp;rsquo;t&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Orson R. L. Peters on January 10th, 2024&lt;/em>&lt;/p>
&lt;p>Generating random numbers on deterministic machines&amp;mdash;like computers are&amp;mdash;is an interesting problem. While it is possible to come up with a good random number generator, most &lt;code>rand&lt;/code>-like functions in most languages use a pseudo random number generator. What this means is that the numbers they produce is deterministic given a specific seed.&lt;/p>
&lt;p>In this article, the author explains how they used this deficiency to break the communication barrier between the sandbox that World of Warcraft uses to run untrusted code and the user-provided add-ons that run under said sandbox. There is &amp;ldquo;some math&amp;rdquo; in there, but you can skip over it and still understand the basis of this sandbox exploit.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://zolutal.github.io/understanding-paging/">&amp;ldquo;Understanding x86_64 Paging&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Justin Miller on December 27th, 2023&lt;/em>&lt;/p>
&lt;p>Knowing the mechanics of virtual memory is a necessity for any systems engineer. Knowing the internals of paging, however, is optional but still a very useful piece of knowledge to carry around. This article equips you with that.&lt;/p>
&lt;p>Myself, I knew how 32-bit paging worked but never bothered to learn how it did in 64-bit x86 chips. The fact is that there are some important differences because the approach that works for a 32-bit address space just doesn&amp;rsquo;t with a 64-bit address space: the page tables would take way too much memory!&lt;/p>
&lt;p>So, read this article for more details. I found the text somewhat hard to read, but it&amp;rsquo;s full of diagrams and detailed information so it&amp;rsquo;s worth a glance.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://davidben.net/2024/01/15/empty-slices.html">&amp;ldquo;Passing nothing is surprisingly difficult&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By David Benjamin on January 175h, 2024&lt;/em>&lt;/p>
&lt;p>Slices are partial views into an existing array: instead of performing a costly copy of a part of the array into a smaller array, you represent the &amp;ldquo;slice&amp;rdquo; as an address of a first element and a length specifying how many elements follow. Slices are traditionally represented as a &amp;ldquo;start pointer + count&amp;rdquo; pair but there are other representations possible.&lt;/p>
&lt;p>So, the question is: how do you represent empty slices? There are different choices, and different languages pick differently. This post dives into how C, C++, and Rust represent slices, and how Rust&amp;rsquo;s choices make it impossible to pass those slices to C and C++ without runtime checks and conversions.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2024/01/from-0-to-1-mb-in-dos.html">&amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on January 17th, 2024&lt;/em>&lt;/p>
&lt;p>Last month I wrote a pretty successful article reminiscing the IDEs we had in the DOS days 30 years ago, and that article made me want to play with and write about DJGPP. However, while writing that &lt;em>other&lt;/em> draft, I realized I needed to clarify some concepts first for my own knowledge.&lt;/p>
&lt;p>Those concepts were around how DOS managed memory back in the day and what all the EMS, XMS, HMA and other acronyms meant. I spent various hours researching the topic and then wrote a summary describing the many ways DOS programs squeezed the most of the first megabyte of the address space. By the way, I discovered &lt;a href="https://www.draw.io/">draw.io&lt;/a> along the way and I regret not having tried it much before; it&amp;rsquo;s great.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://qr.blinry.org/">&amp;ldquo;Reading QR codes without a computer!&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Piko and blinry sometime in December 2023&lt;/em>&lt;/p>
&lt;p>I remember learning how to read barcodes and, I think, QR codes back in school in the early 2000s&amp;hellip; but obviously I had forgotten everything about it. This article is a work of art that explains how QR codes work. I&amp;rsquo;m&amp;hellip; horrified by how long the authors must have spent preparing all the beautiful diagrams that accompany the article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://experimentalworks.net/posts/2024-01-22-simple-phantom-types/">&amp;ldquo;Nominal types&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By David Soria Parra on January 22nd, 2024&lt;/em>&lt;/p>
&lt;p>I am a fan of leveraging the type system to narrowly model the different concepts in a problem domain. Passing around integers or strings that mean different things as raw types has caused serious production outages in the past, and in my software I like to prevent against those. Traditionally I&amp;rsquo;ve used &lt;a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">Rust&amp;rsquo;s &amp;ldquo;new type&amp;rdquo; idiom&lt;/a>, but this article presents a neat trick that seems easier to maintain than that one. If anything, it helps keep all of your types consistent with each other from an API perspective.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://danluu.com/why-video/">&amp;ldquo;Why do people post on [bad platform] instead of [good platform]?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Dan Luu on January 28th, 2024&lt;/em>&lt;/p>
&lt;p>Deciding &lt;em>where&lt;/em> to publish content is something I&amp;rsquo;ve struggled (and I&amp;rsquo;m still struggling) with. No matter the medium, there is a trade off between convenience, familiarity and/or personal preference vs. audience. For example, while I&amp;rsquo;m enjoying my move to Substack from a self-hosted blog because of the sustained subscriber growth, I&amp;rsquo;m also well-aware that some of my past readers may not like this. Or as another example, whenever I have posted a Twitter thread, I&amp;rsquo;ve had to go through great lengths to &lt;em>also&lt;/em> post the same content here to avoid it being slurped into &amp;ldquo;thread reader&amp;rdquo; apps.&lt;/p>
&lt;p>This article does a nice job at diving into why people may be choosing certain publishing mediums and why it&amp;rsquo;s impossible to please everyone. I still don&amp;rsquo;t like the trend to move to video though.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://pong-wars.vercel.app/">&amp;ldquo;Pong wars&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Koen van Glist on January 28th, 2024&lt;/em>&lt;/p>
&lt;p>A mesmerizing 2-player pong-like game where the board is divided in two territories and the bouncing balls try to gain the opposite territory by bouncing onto it.&lt;/p>
&lt;p>I found this so neat that I hacked a very quick&amp;rsquo;n&amp;rsquo;dirty clone with EndBASIC. Launch it in your browser by clicking on &lt;a href="https://repl.endbasic.dev/?run=jmmv/pongwars.bas">jmmv/pongwars.bas&lt;/a> and press any key to drop into the interpreter and explore!&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>From 0 to 1 MB in DOS</title><link>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</link><pubDate>Wed, 17 Jan 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</guid><description>&lt;p>Since the last article on &lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">the text-based IDEs of old&lt;/a>, I&amp;rsquo;ve been meaning to write about the GCC port to DOS, namely &lt;a href="https://www.delorie.com/djgpp/">DJGPP&lt;/a>. As I worked on the draft for that topic, I realized that there is a ton of ground to cover to set the stage so I took most of the content on memory management out and wrote this separate post.&lt;/p>
&lt;p>This article is a deep dive on how DOS had to pull out tricks to maximize the use of the very limited 1 MB address space of the 8086. Those tricks could exist because of the features later introduced by the 80286 and the 80386, but these were just clutches to paper over the fact that DOS could not leverage the real improvements provided by protected mode.&lt;/p>
&lt;p>This detour is long but I hope you&amp;rsquo;ll enjoy it as much as I enjoyed researching the topic. I&amp;rsquo;ll walk you through the changes in the x86 architecture over time, starting with the 8086 and ending in the 80386, and how DOS kept up along the way. I&amp;rsquo;ll conclude with a peek into DOS&amp;rsquo; own &lt;tt>MEM&lt;/tt> and MemMaker utilities. I must omit details to keep the text manageable in size though, so please excuse the lack of detail in some areas; just follow the links to external documentation to learn more.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>&lt;em>Before we begin, I&amp;rsquo;d like to thank neozeed from &lt;a href="https://virtuallyfun.com/">Virtually Fun&lt;/a> for his in-depth review of this article. Head to his blog for a lot of interesting and related content!&lt;/em>&lt;/p>
&lt;h1 id="the-8086-and-real-mode">The 8086 and real mode&lt;/h1>
&lt;p>Back in the 1980s, the &lt;a href="https://en.wikipedia.org/wiki/Intel_8086">Intel 8086&lt;/a> was &lt;em>the&lt;/em> processor for PCs (along with its crippled sibling 8088 which I&amp;rsquo;ll ignore throughout this post). The 8086 was a simple chip with significant limitations, but it was incredibly successful and is the foundation of the x86 architecture that we still use today. Because the 8086 powered PCs, and DOS was the operating system that IBM chose for the PC, DOS was designed to work for the 8086.&lt;/p>
&lt;p>For the purposes of our article, let&amp;rsquo;s focus on two details: the 8086 CPU had a 20-bit address bus, which means it could only address 1 MB of memory, and it was a 16-bit CPU, which means that its internal registers were all 16-bit long. Which begs the question: if registers could only represent &lt;code>2^16 = 64K&lt;/code> different values, how could code reference a 20-bit address space?&lt;/p>
&lt;p>The answer is &lt;em>segmentation&lt;/em>. In the 8086, every instruction that references memory does so by specifying an address as two separate 16-bit quantities: a &lt;em>segment&lt;/em> and an &lt;em>offset&lt;/em> within the segment. Because segments are 16-bit long, there can be up to 64KB segments&amp;mdash;and if we take the 1 MB total address space and divide it by 64KB, we deduce that segments are offset from each other by 16 bytes.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-segments.png" />
&lt;figcaption>Representation of the way segmentation slices the 8086 1 MB address space into 64KB overlapping segments offset by 16 bytes from each other.&lt;/figcaption>
&lt;/figure>
&lt;p>There are two things of note in the diagram. First, segments overlap, meaning that a single memory location can be referenced by many different segment/offset combinations. And, second, all segments after &lt;code>0xF000&lt;/code> reference memory positions above the 1 MB address space that don&amp;rsquo;t exist, which the 8086 chose to wrap around by ignoring the 21st bit of an address. After all, there is no 21st line in the address bus.&lt;/p>
&lt;p>When accessing a piece of memory with an address of the form &lt;code>segment:offset&lt;/code>, say &lt;code>81DA:72C3&lt;/code>, the 8086 multiplies &lt;code>0x81DA&lt;/code> by 16 (a simple 4-bit shift to the left) and adds the &lt;code>0x72C3&lt;/code> offset to the result to obtain address &lt;code>0x89063&lt;/code>. From there on, the 8086 reads from or writes to that memory location and calls it a day. There is no &lt;a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit (MMU)&lt;/a>: every memory access can reference any address, and all accesses are legal (including those that wrap around!) which means null or dangling pointer dereferences don&amp;rsquo;t cause any sort of crash.&lt;/p>
&lt;p>This type of MMU-less segmented addressing is known as &lt;em>real mode&lt;/em>, but this name didn&amp;rsquo;t appear until the 80286 had to give it a name to distinguish it from &lt;em>protected mode&lt;/em>. But before introducing the latter, let&amp;rsquo;s talk about memory maps for a second.&lt;/p>
&lt;h1 id="conventional-and-upper-memory">Conventional and upper memory&lt;/h1>
&lt;p>Just because the 8086 processor can reference 1 MB of memory does not mean that 8086 machines came equipped with 1 full MB of RAM. Machines typically included &lt;em>less&lt;/em> than that for cost reasons, so it&amp;rsquo;s critical to understand that the &lt;em>address space&lt;/em>&amp;mdash;that is, the set of addresses that can be &lt;em>referenced&lt;/em>&amp;mdash;is different from the amount of memory installed. No surprise there: the same is true today of modern 64-bit CPUs.&lt;/p>
&lt;p>This fact was advantageous because certain system devices prefer to expose themselves as part of the address space. For example: the BIOS ROM is accessible via a range of addresses in upper memory. Or another example: video cards tend to expose their framebuffer as a memory-mapped device so that applications can directly write to well-known addresses to manipulate video memory&amp;mdash;bypassing the separate I/O bus and instruction set.&lt;/p>
&lt;p>The question is: where do such devices live within the address space? The choice is pretty much arbitrary, so what IBM did was split the &lt;a href="https://wiki.osdev.org/Memory_Map_(x86)">address space of the original PC&lt;/a> in two parts. The first 640 KB, known as &lt;em>conventional memory&lt;/em>, were mapped to available RAM and were readily usable by applications. The upper 384 KB, known as &lt;em>upper memory&lt;/em> or the &lt;em>Upper Memory Area (UMA)&lt;/em>, were reserved for memory-mapped devices. This assignment of &lt;em>meaning&lt;/em> to portions of the address space for specific purposes is what&amp;rsquo;s called a &lt;em>memory map&lt;/em>, and this was the memory map of the original PC.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-memory-map.png" />
&lt;figcaption>Representation of the 8086 PC memory map. Solid blocks correspond to mapped memory and dashed parts correspond to unmapped memory.&lt;/figcaption>
&lt;/figure>
&lt;p>Note how conventional memory may not be fully usable: as shocking as it may sound today, PCs could have even less than 640 KB of installed RAM. More importantly for our purposes, the upper memory is &lt;em>sparse&lt;/em>: certain address ranges are assigned to devices, but there may be gaps between devices. What happens when reading from or writing to unmapped addresses is hard to tell as this depends on the chipset&amp;mdash;not the CPU&amp;mdash;but remember that all accesses had to be valid in some form.&lt;/p>
&lt;p>And by the way, there is one teeny tiny exception to the &amp;ldquo;all first 640 KB are free to use to applications&amp;rdquo;: the very first 1 KB of RAM is reserved for the Interrupt Vector Table, which is what the 8086 uses to look for interrupt handlers when it receives an interrupt, and a few more bytes after that are used by the BIOS to map volatile data. We can ignore these.&lt;/p>
&lt;h1 id="expanded-memory-specification-ems">Expanded Memory Specification (EMS)&lt;/h1>
&lt;p>As you can imagine, 640 KB of RAM were soon &lt;em>not&lt;/em> enough for many programs. Applications needed access to more memory, but the limitations of the 8086 20-bit address bus made it difficult. Yet there was a need for an immediate solution. The &lt;a href="https://en.wikipedia.org/wiki/Expanded_memory">Expanded Memory Specification (EMS)&lt;/a> was one of those first solutions and was originally designed by Lotus in order to support their star application &lt;a href="https://en.wikipedia.org/wiki/Lotus_1-2-3">1-2-3&lt;/a>.&lt;/p>
&lt;p>The idea is simple. Remember how upper memory is &lt;em>sparse&lt;/em>? What if we could map a window in that address space to a different portion of memory? And what if we could control, via software, which portion of memory was exposed through such window at any given time?&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-8086-ems.png" />
&lt;figcaption>Representation of the 8086 PC memory map and an EMS window in upper memory mapped to a portion of memory provided by an external ISA card.&lt;/figcaption>
&lt;/figure>
&lt;p>This is precisely what EMS did. EMS brought the idea of having a software API that allowed applications to select views into &amp;ldquo;other&amp;rdquo; memory by mapping a 64 KB window in upper memory to another memory chip. Originally, this other memory was supplied by expansion ISA cards like the one below, which means that EMS required hardware support and hardware-specific drivers to perform the window remappings. This also means, by the way, that this memory could be much slower than standard RAM.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-emulex-persyst-4mb-isa.jpg" />
&lt;figcaption>An Emulex Persyst ISA card providing 4 MB of additional memory. It's notable how huge this was. Photo taken from the Wikipedia; &lt;a href="https://en.wikipedia.org/wiki/File:EmulexPersyst_4M_ISA.jpeg">see original&lt;/a>.&lt;/figcaption>
&lt;/figure>
&lt;p>As you can imagine, this trick offered the theoretical ability to access &lt;em>any&lt;/em> amount of extra RAM on a machine&amp;hellip; at the expense of having to structure your application so that it explicitly (re)configured the window. Implementing such applications is difficult and is also insufficient when applications need a larger address space to function comfortably. EMS was a useful kludge, but still a kludge.&lt;/p>
&lt;h1 id="the-80286-and-protected-mode">The 80286 and protected mode&lt;/h1>
&lt;p>As the needs of programs and operating systems grew, processors themselves needed to grow more advanced features as well. In particular, they needed to gain the ability to access much more than just 1 MB of memory, and they needed to offer memory protection features to isolate programs from each other.&lt;/p>
&lt;p>The 80286, still a 16-bit CPU, grew the address space to 24 bits to support up to 16 MB of RAM. It introduced a MMU to offer memory isolation. But there was a problem here: the 8086 memory addressing mode of 16-bit &lt;code>segment:offset&lt;/code> pairs did not permit addressing memory beyond the first 1 MB. Thus the 80286 had to find a different way to reference the RAM beyond 1 MB, also known as &lt;em>extended memory&lt;/em>, and it did so by introducing a completely different operation mode known as &lt;em>protected mode&lt;/em>.&lt;/p>
&lt;p>Once in protected mode, all memory access rules change. For one, the MMU takes charge of all memory accesses, ensuring that they are valid according to predefined protections. For another, the &lt;code>segment:offset&lt;/code> addresses change their semantics. The segment portion of an address stops being a scaled down memory address, and instead becomes an &lt;em>index&lt;/em> &lt;a href="https://wiki.osdev.org/Global_Descriptor_Table">into a table&lt;/a> (the GDT or LDT) of segment descriptors. Each segment descriptor describes the base address of a segment as a 32-bit quantity, the size of the segment as a 20-bit quantity, the access protections of the segment, and a bunch of flags.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-mmu-access.png" />
&lt;figcaption>Diagram representing the operations that the 80286 does, in hardware, to resolve a &lt;tt>segment:address&lt;/tt> memory reference.&lt;/figcaption>
&lt;/figure>
&lt;p>Under this model, instead of having an address like &lt;code>81DA:72C3&lt;/code>, we might see &lt;code>13:72C3&lt;/code>. To access this address, the MMU looks up entry 13 in the GDT, finds a descriptor that says that the segment starts at address &lt;code>0x81DA&lt;/code> and that it is &lt;code>0x7200&lt;/code> bytes long, and concludes that the &lt;code>13:72C3&lt;/code> reference is out of bounds, raising a &lt;a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault&lt;/a> hardware exception (your dreaded &lt;a href="https://en.wikipedia.org/wiki/Segmentation_fault">&amp;ldquo;Segmentation fault&amp;rdquo;&lt;/a> error these days).&lt;/p>
&lt;p>But this access model is really different from what DOS applications were used to in real mode, and DOS itself was only designed to run in real mode. So DOS and all of its ecosystem were stuck in the real mode world, limited to addressing just 1 MB of memory without the ability to access extended memory&amp;hellip; or were they?&lt;/p>
&lt;h1 id="the-high-memory-area-hma">The High Memory Area (HMA)&lt;/h1>
&lt;p>Avid readers might have noticed in a previous picture that, in real mode, there are a few segments that could, in theory, allow access to addresses above the 1 MB mark. Take &lt;code>FFFF:0010&lt;/code>, which is &lt;code>0xFFFF * 0x10 + 0x10 = 0x100000 = 2^20&lt;/code> or 1 followed by 20 zeroes in binary form. This is the first address into extended memory. The 8086 was able to produce such addresses, but they would wrap around because the 8086 had no way to issue the 21st bit to the memory bus.&lt;/p>
&lt;p>For compatibility reasons, the 80286 had to truncate these addresses in real mode, and it did so by wiring the 21st line of the address bus (the A20) to zero. But what if the addresses &lt;em>didn&amp;rsquo;t&lt;/em> wrap around? What if we told the 80286 to &lt;em>not&lt;/em> truncate them? This can, in fact, be done by enabling the &lt;a href="https://en.wikipedia.org/wiki/A20_line#A20_gate">A20 gate&lt;/a>&amp;mdash;a task achieved via the keyboard controller, mind you. Enabling the A20 is a prerequisite for entering protected mode, but if done in real mode, it becomes possible to access an extra 64 KB of memory. This extra memory is known as the &lt;a href="https://en.wikipedia.org/wiki/High_memory_area">High Memory Area (HMA)&lt;/a>.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80286-hma.png" />
&lt;figcaption>Representation of the way segmentation slices the 80286 real mode 1 MB address space into 64KB overlapping segments offset by 16 bytes from each other, and how the last few segments can be made to spill into extended memory.&lt;/figcaption>
&lt;/figure>
&lt;p>The HMA isn&amp;rsquo;t big by any means, but conventional memory was so limited that any tricks to gain extra memory were welcome and DOS did precisely that. By loading the &lt;code>HIMEM.SYS&lt;/code> driver and by specifying &lt;code>DOS=HIGH&lt;/code> in the &lt;code>CONFIG.SYS&lt;/code> file, DOS would relocate parts of itself into the HMA to free up to 64 KB of conventional memory.&lt;/p>
&lt;p>Unfortunately, 64 KB of extra memory really aren&amp;rsquo;t that much. This is a nice trick, but applications really needed access to more memory.&lt;/p>
&lt;h1 id="extended-memory-specification-xms">eXtended Memory Specification (XMS)&lt;/h1>
&lt;p>Another technique to access extended memory (the memory visible beyond the first 1 MB) came in the form of the &lt;a href="https://en.wikipedia.org/wiki/Extended_memory#Extended_Memory_Specification_(XMS)">eXtended Memory Specification (XMS)&lt;/a>.&lt;/p>
&lt;p>The idea of XMS is to provide an API that real mode applications can use to allocate chunks of extended memory and to copy data from/to those chunks via explicit calls. This is different from EMS because we aren&amp;rsquo;t talking about a fixed window of the address space referencing some external memory: we are talking about an API that is able to allocate arbitrary chunks of memory and return references to them, much like &lt;code>malloc&lt;/code> and &lt;code>free&lt;/code> do. Applications then use extra APIs to copy memory from/to those extended memory chunks into conventional memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80386-xms.png" />
&lt;figcaption>Representation of the 80286 memory map with a block of extended memory copied into conventional memory by means of XMS.&lt;/figcaption>
&lt;/figure>
&lt;p>To implement the &lt;a href="http://www.phatcode.net/res/219/files/xms30.txt">XMS API&lt;/a>, a driver such as &lt;code>HIMEM.SYS&lt;/code> uses protected mode to manipulate the extended memory blocks, but the real mode applications never have to. Because XMS requires protected mode, this feature is only available in the 80286 and above processors, whereas EMS could be used by the 8086 with the right hardware assistance.&lt;/p>
&lt;p>Much like EMS, XMS provided the theoretical ability to access an unlimited amount of extended memory from real mode at the expense of having to manually transfer small pieces of it into the limited 1 MB address space. This is not a trivial difficulty and is why even modern architectures like the &lt;a href="https://en.wikipedia.org/wiki/Cell_(processor)">Cell processor&lt;/a> and its &lt;a href="https://en.wikipedia.org/wiki/Cell_(processor)#Synergistic_Processing_Elements_(SPE)">SPEs&lt;/a> with a separate and limited address space didn&amp;rsquo;t succeed.&lt;/p>
&lt;p>So far so good, but&amp;hellip; we can still squeeze some extra memory out of the real mode segmented address space. In particular, we still have some gaps in upper memory that we haven&amp;rsquo;t put to use.&lt;/p>
&lt;h1 id="the-80386-and-vm86-mode">The 80386 and VM86 mode&lt;/h1>
&lt;p>To make further improvements possible, we need the additional processor features that came with the 80386. Compared to the 80286, the 80386 was a 32-bit processor capable of addressing up to 4 GB of RAM. More interesting for our discussion, however, were the addition of pagination&amp;mdash;which is the foundation of any modern operating system&amp;mdash;and a new execution mode known as &lt;a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">&lt;em>Virtual 8086&lt;/em>&lt;/a> or VM86 for short.&lt;/p>
&lt;p>VM86 was originally envisioned to fix a major deficiency in the 80286: that is, the ability to run &lt;em>multiple&lt;/em> concurrent real mode applications from within a protected mode operating system because that&amp;rsquo;s what Windows and OS/2 wanted to provide. In today&amp;rsquo;s terms, VM86 acts as virtual machine hypervisor, providing the processor with a mechanism to enter a mode that behaves like real mode but that is backed by the protected mode MMU. All memory accesses are subject to translation via pagination and all privileged operations trap into protected mode, meaning that a hypervisor process can place VM86 tasks anywhere in the 4 GB memory address space and can context-switch between them.&lt;/p>
&lt;p>But what if our hypervisor only spawned a single VM86 task to run DOS in? What if, then, the hypervisor leveraged the MMU to relocate portions of the real mode address space into portions of extended memory? That way, we could emulate EMS without dedicated hardware, providing applications a trivial way to peek into extended memory via 64 KB windows, or we could play other tricks&amp;hellip; like UMBs.&lt;/p>
&lt;h1 id="upper-memory-blocks-umbs">Upper Memory Blocks (UMBs)&lt;/h1>
&lt;p>Remember the sparse upper memory area? Those 384 KB of memory wired to hardware devices but with gaps in them? What if we could take those gaps in upper memory and map them to some extended memory so that they were directly addressable from real mode? This is precisely what &lt;a href="https://en.wikipedia.org/wiki/Upper_memory_area">Upper Memory Blocks (UMBs)&lt;/a> are: portions of the upper memory area remapped to extended memory by means of VM86, transparently offering access to more memory from real mode.&lt;/p>
&lt;p>As an example, think about the video memory mappings in the original PC specification. The memory map reserved two chunks of the address space for video: one for monochrome displays and one for color displays. But only one of them can be in use at any given time. So whichever video mode is selected leaves the address space of the other mode unused, and thus such address space can be leveraged by the system as an UMB into which to load drivers or place user data.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-80386-umb.png" />
&lt;figcaption>Representation of the 80386 VM86 memory map with two UMBs in upper memory mapped to extended memory by means of the MMU and its pagination features.&lt;/figcaption>
&lt;/figure>
&lt;p>In DOS, the &lt;code>EMM386.EXE&lt;/code> driver is in charge of providing UMBs. In principle, the chipset could also implement them in older processors, but the 80386 made this all possible in software by entering VM86 and then leveraging pagination to map pages of extended memory in the upper memory area.&lt;/p>
&lt;p>When UMBs are available, DOS offered ways to move load drivers and &lt;a href="https://en.wikipedia.org/wiki/Terminate-and-stay-resident_program">TSR programs&lt;/a> into UMBs by specifying &lt;code>DOS=UMB&lt;/code> in the &lt;code>CONFIG.SYS&lt;/code> file and then using the &lt;code>DEVICEHIGH&lt;/code> and &lt;code>LOADHIGH&lt;/code> commands.&lt;/p>
&lt;h1 id="putting-it-all-together">Putting it all together&lt;/h1>
&lt;p>In summary, we have seen four different techniques that evolved over time to squeeze the most memory out of the incredibly limited 1 MB address space of the 8086. These limitations haunted the PC ecosystem until Windows took over and it can be argued that Windows &amp;ldquo;won&amp;rdquo; because it made it much easier to take advantage of the larger address space of the 80386. Until that happened, however, users had to live with the EMS, XMS, HMA, and UMB mess.&lt;/p>
&lt;p>And a mess it was, and it was so pervasive that it leaked to users. Let&amp;rsquo;s take a look at the output of the &lt;code>MEM&lt;/code> command, which was a very common utility to run when trying to maximize free conventional memory. In one of its simplest forms, &lt;code>MEM /C&lt;/code>, the command shows a summary of the memory usage per program and whether they are loaded in conventional or upper memory:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-c-1.png" />
&lt;figcaption>First page of the output of the &lt;tt>MEM /C /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;code>MEM /D&lt;/code>, which I did not know about back in the day, is more interesting. I have to show you its output as three separate images due to console size limitations:&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-1.png" />
&lt;figcaption>First page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-2.png" />
&lt;figcaption>Second page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="/images/2024-01-17-mem-d-3.png" />
&lt;figcaption>Third page of the output of the &lt;tt>MEM /D /P&lt;/tt> command.&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;code>MEM /D&lt;/code> shows us the memory map of the machine along with details about the location of each program. We can also see mentions of the conventional vs. upper address space, whether the HMA is in use, and consumption of XMS memory.&lt;/p>
&lt;p>But in all of these outputs, we see that upper memory is not in use &lt;em>at all&lt;/em>. Why is that? Well, because MS-DOS out of the box doesn&amp;rsquo;t attempt to load drivers into it. For that, we have to manually modify &lt;code>CONFIG.SYS&lt;/code> and &lt;code>AUTOEXEC.BAT&lt;/code> with special commands and reorder entries to maximize the usage of the upper memory and the HMA. A black art.&lt;/p>
&lt;p>Which brings me to MemMaker, a tool that debuted with MS-DOS 6. This tool attempted to automatically reconfigure all drivers and TSRs loaded during boot so that the largest/majority of them fit in upper memory, leaving as much conventional memory free for application usage.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-intro.png" />
&lt;figcaption>Welcome page to the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>As automated as it was, however, I&amp;rsquo;d say that MemMaker was an experts-only tool. Take a look at its advanced configuration options page, which I had to fiddle with to make the tool work in a KVM virtual machine running MS-DOS 6.22. You really need to understand the intricate details of real mode memory management to know what each of these options is about.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-options.png" />
&lt;figcaption>Advanced options in the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>But if you made MemMaker run successfully, it would then greet you with a pretty cool page after a reboot. This page showed a breakdown of the changes made by MemMaker and how it was able to reclaim conventional memory.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-results.png" />
&lt;figcaption>Final report of the changes made by the MemMaker utility.&lt;/figcaption>
&lt;/figure>
&lt;p>After that, we can look at the changes that MemMaker applied to the &lt;code>CONFIG.SYS&lt;/code> and &lt;code>AUTOEXEC.BAT&lt;/code> files. I never truly understood what all of these magic numbers meant, but now that I went through the hassle of researching and writing this article, I finally do. Just 30 years after I regularly used MemMaker to be able to play games in my multimedia 80386.&lt;/p>
&lt;figure>
&lt;img src="/images/2024-01-17-memmaker-changes.png" />
&lt;figcaption>Content of the &lt;tt>CONFIG.SYS&lt;/tt> and &lt;tt>AUTOEXEC.BAT&lt;/tt> files after MemMaker is done making changes.&lt;/figcaption>
&lt;/figure>
&lt;p>You can much read more in Microsoft&amp;rsquo;s own now-archived &lt;a href="https://jeffpar.github.io/kbarchive/kb/095/Q95555/">KB-Q9555 article&lt;/a> or the &lt;a href="https://archive.org/details/DOS_Beyond_640K_2nd_edition">DOS Beyond 640KB book&lt;/a>.&lt;/p>
&lt;p>And that&amp;rsquo;s it for today folks. I intentionally did &lt;em>not&lt;/em> touch on DPMI&amp;mdash;the technology that truly allowed DOS applications to break free from the 1 MB memory limitation&amp;mdash;because I&amp;rsquo;m saving that for the next article. So, make sure to come back for more!&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-01-17-8086-dos.jpg" length="220943" type="image/jpeg"/></item><item><title>Links: December 2023 edition</title><link>https://jmmv.dev/2023/12/links-december-2023-edition.html</link><pubDate>Sun, 31 Dec 2023 09:40:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/links-december-2023-edition.html</guid><description>&lt;p>December draws to a close as does 2023, which means it&amp;rsquo;s time for yet another monthly links recap.&lt;/p>
&lt;p>For context to everyone new around here, what follows is my manual curation of cool articles, videos, and projects I stumbled upon during this time period. But this is not &lt;em>just&lt;/em> a dump of links: &lt;em>each link is accompanied by a short commentary&lt;/em> that justifies why I thought the material was interesting, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading it.&lt;/p>
&lt;p>December has been a slow month though. During the first half, only a handful of articles caught my attention; and during the second half, I&amp;rsquo;ve been traveling so I haven&amp;rsquo;t paid much attention to news sites. In any case, there is some good content to enjoy this month. Read on and have a good entry to 2024!&lt;/p>
&lt;p>Happy new year!&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://dudemanguy.github.io/blog/posts/2022-06-10-wayland-xorg/wayland-xorg.html">&amp;ldquo;Wayland Isn&amp;rsquo;t Going to Save The Linux Desktop&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By dudemanguy on June 10, 2022&lt;/em>&lt;/p>
&lt;p>Do you know how Wayland works, how it differs from X.org, and how it has some architectural limitations that prevent it from solving some problems that X11 does not have? If not, this one is for you. This article is from 2022 but recently surfaced as a timely rant because Fedora is planning to drop X.org in the upcoming Fedora 40 release.&lt;/p>
&lt;p>Things will be&amp;hellip; &amp;ldquo;fun&amp;rdquo; for some of us soon. In my case, I use Fedora 39 and Wayland recently decided to stop working on my Mac Pro 2013 and fell back to X.org. And on my Surface Go 2, on which I need to use &amp;ldquo;bounce keys&amp;rdquo; to prevent repeated input due to some issues with the keyboard, the feature only works with X.org and not Wayland.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/strings-encodings-nuls-and-bazel.html">&amp;ldquo;Strings, encodings, NULs and Bazel&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 3rd, 2023&lt;/em>&lt;/p>
&lt;p>I came across a random tweet that suggested newcomers to C to represent strings as an array plus a length, without the traditional NUL terminator. The slightly-inflammatory tweet prompted me to write about why doing this is a bad idea and showed an example of the inefficiencies that arise from choosing to go your own way.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://virtuallyfun.com/2023/12/08/bsd-on-windows-things-i-wish-i-knew-existed/">&amp;ldquo;BSD on Windows: Things I wish I knew existed&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By neozeed on December 8th, 2023&lt;/em>&lt;/p>
&lt;p>Here is a thing from 1995 that I didn&amp;rsquo;t know existed: a BSD Unix distribution that ran on Windows 3.x. I wonder why this didn&amp;rsquo;t catch on but the likes of Cygwin did. By the way, this post made me remember &lt;strong>&lt;a href="https://www.delorie.com/djgpp/">DJGPP&lt;/a>&lt;/strong>, a distribution of GCC for DOS, and it&amp;rsquo;s something I&amp;rsquo;m considering to analyze and write about in an upcoming article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/a-cli-text-editor-in-my-windows.html">&amp;ldquo;A CLI text editor? In my Windows?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 8th, 2023&lt;/em>&lt;/p>
&lt;p>The Windows Terminal team at Microsoft is considering the addition of a command-line text editor by default in Windows. The thing is: Windows used to ship with one (&lt;code>EDIT.COM&lt;/code>) until they dropped the editor when moving to 64-bit editions&amp;hellip; and I&amp;rsquo;m kinda proposing that they bring something like the old editor back.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://github.com/TobyLobster/multiply_test">&amp;ldquo;6502 Integer Multiplication - which is best?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Toby Nelson&lt;/em>&lt;/p>
&lt;p>Discovered via a &lt;a href="https://news.ycombinator.com/item?id=38598940">discussion in HN&lt;/a>, this is a project that collects more than 120 multiplication algorithms and analyzes their behavior in detail on the 6502 8-bit processor. I barely knew this processor existed before seeing this article so I don&amp;rsquo;t particularly care for it, but the analysis is just mesmerizing and worth a read.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://www.whizzy.org/2023-12-14-bricked-xmas/">&amp;ldquo;Bricked Xmas&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Will Cooke on December 14th, 2023&lt;/em>&lt;/p>
&lt;p>An article on how to reverse-engineer Christmas LED lights that use Bluetooth to control the flashing patterns and how this process resulted in the bricking of said lights. The most interesting content in the article is the very foundations of reverse engineering a binary protocol when all you can do is see packets flow through the wire.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/hard-disk-leds-and-noisy-machines.html">&amp;ldquo;Hard disk LEDs and noisy machines&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 15th, 2023&lt;/em>&lt;/p>
&lt;p>While looking at yet another unexplained performance inefficiency that I observed, I wondered how many of these slip through because the machines we have today are &amp;ldquo;so powerful and quiet&amp;rdquo; that they absorb such abuse of resources without making a big fuss. I wrote a Twitter thread that explains how useful it was to have flashing LEDs for disk activity and loud fans during heavy CPU load, with a suggestion on what to do these days instead on your silent laptops.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://belkadan.com/blog/2022/10/Swift-in-the-OS/">&amp;ldquo;Swift was always going to be part of the OS&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Jordan Rose on October 9th, 2022&lt;/em>&lt;/p>
&lt;p>Using a language as part of an OS poses challenges on how the language and the OS can evolve, if at all, while preserving backwards compatibility. This article explains such difficulties in the context of Swift and justifies the choices that Apple made to allow using Swift for its own frameworks. The same challenges are not unique as they also apply to e.g. .NET in Windows, which Microsoft chose to solve in different ways.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://tim.siosm.fr/blog/2023/12/19/ssh-over-unix-socket/">&amp;ldquo;sudo without a setuid binary or SSH over a UNIX socket&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By TimothÃ©e Ravier on December 19th, 2023&lt;/em>&lt;/p>
&lt;p>Have you ever considered using SSH as a replacement for &lt;code>sudo&lt;/code> by leveraging a Unix socket and file permissions to protect access? I hadn&amp;rsquo;t, but after reading the title, this interesting solution sounded obvious. There is a lot of nuance though, so make sure to read on.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/bazel-interview-at-software-engineering.html">&amp;ldquo;Bazel interview at Software Engineering Daily&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 21st, 2023&lt;/em>&lt;/p>
&lt;p>Two months ago, Jordi Mon Companys interviewed me about various Bazel topics and the podcast episode finally came out this month. I wrote a detailed summary of the 45-minute recording so that you can know what to expect and where exactly to fast-forward to if you want to skip certain topics.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://arne.me/articles/emacs-from-scratch-part-one-foundations">&amp;ldquo;Emacs From Scratch, Part 1: Foundations&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Arne Bahlo on December 22nd, 2023&lt;/em>&lt;/p>
&lt;p>Doom Emacs is my go-to editor. This Emacs &amp;ldquo;distribution&amp;rdquo; is great because its configuration files are trivial to read and edit, but I still feel a bit uncomfortable due to the many abstractions in between those files and the &amp;ldquo;real Emacs&amp;rdquo;&amp;mdash;particularly when Doom Emacs greets me with &amp;ldquo;loaded 200 packages&amp;rdquo; that I know little about. In that regard, this article series seems promising and I might go back to configuring a minimal setup at some point. (The second part is already out at the time of this writing, by the way.)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://retrofun.pl/2023/12/18/was-basic-that-horrible-or-better/">&amp;ldquo;Was BASIC that horrible or&amp;hellip; better?&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Ikari on December 18th, 2023&lt;/em>&lt;/p>
&lt;p>BASIC has received a lot of hatred throughout the years, with Dijkstra claiming &amp;ldquo;It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.&amp;rdquo; Which, OK, fine. I can see that happening if you look at the original Dartmouth BASIC from the 1970s&amp;hellip; but later editions of BASIC included proper flow control to make these criticisms unfounded. Much more on this topic in the referenced article.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="/2023/12/the-ides-we-had-30-years-ago.html">&amp;ldquo;The IDEs we had 30 years ago&amp;hellip; and we lost&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By yours truly on December 25th, 2023&lt;/em>&lt;/p>
&lt;p>My Christmas gift to you all: a tour of the text-based IDEs we had about 30 years ago in DOS land to show how powerful and tiny they were at the time. The article contrasts them with the huge beasts we have nowadays and how they aren&amp;rsquo;t really that novel. And I write this as a &amp;ldquo;Unix convert&amp;rdquo; for many years.&lt;/p>
&lt;p>This is one of my most popular articles and further proves that my experiment with the move to Substack is worthwhile to gain an audience. Previous similarly-successful articles in my blog only brought in a handful of new subscribers, but this one has already raked tens in.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://github.com/minimaxir/hacker-news-undocumented/blob/master/README.md">&amp;ldquo;A List of Hacker News&amp;rsquo;s Undocumented Features and Behaviors&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By Max Woolf&lt;/em>&lt;/p>
&lt;p>If you are an avid Hacker News user like I am, this living guide is a must read. You&amp;rsquo;ll learn many of the ways in which content moderation works, a bunch of hidden endpoints, and the kinds of features that karma points enable.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;a href="https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory">&amp;ldquo;How x86_64 addresses memory&amp;rdquo;&lt;/a>&lt;/strong>&lt;br/>
&lt;em>By William Woodruff on June 13th, 2020&lt;/em>&lt;/p>
&lt;p>&lt;code>mov&lt;/code> is &lt;em>the&lt;/em> x86 instruction, and this article does a good job at looking at all possible memory addressing modes. The reason this is interesting is because the article also looks at &lt;em>why&lt;/em> each addressing mode is useful by mapping it to a C construct that benefits from it.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>The IDEs we had 30 years ago... and we lost</title><link>https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html</link><pubDate>Mon, 25 Dec 2023 10:40:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html</guid><description>&lt;p>I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we had. Having gained more knowledge throughout the years, it is now really fun to pick up DOSBox to re-experience those programs and compare them with our current state of affairs.&lt;/p>
&lt;p>This time around, I want to look at the pure text-based IDEs that we had in that era before Windows eclipsed the PC industry. I want to do this because those IDEs had little to envy from the IDEs of today&amp;mdash;yet it feels as if we went through a dark era where we lost most of those features for years and they are only resurfacing now.&lt;/p>
&lt;p>If anything, stay for a nostalgic ride back in time and a little rant on &amp;ldquo;bloat&amp;rdquo;. But, more importantly, read on to gain perspective on what existed before so that you can evaluate future feature launches more critically.&lt;/p>
&lt;div class="container action-highlight p-4 my-4 d-md-none">
&lt;div class="row text-center">
&lt;p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.&lt;/p>
&lt;/div>
&lt;div class="row">
&lt;div class="col">
&lt;div class="form-group">
&lt;form action="https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add" method="post">
&lt;input type="text" name="email"
placeholder="Enter your email"
class="form-control input-sm text-center my-1"/>
&lt;button type="submit" class="btn btn-primary btn-block my-1">Subscribe&lt;/button>
&lt;/form>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="row px-2">
&lt;div class="col col-sm-5 text-left">
&lt;small>&lt;span class="subscriber-count">0&lt;/span> subscribers&lt;/small>
&lt;/div>
&lt;div class="col col-sm-7 text-right">
&lt;p>
&lt;a rel="me" href="https://mastodon.online/@jmmv">
&lt;img src="/images/badges/mastodon-logo.svg" width="32px" height="32px" alt="Follow @jmmv on Mastodon">
&lt;/a>
&lt;a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;amp;screen_name=jmmv">
&lt;img src="/images/badges/Twitter_logo_blue.svg" width="32px" height="32px" alt="Follow @jmmv on Twitter">
&lt;/a>
&lt;a href="/feed.xml">&lt;img src="/images/badges/feed-icon-28x28.png" alt="RSS feed">&lt;/a>
&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="first-editors-and-tuis">First editors and TUIs&lt;/h1>
&lt;p>In the 1990s, almost every DOS program you ran had a full-screen Text User Interface (TUI) which sported text-based windows, drop shadows, colors, and mouse support. Here is just one example:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-edit-com-colors.png" class="with-border">
&lt;figcaption>The MS-DOS Editor (aka &lt;tt>EDIT.COM&lt;/tt>) with one of its settings dialog open. Note the menu bar, the rich dialog with list selectors and buttons, and the status bar documenting navigation shortcuts.&lt;/figcaption>
&lt;/figure>
&lt;p>Each program was its own island because its interface was unique to the program. However, they were all so similar in how they looked like&amp;mdash;80x25 characters didn&amp;rsquo;t leave much room for uniqueness&amp;mdash;and how they worked that the differences didn&amp;rsquo;t really get in the way of usability and discoverability. Once you learned that the Alt key opened the menus and that Tab moved across input fields and buttons, you could navigate almost any program with ease.&lt;/p>
&lt;p>But let&amp;rsquo;s talk about editors. MS-DOS shipped with a TUI text editor since version 5 (1991), which &lt;a href="/2023/12/a-cli-text-editor-in-my-windows.html">I previously covered in a recent article&lt;/a> and is shown above. This editor &amp;ldquo;worked&amp;rdquo;, but it was really inconvenient for coding: you needed to exit the editor to compile and run your code, and when you re-ran the editor, you&amp;rsquo;d have to navigate back to where you were before.&lt;/p>
&lt;p>&amp;ldquo;In my house&amp;rdquo;, we used something called &lt;a href="https://en.wikipedia.org/wiki/Borland_Sidekick">SideKick Plus&lt;/a> (1984), which wasn&amp;rsquo;t really a code editor: it was more of a Personal Information Management (PIM) system with a built-in notepad. The cool thing about it, however, was that it was a Terminate and Stay Resident (TSR) program, which meant that it loaded in the background and you could bring it up at any time by pressing Ctrl+Alt.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-sidekick-plus.png" class="with-border">
&lt;figcaption>SideKick Plus' main screen after pressing Ctrl+Alt to bring it up. Note how DOS remains in the background.&lt;/figcaption>
&lt;/figure>
&lt;p>Think of this TSR feature as rudimentary multitasking for an OS that did &lt;em>not&lt;/em> have multitasking. This was really effective because quickly switching between code editing and building is critical for an efficient inner development loop. (And by the way, this past experience explains the design of the &lt;a href="https://www.endbasic.dev/docs.html#intro-first">code editing flow in EndBASIC&lt;/a>. I did not implement the equivalent of Ctrl+Alt, but I&amp;rsquo;ve considered it many times.)&lt;/p>
&lt;p>By this point, however, real IDEs had already existed for a few years. Turbo Pascal 1.0 (1983) shows the beginning of an integrated experience, although it did not feature its iconic TUI yet. QuickBASIC 2.0 (1986) shows more of a &amp;ldquo;traditional&amp;rdquo; TUI (the same as &lt;code>EDIT.COM&lt;/code>, because they are the same editor), and MS-DOS 5 came with QBasic, a reduced version of QuickBASIC that didn&amp;rsquo;t allow compiling to native code but that had the same look.&lt;/p>
&lt;h1 id="the-borland-turbo-series">The Borland Turbo series&lt;/h1>
&lt;p>The crown jewel of IDEs, in my opinion, were the later Borland Turbo series, which included Turbo C++ (1990), Turbo Assembler and Turbo Pascal. These IDEs were language specific, but they had full-screen TUIs and were extremely powerful.&lt;/p>
&lt;p>Here, take a look at what we had. Syntax highlighting:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-syntax-highlighting.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing a "Hello World" program to demonstrate syntax highlighting.&lt;/figcaption>
&lt;/figure>
&lt;p>Compiler integration and diagnostics:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-warnings.png" class="with-border">
&lt;figcaption>Borland Turbo C++ after compiling a program, showing a warning because I did not return a value from &lt;tt>main()&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Integrated project and build system management:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-project.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing its project management and multi-window features. In the picture, you can see two C++ source files, with one depending on the other, and the project window listing all files that need to be compiled together.&lt;/figcaption>
&lt;/figure>
&lt;p>A debugger with breakpoints, stack traces, and the like:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-debugger.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing a debugging session with a program that contains multiple functions, a breakpoint, and the current call stack.&lt;/figcaption>
&lt;/figure>
&lt;p>And even a full reference manual:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-turbo-cpp-help.png" class="with-border">
&lt;figcaption>Borland Turbo C++ showing its integrated help system, with the "Hello World" program in the background and the help for &lt;tt>printf&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Remember: all of this in the early 1990s&amp;mdash;a little over 30 years ago at the time of this writing.&lt;/p>
&lt;p>I was an avid user of Turbo C++, with which I learned a lot. I remember using their &lt;code>conio.h&lt;/code> libraries to implement TUIs of my own, and then their builtin &lt;code>graphics.h&lt;/code> libraries to play with implementing GUIs. And note: this was &lt;em>without the Internet&lt;/em>. There was no option for many to just &amp;ldquo;look up how things worked&amp;rdquo; in Stack Overflow: the IDE had to be discoverable right away (which it was) and self-contained to offer you a complete development experience.&lt;/p>
&lt;h1 id="what-about-linux-back-then">What about Linux back then?&lt;/h1>
&lt;p>Now take a moment to compare this scene with Linux in the early 1990s.&lt;/p>
&lt;p>In Linux, almost every program was &lt;em>also&lt;/em> text based, but those programs did not come with a full-screen TUI. It just wasn&amp;rsquo;t &amp;ldquo;the Unix way&amp;rdquo;. I remember watching the X11 configuration tool (&lt;a href="https://www.xfree86.org/3.3.6/QuickStart3.html">&lt;code>XF86Setup&lt;/code>&lt;/a>) or the OpenBSD installer and feeling shocked by how simplistic those were: me, a young teenager with barely any &amp;ldquo;real&amp;rdquo; coding experience, had written better-looking programs already.&lt;/p>
&lt;p>In any case, this didn&amp;rsquo;t stop me from my quest to &lt;em>not&lt;/em> use Windows. I continued to learn the ways of Linux and soon faced the &amp;ldquo;best&amp;rdquo; editors recommended by every book and community online: Vim and Emacs. And I could not understand why they were praised. Using these was like stepping back into the past. They were full-screen programs indeed, but they seemed pretty arcane. Vim did have syntax highlighting but it was far from being an IDE. Emacs could be configured to integrate with some code assisting features and the like, but it was far from being &amp;ldquo;fire and forget&amp;rdquo; like the Turbo family of IDEs.&lt;/p>
&lt;p>Just look at the default Emacs configuration &lt;em>today&lt;/em>, which hasn&amp;rsquo;t changed much (if at all) since then. It does have windows, but they aren&amp;rsquo;t decorated. It didn&amp;rsquo;t have colors (and now barely has), because why? It didn&amp;rsquo;t use to have mouse support. It &lt;em>does&lt;/em> have a menu bar though, but it is just a gimmick? If you press &lt;tt>M-`&lt;/tt> as the instructions tell you, you face a truly strange interface to navigate the menu&amp;mdash;which makes one wonder why they even bothered to waste a full line of screen real state to show a menu bar that does nothing.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-emacs-menubar.png" class="with-border">
&lt;figcaption>A fresh installation of Emacs in the console, with the standard welcome screen in the background and the "menu" open after pressing &lt;tt>M-`&lt;/tt>.&lt;/figcaption>
&lt;/figure>
&lt;p>Now try giving this to anyone with little coding experience and getting them to create, compile, and debug a program. They will have trouble just navigating the editor, and they won&amp;rsquo;t find any of the features that would allow for project management or compiler integration.&lt;/p>
&lt;p>For comparison, in writing this post, I fired up Turbo C++ in DOSBox and I was able to create a &amp;ldquo;hello world&amp;rdquo; project and navigate the environment in minutes&amp;mdash;all without prior knowledge (everything I had known has been forgotten by now). The environment is intuitive and, as an IDE, integrated all around.&lt;/p>
&lt;h1 id="contemporary-tui-ides">Contemporary TUI IDEs&lt;/h1>
&lt;p>Anyhow. Let&amp;rsquo;s forget about the past and look at what we have today in TUI-land. I don&amp;rsquo;t want to look at GUIs because&amp;hellip; well, Visual Basic was the pinnacle of graphics programming and we don&amp;rsquo;t have that either anymore&amp;mdash;which is also a topic for another day. (Well, OK, you have &lt;a href="https://gambas.sourceforge.net/">Gambas&lt;/a>&amp;hellip; but who knows about it?)&lt;/p>
&lt;p>The closest more-modern equivalent to the Borland Turbo C++ environment is &lt;a href="https://directory.fsf.org/wiki/RHIDE">RHIDE&lt;/a>. As you can see in the picture below, it looks incredibly similar&amp;mdash;and you&amp;rsquo;d be forgiven if you thought this &lt;em>is&lt;/em> Turbo C++. Unfortunately, it is DOS-only and seems to be mostly abandoned by now with its latest release dated 7 years ago.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-rhide.png" class="with-border">
&lt;figcaption>The RHIDE IDE showing the same "hello world" program as before, with no errors nor warnings after compilation.&lt;/figcaption>
&lt;/figure>
&lt;p>Then we have &lt;a href="https://www.freepascal.org/">Free Pascal&lt;/a>. This is the closest you&amp;rsquo;ll get to the old experience but with a modern codebase, running natively on Unix systems and leveraging terminals of any size.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-free-pascal.png" class="with-border">
&lt;figcaption>The Free Pascal IDE with a trivial "hello world" program and overlapping windows for a built-in ASCII table and a calculator.&lt;/figcaption>
&lt;/figure>
&lt;p>And lastly we have &lt;a href="https://qb64.com/">QB64&lt;/a>. This closely resembles Microsoft QuickBasic but&amp;hellip; don&amp;rsquo;t let it trick you: even though it looks like a TUI, it is actually a GUI application that simulates a TUI. You cannot run QB64 in a terminal.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-qb64.png" class="with-border">
&lt;figcaption>The QB64 IDE, which looks textual but is actually a graphical program.&lt;/figcaption>
&lt;/figure>
&lt;p>Both Free Pascal and QB64 are maintained and under relatively-active development, with their most recent releases in 2021&amp;hellip; but they are mostly ignored because they expose arcane languages that most people have no interest in these days.&lt;/p>
&lt;h1 id="real-contemporary-console-ides">&amp;ldquo;Real&amp;rdquo; contemporary console IDEs&lt;/h1>
&lt;p>So what are we left with for &lt;em>modern&lt;/em> languages today?&lt;/p>
&lt;p>The state of the art seems to be &lt;a href="https://neovim.io/">Neovim&lt;/a>, &lt;a href="https://github.com/doomemacs/doomemacs">Doom Emacs&lt;/a>, or even &lt;a href="https://helix-editor.com/">Helix&lt;/a>. These editors are very powerful and, thanks to various plugins, offer reasonable IDE-like experiences. That said, if you ask me, none of these provide the same kind of experience that the previous Borland products offered: their interfaces are obscure and, due to their multi-language nature, they work OK for almost everything but they aren&amp;rsquo;t great for anything. &amp;ldquo;Jack of all trades, master of none&amp;rdquo; if you will.&lt;/p>
&lt;p>In any case, the preferred &amp;ldquo;simple&amp;rdquo; TUI editor, based on what I observed in the deranged &lt;a href="https://github.com/microsoft/terminal/discussions/16440">microsoft/terminal#16440&lt;/a> discussion, seems to be&amp;hellip; &lt;a href="https://www.nano-editor.org/">GNU Nano&lt;/a>&amp;hellip; which OK, it works, but first: it&amp;rsquo;s no IDE, and second, to me this looks like WordStar. Yeah, I know it isn&amp;rsquo;t WordStar: if you want WordStar, the closest you&amp;rsquo;ll find is &lt;a href="https://joe-editor.sourceforge.io/">Joe&lt;/a>, but the &lt;em>looks&lt;/em> of Nano remind me of my first experiences with a word processor back in the CP/M days. Here, look:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-25-nano.png" class="with-border">
&lt;figcaption>The GNU Nano editor in its default setup, with an empty file open.&lt;/figcaption>
&lt;/figure>
&lt;p>So even though we &lt;em>do&lt;/em> have powerful console editors these days, they don&amp;rsquo;t quite offer the same usable experience we had 30 years ago. In fact, it feels like during these 30 years, we regressed in many ways, and only now are reaching feature parity with some of the features we used to have.&lt;/p>
&lt;p>It is natural that TUIs diminished in popularity once graphical OSes gained traction, and it is somewhat interesting that they are making a comeback just now. As for why, I think we have to thank the invention of &lt;a href="https://microsoft.github.io/language-server-protocol/">LSP&lt;/a> for most of the recent progress in this area. TUI editors were &amp;ldquo;on hold&amp;rdquo; for many years because building IDE features for them was a lot of effort and their small maintainer base could not afford to implement them. LSP unlocked access to existing language-specific integrations and reinfused interest in the old-and-trusty Vim and Emacs. Hopefully, the upcoming &lt;a href="https://build-server-protocol.github.io/">BSP&lt;/a> will do even more to make these TUIs more IDE-like.&lt;/p>
&lt;h1 id="why-tui-ides-anyway">Why TUI IDEs anyway?&lt;/h1>
&lt;p>It is fair to ask &amp;ldquo;Who cares? Every desktop and laptop runs a graphical OS now!&amp;rdquo;&lt;/p>
&lt;p>And it&amp;rsquo;s a good question. In general, you probably &lt;em>don&amp;rsquo;t&lt;/em> want a TUI IDE. If VSCode is your jam, its remoting abilities are superb and VSCode has a reasonably good graphical interface without being a full-blown IDE. But there are a few things that VSCode doesn&amp;rsquo;t give us.&lt;/p>
&lt;p>The first is that a TUI IDE is excellent for work on remote machines&amp;mdash;even better than VSCode. You can SSH into &lt;em>any&lt;/em> machine with ease and launch the IDE. &lt;a href="/2015/09/my-coding-workflow.html">Combine it with tmux and you get &amp;ldquo;full&amp;rdquo; multitasking.&lt;/a> Yes, you could instead use a remote desktop client instead of SSH, but I&amp;rsquo;ve always found them clunky due to lag and the improper integration with the local desktop shortcuts.&lt;/p>
&lt;p>The second is that &lt;a href="https://code.visualstudio.com/docs/remote/faq#_why-arent-the-remote-development-extensions-or-their-components-open-source">VSCode&amp;rsquo;s remote extensions are &lt;em>not&lt;/em> open source&lt;/a>, which isn&amp;rsquo;t a major problem&amp;hellip; except for the fact that they don&amp;rsquo;t work on, say, FreeBSD and there is no way to fix them. So this makes it impossible for me to remote into my primary development server with VSCode.&lt;/p>
&lt;p>And the third is&amp;hellip; reduced resource consumption.&lt;/p>
&lt;h1 id="bloat-everywhere">Bloat everywhere&lt;/h1>
&lt;p>I can&amp;rsquo;t leave without ranting about &amp;ldquo;bloat&amp;rdquo; for a little bit. Borland Turbo C++, with all its bells and whistles (the UI, the C++ toolchain, the integrated manuals&amp;hellip;), is less than 9 MB after installation and ran within 640kb of RAM.&lt;/p>
&lt;p>For comparison, Helix is 16 MB on disk, which is pretty impressive (and honestly unexpected), but Doom Emacs is about 500 MBs and consumes many MBs of RAM. Note, however, that none of these numbers account for the language toolchains or help systems, and toolchains nowadays rank in the GBs of disk space.&lt;/p>
&lt;p>To get &amp;ldquo;real&amp;rdquo; IDEs, we have to jump to graphical programs like IntelliJ or VSCode. VSCode, for example, is about 350 MBs on disk (surprisingly less than Doom Emacs) but it will eat your computer for lunch: it&amp;rsquo;s Electron after all. I have noticed very significant savings in laptop battery life by dropping VSCode and moving to Doom Emacs.&lt;/p>
&lt;p>So the question I want to part with is: have we advanced &lt;em>much&lt;/em> in 30 years? Modern IDEs have some better refactoring tools, better features, and support more languages, but fundamentally&amp;hellip; they haven&amp;rsquo;t changed much. The only major difference that we are &lt;em>starting&lt;/em> to see might be AI-assisted coding, but this is a feature mostly provided by a remote service, not even by the installed code!&lt;/p>
&lt;p>And that&amp;rsquo;s all for today. On my side, I&amp;rsquo;ll happily continue using &lt;em>all of&lt;/em> Doom Emacs, Vim, VSCode, and IntelliJ depending on the situation. Merry Christmas if this is your thing!&lt;/p></description></item><item><title>Bazel interview at Software Engineering Daily</title><link>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</link><pubDate>Thu, 21 Dec 2023 09:50:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</guid><description>&lt;p>Just a bit over 2 months ago, on October 5th, 2023, Jordi Mon Companys interviewed me about Bazel for an episode in the &lt;a href="https://softwareengineeringdaily.com/">Software Engineering Daily&lt;/a> podcast. The episode finally came out on December 18th, 2023, so here is your announcement to stop by and listen to it!&lt;/p>
&lt;figure>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
&lt;img src="/images/2023-12-21-bazel-interview-cover.jpg" class="with-border" />
&lt;/a>
&lt;figcaption>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
Cover image (and link) to the Bazel interview in Software Engineering Daily.
&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;p>If you don&amp;rsquo;t have time to listen to the whole 45 minutes, or if you want to get a sense of what you will get out of it, here is a recap of everything we touched on. Every paragraph is annotated with the rough time where the discussion starts so that you can jump right in to whatever interests you the most.&lt;/p>
&lt;h1 id="my-background">My background&lt;/h1>
&lt;p>&lt;strong>[01:10]&lt;/strong> Introduction about myself. Really brief overview about my roles and the companies I&amp;rsquo;ve been at throughout the years.&lt;/p>
&lt;p>&lt;strong>[01:58]&lt;/strong> A retrospective about how I got into computers and why I think things were much easier to dive into years ago. In other words, a plug for &lt;a href="https://www.endbasic.dev/">EndBASIC&lt;/a>.&lt;/p>
&lt;p>&lt;strong>[03:34]&lt;/strong> My history with open source projects and how I got into Linux, the BSDs, and why I ended up as a contributor to NetBSD.&lt;/p>
&lt;p>&lt;strong>[05:05]&lt;/strong> How my background helped me join Google as a Site Reliability Engineer (SRE), even if I did not have much experience in systems administration. SRE is a really cool position because of the many paths that lead into it!&lt;/p>
&lt;p>&lt;strong>[05:51]&lt;/strong> Why I moved years later to the Bazel team as a software engineer while remaining at Google.&lt;/p>
&lt;h1 id="introduction-to-bazel">Introduction to Bazel&lt;/h1>
&lt;p>&lt;strong>[06:57]&lt;/strong> Google and internal tools. Why Google invented &amp;ldquo;everything&amp;rdquo; in house, including Bazel and the distributed build services it relies on.&lt;/p>
&lt;p>&lt;strong>[08:35]&lt;/strong> Brief introduction to what Bazel is: a polyglot build system.&lt;/p>
&lt;p>&lt;strong>[10:11]&lt;/strong> Thoughts on the distinction&amp;mdash;or rather, lack thereof&amp;mdash;between build systems and CI systems. While they have been traditionally thought of as separate, they are pretty intertwined and you need your CI system to be as aware of the build process as possible to be maximally efficient.&lt;/p>
&lt;p>&lt;strong>[10:56]&lt;/strong> Brief introduction to what the Starlark language is, why it exists, and how it is used to define Bazel rules. Includes a brief explanation of major Bazel concepts such as targets, rules, and actions.&lt;/p>
&lt;p>&lt;strong>[13:28]&lt;/strong> Thoughts on why Bazel is a good fit for a monorepo.&lt;/p>
&lt;h1 id="build-incrementality">Build incrementality&lt;/h1>
&lt;p>&lt;strong>[14:45]&lt;/strong> Description of how build incrementality works and how Bazel determines which parts of the build graph to rebuild. Covers how traditional file systems use timestamps, how Bazel tries to do something better, and how you can do even fancier stuff if you have the right support from the file system.&lt;/p>
&lt;p>&lt;strong>[17:36]&lt;/strong> Deeper dive into Skyframe: the component within Bazel that tracks the build graph and helps decide which parts need to be rebuilt every time.&lt;/p>
&lt;p>&lt;strong>[19:02]&lt;/strong> Separation of local machine vs. remote machine resources: what parts of the build happen where? Is the build graph &amp;ldquo;in the cloud&amp;rdquo; too?&lt;/p>
&lt;p>&lt;strong>[20:06]&lt;/strong> Notes on how Bazel decides how to behave (spolier alert: manual configuration) and a mini-rant about Bazel having too many flags.&lt;/p>
&lt;h1 id="dependency-management">Dependency management&lt;/h1>
&lt;p>&lt;strong>[21:12]&lt;/strong> Exploring dependency management for third-party packages, focusing on how Google had traditionally done this in their monorepo.&lt;/p>
&lt;p>&lt;strong>[22:16]&lt;/strong> Deeper dive into the history of dependency management by looking into how the workspace file came to be and why it has limitations.&lt;/p>
&lt;p>&lt;strong>[24:01]&lt;/strong> Extending Bazel, or rather the difference between the Java core vs. the Starlark ecosystem, and how the Build API bridges the gap between the two.&lt;/p>
&lt;p>&lt;strong>[25:34]&lt;/strong> Brief digression into the newly-released &lt;a href="https://buck2.build/">Buck2&lt;/a>.&lt;/p>
&lt;h1 id="bazel-migrations">Bazel migrations&lt;/h1>
&lt;p>&lt;strong>[26:23]&lt;/strong> Migrating to Bazel at a company like Snowflake. Exploration of where the difficulties arise.&lt;/p>
&lt;p>&lt;strong>[28:50]&lt;/strong> Discussion on how platform engineering is becoming its own thing, with the goal of building developer tools and experiences as company-internal products.&lt;/p>
&lt;p>&lt;strong>[30:44]&lt;/strong> Highlights of the primary (positive) benefits for the users after a Bazel migration: fast builds and &lt;a href="/2020/12/google-no-clean-builds.html">no more &amp;ldquo;make clean&amp;rdquo;&lt;/a>.&lt;/p>
&lt;h1 id="remote-execution">Remote execution&lt;/h1>
&lt;p>&lt;strong>[32:59]&lt;/strong> Integration of Bazel with remote services. Differences between remote caching and remote execution, and an exploration of different implementations of each.&lt;/p>
&lt;p>&lt;strong>[34:25]&lt;/strong> Brief discussion on generating SBOMs and how Bazel&amp;rsquo;s dependency tracking is perfectly aligned to provide these.&lt;/p>
&lt;p>&lt;strong>[35:26]&lt;/strong> Sandboxing. A discussion on the different levels of what you can restrict per platform and the trade-offs in complexity and performance. In other words: sandboxing is a spectrum.&lt;/p>
&lt;h1 id="forward-looking-plans">Forward-looking plans&lt;/h1>
&lt;p>&lt;strong>[37:15]&lt;/strong> Bazel&amp;rsquo;s future plans. Not my plans nor predictions, but rather what&amp;rsquo;s coming up in Bazel 7. (&lt;a href="https://blog.bazel.build/2023/12/11/bazel-7-release.html">Already released&lt;/a> at the time of this writing.)&lt;/p>
&lt;p>&lt;strong>[38:14]&lt;/strong> My wishlist for Bazel, which is basically &lt;a href="/2015/04/on-bazel-and-open-source.html">what I brought up back in 2015&lt;/a>: it&amp;rsquo;d be awesome if it was smaller so that it could be usable in the smaller projects that lie in the foundations of the Unix systems we use today.&lt;/p>
&lt;p>&lt;strong>[38:49]&lt;/strong> Thoughts on the upcoming BazelCon. (It was awesome. See &lt;a href="/2023/10/bazelcon-2023-et-al-trip-report.html">my attendance report&lt;/a>!)&lt;/p>
&lt;h1 id="source-control">Source control&lt;/h1>
&lt;p>&lt;strong>[39:30]&lt;/strong> Digression on source control, how Git is not great for monorepos, and how Google ended up building their own thing after using Perforce for many years. Also a brief explanation on how Bazel can leverage source control system integrations for better performance.&lt;/p>
&lt;p>&lt;strong>[42:28]&lt;/strong> And a related follow-up topic: test selection strategies in a massive monorepo, starting with how unit tests are easy to handle but doing something smart about integration tests requires heurisitics or maybe some sort of AI.&lt;/p>
&lt;p>And that&amp;rsquo;s about it. Hope you enjoy this episode!&lt;/p></description></item><item><title>Hard disk LEDs and noisy machines</title><link>https://jmmv.dev/2023/12/hard-disk-leds-and-noisy-machines.html</link><pubDate>Fri, 15 Dec 2023 09:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/12/hard-disk-leds-and-noisy-machines.html</guid><description>&lt;p>The computers of yesteryear had this little feature known as blinking LED lights ð. They also had this other feature called noisy disks ð¾ and loud fans ðª­. Uh wait. Features? Why &amp;ldquo;features&amp;rdquo; and not &amp;ldquo;annoyances&amp;rdquo;?! ð§µð&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-15-retro-pc-leds.jpg" class="with-border">
&lt;figcaption>Front panel of a common PC case in the late 1990s. My Pentium MMX 166 was hosted in one of these.&lt;/figcaption>
&lt;/figure>
&lt;p>You see, these bright lights and loud noises acted as canaries ð¦ in a performance mine. They gave developers a chance to notice when things were off performance-wise. If your code abused the CPU or the hard disk by mistake, you could tell right away.&lt;/p>
&lt;p>Nowadays, developer machines tend to be quiet under heavy load, and the vast majority of laptops don&amp;rsquo;t even have lights anymore. The obvious example are Macs: they haven&amp;rsquo;t had hard disk LEDs for a really long time, and since the M1, they are silent and cold too.&lt;/p>
&lt;p>These characteristics are nice from a usability perspective. Unfortunately, as a developer, you now need to first &lt;em>imagine&lt;/em> that something is wrong before even deciding to look for a problem. If the thought never crosses your mind, then you may never look.&lt;/p>
&lt;p>Let me give you a few examples of the kinds of inefficiencies that I&amp;rsquo;m talking about. These would have been trivially noticed by the presence of indicators. These are all based on real-world situations I faced at some point in the (recent) past.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ðªµ In a project I worked on, our development builds started writing about 80 MB of log messages &lt;em>per second&lt;/em> to disk. No matter how you look at it, that&amp;rsquo;s &lt;em>a lot&lt;/em> of disk traffic, and yet&amp;hellip; the problematic code passed code review and was merged into the main branch.&lt;/p>
&lt;p>The only indication that something was wrong was when &lt;em>other&lt;/em> developers came asking for help because their local disk space was running out faster than usual. There was no other symptom behind the problem.&lt;/p>
&lt;p>You&amp;rsquo;d hope that this inefficiency would be caught while qualifying the new release for production because, in theory, such logging waste would translate in an increase in CPU consumption or network bandwidth. But&amp;hellip; I&amp;rsquo;m not so sure the issue would have been noticed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ð In another project I worked on, I noticed that Bazel took an incredibly long time to complete some actions. It wasn&amp;rsquo;t until I looked in detail that I saw it stuck in a loop fetching the same remote artifact over and over again due to connection resets.&lt;/p>
&lt;p>The build completed successfully after many minutes once Bazel gave up on the downloads and fell back local execution. There was no reason to suspect that something was wrong other than &amp;ldquo;these actions are just huge&amp;rdquo;. In reality, though, there was a bug somewhere.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ð§± Just today, I was in a video call and noticed that my laptop was reading 100MB/s from disk non-stop. I concluded the meeting but the disk reads didn&amp;rsquo;t stop. A quick peek at &lt;code>top&lt;/code> showed something called &lt;code>WallpaperVideoExtension&lt;/code> that seemed to have gone rogue.&lt;/p>
&lt;p>This background process was consuming one full CPU, but such load wasn&amp;rsquo;t enough to make the system feel slower nor noisier. I suppose I would eventually have noticed that the battery was running out quicker than usual, but maybe not.&lt;/p>
&lt;p>Killing the process made the problem go away and the constant disk reads stopped. Looking online, I find other instances of &lt;code>WallpaperVideoExtension&lt;/code> consuming lots of CPU and memory, so this seems to be a bug. But if it&amp;rsquo;s common, why wasn&amp;rsquo;t it noticed in the first place?&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In any case, this last scenario gives you a hint ð as to where I&amp;rsquo;m going: how did I even notice this last problem? After all, my M1 Mac was working just fine: it was just slightly warmer than usual but there was no loud fan noise nor lights to tell me about disk activity.&lt;/p>
&lt;p>The answer is simple: I have an omnipresent performance monitor in my screen that shows CPU load, memory pressure, disk I/O throughput, and network traffic. This monitor is always visible, taking little space in the menu bar or the task bar.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-15-istat-menus.png" class="with-border">
&lt;figcaption>iStat Menus on the macOS menu bar, with the panel for CPU usage tracking open.&lt;/figcaption>
&lt;/figure>
&lt;p>Every time I sense something is a tiny bit off, I glance ð at the monitor. You cannot imagine how many times I&amp;rsquo;ve gone &amp;ldquo;huh, that&amp;rsquo;s interesting&amp;rdquo; by seeing unexpected activity and then went on to discover big performance problems somewhere in the system.&lt;/p>
&lt;p>My recommendation is that you stop what you are doing and go and install such a performance monitor &lt;em>right now&lt;/em>. I&amp;rsquo;d even argue that having one always visible should be a hard requirement for any development machine and corp IT departments should preinstall one.&lt;/p>
&lt;p>Personally, I&amp;rsquo;m a huge fan of &lt;a href="https://bjango.com/mac/istatmenus/">iStat Menus&lt;/a> for macOS and have been using it for years. But if macOS is not your thing, you can find similar tools for other platforms like &lt;a href="https://extensions.gnome.org/extension/3010/system-monitor-next/">system-monitor-next&lt;/a> for Gnome.&lt;/p>
&lt;p>Unfortunately, these monitors only help if you develop on your local machine&amp;mdash;a workflow that&amp;rsquo;s becoming exceedingly rare. If, instead, you SSH into remote virtual machines to do your development or use VSCode&amp;rsquo;s remote features, you&amp;rsquo;ll need a different answer.&lt;/p>
&lt;p>This is a situation I face right now. The modern ThinkStation I have in the garage is well-equipped with useful lights&amp;hellip; but I only access it over SSH for development so those lights and its disk noises are kinda useless from where I sit.&lt;/p>
&lt;p>And I&amp;rsquo;m not sure what the right answer here is. If you have been around for a while, you may remember &lt;a href="http://gkrellm.srcbox.net">GKrellM&lt;/a>, which I was an avid user of. This system monitor had the ability to display &lt;em>remote&lt;/em> machine activity and I&amp;rsquo;d love to have that again.&lt;/p></description></item><item><title>A CLI text editor? In my Windows?</title><link>https://jmmv.dev/2023/12/a-cli-text-editor-in-my-windows.html</link><pubDate>Fri, 08 Dec 2023 14:45:00 -0800</pubDate><guid>https://jmmv.dev/2023/12/a-cli-text-editor-in-my-windows.html</guid><description>&lt;p>&lt;em>It&amp;rsquo;s more likely than you think!&lt;/em>&lt;/p>
&lt;p>In a surprising twist of events, Microsoft is &lt;a href="https://twitter.com/plante_msft/status/1732857615997132834">exploring the addition of a command-line (CLI) text editor to Windows&lt;/a>. If you ask me, &lt;em>not&lt;/em> having a CLI text editor on Windows is mind-boggling: you can access a Windows machine via SSH these days, so not having an editor that works in the console is a big handicap for remote system administration. So, should Windows bundle a CLI text editor? Of course it should.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-windows-95-edit-com.png" class="with-border">
&lt;figcaption>Windows 95 running an MS-DOS Prompt with the &lt;tt>EDIT.COM&lt;/tt> that shipped with it.&lt;/figcaption>
&lt;/figure>
&lt;p>But&amp;hellip; wait as second. Didn&amp;rsquo;t Windows use to ship with a CLI text editor? The one inherited from MS-DOS? Yes it did. So what happened? How was the editor lost? Let&amp;rsquo;s take a peek at the history and let&amp;rsquo;s see if you agree with me that Microsoft should revive the old editor instead of bundling modern-yet-alien Vim or Emacs.&lt;/p>
&lt;p>By the way, this post is brought to you by the inspiration provided by my first paid subscriber. Thank you very much, K., for taking this step and supporting my work.&lt;/p>
&lt;h1 id="in-the-beginning-there-was-edlin">In the beginning, there was Edlin&lt;/h1>
&lt;p>Early versions of DOS (1980) all the way through MS-DOS 5.0 (1990) included a &amp;ldquo;line editor&amp;rdquo; called &lt;a href="https://en.wikipedia.org/wiki/Edlin">Edlin&lt;/a> and nothing else. You may have never heard of or used a line editor, so let me show you how they look like and work. Here is a sample session with Edlin:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">C:\&amp;gt;EDLIN TEST.TXT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">New file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*I
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1:*second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3:*[Ctrl+Z followed by Enter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*L
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1: second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2: delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*1I
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1:*first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*[Ctrl+Z followed by Enter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*L
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1: first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2:*second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3: delete me
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*3D
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*W
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*E
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">C:\&amp;gt;TYPE TEST.TXT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">second line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">C:\&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see from the above, a line editor does not have a full-screen UI. Instead, the editor works by letting you issue textual commands that affect the contents of a file. You can insert new lines, delete existing ones, modify their content, and list what the file has in it&amp;mdash;much like how you enter programs in a line-oriented BASIC interpreter or how you interact with the files on your machine via the shell.&lt;/p>
&lt;p>Needless to say, and while line editors work and are truly amenable to scripting, they are not particularly intuitive nor user-friendly. I have to wonder why MS-DOS shipped with &lt;em>just&lt;/em> Edlin until 1990. After all, by the time Edlin was created in 1980, full-screen editors like &lt;code>vi(1)&lt;/code> had already existed for 4 years so it&amp;rsquo;s not like they were impossible to create. However, it&amp;rsquo;s plausible that the limitations of DOS and the machines that DOS ran on made it much more difficult to recreate an editor like &lt;code>vi(1)&lt;/code>, which was made for Unix systems that ran on more powerful hardware.&lt;/p>
&lt;p>As an aside: &lt;code>ed(1)&lt;/code> and &lt;code>ex(1)&lt;/code> are similar to Edlin and you have both &lt;em>today&lt;/em> on pretty much any Unix or Linux system you access. And the &lt;code>vi(1)&lt;/code> that you like is &amp;ldquo;just&amp;rdquo; a facade over &lt;code>ex(1)&lt;/code>. When you use the &lt;code>:&lt;/code> command to get to the &lt;code>vi(1)&lt;/code> prompt to type a command, what you are typing are &lt;code>ex(1)&lt;/code> commands. Keep that in mind if you ever face a situation where the terminal doesn&amp;rsquo;t work and all you can use are the line editors: previous &lt;code>vi(1)&lt;/code> knowledge could come in handy.&lt;/p>
&lt;h1 id="and-microsoft-said-let-there-be-editcom">And Microsoft said, &amp;ldquo;Let there be EDIT.COM&amp;rdquo;&lt;/h1>
&lt;p>In 1990, Microsoft launched MS-DOS 5.0 and, with it, a full-screen text editor called &lt;a href="https://en.wikipedia.org/wiki/MS-DOS_Editor">MS-DOS Editor&lt;/a>, or &lt;code>EDIT.COM&lt;/code> for short. This editor was built on QBasic and it featured a full-screen interactive UI. The latest version of the editor, which was included with Windows 9x (MS-DOS 7.x), looked like this:&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-dosbox-edit-com.png" class="with-border">
&lt;figcaption>The original &lt;tt>EDIT.COM&lt;/tt> from Windows 9x running in DOSBox.&lt;/figcaption>
&lt;/figure>
&lt;p>This new version of the editor was obviously much more usable and welcoming than Edlin. As you can see from the picture, &lt;code>EDIT.COM&lt;/code> featured a full-screen windowed textual interface with support for multiple files (in its Windows 9x versions), drop down menus, and even mouse integration. These interfaces were extremely common back in the day in DOS: almost every program you ran launched a full-screen UI with textual windows and menus.&lt;/p>
&lt;p>Interestingly, interfaces like these were never a thing on Unix systems and I must confess I was shocked when I first moved from DOS to Linux. I was used to Borland Turbo C++ and WordPerfect 5.1, so when I faced &lt;code>vi(1)&lt;/code> on Linux for the first time, I couldn&amp;rsquo;t believe my eyes: what was this barren interface with its awkward commands? I eventually learned the &lt;code>vi(1)&lt;/code> and Emacs ways, but it&amp;rsquo;s a pity that those interfaces have been lost. They were really intuitive and powerful, and they would be wonderful to have in these days of cloud computing where we access remote computers over SSH all the time.&lt;/p>
&lt;h1 id="but-then-darkness-settled-in">But then&amp;hellip; darkness settled in&lt;/h1>
&lt;p>Unfortunately, both Edlin and &lt;code>EDIT.COM&lt;/code> were 16-bit DOS applications and they were never ported to 32-bit Windows. They were able to stay bundled with all 32-bit x86 Windows editions up to Windows 10 because Windows could run such ancient binaries via &lt;a href="https://en.wikipedia.org/wiki/Virtual_DOS_machine">NT&amp;rsquo;s Virtual DOS Machines&lt;/a>&amp;hellip; but the two editors were scraped in the x64 editions. Yes, this means that all 64-bit Windows editions have been devoid of a CLI text editor from the beginning.&lt;/p>
&lt;p>You could say that this is not a big deal because Windows still includes Notepad and Notepad is similar to &lt;code>EDIT.COM&lt;/code> in its feature set. And yes, they are similar&amp;hellip; but with a critical and obvious difference: Notepad cannot be used on a remote machine via SSH. For someone that has grown up routinely accessing other machines to do work on them via SSH, this sounded like a ridiculous move and further perpetuated the feeling that administering a Windows machine from the shell was a joke&amp;mdash;even with all effort that the PowerShell developers have put to make this possible.&lt;/p>
&lt;h1 id="and-in-the-end-there-may-be-light">And in the end, there may be light&lt;/h1>
&lt;p>But hey, it seems like Microsoft may be correcting course here thanks to, and this is the big surprise, the Windows Terminal team. In discussion &lt;a href="https://github.com/microsoft/terminal/discussions/16440">#16440&lt;/a>, the team is exploring (re)adding a CLI text editor to Windows. As the discussion says: &lt;em>&amp;ldquo;A CLI editor is a core tool for system admins, developers, and power users.&amp;rdquo;&lt;/em> Well, yes, no kidding. I&amp;rsquo;m just surprised it took this long to reach this conclusion.&lt;/p>
&lt;p>Now, what would &lt;em>you&lt;/em> pick as the default text editor for the Windows textual console?&lt;/p>
&lt;p>Personally, and while I&amp;rsquo;d quickly say &amp;ldquo;just bundle Vim&amp;rdquo; like many others have&amp;hellip; I acknowledge it would feel out of place. Vim, Emacs, or even Nano are &lt;em>not&lt;/em> Windows applications. Yes, they work on Windows, but they don&amp;rsquo;t embody the traditional way things have worked on this platform. I feel that integrating any of these editors into Windows would further perpetuate the impression that Windows is just trying to copy Linux without actually being Linux.&lt;/p>
&lt;p>So, if you ask me, I&amp;rsquo;d vote for the re-addition of &lt;code>EDIT.COM&lt;/code>. Obviously not a verbatim copy of what it was because it&amp;rsquo;d be nice to have one or two extra features added to it: I&amp;rsquo;d personally welcome making the editor respect indentation when inserting lines and maybe having some sort of syntax highlighting (without going all the way with LSP support). The key would be to preserve the simple, full-screen UI.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-12-08-yori-yedit.png" class="with-border">
&lt;figcaption>YEdit running in a Yori Windows Terminal session on Windows 11.&lt;/figcaption>
&lt;/figure>
&lt;p>And as it turns out, the foundations for this already exist in &lt;a href="http://www.malsmith.net/edit/">YEdit&lt;/a>, a modern free reimplementation of the old editor for Windows. It has even been brought up in the discussion, so it seems I&amp;rsquo;m not the only one thinking this way.&lt;/p>
&lt;p>In any case, I encourage you to leave your thoughts in the comments section below or, even better, join the official discussion at &lt;a href="https://github.com/microsoft/terminal/discussions/16440">microsoft/terminal#16440&lt;/a>.&lt;/p></description></item><item><title>Strings, encodings, NULs and Bazel</title><link>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</link><pubDate>Sun, 03 Dec 2023 10:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</guid><description>&lt;p>Just yesterday, &lt;a href="https://twitter.com/vkrajacic/status/1730891609191981305">Twitter user @vkrajacic wrote&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Advice for new C programmers: &amp;ldquo;Avoid null-terminated strings; they&amp;rsquo;re outdated, inefficient and impractical.&amp;rdquo;&lt;/p>
&lt;p>Create your own type with basic functions. It&amp;rsquo;s not that hard, and it goes a long way. One of the benefits of this approach, among others, is slicing without copying.&lt;/p>
&lt;/blockquote>
&lt;p>This suggestion has its merits and I understand where it is coming from: &lt;em>performance&lt;/em>. You see: the traditional way to represent strings in C is to use &lt;a href="https://en.wikipedia.org/wiki/Null_character">NUL-terminated byte arrays&lt;/a>. Yet&amp;hellip; this has deemed to be &lt;a href="https://queue.acm.org/detail.cfm?id=2010365">the most expensive one-byte mistake&lt;/a> because of the adverse performance implications that this carries. (NUL, &lt;em>not&lt;/em> NULL, is the better name for the &lt;code>\0&lt;/code> byte by the way.)&lt;/p>
&lt;p>It is of course possible to do differently. Pascal, for example, used a 1-byte prefix to indicate how long strings are. This representation takes the same space as a NUL terminator and fixes the performance problems, but it carries the downside of limiting strings to 255 bytes in length. And you can do as the original author said: amend your strings with a (larger) size field so you do not suffer from this limitation.&lt;/p>
&lt;p>So, yes, it &lt;em>is&lt;/em> possible to use strings without NUL terminators. Unfortunately, you are in for pain if you do so for one simple reason: interop. Your code does not run in a vacuum: it runs in the context of an existing operating system, and it probably uses one or more libraries. Almost all operating systems to date, if not all, expose a C API (libc and system calls), which means that they expect strings to be NUL-terminated. And the same is true for all interesting libraries out there.&lt;/p>
&lt;p>And for this reason, I want to tell you a little story about how I found this painful problem when I was working on Bazel a few years ago.&lt;/p>
&lt;hr>
&lt;p>Bazel is primarily a Java program. Bazel also has a bunch of C and C++ code integrated via JNI, which is used to reach certain system calls and libraries that are only available in C. For &lt;a href="https://www.oracle.com/technical-resources/articles/javase/supplementary.html">historical reasons&lt;/a>, Java uses UTF-16 to represent strings but&amp;hellip; most operating systems out there &lt;em>do not&lt;/em>. As a consequence, every JNI call has to start with a conversion from UTF-16 into whatever the operating system may accept, which typically is Latin-1 or UTF-8. This is a costly, unavoidable step.&lt;/p>
&lt;p>Fortunately, Java 9 introduced a new feature called &lt;a href="https://openjdk.org/jeps/254">&lt;em>compact strings&lt;/em>&lt;/a>. When this feature is enabled, the JVM represents strings as Latin-1 wherever possible: as long as the string&amp;rsquo;s characters can be represented with this encoding, UTF-16 doesn&amp;rsquo;t enter the picture. This is great because most strings that Bazel handles are file paths&amp;mdash;it handles &lt;em>a lot&lt;/em> of paths&amp;mdash;and these can typically be represented in Latin-1. With this feature, we could modify &lt;a href="https://cs.opensource.google/bazel/bazel/+/master:src/main/native/latin1_jni_path.cc;drc=26c7e10739907332e70d31e68d2bd2ff2e9a84fb">the JNI shims&lt;/a> to reuse the in-memory bytes &lt;em>as is&lt;/em>, without a costly conversion in the common case.&lt;/p>
&lt;p>But there is an unfortunate twist. The Latin-1 compact strings that the JVM creates are &lt;em>not&lt;/em> NUL-terminated. This means that, even if the string bytes that Java hands to C are exactly as we need them in memory to call some other API, they are not directly usable. As a result, the JNI code is forced to make a &lt;em>copy&lt;/em> of the string just so that it can pad it with a NUL terminator.&lt;/p>
&lt;p>Which is&amp;hellip; sad and wasteful. As I mentioned, Bazel handles a ton of paths. Most of the memory bloat in the Bazel server process comes from the need to track file paths and command line arguments, and when you have many of these strings amounting to GBs of RAM, you can imagine that processing and copying them is costly too. I think I did measure a not-insignificant runtime penalty from these unnecessary copies back in the day, but I forget the details now.&lt;/p>
&lt;p>So, be careful: it&amp;rsquo;s entirely reasonable to annotate string representations with their size, and you should do so where possible because of the performance gains that come with it. But when you do this, don&amp;rsquo;t forget to pad the strings with a NUL character for the cases where you need interop. You don&amp;rsquo;t want to be making unnecessary string copies just because of this, and you don&amp;rsquo;t know when you&amp;rsquo;ll need the interop.&lt;/p>
&lt;p>C++&amp;rsquo;s &lt;code>std::string&lt;/code>, for example, uses a combination of a NUL terminator and a size length, which allows it to be efficient for manipulation but also allows passing the &amp;ldquo;raw bytes&amp;rdquo; to C interfaces. I suppose Go and Rust do the same, but I haven&amp;rsquo;t looked. &lt;a href="https://www.brandons.me/blog/why-rust-strings-seem-hard">Strings are hard though&lt;/a> and some languages do better than others in handling them.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-12-03-threads.jpg" length="588993" type="image/jpeg"/></item><item><title>Links: November 2023 edition</title><link>https://jmmv.dev/2023/11/links-november-2023-edition.html</link><pubDate>Thu, 30 Nov 2023 10:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/links-november-2023-edition.html</guid><description>&lt;p>Welcome to the second edition of my &amp;ldquo;interesting links&amp;rdquo; recap, this time covering the month of November 2023.&lt;/p>
&lt;p>For context, what follows is my manual curation of cool articles, videos, and projects I stumbled upon during this time period. But this is not &lt;em>just&lt;/em> a dump of links: &lt;em>each link is accompanied by a 1-paragraph commentary&lt;/em> that justifies why I thought the material was cool, why it is relevant to this publication and, more importantly, an attempt to nudge you into reading it.&lt;/p>
&lt;p>Before we dive in, two quick things. First: I want to explicitly acknowledge all the new subscribers that have joined us since &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">the last post on Windows NT&lt;/a> landed on some major news sites. Thank you; I hope you find this interesting and a good reason to stick around. And, second: the &lt;a href="/2023/10/links-october-2023-edition.html">first edition&lt;/a> of this recap didn&amp;rsquo;t get any real traction, so let&amp;rsquo;s see if this one fares better. You can help by liking and resharing this post &lt;em>wink&lt;/em> &lt;em>wink&lt;/em> or&amp;hellip; as usual, by subscribing.&lt;/p>
&lt;h1 id="articles">Articles&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.notebookcheck.net/Lenovo-ThinkPad-T14s-G4-review-Business-laptop-is-better-with-AMD-Zen4.763581.0.html">&amp;ldquo;Lenovo ThinkPad T14s G4 review: Business laptop is better with AMD Zen4&amp;rdquo;&lt;/a> by Andreas Osthoff on November 1st, 2023.&lt;/strong>&lt;/p>
&lt;p>I have been eyeing the T14s that Costco has on sale for a while and, while I&amp;rsquo;m not going to get it because of the &amp;ldquo;low&amp;rdquo; screen resolution, I had to read through this review. And oh wow, what an amazing, in-depth description of the device. I&amp;rsquo;m now waiting for the X1 Nano to be in stock again&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://mjg59.dreamwidth.org/68350.html">&amp;ldquo;Why ACPI?&amp;rdquo;&lt;/a> by Matthew Garrett on October 31st, 2023.&lt;/strong>&lt;/p>
&lt;p>A high-level overview of what ACPI is, why it was needed to replace APM, and how computers would look like in a world without ACPI.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://quick-lint-js.com/blog/bug-journey/">&amp;ldquo;Sometimes, it &lt;em>is&lt;/em> a compiler bug&amp;rdquo;&lt;/a> by strager on May 25th, 2022.&lt;/strong>&lt;/p>
&lt;p>Great debugging story of an obscure problem that the author hit when seeing someone else write a bug in their code, suggesting that they install a VSCode extension that would have highlighted the bug, and watching in real time how the extension then pointed at a non-existent bug. I recall hitting some compiler bugs myself (a similar issue with Rust&amp;rsquo;s incremental compilation, and various ICEs) but I have never had the patience to dig for an answer.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.xtof.info/intel80386.html">&amp;ldquo;Intel 80386, a revolutionary CPU&amp;rdquo;&lt;/a> by Christophe Meneboeuf on September 2nd, 2023.&lt;/strong>&lt;/p>
&lt;p>A good story on how the 80386 came to be and why it was important at the time. I recall reading a book (&lt;a href="https://twitter.com/jmmv/status/1721531589635813396">that I still have&lt;/a>) that described the 8086, the 80286, and the 80386 in great depth and how they differed among each other. All of the details about memory and task management felt fascinating to me at the time, and I&amp;rsquo;ve always found it weird that almost none of the features that the chips provided (segmentation instead of pagination; 4 protection levels; task, interrupt, and call gates; hardware-assisted task switching&amp;hellip;) were put to use by operating systems. Sure, their original implementation might have sucked and been slow, but if they had been used, Intel would have improved those over time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.vidarholen.net/contents/blog/?p=1035">&amp;ldquo;What exactly was the point of [ âx$varâ = âxvalâ ]?&amp;rdquo;&lt;/a> by Vidar on April 12th, 2021.&lt;/strong>&lt;/p>
&lt;p>One more oddity that you&amp;rsquo;ll find in shell scripts. And not just ancient ones: this still shows up regularly in auto-generated &lt;code>configure&lt;/code> scripts, or even in their &lt;code>configure.ac&lt;/code> originals because people copy/paste code snippets without thinking about them much.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://devblogs.microsoft.com/oldnewthing/20231103-00/?p=108966">&amp;ldquo;Why does unsafe multithreaded use of an &lt;code>std::unordered_map&lt;/code> crash more often than unsafe multithreaded use of a &lt;code>std::map&lt;/code>?&amp;rdquo;&lt;/a> by Raymond Chen on November 3rd, 2023.&lt;/strong>&lt;/p>
&lt;p>I always enjoy Raymond&amp;rsquo;s posts, and to be honest, his blog is what drove me into writing mine and changing the way I looked at Microsoft and Windows 9x. In this one, he entertains a question of the type &amp;ldquo;this thing is broken, but why does it look more broken in this case than in this other one?&amp;rdquo;. Obviously, The Internet cannot read subtlety.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="end-to-end-tool-testing-with-bazel.md">&amp;ldquo;End-to-end testing with Bazel and shtk&amp;rdquo;&lt;/a> by yours truly on November 4th, 2023.&lt;/strong>&lt;/p>
&lt;p>Last month, and for reasons that are not interesting, I revived an old project of mine: &lt;a href="https://shtk.jmmv.dev">shtk&lt;/a>. This, combined with my trip to BazelCon 2023, made me want to create a new ruleset to integrate shtk with Bazel builds because I know the shell is a great language to write integration tests for tools. So I ended up creating &lt;a href="https://github.com/jmmv/rules_shtk/">rules_shtk&lt;/a> and wrote this post to explain how to use it and how it can help you write better tools.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://blog.rust-lang.org/2023/11/09/parallel-rustc.html">&amp;ldquo;Faster compilation with the parallel (Rust) front-end in nightly&amp;rdquo;&lt;/a> by Nicholas Nethercote on behalf of The Parallel Rustc Working Group on November 9th, 2023.&lt;/strong>&lt;/p>
&lt;p>This is exciting work. I have an overkill server in the garage with 72 cores where I remote into for development and, most of the time, it goes vastly unused. I doubt the Rust compiler will be able to use that many cores, at least for the kind of projects I work on&amp;mdash;they aren&amp;rsquo;t &lt;em>that&lt;/em> large&amp;mdash;but still, this is exciting.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://flak.tedunangst.com/post/write-your-own-terminal">&amp;ldquo;Write your own terminal&amp;rdquo;&lt;/a> by Ted Unangst on November 10th, 2023.&lt;/strong>&lt;/p>
&lt;p>Writing a terminal is surely rewarding: as the author says, you have to do very little to get it to a functional state, but then can iterate endlessly on the details and on performance. And I know it&amp;rsquo;s fun because I had to do this for the &lt;a href="https://www.endbasic.dev/">EndBASIC&lt;/a> console. Replacing the use of Xterm.js with my own implementation showed results quickly, and I was then able to mix text and graphics seamlessly.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="why-do-i-know-shell-and-how-can-you.md">&amp;ldquo;Why do I know shell, and how can you?&amp;rdquo;&lt;/a> by yours truly on November 10th, 2023.&lt;/strong>&lt;/p>
&lt;p>I spent some time last month and this month writing more shell than usual, and people at work often ask me &amp;ldquo;why I know so many ancient incantations&amp;rdquo;. So I decided to explain how the constraints of &lt;a href="http://www.NetBSD.org/">NetBSD&lt;/a>, an open-source OS project I contributed to for many years, guided me down this path.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://virtuallyfun.com/2023/11/12/dont-waste-money-on-a-math-coprocessor-they-said/">&amp;ldquo;Don&amp;rsquo;t waste money on a math coprocessor they said&amp;rdquo;&lt;/a> by neozeed on November 12th, 2023.&lt;/strong>&lt;/p>
&lt;p>Did you know that CPUs did not use to have floating point operations and that there were optional chips you could buy to supplement the CPU with those? Say hi to the FPUs. This article dives into history and shows how installing an 80287 along an 80286 fixed a mysterious crashing bug in a game and in OS/2&amp;mdash;even when none of this code was using floating point. If you are into retro stuff, this one (and &lt;a href="https://virtuallyfun.com/">the whole blog&lt;/a> it seems!) is for you&amp;hellip; but I only wish the author came up with a precise explanation of what went wrong here.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://wingolog.org/archives/2023/11/13/i-accidentally-a-scheme">&amp;ldquo;i accidentally a scheme&amp;rdquo;&lt;/a> by wingo on November 13th, 2023.&lt;/strong>&lt;/p>
&lt;p>This article is short and not very detailed, but it contains a bunch of interesting references to programming language implementation topics and is entertaining to read. You must read the intro, though; it is just great. Plus I learned a new meme&amp;hellip; and several new words.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://yorickpeterse.com/articles/a-decade-of-developing-a-programming-language/">&amp;ldquo;A decade of developing a programming language&amp;rdquo;&lt;/a> by Yorick Peterse on November 14th, 2023.&lt;/strong>&lt;/p>
&lt;p>An easy-to-read reflection on the challenges of building a new programming language, along with some suggestions on how to approach doing so.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://lock.cmpxchg8b.com/reptar.html">&amp;ldquo;Reptar&amp;rdquo;&lt;/a> by Tavis Ormandy on November 14th, 2023.&lt;/strong>&lt;/p>
&lt;p>An article from Google&amp;rsquo;s Project Zero team describing a glitch in instruction processing that makes certain modern x86 processors enter an invalid state. Whether this can be used for privilege escalation is still unknown, but assume the worst.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="ssh-agent-forwarding-and-tmux-done.md">&amp;ldquo;SSH agent forwarding and tmux done right&amp;rdquo;&lt;/a> by yours truly on November 17th, 2023.&lt;/strong>&lt;/p>
&lt;p>If you have ever used SSH agent forwarding and you keep long-running tmux sessions on the remote machine, you know you are in for trouble. This article covers why agent forwarding breaks in this case, describes various solutions, and presents a prototype I quickly wrote (the &lt;a href="https://github.com/jmmv/ssh-agent-switcher/">ssh-agent-switcher&lt;/a>) to fix the problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.evanjones.ca/setenv-is-not-thread-safe.html">&amp;ldquo;Setenv is not Thread Safe and C Doesn&amp;rsquo;t Want to Fix It&amp;rdquo;&lt;/a> by Evan Jones on November 19th, 2023.&lt;/strong>&lt;/p>
&lt;p>Well, yes, it is not thread safe&amp;mdash;but you should &lt;em>not&lt;/em> be modifying the environment of your own process, except right before &lt;code>exec&lt;/code>. Environment variables &lt;em>are&lt;/em> global, untyped, not-thread-safe variables.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://pikuma.com/blog/what-is-dos4gw-protected-mode">&amp;ldquo;DOS/4GW and Protected Mode&amp;rdquo;&lt;/a> by Gustavo Pezzi on December 12th, 2021.&lt;/strong>&lt;/p>
&lt;p>Ah, the memories. Learn more about how DOS games could unleash the power of 32 bits and more than 1 MB (yes, MB) of memory by using an &amp;ldquo;extender&amp;rdquo; while running on an &amp;ldquo;OS&amp;rdquo; that was 16-bit real mode.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="code-reviews-a-success-story.md">&amp;ldquo;Code reviews: A success story&amp;rdquo;&lt;/a> by yours truly on November 21st, 2023.&lt;/strong>&lt;/p>
&lt;p>If you ask people what they think about the Pull Request process to get code merged into a project, you&amp;rsquo;ll find critics. I do think PR reviews, and in particular code reviews, are a good process that can increase the quality of the software you ship&amp;mdash;but it&amp;rsquo;s important for the people involved to understand the limitations of the process and when they need to take a different route. This Twitter thread presents a success story that I was personally involved in.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.10stripe.com/articles/why-is-56k-the-fastest-dialup-modem-speed.php">&amp;ldquo;Why is 56k the fastest dialup modem speed?&amp;rdquo;&lt;/a> by Alex Freeman probably pre-2008.&lt;/strong>&lt;/p>
&lt;p>I can hear this article. A good technical explanation on why the maximum transmission speed for dial-up connections is 56k, a number that seems pulled out of thin air, and how it&amp;rsquo;s not possible to achieve it in practice.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://devblogs.microsoft.com/oldnewthing/20231124-00/?p=109059">&amp;ldquo;On harmful overuse of &lt;code>std::move&lt;/code>&amp;rdquo;&lt;/a> by Raymond Chen on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>So using &lt;code>std::move&lt;/code> can hurt? Thanks, C++. The article touches upon optimizations that the compiler can perform and how move construction can hamper them. Also, this reminds me how the NRVO (described in the article too) masked a bug in code I wrote long ago, and how I do not want to ever write C++ again if I can avoid it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="windows-nt-peeking-into-the-cradle.md">&amp;ldquo;Windows NT: Peeking into the cradle&amp;rdquo;&lt;/a> by yours truly on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>A review of the &amp;ldquo;Showstopper!&amp;rdquo; book combined with my own commentary on how exciting (and tiresome) it must have been to live through the development of Windows NT: the OS that still powers most PCs in the world, more than 30 years after its inception.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://tedium.co/2023/11/24/weird-html-hacks-history/">&amp;ldquo;10 Weird HTML Hacks That Shaped The Internet&amp;rdquo;&lt;/a> by Ernie Smith on November 24th, 2023.&lt;/strong>&lt;/p>
&lt;p>This article gets my vote if only for its retro photos of Netscape 4. But, in any case, the article is a neat summary of weird things that people did (and still do!) with HTML to format their websites. The article is long, but each of the 10 entries has a very brief what/how/why summary at the top which makes it easy to decide what you want to read.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ShellsAndCurrentDirectory">&amp;ldquo;Unix shells and the current directory&amp;rdquo;&lt;/a> by Chris Siebenmann on November 25th, 2023.&lt;/strong>&lt;/p>
&lt;p>It&amp;rsquo;s interesting to think about how the &amp;ldquo;current directory&amp;rdquo; is represented in the kernel and how, depending on the choices, the kernel may not be able to provide a &lt;code>getcwd(2)&lt;/code> system call. When that happens, how does &lt;code>pwd(1)&lt;/code> work? This article answers these questions, and more.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://muxup.com/2023q4/storing-data-in-pointers">&amp;ldquo;Storing data in pointers&amp;rdquo;&lt;/a> by Alex Bradbury on November 27th, 2023.&lt;/strong>&lt;/p>
&lt;p>Pointers are really wide, but addressable memory isn&amp;rsquo;t yet&amp;mdash;so pointers have enough room to carry data in them. This article describes how, but the more interesting part is the list at the end covering the many real-world use cases where this is done.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="other">Other&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://retrocomputing.stackexchange.com/questions/27926/who-invented-file-extensions-in-file-names">&amp;ldquo;Who invented file extensions in file names?&amp;rdquo;&lt;/a> StackExchange discussion on November 1st, 2023.&lt;/strong>&lt;/p>
&lt;p>We take file extensions as part of file names for granted today, but looking into their history, we discover that extensions were a separate metadata field in the file system, much like timestamps are. It wasn&amp;rsquo;t until Unix and its flat approach to file names that extensions became part of the file names. This is why on MS-DOS you can refer to files without specifying their extension (again, just like you can refer to files without specifying the time they were modified).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Caldera_OpenLinux">&amp;ldquo;Caldera OpenLinux&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>The very first Linux distribution I ever tried. I recall that this came with the PC Actual magazine and remember how the installation instructions in the corresponding article described a workaround for a bug in the mounting of the CD. I also remember not achieving a resolution larger than 320x200 with X11. Not a great first impression&amp;hellip; but this hooked me into the Unix world forever.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=qbKGw8MQ0i8">&amp;ldquo;NTFS really isn&amp;rsquo;t that bad [video]&amp;rdquo;&lt;/a> by Robert Collins on January 16th, 2020.&lt;/strong>&lt;/p>
&lt;p>A conference presentation that describes how the speaker optimized Rust&amp;rsquo;s installation from 3 and a half minutes to just 14 seconds on Windows. NTFS isn&amp;rsquo;t the problem: it&amp;rsquo;s the applications assuming that the whole world is like Linux.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.nasm.us/">&amp;ldquo;The Netwide Assembler (NASM)&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>Brought to memory by &lt;a href="https://news.ycombinator.com/item?id=38203553">a Hacker News discussion&lt;/a>. It&amp;rsquo;s interesting to me to see people disregard the AT&amp;amp;T syntax as unusable, which makes me feel better about never learning it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=TbZ3HzvFEto">&amp;ldquo;Half-Life: 25th anniversary documentary [video]&amp;rdquo;&lt;/a> by Valve on November 17th, 2023.&lt;/strong>&lt;/p>
&lt;p>A documentary on my favorite game of all times. Well worth the watch, even for the whole family.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://effective-rust.com/">&amp;ldquo;Effective Rust&amp;rdquo;&lt;/a> online book.&lt;/strong>&lt;/p>
&lt;p>Inspired by Scott Meyer&amp;rsquo;s famous Effective C++ book, this online book takes a similar approach to show more than 30 different scenarios in how to better apply Rust. I haven&amp;rsquo;t read it cover to cover, but the few items I skimmed through seem solid. Worth a read and, as with any programming guidelines, lots of what you can find here apply to any language.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.freebsd.org/releases/14.0R/announce/">&amp;ldquo;FreeBSD 14.0-RELEASE Announcement&amp;rdquo;&lt;/a> on November 20th, 2023.&lt;/strong>&lt;/p>
&lt;p>It&amp;rsquo;s here! Go grab it while it&amp;rsquo;s hot. There are claims to significant performance improvements, so I&amp;rsquo;m eagerly awaiting to have a few spare hours to upgrade my server in the garage. I suspect I&amp;rsquo;ll only need a few minutes&amp;hellip; but need to plan for the worst case scenario.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://tmpout.sh/3/">&amp;ldquo;tmp0ut.sh #003&amp;rdquo;&lt;/a> by multiple authors on November, 2023.&lt;/strong>&lt;/p>
&lt;p>A new edition of an online underground ezine talking about security and exploits. The content is super-interesting, but the looks of this are frigging awesome too.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.xbox.com/en-US/power-on">&amp;ldquo;Power On: The Story of Xbox [video series]&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>A 6-part documentary on how the Xbox came to be, and how it almost didn&amp;rsquo;t launch. I&amp;rsquo;ve only been able to watch the first episode so far, but it was engaging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://www.youtube.com/watch?v=xi1Lq79mLeE">&amp;ldquo;The mind behind Windows: Dave Cutler&amp;rdquo;&lt;/a> by Dave&amp;rsquo;s Garage on October 21st, 2023.&lt;/strong>&lt;/p>
&lt;p>A 3-hour long interview with Dave Cutler on the creation of Windows NT. Having just written a &lt;a href="/2023/11/windows-nt-peeking-into-the-cradle.html">detailed article on this part of history&lt;/a>, this looks very interesting to watch.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a href="https://infinitemac.org/">&amp;ldquo;Infinite Mac&amp;rdquo;&lt;/a>.&lt;/strong>&lt;/p>
&lt;p>Pick any version of System Software/Mac OS from the 1980s or 1990s and run it right in your browser. I wasn&amp;rsquo;t a Mac user until Mac OS X Tiger, so these are systems I never experienced&amp;mdash;except for System 7.5, I think, which I had to use to bootstrap a NetBSD/mac68k system. But if you did, this is a good toy to recreate memories.&lt;/p>
&lt;/li>
&lt;/ul></description><enclosure url="https://jmmv.dev/images/2023-10-31-links.png" length="56457" type="image/jpeg"/></item><item><title>Windows NT: Peeking into the cradle</title><link>https://jmmv.dev/2023/11/windows-nt-peeking-into-the-cradle.html</link><pubDate>Fri, 24 Nov 2023 09:40:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/windows-nt-peeking-into-the-cradle.html</guid><description>&lt;p>It&amp;rsquo;s strange&amp;hellip; but I&amp;rsquo;ve been able to finish reading a book cover-to-cover that&amp;rsquo;s not a book for my kids. It&amp;rsquo;s hard for me to get hooked into books and find the time to read them. I think the one I finished before this might have been &amp;ldquo;&lt;a href="https://www.amazon.com/10-PRINT-CHR-205-5-RND/dp/0262018462?&amp;amp;_encoding=UTF8&amp;amp;tag=blogsystem503-20&amp;amp;linkCode=ur2&amp;amp;linkId=c3ddd9f1db5ead180ea40a44f495092b&amp;amp;camp=1789&amp;amp;creative=9325">10 PRINT&lt;/a>&amp;rdquo;, and that was over a year ago. This time, though, I completed the book on the story behind the creation of Windows NT: namely, &amp;ldquo;Showstopper!&amp;rdquo; in its short form, written by G. Pascal Zachary.&lt;/p>
&lt;p>Reading the story of how Windows NT came to be was entertaining, as it is a story of the system itself and the dynamics between Dave Cutler, the original designer and lead for NT, and the other people involved in the project. I was shy of being 10 years old when Windows NT launched and I didn&amp;rsquo;t comprehend what was going on in the operating systems world and why this release was such a big deal. Reading the book made me learn various new things about the development process, the role of Microsoft in that era, and allowed me to settle some questions I&amp;rsquo;ve had over the years.&lt;/p>
&lt;p>This article is a mixture of a book review and a collection of thoughts and reflections that the book evoked. Let&amp;rsquo;s begin because we have a lot of ground to cover.&lt;/p>
&lt;h1 id="lets-create-a-brand-new-os">Let&amp;rsquo;s create a brand new OS&lt;/h1>
&lt;p>Operating systems are pretty much a commodity these days&amp;mdash;but you couldn&amp;rsquo;t take them for granted before. There was a time during the 1980s and 1990s when a multitude of computer architectures and operating systems thrived, each offering vastly different feature sets and levels of stability than the others. Yes, DOS and Windows were the most popular choices for personal computers, but there were other contenders such as OS/2, BeOS, QNX&amp;hellip; as well as the myriad different commercial Unix derivatives. The open-source BSDs and Linux had just seen the light of day.&lt;/p>
&lt;p>Microsoft&amp;rsquo;s bet to build NT in 1988, a brand new OS from scratch, was bold. There were good reasons for taking the risk, which centered around the desire to modernize DOS and to have first-class support for networks, but investing multiple years of R&amp;amp;D on a massive project like this was risky: others had tried and failed.&lt;/p>
&lt;p>At the end of the day, Microsoft succeeded with NT. The development process took longer than anticipated, but the system finally shipped in 1993. Now, more than 30 years later, NT is behind almost all desktop and laptop computers in the world. The book claims that Cutler repeatedly told his team that they&amp;rsquo;d remember this time period as &amp;ldquo;the good old days&amp;rdquo;, and I think he was well damn right. As tough as that period must have been for everyone involved, they were writing history and setting the direction of personal computing for years to come.&lt;/p>
&lt;h1 id="development-pressure">Development pressure&lt;/h1>
&lt;p>Contrast this to the open-source BSDs and Linux, which were already a reality by NT&amp;rsquo;s launch in 1993. Linux and the original 386BSD were &amp;ldquo;hobby projects&amp;rdquo; for their creators. I&amp;rsquo;m convinced that, at the time, these people and their contributors didn&amp;rsquo;t imagine their toys as anything that would influence the world&amp;mdash;even if, in retrospect, they kinda have: Linux is the basis for almost all mobile devices and servers, and macOS is derived from those original BSDs.&lt;/p>
&lt;p>What I&amp;rsquo;m trying to get at is that there is something to be said about the different thrill of working on these projects. On the one hand, NT was in a race to ship the next revolutionary OS to power all personal computers, with intense pressure from OS/2 and other contenders, and with a design that went against established practice. On the other hand, Linux was in no such rush: its developers worked on it for their own entertainment, probably not grasping what was ahead of them.&lt;/p>
&lt;p>Having been part of the NT team and of that era of computing must have been incredibly exciting. However, it was not all roses for this team. Even though the work of the team was exciting and the potential for impact was massive, the book also shows a clear picture of a really toxic culture: leaders screaming to their peers and reports; normalized long hours and destroyed families; cross-team distrust and shaming&amp;hellip; not something you&amp;rsquo;d probably want to be involved in.&lt;/p>
&lt;h1 id="dogfooding">Dogfooding&lt;/h1>
&lt;p>Creating a new OS is fun but, unless you use the OS regularly, you will have little incentive to discover and fix sharp usability edges or certain classes of bugs. This is where dogfooding, or the practice of &lt;del>eating your own dog food&lt;/del> using your own creations, becomes key. And due to the importance of this, the book has a whole chapter on dogfooding NT.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-31-boot.png" class="with-border">
&lt;figcaption>Windows NT 3.1 boot screen. &lt;a href="https://winworldpc.com/product/windows-3/31">Courtesy of WinWorld.&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>The mandate to dogfood NT after it passed a certain functionality threshold comes from Cutler himself and sounds awesome&amp;hellip; and frustrating at the same time. I&amp;rsquo;ve previously dogfooded operating systems&amp;mdash;I ran NetBSD and FreeBSD CURRENT for years while I was a contributor&amp;mdash;and the infrequent crashes were annoying. Note, however, that these two systems were already past a certain stability point by the time I used them so, in general, they worked. I wonder what level of functionality the first dogfood versions of NT had but, based on what I grasp from the book, the answer is &amp;ldquo;not a lot&amp;rdquo;, which means the experience may have been quite a nightmare.&lt;/p>
&lt;p>Note that these days, it seems silly to talk about &amp;ldquo;how this OS is more stable than this other one&amp;rdquo; because all modern OSes implement similar process and file protections, but stability couldn&amp;rsquo;t be taken for granted back then. The DOS-based Windows editions really were quite unstable, and OS/2 and Unix systems put them to shame. The design of NT was going to fix these issues for the Windows world, but it had to be stabilized first too.&lt;/p>
&lt;h1 id="the-build-lab">The build lab&lt;/h1>
&lt;p>Windows releases are often referred to by specific build numbers, which always sounded weird to me: as a regular FreeBSD and NetBSD &lt;em>user&lt;/em>, I churned out multiple new builds of these whole OS &lt;em>per day&lt;/em>, and doing so was trivial and inconsequential. What was so special about Windows that individual build numbers were important? Was it really true that Windows NT 3.51, numbered build 1057, was the 1057th time that the codebase had been assembled together? And the answer is&amp;hellip; yes.&lt;/p>
&lt;p>The book talks a lot about the build lab: the &lt;em>place&lt;/em>&amp;mdash;laptops and remote work were &lt;em>definitely&lt;/em> not a thing in the early 1990s&amp;mdash;where a few engineers took the changes that everyone else made and assembled the whole system into something that could boot. This system was then distributed to the whole team for dogfooding on a daily basis.&lt;/p>
&lt;p>This sounds ridiculous, right? Why wasn&amp;rsquo;t there a CI/CD pipeline to build the system every few hours and publish the resulting image to a place where engineers could download it? Ha, ha. Things weren&amp;rsquo;t this rosy back then. Having automated tests, reproducible builds, a CI/CD system, unattended nightly builds, or even version control&amp;hellip; these are all a pretty new &amp;ldquo;inventions&amp;rdquo;. Quality control had to be done by hand, as did integrating the various pieces that formed the system.&lt;/p>
&lt;p>Regardless, even if you think about having to design a CI/CD system for an OS today, it isn&amp;rsquo;t as trivial as what you need for your run-of-the-mill GitHub project. Validating the built OS against different hardware, assessing the behavior of fundamental system components like the process scheduler, and accepting that any validation can crash the machine and require a physical power cycle&amp;hellip; is not trivial. Even relying on VMs like we do today isn&amp;rsquo;t sufficient, because you &lt;em>do&lt;/em> want to test the OS against real hardware.&lt;/p>
&lt;h1 id="portability-and-design-cleanliness">Portability and design cleanliness&lt;/h1>
&lt;p>These days we take x86-based personal computers as the one and only possibility, which wasn&amp;rsquo;t true back in the day&amp;mdash;and may not be true in the near future either. As I mentioned earlier, the computer world was full of different architectures during the 1980s and early 1990s.&lt;/p>
&lt;p>In my journey to move away from Windows, which &lt;a href="/2020/08/os2-memory-lane.html">started with OS/2 Warp 3&lt;/a> and was followed by Linux and the BSDs, I was lured by NetBSD and stuck with it for years. The main reason I ended up settling on NetBSD was its claims of being &amp;ldquo;cleanly designed&amp;rdquo;, and a big reason for needing &lt;em>and&lt;/em> having a clean design was supporting tens of different architectures out of the same codebase.&lt;/p>
&lt;p>Which is interesting because this is precisely how NT started. From reading the book, I learned that Cutler had the same mentality for his OS and, in fact, the system wasn&amp;rsquo;t ported to x86 until late in its development. He wanted developers to target non-x86 machines &lt;em>first&lt;/em> to prevent sloppy non-portable coding, because x86 machines were already the primary desktops that developers had. In fact, even as x86 increasingly became the primary target platform for NT, the team maintained a MIPS build at all times, and having most tests passing in this platform was a requirement for launching.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-351-powerpc.png" class="with-border">
&lt;figcaption>Windows NT 3.51 running on a PowerPC machine. From the &lt;a href="https://virtuallyfun.com/2020/08/02/the-lost-history-of-prep-windows-nt-3-5x-and-the-rs-6000-40p/">"The lost history of PReP: Windows NT 3.5x and the RS/6000 40p"&lt;/a> article at Virtually Fun.&lt;/figcaption>
&lt;/figure>
&lt;p>On this topic, I briefly remember some contemporary news articles in computer magazines describing how the PowerPC was going to be &amp;ldquo;the next big thing&amp;rdquo; and how NT ran on it. I did not grasp what a big deal this was at the time because based on the screenshots that they printed, Windows NT on PowerPC looked exactly the same as Windows 3.11 on my i386 PC. Well, I guess I really just didn&amp;rsquo;t understand what PowerPC nor NT were at all.&lt;/p>
&lt;h1 id="dialing-difficulty-up-to-11-with-ntfs">Dialing difficulty up to 11 with NTFS&lt;/h1>
&lt;p>This golden era also saw the creation of many new file systems. If you were on DOS and Windows 3.x land, your choices were limited, but if you were playing with Linux, you saw new file systems pop up &amp;ldquo;every week&amp;rdquo;. Things settled around the early/mid 2010s, except maybe for the uneventful launch of &lt;a href="https://en.wikipedia.org/wiki/Apple_File_System">APFS&lt;/a> in 2017.&lt;/p>
&lt;p>Creating a new OS from scratch is no easy feat, but wanting to create a brand new file system to go with it is making things difficult just because. While writing a file system is already tricky enough, &lt;em>stabilizing&lt;/em> it is a whole different story. But, as the book describes, the team felt that they needed a new file system to support the reliability and networking needs of NT, so it had to be done. FAT was nowhere close to offer them.&lt;/p>
&lt;p>And NTFS is very interesting. NTFS was a really advanced file system for its time thanks to journaling, support for multi-TB volumes, optional per-directory and per-file compression, detailed ACLs&amp;hellip; none of the Unix file systems of the era had these features. For example, ext3, which extended ext2 with journaling support, did not exist until 2001, and it has been replaced by ext4 and btrfs since. But NTFS is still chugging along in Windows 11, so it is impressive that they could make it happen on time for the OS release. (The same cannot be said about &lt;a href="https://en.wikipedia.org/wiki/WinFS">WinFS&lt;/a>&amp;hellip; which was supposed to ship with Vista and didn&amp;rsquo;t.)&lt;/p>
&lt;p>Now, I know you will complain that NTFS is slow&amp;hellip; but you know what? It almost-certainly is not. Most of the problems with NTFS performance stem from file system filters, which intercept all I/O operations to do heavy stuff like virus scanning. &lt;a href="https://www.youtube.com/watch?v=qbKGw8MQ0i8">NTFS on its own is fine&lt;/a>, but you need to write your applications with knowledge of the system you target: if you treat something as Unix when it isn&amp;rsquo;t, then bad things happen.&lt;/p>
&lt;h1 id="correctness-first-performance-second">Correctness first, performance second&lt;/h1>
&lt;p>Speaking of NTFS performance, the book also touches upon system performance. Unsurprisingly, Cutler wanted to make the system stable and well-designed first, leaving performance for later. Performance was pushed to the side for a while, but the team was confident that they could improve performance and resource consumption later. This was a good strategy, although it didn&amp;rsquo;t play out well for a while.&lt;/p>
&lt;p>What I found interesting is that the book claims that Bill Gates was obsessed with performance and routinely asked about it, because the prospective user base of NT did not have the means to buy high-end computers. Which is great&amp;hellip; but then, I just don&amp;rsquo;t know where &lt;a href="/2023/06/fast-machines-slow-machines.html">performance has gone wrong&lt;/a> at Microsoft because that doesn&amp;rsquo;t seem to be the focus anymore.&lt;/p>
&lt;p>Regardless, and even after performance work, NT was not the fastest at its launch. As the initial reviews published, the system was deemed &amp;ldquo;too big, too slow&amp;rdquo; and requiring too high hardware requirements. This seemed to affect Cutler. Right after the initial 3.1 launch, when the team deserved a break, they were back at work right away to improve these topics in preparation for the 3.51 launch.&lt;/p>
&lt;h1 id="huge-migrations-at-microsoft">Huge migrations at Microsoft&lt;/h1>
&lt;p>Apple is touted as the expert in huge migrations: they moved their hardware lineup from 68k to PowerPC, from PowerPC to x86 and, most recently, from x86 to &lt;a href="https://en.wikipedia.org/wiki/Apple_silicon">Apple Silicon&lt;/a> (ARM). They also moved from 32 bits to 64 bits, dropping 32-bit support later, and from Mac OS Classic to Mac OS X. Apple has indeed executed these huge migrations well, but at each step, they have left apps and developers behind because Apple has never been big on backwards compatibility. Somehow its customers have accepted that.&lt;/p>
&lt;p>If we peek under the covers, Microsoft has also pushed similar humongous migrations. At each step, however, Microsoft has preserved backwards compatibility as much as possible, and I think this is why these migrations seem less of a big deal than they really were.&lt;/p>
&lt;p>What am I talking about? For starters: the jump from the DOS / Windows 3.x world to Windows 95. Windows 95 unified these two systems by making DOS applications work well under Windows&amp;mdash;something that wasn&amp;rsquo;t true in 3.x. To make this possible, Windows 95 carried tons of application-specific tweaks to remain bug-for-bug compatible and, while gross, that&amp;rsquo;s what users needed. We know how big of a splash Windows 95 made.&lt;/p>
&lt;p>But the other huge migration was the jump from Windows 9x to Windows NT. Maintaining two separate operating systems with the same UI for a few years with support for roughly the same apps is a big feat, but it&amp;rsquo;s an even bigger feat to unify these two tracks into one with Windows XP. And, with that release, they were finally able to drop the Windows 9x line for good.&lt;/p>
&lt;h1 id="putting-the-windows-in-nt">Putting the Windows in NT&lt;/h1>
&lt;p>NT started as a joint project between Microsoft and IBM. The goal was to create the next OS for PC systems, named OS/2. So, while NT was designed from the ground up to support multiple personalities (or&amp;hellip; &lt;a href="/2020/11/wsl-lost-potential.html">subsystems, like WSL 1&lt;/a>), the original plan was to make NT support DOS and OS/2 applications.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-microsoft-os2-logo.png" class="with-border">
&lt;figcaption>Microsoft OS/2 1.3 logo. &lt;a href="https://www.os2world.com/wiki/index.php/Microsoft_OS/2_1.3">Courtesy of OS/2 World.&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>The Windows personality&amp;mdash;the thing that gives NT its ability to run Windows applications&amp;mdash;wasn&amp;rsquo;t in the cards at first. As the book explains, the project was originally called NT, not Windows NT, and was supposed to become OS/2. It wasn&amp;rsquo;t until later that it became clear within Microsoft that NT had to run Windows applications to not be dead on arrival, and thus Gates pushed for NT to prioritize compatibility with Windows applications. Later on, the system was renamed to Windows NT to emphasize this point, and all ties with IBM broke.&lt;/p>
&lt;p>One thing that struck as interesting was how the team struggled to fix compatibility bugs late in the development cycle, because each fixed bug resulted in a new batch of compatibility issues. It wasn&amp;rsquo;t until later in the project that a key developer had the insight to create a tracer that recorded the system/library calls an app made. This recording could then be used by developers, without the help of testers, to trivially observe the behavior of a sequence of operations on NT and adjust them. This was the magic piece that provided a path towards stability and being able to ship.&lt;/p>
&lt;p>From this work, NT also gained the ability to define &amp;ldquo;compatibility flags&amp;rdquo; for certain applications. This was necessary to work around cases where the applications did the wrong thing&amp;mdash;yet compatibility had to be kept. And this is why Windows 9x and NT had (and still have) such a great compatibility story: the system is full of levers to appease weird behaviors in random apps, even if the apps themselves do something &amp;ldquo;wrong&amp;rdquo;. Most developers would go against the latter, claiming that those are bugs in the apps and they deserve to break. Apple has taken this path. Open source tries to take this path. &lt;a href="https://www.amazon.com/Old-New-Thing-Development-Throughout/dp/0321440307?&amp;amp;_encoding=UTF8&amp;amp;tag=blogsystem503-20&amp;amp;linkCode=ur2&amp;amp;linkId=b373dc6d4f2a06aac4cfec48134f4d71&amp;amp;camp=1789&amp;amp;creative=9325">Microsoft didn&amp;rsquo;t.&lt;/a>&lt;/p>
&lt;h1 id="the-ui-matters">The UI matters&lt;/h1>
&lt;p>Another topic that the book touches upon was the animosity between Cutler and the graphics team. Cutler did not think that graphics were important, which means they were neglected for a long while. And even when a UI team was put together, Cutler was not particularly happy or impressed by them.&lt;/p>
&lt;p>However, graphics are critical and they were difficult to get right. Performance was a problem, as were the many bugs that plagued the primary UI apps of the OS. And&amp;hellip; you might have the fastest, most portable, best designed OS in the world, but if its shell is not usable nor stable&amp;hellip; nobody will care. The UI makes the OS as much as the kernel makes the OS.&lt;/p>
&lt;p>Eventually, due to the desire to support primarily Windows applications in NT, the team adopted the UI that had been developed for OS/2 and for Windows 3.x. This was critical to make the OS seem familiar, although as I briefly touched upon earlier, this also made it difficult to see how 3.x and NT differed to the untrained eye. Later in life, I had a hard time seeing how the Windows NT 4 that ran in our high school computer lab differed from the Windows 95 I had at home: to me, it just seemed slower and heavier.&lt;/p>
&lt;figure>
&lt;img src="/images/2023-11-24-windows-nt-4-desktop.png" class="with-border">
&lt;figcaption>Windows NT 4 initial desktop to emphasize how it looks exactly the same as Windows 95.&lt;/figcaption>
&lt;/figure>
&lt;p>In any case, the UI is crucial to the way people appreciate an OS. And, for NT specifically, I&amp;rsquo;m sad that there is no choice: Microsoft keeps &amp;ldquo;advancing&amp;rdquo; the UI in ways that seem detrimental. In particular, modern versions of Windows feel incredibly slow in hardware barely 10 years old&amp;hellip; which is sad because you can&amp;rsquo;t do anything about it other than stay in the hardware upgrade treadmill. I want to like Windows, but recent UI changes have slowly pushed me away.&lt;/p>
&lt;h1 id="and-finally-about-the-book">And finally, about the book&lt;/h1>
&lt;p>To conclude this look into the past, let&amp;rsquo;s actually talk a tiny bit about the book that sparkled it.&lt;/p>
&lt;p>The book is definitely entertaining to read; I guess the fact that I now live in the area where this all happened helped a tiny bit make it more so. It&amp;rsquo;s easy to read. It&amp;rsquo;s fun. It makes me wish I had been born just a few years earlier to understand everything that was going on in more detail&amp;mdash;and maybe to have had a chance to become part of it. And as I mentioned in the introduction, it is engaging enough that I was able to stick with it for about three months.&lt;/p>
&lt;p>But one thing that surprised me is that the book carries a handful of really obvious, painful editing mistakes. A couple of paragraphs are completely unreadable due to broken grammar, punctuation, and capitaliazation. I&amp;rsquo;m not sure how that happened. Luckily, the unreadable parts are reduced to one or two pages&amp;hellip; so you don&amp;rsquo;t miss much.&lt;/p>
&lt;p>Hope you enjoyed this article. And if you did, I&amp;rsquo;m sure you&amp;rsquo;ll enjoy the book much more. Click on the picture to buy and read it!&lt;/p>
&lt;blockquote>
&lt;a target="_blank" href="https://www.amazon.com/Showstopper-Breakneck-Windows-Generation-Microsoft-ebook/dp/B00J5X5E9U?&amp;_encoding=UTF8&amp;tag=blogsystem503-20&amp;linkCode=ur2&amp;linkId=b3bfada207b7929529132de33861f4e3&amp;camp=1789&amp;creative=9325">
&lt;figure>
&lt;img src="/images/2023-11-24-showstopper-alone.jpg"/>
&lt;figcaption>
"Showstopper!: The Breakneck Race to Create Windows NT and the Next Generation at Microsoft", by G. Pascal Zachary.
&lt;/figcaption>
&lt;/figure>
&lt;/a>
&lt;/blockquote></description><enclosure url="https://jmmv.dev/images/2023-11-24-showstopper-pile.jpg" length="180641" type="image/jpeg"/></item></channel></rss>