<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Rust review: Protect the data - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Rust review: Protect the data - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Rust review: Protect the data - Julio Merino (jmmv.dev)"><meta name=description content="The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.
I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil&rsquo;s MutexLock) was the panacea. (I&rsquo;m a fan of RAII in C++ by the way, in case you haven&rsquo;t noticed.)
As Rust has taught me, that&rsquo;s far from the truth: in Rust, you protect the data, not the code. What this means is that, e.g. a mutex is not an object to control access to a piece of data: a mutex is a container for a piece of data. It is impossible to access the data without going through the mutex.
"><meta property="og:description" content="The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.
I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil&rsquo;s MutexLock) was the panacea. (I&rsquo;m a fan of RAII in C++ by the way, in case you haven&rsquo;t noticed.)
As Rust has taught me, that&rsquo;s far from the truth: in Rust, you protect the data, not the code. What this means is that, e.g. a mutex is not an object to control access to a piece of data: a mutex is a container for a piece of data. It is impossible to access the data without going through the mutex.
"><meta property="twitter:description" content="The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.
I had always thought of mutexes as something that is easy to get wrong and was convinced that the …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.136.5"><meta property="og:url" content="https://jmmv.dev/2018/06/rust-review-protect-the-data.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2018/06/rust-review-protect-the-data.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Rust review: Protect the data</h1><p>June 5, 2018 &#183;
About 5 minutes
&#183;
Tags:
<a href=/tags/programming>programming</a>, <a href=/tags/rust>rust</a>, <a href=/tags/sandboxfs>sandboxfs</a></p><p class=post-meta-p>This article is part number
4 of the ongoing
<a href=/series.html#Rust%20review><b>Rust review</b></a> series.</p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p><em>The one thing</em> that blew my mind about Rust is its approach to data sharing in concurrent situations.</p><p>I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with <a href=https://github.com/abseil/abseil-cpp/blob/59ae4d5a0e833bedd9d7cc059ac15a9dc130e3f7/absl/synchronization/mutex.h#L499>Abseil&rsquo;s <code>MutexLock</code></a>) was the panacea. (I&rsquo;m a fan of RAII in C++ by the way, in case you haven&rsquo;t noticed.)</p><p>As Rust has taught me, that&rsquo;s far from the truth: <strong>in Rust, you protect the <em>data</em>, not the <em>code</em>.</strong> What this means is that, e.g. a mutex is not an object to control access to a piece of data: <strong>a mutex is a <em>container</em> for a piece of data</strong>. It is impossible to access the data without going through the mutex.</p><p><em>&ldquo;Ah! Not so fast! You can do exactly the same in C++ or even in Go!&rdquo;</em>, you claim. Yeeee&mldr; no, not at all. Sure, you can implement a container that holds the data and only exposes its contents via a getter after grabbing the lock. But there is <em>nothing</em> preventing the code from leaking a reference to that inner data after the mutex is released. Let&rsquo;s imagine an interface like this (with lots of details omitted, like suppression of copies and assignments):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>typename</span> <span class=n>T</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Lock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>Mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span><span class=p>);</span>  <span class=c1>// Grabs non-owning reference to the data.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Lock</span><span class=p>();</span>  <span class=c1>// Releases mutex.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>get</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>&amp;</span> <span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>typename</span> <span class=n>T</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Mutex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Mutex</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span><span class=p>);</span>  <span class=c1>// Grabs ownership of the data.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Lock</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>  <span class=c1>// Acquires mutex.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>Looks legit, right? We can only construct a <code>Mutex</code> by moving an arbitrary object into it, and from there on, the only way to get back to the object is to first call <code>lock()</code> on the mutex. Doing so returns us a <code>Lock</code> RAII construct that automatically releases the lock on destruction. And with that done, the only way to reach the data is by invoking <code>get()</code> on a valid <code>Lock</code>, which we know holds the mutex.</p><p>But, ha ha, it is trivial to escape all these nice intentions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Mutex</span><span class=o>&lt;</span><span class=n>SuperDuperType</span><span class=o>&gt;</span> <span class=n>mutex</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>data</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SuperDuperType</span><span class=o>*</span> <span class=n>dangling_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span><span class=o>&lt;</span><span class=n>SuperDuperType</span><span class=o>&gt;</span> <span class=n>lock</span> <span class=o>=</span> <span class=n>mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>dangling_pointer</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>lock</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// lock goes out of scope here so the mutex is released.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Oh oh.  We now have a pointer to the inner object, which is not locked any
</span></span></span><span class=line><span class=cl><span class=c1>// more... and it wouldn&#39;t even be valid if the mutex had gone out of scope.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dangling_pointer</span><span class=o>-&gt;</span><span class=n>i_will_misbehave</span><span class=p>();</span>
</span></span></code></pre></div><p>No matter how good your intentions are, such an API will leak the data in one way or another and, <a href=http://www.hyrumslaw.com>eventually, someone will write broken code</a> like the one shown above—possibly along a lengthy comment explaining why they had to go through such nastiness.</p><p>So no. It&rsquo;s just impossible to <em>safely</em> implement a mutex as a data container in C++—and, for that matter, in Go as well because the language has even fewer protections. The resulting interface would be so fragile that you may as well not bother implementing it in the first place.</p><p>In Rust, however&mldr; it is perfectly possible to implement this API safely: <strong><em>the Rust compiler</em> will catch misuses and disallow code from even building when it violates data access restrictions</strong>. And that is precisely how the <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html><code>std::sync::Mutex</code></a> type in the standard library behaves.</p><p>For completeness sake, let&rsquo;s try to translate the above example to Rust:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Mutex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>SuperDuperType</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>value</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SuperDuperType</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>value</span>: <span class=mi>3</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>mutex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=n>data</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>leaked</span>: <span class=kp>&amp;</span><span class=nc>SuperDuperType</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>locked_data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>locked_data</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>leaked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>locked_data</span><span class=p>;</span><span class=w>  </span><span class=c1>// Impossible.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>If we try to <em>build</em> this code, we&rsquo;ll be greeted with the following <em>error</em> at the point were we tried to leak the reference to the inner, locked data:</p><pre tabindex=0><code>error[E0597]: `locked_data` does not live long enough
  --&gt; data.rs:15:31
   |
15 |         leaked = &amp;locked_data;  // Broken.
   |                   ^^^^^^^^^^^ borrowed value does not live long enough
16 |     }
   |     - `locked_data` dropped here while still borrowed
17 | }
   | - borrowed value needs to live until here
`
</code></pre><p>I encourage you to try to come up with a pathological piece of code that lets you leak the reference. Try to implement it and see what happens. My original thought when I went through this exercise was: &ldquo;well, what if I create a thread once the mutex is held and access the reference through the other thread? Surely that&rsquo;d lead to a bug.&rdquo; Turns out you cannot even express this: the reference cannot be passed to the new thread (see <a href=https://doc.rust-lang.org/book/second-edition/ch16-01-threads.html#using-move-closures-with-threads>the <code>move</code> keyword</a> for details), so you cannot reach this situation. The only thing you can pass to the new thread without losing ownership of the data is the <code>Mutex</code> itself or something like a thread-safe reference-counted container like an <code>Arc</code>. (<strong>Update:</strong> OK, I was wrong&mldr;. <a href=https://twitter.com/Argorak/status/1004375508640043008>As Florian Gilcher points out</a>, it&rsquo;s still possible to break the safety guarantees in some cases but the good thing is that <a href=https://internals.rust-lang.org/t/announcing-the-formal-verification-working-group/7240>there is a Formal Verification Working Group</a> to address these!)</p><p><strong>The fact that the language is able to enforce these restrictions at <em>build</em> time is hard to believe.</strong> And these restrictions are possible thanks to Rust&rsquo;s data ownership rules and thanks to our <del>evil</del> good friend <a href=/2018/06/rust-review-borrow-checker.html>the borrow checker, which we previously discussed</a>.</p><p>Even with the examples above, which I know are convoluted, it&rsquo;s hard for me to articulate how powerful these concepts are unless you experience their benefits firsthand. In my case, I witnessed these during the sandboxfs rewrite: while &ldquo;transcribing&rdquo; the original design from Go to Rust, I was able to catch a bunch of cases in which concurrency was slightly off. The code was rightfully buggy, but Go itself didn&rsquo;t nor <em>couldn&rsquo;t</em> care. On the other hand, Rust just didn&rsquo;t allow me express those invalid constructions in the first place, which forced me to fix the design.</p><p>In the next episode, we&rsquo;ll explore how these theoretically simple concepts tie to computing fundamentals and how they make Rust&rsquo;s learning curve steep.</p></article><p class=post-meta-p>This article is part number
4 of the ongoing
<a href=/series.html#Rust%20review><b>Rust review</b></a> series.</p></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2018/06/rust-review-borrow-checker.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2018/06/rust-review-learning-curve.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Rust+review%3A+Protect+the+data&amp;url=https%3A%2F%2Fjmmv.dev%2F2018%2F06%2Frust-review-protect-the-data.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Rust+review%3A+Protect+the+data&amp;u=https%3A%2F%2Fjmmv.dev%2F2018%2F06%2Frust-review-protect-the-data.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Rust+review%3A+Protect+the+data+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2018%2F06%2Frust-review-protect-the-data.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2024
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDE4LzA2L3J1c3QtcmV2aWV3LXByb3RlY3QtdGhlLWRhdGEuaHRtbA==/stamp.gif" style=display:none></noscript></body></html>