<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Making NetBSD Multiboot-Compatible - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Making NetBSD Multiboot-Compatible - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Making NetBSD Multiboot-Compatible - Julio Merino (jmmv.dev)"><meta name=description content="This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
The i386 architecture is full of cruft required to maintain compatibility with old machines that go back as far as the 8086 series."><meta property="og:description" content="This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
The i386 architecture is full of cruft required to maintain compatibility with old machines that go back as far as the 8086 series."><meta property="twitter:description" content="This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2007/03/making-netbsd-multiboot-compatible.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2007/03/making-netbsd-multiboot-compatible.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Making NetBSD Multiboot-Compatible</h1><p>March 1, 2007 &#183;
About 13 minutes
&#183;
Tags:
<a href=/tags/featured>featured</a>, <a href=/tags/netbsd>netbsd</a>, <a href=/tags/onlamp>onlamp</a>, <a href=/tags/os>os</a>, <a href=/tags/programming>programming</a></p><p class=post-meta-p>This article is part number
5 of 5 of the
<a href=/series.html#ONLamp.com%20guest%20posts><b>ONLamp.com guest posts</b></a> series.</p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p><em>This article first appeared on this date in O&rsquo;Reilly&rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to <a href=https://web.archive.org/web/20070303102352/http://www.onlamp.com/pub/a/bsd/2007/03/01/inside-multiboot.html>find a copy</a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.</em></p><hr><p>The i386 architecture is full of cruft required to maintain compatibility with old machines that go back as far as the 8086 series. Technically speaking, these features aren&rsquo;t necessary anymore because any recent computer based on this architecture uses a full 32-bit operating system that could work perfectly fine without the legacy code. Unfortunately, the compatibility hacks remain in place and hurt the development of new software.</p><p>One of the details that has not changed for years is the i386 boot process. It was designed back in the days when computers had only floppy disk drives and machines had limited firmware. Since then, the procedure has not suffered any change and it makes some tasks very complex; one of these is the configuration of multiple operating systems (OSes) on a single machine.</p><p>The new firmware for Intel-based machines, the <a href=http://www.intel.com/technology/efi/>Extensible Firmware Interface (EFI)</a>, resolves this issue by providing a more versatile boot process. Other architectures have already provided improved firmware with nicer boot mechanisms, including, for example, the ability to load and execute an <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>ELF</a> image straight from the machine initialization code. Such is the case with <a href=https://www.openfirmware.org/>OpenFirmware</a> as shipped in PowerPC Macintoshes.</p><p>Even though alternative firmware implementations exist, the i386 architecture as we known it today will still be with us for a long time. Therefore, it would be nice to resolve some of its limitations through software. This is what The Multiboot Specification attempts to do in the boot area: provide the ability to boot any operating system from a single boot loader, hence simulating an improved firmware.</p><p>I recently modified the <a href=http://www.netbsd.org/>NetBSD</a>&rsquo;s kernel to become Multiboot-compliant. There are many code references in the text, but the main idea behind the essay is to introduce Multiboot and show you that a real-world operating system can easily be converted to support this specification. Please note that all code references point to the netbsd-4 stable branch to ensure that the code remains consistent with the explanations given here.</p><h1 id=the-i386-boot-process>The i386 Boot Process</h1><p>The traditional i386 architecture uses a very simple firmware known as the Basic Input/Output System, or BIOS. The BIOS is in charge of initializing the hardware after powering up the machine and provides a low-level interface to access it from boot loaders and OSes. Unfortunately, it has inherited a lot of deficiencies from the past: these services are available from real mode only and they do not provide high-level abstractions for the underlying hardware.</p><p>To put things in perspective, the BIOS is unable to access any on-disk filesystem (not even <a href=https://en.wikipedia.org/wiki/File_Allocation_Table>FAT</a>) and therefore cannot directly load any executable such as the OS kernel. Instead, all the BIOS does is load the first sector of the selected boot disk into a specific memory location (<code>07C0h:0000h</code>) and transfer the execution control to it. To make things worse, each OS kernel has traditionally provided its own boot code tailored to its needs. For example, the old MS-DOS OS loaded from a FAT disk and executed in real mode; on the other hand, newer systems can boot from a large variety of filesystems (FAT, NTFS, Ext2, and more) and need to run in protected mode from the very beginning because their kernels are too big to fit into the first megabyte of memory (all the memory addressable from real mode).</p><p>The fact that each OS needs its own boot loader causes a lot of problems when setting up several different systems on a single machine and poses a lot of questions that the user will most likely be unable to answer. What do you install in the <a href=https://en.wikipedia.org/wiki/Master_boot_record>MBR</a>? Where do you put each boot loader? Why do you need to configure each of them independently? Why do you need more than one?</p><p>It could be very convenient if there was a generic interface that decoupled the load and bootstrapping of an OS kernel from its boot loader. This way, an OS developer could focus exclusively on the task at hand and forget about writing a boot loader. Similarly, boot loader developers could join forces to write a more complete utility or, alternatively, write their own with minimal code, while being able to boot any OS that supported such interfaces (ideally all OSes). The good thing is that the <a href=https://www.gnu.org/software/grub/>GRUB</a> developers already had this idea in the past and developed such an interface: Multiboot.</p><h1 id=the-multiboot-specification>The Multiboot Specification</h1><p>The <a href=https://www.gnu.org/software/grub/manual/multiboot/multiboot.html>Multiboot Specification</a> (MS) defines a protocol between boot loaders and OS kernels that allows any Multiboot-compliant boot loader to load and execute any Multiboot-compliant OS kernel. This permits the end user to install a single boot loader in his machine and use it to boot any system directly, without having to chain-load different boot utilities.</p><p>In order to accomplish this abstraction, the MS defines two items:</p><ul><li><p><em>The Multiboot Header (MH)</em></p><p>This is a 4-byte aligned data structure located within the first 8 KB of the OS kernel image. It provides a magic number used to identify the file as being Multiboot-compliant, a set of flags indicating specific kernel needs, and additional fields describing the structure of the binary. The latter are only used if the kernel is in the a.out format (with some exceptions); using ELF makes things much simpler and also more versatile.</p></li><li><p><em>The Multiboot Information Structure (MIS)</em></p><p>This is a data structure constructed by the boot loader and passed to the OS kernel as part of the boot process. It includes information such as which disk is the boot disk, a memory map, the kernel parameters, where additional kernel modules are in memory (if loaded at boot time), etc.</p></li></ul><p>There is some interaction between the two structures in the sense that the MH may request the boot loader to set some fields in the MIS for a successful boot. If the boot loader cannot fulfill the kernel&rsquo;s needs, the load will fail gracefully.</p><p>If you&rsquo;re making good use of these two structures, it&rsquo;s trivial to write a simple binary file that acts as an OS kernel—that is, a binary that is able to run standalone on the machine without any other OS. See the <a href="http://cvs.savannah.gnu.org/viewvc/grub/grub/docs/boot.S?revision=1.2&amp;view=markup"><code>boot.S</code></a>, <a href="http://cvs.savannah.gnu.org/viewvc/grub/grub/docs/kernel.c?revision=1.4&amp;view=markup"><code>kernel.c</code></a>, and related files that form the example kernel distributed alongside GRUB in the <a href=http://cvs.savannah.gnu.org/viewvc/grub/grub/docs/><code>docs</code></a> directory.</p><p>It is also interesting to note that a Multiboot-compliant boot loader will enter protected mode and set up a preliminary GDT for a flat memory model, so the kernel needn&rsquo;t do this by itself. Of course, the kernel will have to reload the GDT with values of its own later in the initialization process, but the one set up by the boot loader is enough to get started. In some sense, it&rsquo;s possible to write the OS kernel as if the real mode did not exist at all, as happens on other (saner) platforms.</p><h1 id=the-netbsdi386-boot-process>The NetBSD/i386 Boot Process</h1><p><a href=http://www.netbsd.org/ports/i386/>NetBSD/i386</a> uses a two-stage boot loader. The first stage gets installed into a known physical location—typically, the first sector of the hard disk or partition in which the system is installed and spans over some other reserved free space in the filesystem. This little program, which is generally limited in size, has the required knowledge to read the second stage boot loader and transfer the execution control to it; this one installs into the root filesystem as <code>/boot</code>, so its physical location may vary across reboots: there is nothing in the filesystem that binds a file to specific disk blocks.</p><p>Once the second stage boot loader receives control, it enters the flat protected mode (no paging, segments spanning the whole memory space), loads the kernel from disk, and runs it; it also accepts user input to choose which kernel to boot and which options to pass to it, if any. This loader also passes boot-time information to the kernel by means of the <em>bootinfo</em> framework. Simply put, this is a table that contains information, all gathered by the boot loader, about the machine and execution environment, including:</p><ul><li>Amount of available memory</li><li>The boot device</li><li>The kernel&rsquo;s filename</li><li>Where the console is attached (e.g., serial line, local video card)</li></ul><p>The <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/x86/include/bootinfo.h?rev=1.11&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/arch/x86/include/bootinfo.h</code></a> file holds the complete list of possible values for bootinfo items. bootinfo is similar to the MIS, although the information it includes is slightly different and, in some specific cases, more complete. In fact, this was one of the main headaches when adapting the NetBSD kernel to support Multiboot.</p><p>Later on, the kernel gets the execution control and proceeds by:</p><ol><li><p>Storing the boot information (bootinfo or MIS) in a safe place. See the <code>native_loader</code> function in <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/i386/i386/machdep.c?rev=1.586.2.6&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/arch/i386/i386/machdep.c</code></a>.</p></li><li><p>Detecting the CPU model in use (e.g., 386, 486, Pentium).</p></li><li><p>Setting up a preliminary page directory and the corresponding page tables to remap the kernel&rsquo;s virtual addresses above <code>0xC01000000</code>.</p></li><li><p>Enabling memory paging and jumping to high memory.</p></li><li><p>Continuing to boot and processing the boot information during its initialization.</p></li></ol><p>One tricky thing is that the NetBSD kernel runs, by design, at very high memory addresses (<code>0xC0100000</code> and higher) for efficiency reasons: doing this allows the mapping of the kernel inside the processes&rsquo; virtual address spaces without interferences. However, as mentioned earlier, the boot loader does not enable paging so it is impossible for it to put the kernel at such high addresses (unless the machine has lots of physical memory, but that is not the idea).</p><p>The ELF file format resolves this issue: each section in the image (text, data, bss, and so on) specifies which address is its starting virtual address, but <em>also</em> specifies its physical load address. The NetBSD kernel&rsquo;s linker script takes advantage of this to generate an ELF image mapped over <code>0xC0100000</code> but placed at the <code>0x00100000</code> physical address. Note that the address is not <code>0x00000000</code> to ensure that the kernel does not overwrite any BIOS code and/or data stored below the first megabyte (the only address space accessible from real mode) when loaded.</p><p>Before paging is enabled, the kernel code is critical because it must be careful to not use the raw addresses generated by the linker (as they point to unavailable memory positions). The <code>RELOC</code> macro resolves this by converting a given virtual address to its corresponding physical location. Fortunately, once paging works, no more problems appear and this is basically a non-issue.</p><h1 id=making-netbsd-multiboot-compliant>Making NetBSD Multiboot-Compliant</h1><p>Due to some limitations in the native NetBSD boot loader, I needed to boot NetBSD using GRUB in a spare machine I used for kernel testing. When doing so, I found that native NetBSD boot support in GRUB is very rudimentary, and even broken in several situations. For example, it does not set up the ksyms correctly, so <a href=https://netbsd.gw.com/cgi-bin/man-cgi?ddb+4><code>ddb(4)</code></a> backtraces are very difficult to understand. In addition, the upstream code does not support passing boot-time options to the kernel, but fortunately pkgsrc includes some local patches to resolve this issue.</p><p>There were two different solutions to my problems: fix GRUB to include full support for native NetBSD boots or make the NetBSD kernel Multiboot-compliant. I chose the latter because I personally like the idea behind Multiboot: it is more in the line of defining an abstract interface between two different system components. More importantly, though, is that changing the NetBSD kernel alone has the advantage that the code in GRUB will not rot: the GRUB developers are the main developers of The Multiboot Specification and, because it has no NetBSD-specific bits in it, they don&rsquo;t need to have a NetBSD system available to ensure it is supported.</p><p>The first step was to define some high-level data structures to represent and manage the MH and the MIS from within the kernel—something easy thanks to the detailed documentation about them. The results are in <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/i386/include/multiboot.h?rev=1.4&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/arch/i386/include/multiboot.h</code></a>.</p><p>Then, the obvious move was to add an MH to the kernel so that GRUB could recognize it. To ensure that it was within the first 8KB of the image, I added it in the text section of <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/i386/i386/locore.S?rev=1.44.2.1&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/arch/i386/i386/locore.S</code></a> alongside the kernel&rsquo;s entry point. This was not easy at all: the kernel&rsquo;s linker script had a bug that made the sections&rsquo; physical addresses point to the virtual addresses. This forced me to use the address fields in the MH to indicate where to load the file, but GRUB was not honoring them for ELF files. I had to come up with a fix for GRUB until a fellow developer, Pavel Cahyna, fixed the problem from its root: he rewrote the linker script to generate the appropriate physical addresses. Nowadays, those extra fields in the MH are not used, and a mainstream GRUB image (distributed in virtually any GNU/Linux distribution) can boot a NetBSD kernel.</p><p>With the kernel recognized as a Multiboot binary, I had to add the necessary code to parse the MIS during boot and convert it to the native bootinfo format to minimize changes in the overall kernel. Keep in mind that I was just adding another entry point to the kernel, not removing the old one, so both needed to coexist. This was tricky because of the virtual address space change that happens during bootstrap, as explained earlier: some MIS handling needed to happen before the kernel enabled paging to avoid corrupting important information (basically, the ksyms). The C code that handles this is rather delicate and, therefore, I kept it as short as possible. Once the kernel has enabled paging, the real MIS parsing is done and the kernel continues its boot procedure. You can see all of this in the <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/i386/i386/multiboot.c?rev=1.9&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/arch/i386/i386/multiboot.c</code></a> source file.</p><p>At last, I would like to comment on another area that was difficult to manage. The native boot loader loads the NetBSD kernel and stores it in memory following a specific memory layout: the kernel is first, followed by an integer that registers how many symbols the kernel has, followed by a minimal ELF image that contains the kernel&rsquo;s symbol and string tables. When using GRUB, these tables load in different and unpredictable locations. A first step in resolving this problem was to reserve some space in the kernel to copy the symbols table to the appropriate place on the fly, but this proved to be a very ugly hack. A recent fix moved the symbols table to just after the kernel (taking care not to overwrite it or other important information during the move). The kernel also has a specific function to initialize the ksyms global table based on a memory region (not necessarily a complete ELF image). You can see this in the <code>ksyms_init_explicit</code> function defined in <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/kern/kern_ksyms.c?rev=1.31&amp;content-type=text/x-cvsweb-markup&amp;only_with_tag=netbsd-4"><code>src/sys/kern/kern_ksyms.c</code></a>.</p><h1 id=conclusion>Conclusion</h1><p>If all operating systems supported The Multiboot Specification, users would be happier than they are now: a very advanced boot loader supporting all operating systems would most likely exist, and its installation could be trivial. Plus, these users would not need to care about the installation of an OS disabling another OS.</p><p>Personally, I found the process of making the NetBSD kernel Multiboot-compliant to be a very interesting and instructive task. Furthermore, because almost all Linux distributions nowadays install GRUB by default, it is now a lot easier to set up a dual-boot machine with both Linux and NetBSD. Further steps involve splitting the kernel in two different sections within the ELF binary in order to map each of them at separate virtual addresses. This could simplify some of the issues that arise in the code that runs before paging is enabled.</p><p>Now it is your turn to adapt your favorite operating system to this protocol and attempt to get your modifications into the mainstream sources!</p></article><p class=post-meta-p>This article is part number
5 of 5 of the
<a href=/series.html#ONLamp.com%20guest%20posts><b>ONLamp.com guest posts</b></a> series.</p></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2007/02/icb-support-added-to-colloquy.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2007/03/article-on-multiboot-and-netbsd.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Making+NetBSD+Multiboot-Compatible&amp;url=https%3A%2F%2Fjmmv.dev%2F2007%2F03%2Fmaking-netbsd-multiboot-compatible.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Making+NetBSD+Multiboot-Compatible&amp;u=https%3A%2F%2Fjmmv.dev%2F2007%2F03%2Fmaking-netbsd-multiboot-compatible.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Making+NetBSD+Multiboot-Compatible+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2007%2F03%2Fmaking-netbsd-multiboot-compatible.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDA3LzAzL21ha2luZy1uZXRic2QtbXVsdGlib290LWNvbXBhdGlibGUuaHRtbA==/stamp.gif" style=display:none></noscript></body></html>