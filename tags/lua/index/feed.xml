<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lua on Julio Merino (jmmv.dev)</title>
    <link>https://jmmv.dev/tags/lua/index/</link>
    <description>Recent content in lua on Julio Merino (jmmv.dev)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Nov 2013 09:00:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/lua/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Three productive days on the Kyua front</title>
      <link>https://jmmv.dev/2013/11/three-productive-days-on-kyua-front.html</link>
      <pubDate>Thu, 28 Nov 2013 09:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/11/three-productive-days-on-kyua-front.html</guid>
      <description>This being Thanksgiving week in the U.S. and Google giving us Thursday and Friday off, I decided to take Monday to Wednesday off as well to spend some time hacking on Kyua &amp;mdash; yes, finally, after months of being inactive. And what a three productive days!
Here comes a little briefing on the three fronts in which I made progress. (This puts on hold the header files series until next Monday.</description>
    </item>
    
    <item>
      <title>Exposing a configuration tree through Lua</title>
      <link>https://jmmv.dev/2012/06/exposing-configuration-tree-through-lua.html</link>
      <pubDate>Sat, 02 Jun 2012 20:47:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/06/exposing-configuration-tree-through-lua.html</guid>
      <description>In the previous post, I discussed the&amp;nbsp;type-safe tree data structure&amp;nbsp;that is now in the Kyua codebase, aimed at representing the configuration of the program. In this post, we&#39;ll see how this data structure ties to the parsing of the configuration file.
One goal in the design of the configuration file was to make its contents a simple key/value association (i.e. assigning values to predetermined configuration variables). Of course, the fact that the configuration file is just a Lua script means that additional constructions (conditionals, functions, etc.</description>
    </item>
    
    <item>
      <title>Rethinking Kyua&#39;s configuration system</title>
      <link>https://jmmv.dev/2012/05/rethinking-kyuas-configuration-system.html</link>
      <pubDate>Mon, 28 May 2012 19:48:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/05/rethinking-kyuas-configuration-system.html</guid>
      <description>In the&amp;nbsp;previous blog post, I described the problems that the implementation of the Kyua configuration file parsing and in-memory representation posed. I also hinted that some new code was coming and, after weeks of work, I&#39;m happy to say that it has just landed in the tree!

I really want to get to explaining the nitty-gritty details of the implementation, but I&#39;ll keep these for later. Let&#39;s focus first on what the goals for the new configuration module were, as these drove a lot of the implementation details:Key/value pairs representation: The previous configuration system did this already, and it is a pretty good form for a configuration file because it is a simple, understandable and widespread format.</description>
    </item>
    
    <item>
      <title>Name your C&#43;&#43; auto-cleaners</title>
      <link>https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html</link>
      <pubDate>Sat, 17 Sep 2011 23:26:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html</guid>
      <description>As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the stack-managed object goes out of scope, it releases the corresponding non-stack-managed object. Smart pointers are just one example of this technique, but so are IO streams too.
Before getting into the point of the article, bear with me for a second while I explain what the&amp;nbsp; stack_cleaner object of Lutok is.</description>
    </item>
    
    <item>
      <title>Introducing Lutok: A lightweight C&#43;&#43; API for Lua</title>
      <link>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</link>
      <pubDate>Thu, 15 Sep 2011 15:18:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</guid>
      <description>It has finally happened. Lutok is the result of what was promised in the &#34;Splitting utils::lua from Kyua&#34; web post.
Quoting the project web page:
Lutok provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua. These wrappers make intensive use of RAII to prevent resource leakage, expose C++-friendly data types, report errors by means of exceptions and ensure that the Lua stack is always left untouched in the face of errors.</description>
    </item>
    
    <item>
      <title>Splitting utils::lua from Kyua</title>
      <link>https://jmmv.dev/2011/09/splitting-utilslua-from-kyua.html</link>
      <pubDate>Sat, 03 Sep 2011 09:43:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/splitting-utilslua-from-kyua.html</guid>
      <description>If you remember a post from January titled C++ interface to Lua for Kyua (wow, time flies), the Kyua codebase includes a small library to wrap the native Lua C library into a more natural C++ interface. You can take a look at the current code as of r129.
Quoting the previous post:
The utils::lua library provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua.</description>
    </item>
    
    <item>
      <title>Injecting C&#43;&#43; functions into Lua</title>
      <link>https://jmmv.dev/2011/01/injecting-c-functions-into-lua.html</link>
      <pubDate>Mon, 17 Jan 2011 11:09:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/injecting-c-functions-into-lua.html</guid>
      <description>The C++ interface to Lua implemented in Kyua exposes a lua::state class that wraps the lower-level lua_State* type. This class completely hides the internal C type of Lua to ensure that all calls that affect the state go through the lua::state class.
Things get a bit messy when we want to inject native functions into the Lua environment. These functions follow the prototype represented by the lua_CFunction type:typedef int (*lua_CFunction)(lua_State*);Now, let&#39;s consider this code:int</description>
    </item>
    
    <item>
      <title>Error handling in Lua: the Kyua approach</title>
      <link>https://jmmv.dev/2011/01/error-handling-in-lua-kyua-approach.html</link>
      <pubDate>Fri, 14 Jan 2011 03:04:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/error-handling-in-lua-kyua-approach.html</guid>
      <description>About a week ago, I detailed the different approaches I encountered to deal with errors raised by the Lua C API. Later, I announced the new C++ interface for Lua implemented within Kyua. And today, I would like to talk about the specific mechanism I implemented in this library to deal with the Lua errors.
The first thing to keep in mind is that the whole purpose of Lua in the context of Kyua is to parse configuration files.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; interface to Lua for Kyua</title>
      <link>https://jmmv.dev/2011/01/c-interface-to-lua.html</link>
      <pubDate>Sat, 08 Jan 2011 08:17:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/c-interface-to-lua.html</guid>
      <description>Finally! After two weeks of holidays work, I have finally been able to submit Kyua&#39;s r39: a generic library that implements a C++ interface to Lua. The code is hosted in the utils/lua/ subdirectory.
From the revision description:The utils::lua library provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua. These wrappers make intensive use of RAII to prevent resource leakage, expose C++-friendly data types, report errors by means of exceptions and ensure that the Lua stack is always left untouched in the face of errors.</description>
    </item>
    
    <item>
      <title>Error handling in Lua</title>
      <link>https://jmmv.dev/2011/01/error-handling-in-lua.html</link>
      <pubDate>Fri, 07 Jan 2011 08:01:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/error-handling-in-lua.html</guid>
      <description>Some of the methods of the Lua C API can raise errors. To get an initial idea on what these are, take a look at the Functions and Types section and pay attention to the third field of a function description (the one denoted by &#39;x&#39; in the introduction).
Dealing with the errors raised by these functions is tricky, not to say a nightmare. Also, the ridiculously-short documentation on this topic does not help.</description>
    </item>
    
    <item>
      <title>Using RAII to clean up temporary values from a stack</title>
      <link>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</link>
      <pubDate>Mon, 27 Dec 2010 04:06:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</guid>
      <description>For the last couple of days, I have been playing around with the Lua C API and have been writing a thin wrapper library for C++. The main purpose of this auxiliary library is to ensure that global interpreter resources such as the global state or the execution stack are kept consistent in the presence of exceptions &amp;mdash; and, in particular, that none of these are leaked due to programming mistakes when handling error codes.</description>
    </item>
    
    <item>
      <title>Kyua: Design of the configuration system</title>
      <link>https://jmmv.dev/2010/12/kyua-design-of-configuration-system.html</link>
      <pubDate>Wed, 22 Dec 2010 09:48:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2010/12/kyua-design-of-configuration-system.html</guid>
      <description>Over a week ago, I mostly finished the implementation of the runtime engine for test cases of Kyua and, along the way, realized that it is imperative to write a configuration system right now before the configuration code becomes messier than it already is.
To that end, I spent the last week working on a design document for the configuration system. Summarizing, the document describes what the requirements for the configuration files of Kyua are, what the possible alternatives to implement them are, and advocates the use of Lua &amp;mdash; a tiny embedded programming language &amp;mdash; to bring these configuration files to life.</description>
    </item>
    
  </channel>
</rss>
