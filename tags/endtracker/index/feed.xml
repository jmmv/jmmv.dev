<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Endtracker on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/endtracker/index.html</link><description>Recent content in Endtracker on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Sun, 06 Aug 2023 05:30:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/endtracker/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>A failed experiment with Rust static dispatch</title><link>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</link><pubDate>Sun, 06 Aug 2023 05:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</guid><description>&lt;p>Initial versions of the EndBASIC Service, and therefore initial versions of EndTRACKER, used dynamic dispatch to support abstract definitions of system services such as the database they talk to and the clock they use. This looked like a bunch of &lt;tt>Arc&lt;dyn Foo>&lt;/tt> objects passed around and was done to support extremely fast unit testing.&lt;/p>
&lt;p>When I generalized the core logic of these services into the III-IV framework, I decided to experiment with a switch to static dispatch. The rationale was that using static dispatch better aligns with the design of well-regarded crates in the Rust ecosystem, and also because I wanted to avoid unnecessary runtime costs in the foundational pieces of my web services.&lt;/p>
&lt;p>Let me tell you that this decision was a huge mistake and that the experiment has utterly failed. Using static dispatch has been a constant source of frustration due to the difficulty in passing types around and reasoning about trait bounds. The situation had gotten so bad that I dreaded adding new functionality to my services whenever a change to a statically-typed &lt;tt>struct&lt;/tt> was needed, because that meant adding yet another type parameter and plumbing it through tens of source files.&lt;/p>
&lt;p>In lieu of the difficulties, which eventually turned into blockers to implementing new features, I made the choice of going back to dynamic dispatch. The goal was to gain ergonomics at the expense of a supposedly-negligible runtime cost. Let me tell you about the problems I faced, the refactoring journey, and some measurements I gathered after the rewrite.&lt;/p></description></item><item><title>Unit-testing a web service in Rust</title><link>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</link><pubDate>Fri, 07 Jul 2023 06:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</guid><description>&lt;p>One of the things I'm most proud of the Rust web services I have written is how I can run their tests with zero setup and within milliseconds, all while making me confident that "main" can always be shipped to production. I've previously touched upon how this all works in other articles, but it's time for a deep dive.&lt;/p>
&lt;p>To make things specific, I'll be describing the testing infrastructure of EndTRACKER, the EndBASIC Service, and the sample key/value store app of III-IV. These services are all structured in three separate layers, and I'll be covering the testing strategy for each of them.&lt;/p></description></item><item><title>A persistent task queue in Rust</title><link>https://jmmv.dev/2023/06/iii-iv-task-queue.html</link><pubDate>Fri, 23 Jun 2023 06:35:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/06/iii-iv-task-queue.html</guid><description>A couple of posts ago, I described why I built custom email subscriptions for this blog. I briefly mentioned that there is new automation that scrapes the RSS feed and sends new post notifications to you all. Today, it&amp;rsquo;s time to look into how this all works and how this is based on a new persistent task queuing service in Rust. The queue handles tasks to periodically scrape the RSS feed and schedule emails, all with various quota enforcers and retry policies in place. Read on for the design requirements and constraints of the task queue, how the client and worker Rust APIs look like, and how this all can be made to work inside the Azure Functions serverless runtime for minimal deployment hassle and cost.</description></item><item><title>In-house email subscriptions</title><link>https://jmmv.dev/2023/06/in-house-email-subscriptions.html</link><pubDate>Fri, 16 Jun 2023 06:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/06/in-house-email-subscriptions.html</guid><description>Fellow readers! The radio silence for the last two months has an explanation. I&amp;rsquo;ve been busy creating a custom email subscription service for this blog, all so that you can be notified about new posts without the noise added by intermediaries. This feature is built into a little Rust web service that already offered analytics, page comments and more, and that can be potentially integrated into arbitrary static websites. Read on for what was involved, stay tuned for a deep dive on the internals, and&amp;hellip; upfront apologies if this first email does the wrong thing!</description></item><item><title>Comments are back and other news</title><link>https://jmmv.dev/2022/02/comments-and-ids.html</link><pubDate>Wed, 16 Feb 2022 10:00:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2022/02/comments-and-ids.html</guid><description>Just a couple of weeks ago, I described my home-grown analytics service for this site. Today, I&amp;rsquo;m here to describe a couple of related updates: namely, the support for comments and the complete removal of client-side fingerprinting.</description></item><item><title>DIY web analytics</title><link>https://jmmv.dev/2022/02/diy-web-analytics.html</link><pubDate>Tue, 01 Feb 2022 09:15:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2022/02/diy-web-analytics.html</guid><description>&lt;p>One thing that had been bothering me about my websites&amp;mdash;including this blog, but especially when launching &lt;a href="https://www.endbasic.dev/">https://www.endbasic.dev/&lt;/a> just a few months ago&amp;mdash;was this:&lt;/p>
&lt;figure>
&lt;img src="https://jmmv.dev/images/2022-02-01-analytics-ublock.png"/>
&lt;figcaption>uBlock showing a warning that it blocked a tracker on the EndBASIC site.&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;em>A tracking warning.&lt;/em> uBlock complained that my properties had one tracker. And it&amp;rsquo;s true they had just one: it was Google Analytics, or GA for short.&lt;/p>
&lt;p>GA is the de-facto standard for web analytics: it is extremely powerful and ubiquitous. However, GA has grown exceedingly complicated, installs cookies (thus requiring the utterly annoying cookie warning in the EU), has issues with the GDPR, and, depending on how you look at it, is also very privacy invasive.&lt;/p></description></item></channel></rss>