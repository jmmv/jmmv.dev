<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Perl on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/perl/index.html</link><description>Recent content in Perl on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Thu, 07 Jun 2007 17:44:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/tags/perl/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Flattening an array of arrays</title><link>https://jmmv.dev/2007/06/flattening-array-of-arrays.html</link><pubDate>Thu, 07 Jun 2007 17:44:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/06/flattening-array-of-arrays.html</guid><description>This evening &lt;a href="http://blogs.nopcode.org/brainstorm/">a friend&lt;/a> asked me if I knew how to easily flatten an &lt;span style="font-style: italic;">array of arrays&lt;/span> (&lt;span class="blsp-spelling-error" id="SPELLING_ERROR_0">AoA&lt;/span> from now on) in Perl 5. What that means is, basically, to construct a single array that contains the concatenation of all the arrays inside the &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_1">AoA&lt;/span>.&lt;br />&lt;br />My first answer was: "&lt;tt>&lt;span class="blsp-spelling-error" id="SPELLING_ERROR_2">foldr&lt;/span>&lt;/tt>", but I knew beforehand that he wouldn't like it because... this is &lt;a href="http://www.haskell.org/haskellwiki/Haskell">Haskell&lt;/a>. After some time we got to the conclusion that there is no trivial way to flatten an &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_3">AoA&lt;/span> in Perl 5, even though Perl 6 includes a built-in function to do so. He ended up using this code to resolve the problem:&lt;br />&lt;br />&lt;tt>my @ordered = map { @$_ } values %arches;&lt;/tt>&lt;br />&lt;br />&lt;span class="blsp-spelling-error" id="SPELLING_ERROR_4">Ew&lt;/span>, how ugly. Anyway, as part of the discussion, I then continued on my first answer just to show him how versatile functional programming is. And I said, hey, look at this nice example:&lt;br />&lt;br />&lt;tt>Hugs> &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_5">foldr&lt;/span> (++) [] [[1,2], [3,4]]&lt;br />&lt;br />[1,2,3,4]&lt;/tt>&lt;br />&lt;br />His answer: oh well, but it is easier in Ruby: just use the built-in &lt;tt>&lt;span class="blsp-spelling-error" id="SPELLING_ERROR_6">ary&lt;/span>.flatten&lt;/tt> function. &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_7">Hmm&lt;/span>... but why would I need a built-in function in Haskell when I can just redefine it in a trivial single line?&lt;br />&lt;br />&lt;tt>flatten = &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_8">foldr&lt;/span> (++) []&lt;/tt>&lt;br />&lt;br />There you go, you can now flatten as much &lt;span class="blsp-spelling-error" id="SPELLING_ERROR_9">AoAs&lt;/span> as you want! (Huh, no parameters? Well, you don't need to name them.) Isn't functional programming great? ;-)&lt;br />&lt;br />PS: I know nothing about Ruby, but I bet you can write a very similar definition using this or other non-functional languages. I remember someone explaining somewhere (yeah, that's very specific) that Ruby has some patterns that resemble functional programming. So yes, you can probably define a flatten function by using something that looks like &lt;tt>&lt;span class="blsp-spelling-error" id="SPELLING_ERROR_10">foldr&lt;/span>&lt;/tt>, but that might look out of place in an imperative language. (Would be great to know about it for sure!)&lt;br />&lt;br />&lt;b>Edit (June 9th)&lt;/b>: Added a link to my friend's blog.</description></item></channel></rss>