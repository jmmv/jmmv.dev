<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/c/index.html</link><description>Recent content in C on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&#150;2025 Julio Merino</copyright><lastBuildDate>Mon, 12 Jul 2021 06:20:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/c/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Definitions and initializations in C++</title><link>https://jmmv.dev/2021/07/cpp-definition-initialization.html</link><pubDate>Mon, 12 Jul 2021 06:20:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2021/07/cpp-definition-initialization.html</guid><description>When reviewing an incoming C++ PR last week, I left a comment along the lines: &amp;ldquo;merge local variable declaration with its initialization&amp;rdquo;. But why? Is this just a stylistic issue or is there something deeper to warrant making the change? Let&amp;rsquo;s look at stack frames, C, and then C++ to answer these questions.</description></item><item><title>Unused parameters in C and C++</title><link>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</link><pubDate>Mon, 16 Feb 2015 17:40:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</guid><description>&lt;p>Today I would like to dive into the topic of &lt;em>unused parameters&lt;/em> in C and C++: why they may happen and how to properly deal with them—because smart compilers will warn you about their presence should you enable &lt;code>-Wunused-parameter&lt;/code> or &lt;code>-Wextra&lt;/code>, and even error out if you are brave enough to use &lt;code>-Werror&lt;/code>.&lt;/p>
&lt;h1 id="why-may-unused-parameters-appear">Why may unused parameters appear?&lt;/h1>
&lt;p>You would think that unused parameters should never exist: if the parameter is not necessary as an input, it should not be there in the first place! That&amp;rsquo;s a pretty good argument, but it does not hold when polymorphism enters the picture: if you want to have different implementations of a single API, such API will have to provide, on input, a superset of all the data required by all the possible implementations.&lt;/p></description></item><item><title>Using va_copy to safely pass ap arguments around</title><link>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</link><pubDate>Mon, 12 Sep 2011 22:34:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</guid><description>&lt;p>&lt;b>Update (2014-12-19)&lt;/b>: The advice provided in this blog post is questionable and, in fact, probably incorrect. The bug described below must have happened for some unrelated reason (like, maybe, reuse of &lt;tt>ap&lt;/tt>), but at this point (three years later!) I do not really remember what was going on here nor have much interest in retrying.&lt;/p>A long time ago, while I was preparing an ATF release, I faced many failing tests and crashes in one of the platforms under test. My memory told me this was a problem in OpenSolaris, but the &lt;a href="http://www.blogger.com/mtn-host.prjek.net/viewmtn/atf/revision/info/655c6c51f2155076f482a038042c67fd25adc934">repository logs&lt;/a> say that the problem really happened in Fedora 8 x86_64.&lt;br />The problem manifested itself as segmentation faults pretty much everywhere, and I could trace such crashes down to pieces of code like the following, of which the C code of ATF is full of:&lt;br />&lt;pre>void&lt;br />foo_fmt(const char *fmt, ...)&lt;br />{&lt;br /> va_list ap;&lt;br />&lt;br /> va_start(ap, fmt);&lt;br /> foo_ap(fmt, ap);&lt;br /> va_end(ap);&lt;br />}&lt;br />&lt;br />void&lt;br />foo_ap(const char *fmt, va_list ap)&lt;br />{&lt;br /> char buf[128];&lt;br />&lt;br /> vsnprintf(buf, sizeof(buf), fmt, ap);&lt;br />&lt;br /> ... now, do something with buf ...&lt;br />}&lt;/pre>The codebase of ATF provides &lt;tt>_fmt&lt;/tt> and &lt;tt>_ap&lt;/tt> variants for many functions to give more flexibility to the caller and, as shown above, the &lt;tt>_fmt&lt;/tt> variant just relies on the &lt;tt>_ap&lt;/tt> variant to do the real work.&lt;br />Now, the crashes that appeared from the code above seemed to come from the call that consumes the &lt;tt>ap&lt;/tt> argument, which in this case is &lt;tt>vsnprintf&lt;/tt>. Interestingly, though, all the tests in other platforms but Linux x86_64 worked just fine, and this included OpenSolaris, other Linux distributions, some BSDs and even different hardware platforms.&lt;br />As it turned out, you &lt;b>cannot blindly pass &lt;tt>ap&lt;/tt> arguments around&lt;/b> because they are not "normal" parameters (even though, unfortunately, they look like so!). In most platforms, the &lt;tt>ap&lt;/tt> element will be just an "absolute" pointer to the stack, so passing the variable to an inner function calls is fine because the caller's stack has not been destroyed yet and, therefore, the pointer is still valid. But... the &lt;tt>ap&lt;/tt> argument can have other representations. It'd be an offset to the stack instead of a pointer, or it'd be a data structure that holds all the variable parameters. If, for example, the &lt;tt>ap&lt;/tt> argument held an offset, passing it to an inner function call would make such offset point to "garbage" because the stack would have been grown due to the new call frame. (I haven't investigated what specific representation is x86_64 using.)&lt;br />The solution is to use the &lt;tt>va_copy&lt;/tt> function to generate a new &lt;tt>ap&lt;/tt> object that is valid for the current stack frame. This is easy, so as an example, we have to rewrite the &lt;tt>foo_ap&lt;/tt> function above as follows:&lt;br />&lt;pre>void&lt;br />foo_ap(const char *fmt, va_list ap)&lt;br />{&lt;br /> char buf[128];&lt;br /> va_list ap2;&lt;br />&lt;br /> va_copy(ap2, ap);&lt;br /> vsnprintf(buf, sizeof(buf), fmt, ap2);&lt;br /> va_end(ap2);&lt;br />&lt;br /> ... now, do something with buf ...&lt;br />}&lt;/pre>This duplication of the &lt;tt>ap&lt;/tt> argument pointing to the variable list of arguments ensures that &lt;tt>ap2&lt;/tt> can be safely used from the new stack frame.</description></item><item><title>Validating format strings in custom C functions</title><link>https://jmmv.dev/2011/06/validating-format-strings-in-custom-c.html</link><pubDate>Fri, 17 Jun 2011 11:40:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/06/validating-format-strings-in-custom-c.html</guid><description>In C, particularly due to the lack of dynamic strings, it's common to pass format strings around together with a variable set of arguments. A prototype like this is very common:&lt;br />&lt;br />&lt;tt>void&amp;nbsp;my_printf(const char*, ...);&lt;/tt>&lt;br />&lt;br />For the standard &lt;tt>printf&lt;/tt> and similar functions, some compilers will ensure that the variable list of arguments matches the positional parameters in the format string and, if they don't match, raise a warning. &amp;nbsp;This is, however, just a warning "hardcoded" to match these functions, as the compiler can't know how the variable arguments of our custom &lt;tt>my_printf&lt;/tt> function relate to the first argument.&lt;br />&lt;br />Or can it?&lt;br />&lt;br />&lt;a href="http://mail-index.netbsd.org/source-changes/2011/06/11/msg023084.html">I was made aware&lt;/a> of a nice GCC attribute that allows developers to tag printf-like functions in a manner that allows the compiler to perform the same validation of variable arguments and format strings. &amp;nbsp;This is in the form of a GCC &lt;tt>__attribute__&lt;/tt> that also happens to work with CLang. &amp;nbsp;Let's see an example to illustrate how this works:&lt;br />&lt;br />&lt;pre>#include &amp;lt;stdarg.h&amp;gt;&lt;br />#include &amp;lt;stdio.h&amp;gt;&lt;br />&lt;br />static void my_printf(const char*, ...)&lt;br />&amp;nbsp; &amp;nbsp; __attribute__((format(printf, 1, 2)));&lt;br />&lt;br />static void&lt;br />my_printf(const char* format, ...)&lt;br />{&lt;br />&amp;nbsp; &amp;nbsp; va_list ap;&lt;br />&lt;br />&amp;nbsp; &amp;nbsp; printf("Custom printf: ");&lt;br />&amp;nbsp; &amp;nbsp; va_start(ap, format);&lt;br />&amp;nbsp; &amp;nbsp; vprintf(format, ap);&lt;br />&amp;nbsp; &amp;nbsp; va_end(ap);&lt;br />}&lt;br />&lt;br />int&lt;br />main(void)&lt;br />{&lt;br />&amp;nbsp; &amp;nbsp; my_printf("this is valid %dn", 3);&lt;br />&amp;nbsp; &amp;nbsp; my_printf("but this is not %fn", 3);&lt;br />}&lt;/pre>&lt;br />If we compile the code above:&lt;br />&lt;br />&lt;pre>$&amp;nbsp;clang example.c&lt;br />example.c:22:33: warning: conversion specifies type 'double' but&lt;br />the argument has type 'int' [-Wformat]&lt;br />&amp;nbsp; &amp;nbsp; my_printf("but this is not %fn", 3);&lt;br />&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;~^ &amp;nbsp; &amp;nbsp; ~&lt;br />1 warning generated.&lt;/pre>&lt;div>&lt;br />&lt;/div>&lt;div>Very useful. &amp;nbsp;This function attribute has been applied to many functions in the NetBSD tree and many bugs have been spotted thanks to it.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Instead of me explaining how the format attribute works, I'll refer you to the &lt;a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">official documentation&lt;/a>. The attribute recognizes several format styles and takes different arguments depending on them, so it is a bit tricky to explain. Plus, if you look at the extensive list of attributes, you may find some useful stuff ;-)&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Happy debugging!&lt;/div></description></item><item><title>Use explicit conditionals</title><link>https://jmmv.dev/2011/04/use-explicit-conditionals.html</link><pubDate>Sat, 30 Apr 2011 05:29:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/04/use-explicit-conditionals.html</guid><description>In C — or, for that matter, several other languages such as Python or C++ — most native types can be coerced to a boolean type: expressions that deliver integers, pointers or characters are automatically treated as boolean values whenever needed. For example: non-zero integer expression and non-NULL pointers evaluate to true whereas zero or NULL evaluate to false.&lt;br />&lt;br />Many programmers take advantage of this fact by stating their conditionals like this:&lt;br />&lt;br />&lt;pre>void func(const int in) {&lt;br /> if (in) {&lt;br /> ... do something when in != 0 ...&lt;br /> } else {&lt;br /> ... do something else when in == 0 ...&lt;br /> }&lt;br />}&lt;/pre>&lt;br />... or even do something like:&lt;br />&lt;br />&lt;pre>bool func(const struct mystruct *ptr) {&lt;br /> int out = calculate_out(in);&lt;br />&lt;br /> ... do something more with out ...&lt;br />&lt;br /> return out; // The return type is bool though; is this ok?&lt;br />}&lt;/pre>&lt;br />... but such idioms are sloppy and can introduce confusion or bugs. Yes, things work in many cases, but "work" is not a synonym for "good" ;-)&lt;br />&lt;br />Taking advantage of coercions (automatic type conversions) typically makes the code harder to follow. In statically-typed languages, whenever you define a variable to be of a particular type, you should adhere to said type by all means so that no confusion is possible. Conceptually, an integer is not a boolean and therefore it should not be treated as such. But this is just a matter of style.&lt;br />&lt;br />On the other hand, the automatic conversions can lead to hidden bugs; for example, in the second function above, did we really want to convert the "out" value to a boolean or was that a mistake? &amp;nbsp;This is not so much a matter of style but a matter of careful programming, and having as much state as possible "in your face" can help prevent these kind of trivial errors.&lt;br />&lt;br />In contrast, one would argue that having to provide explicit checks or casts on every expression is a waste of time. But keep in mind that code is supposed to be written once and read many times. Anything you can do to communicate your &lt;i>intent&lt;/i> to the reader will surely be appreciated.&lt;br />&lt;br />Disclaimer: the above is my personal opinion only. Not following the style above should have no implications on the resulting binary code. (Wow, this post had been sitting as a draft around here for a too long time.)</description></item><item><title>Error handling in Lua</title><link>https://jmmv.dev/2011/01/error-handling-in-lua.html</link><pubDate>Fri, 07 Jan 2011 08:01:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/01/error-handling-in-lua.html</guid><description>Some of the methods of the Lua C API can raise errors. To get an initial idea on what these are, take a look at the &lt;a href="http://www.lua.org/manual/5.1/manual.html#3.7">Functions and Types&lt;/a> section and pay attention to the third field of a function description (the one denoted by 'x' in the introduction).&lt;div>&lt;br />&lt;/div>&lt;div>Dealing with the errors raised by these functions is tricky, not to say a nightmare. Also, the &lt;a href="http://www.lua.org/manual/5.1/manual.html#3.6">ridiculously-short documentation on this topic&lt;/a> does not help. This post is dedicated to explain how these errors may be handled along with the advantages and disadvantages of each case.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>The Lua C API provides two modes of execution: protected and unprotected. When in protected mode, all errors caused by Lua are caught and reported to the caller in a controlled manner. When in unprotected mode, the errors just abort the execution of the calling process by default. So, one would think: just run the code in protected mode, right? Yeah, well... entering protected mode is nontrivial and it has its own particularities that make interaction with C++ problematic.&lt;br />&lt;br />&lt;/div>&lt;div>Let's analyze error reporting by considering a simple example: the &lt;tt>lua_gettable&lt;/tt> function. The following Lua code would error out when executed:&lt;pre>my_array = nil&lt;br />return my_array["test"]&lt;/pre>... which is obvious because indexing a non-table object is a mistake. Now let's consider how this code would look like in C (modulo the &lt;tt>my_array&lt;/tt> assignment):&lt;pre>lua_getglobal(state, "my_array");&lt;br />lua_pushstring(state, "test");&lt;br />lua_gettable(state, -2);&lt;/pre>Simple, huh? Sure, but as it turns out, &lt;i>any&lt;/i> of the API calls (not just &lt;tt>lua_gettable&lt;/tt>) in this code can raise errors (I'll call them &lt;i>unsafe&lt;/i> functions). What this means is that, unless you run the code with a &lt;tt>lua_pcall&lt;/tt> wrapper, your program will simply &lt;i>exit&lt;/i> in the face of a Lua error. Uh, your scripting language can "crash" your host program out of your control? Not nice.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>What would be nice is if each of the Lua C API unsafe functions reported an error (as a return value or whatever) and allowed the caller to decide what to do. Ideally, no state would change in the face of an error. Unfortunately, that is not the case but it is exactly what I would like to do. I am writing a C++ wrapper for Lua in the context of Kyua and fine granularity in error reporting means that automatic cleanup of resources managed by RAII is trivial.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Let's analyze the options that we have to control errors caused within the Lua C API. I will explain in a later post the one I have chosen for the wrapper in Kyua (it has to be later because I'm not settled yet!).&lt;/div>&lt;div>&lt;br />&lt;span class="Apple-style-span">&lt;b>Install a panic handler&lt;/b>&lt;/span>&lt;div>&lt;br />&lt;/div>&lt;div>Whenever Lua code runs in an unprotected environment, one can use &lt;tt>lua_atpanic&lt;/tt> to install a handler for errors. The function provided by the user is executed when the error occurs and, if the panic function returns, the program exits. To prevent exiting prematurely, one could opt for two mechanisms:&lt;br />&lt;ul>&lt;li>Make the panic handler raise a C++ exception. Sounds nice, right? Well, it does not work. The Lua library is generally built as a C binary which means that our panic handler will be called from within a C environment. As a result, we cannot throw an exception from our C++ handler and expect things to work: the exception won't propagate correctly from a C++ context to a C context and then back to C++. Most likely, the program will abort as soon as we leave the C++ world and enter C to unwind the stack.&lt;/li>&lt;li>Use &lt;tt>setjmp&lt;/tt> before the call to the unsafe Lua function and recover with &lt;tt>longjmp&lt;/tt> from within the panic handler. It turns out that this does work &lt;i>but&lt;/i> with one important caveat: the stack is completely cleared before the call to the panic handler. As a result, this prevents the requirement of "leave the stack unmodified on failure" as is desired of any function (report errors early before changing state).&lt;/li>&lt;/ul>&lt;span class="Apple-style-span">&lt;b>Run every single call in a protected environment&lt;/b>&lt;/span>&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>This is doable but complex and not completely right: to do this, we need to write a C wrapper function for every unsafe API function and run it with &lt;tt>lua_pcall&lt;/tt>. The overhead of this approach is significant: something as simple as a call to &lt;tt>lua_gettable&lt;/tt> turns into several stack manipulation operations, a call to &lt;tt>lua_pcall&lt;/tt> and then further stack modifications to adjust the results.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Additionally, in order to prepare the call to &lt;tt>lua_pcall&lt;/tt>, one has to use the multiple &lt;tt>lua_push*&lt;/tt> functions to prepare the stack for the call. And, guess what, most of these functions that push values onto the stack can themselves fail. So... in order to prepare the environment for a safe call, we are already executing unsafe calls. (Granted, the errors in these case are only due to memory exhaustion... but still, the solution is not fully robust.)&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Lastly, note that we cannot use &lt;tt>lua_cpcall&lt;/tt> because it does discard all return values of the executed function. Which means that we can't really wrap single Lua operations. (We could wrap a whole algorithm though.)&lt;br />&lt;br />&lt;span class="Apple-style-span">&lt;b>Run the whole algorithm in a protected environment&lt;/b>&lt;/span>&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>This defeats the whole purpose of the per-function wrapping. We would need to provide a separate C/C++ function that runs all unsafe code and then call it by means of &lt;tt>lua_pcall&lt;/tt> (or &lt;tt>lua_cpcall&lt;/tt>) so that errors are captured and reported in a controlled manner. This seems very efficient... albeit not transparent and will surely cause issues.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Why is this problematic? Errors that happen inside the protected environment are managed by means of a &lt;tt>longjmp&lt;/tt>. If the code wrapped by &lt;tt>lua_pcall&lt;/tt> is a C++ function, it can instantiate objects. These objects have destructors. A &lt;tt>longjmp&lt;/tt> outside of the function means that no destructors will run... so objects will leak memory, file descriptors, and anything you can imagine. Doom's day.&lt;br />&lt;br />Yes, I know Lua can be rebuilt to report internal errors by means of exceptions which would make this particular problem a non-issue... but this rules out any pre-packaged Lua binaries (the default is to use &lt;tt>longjmp&lt;/tt> and henceforth what packaged binaries use). I do not want to embed Lua into my source tree. I want to use Lua binary packages shipped with pretty much any OS (hey, including NetBSD!), which means that my code needs to be able to cope with Lua binaries that use &lt;tt>setjmp&lt;/tt>/&lt;tt>longjmp&lt;/tt> internally.&lt;/div>&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>&lt;span class="Apple-style-span" >&lt;b>Closing remarks&lt;/b>&lt;/span>&lt;/div>&lt;div>&lt;span class="Apple-style-span" >&lt;b>&lt;br />&lt;/b>&lt;/span>&lt;/div>&lt;div>&lt;span class="Apple-style-span" >I hope the above description makes any sense because I had to omit many, many details in order to make the post reasonably short. It could also be that there are other alternatives I have not considered, in which case I'd love to know them. Trying to find a solution to the above problem has already sucked several days of my free time, which translates in Kyua not seeing any further development until a solution is found!&lt;/span>&lt;/div></description></item><item><title>Understanding setjmp/longjmp</title><link>https://jmmv.dev/2011/01/understanding-setjmplongjmp.html</link><pubDate>Sun, 02 Jan 2011 03:22:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/01/understanding-setjmplongjmp.html</guid><description>For a long time, I have been aware of the existence of the standard C functions &lt;tt>setjmp&lt;/tt> and &lt;tt>longjmp&lt;/tt> and that they can be used to simulate exceptions in C code. However, it wasn't until yesterday that I had to use them... and it was not trivial. The documentation for these functions tends to be confusing, and understanding them required looking for additional documents and a bit of experimentation. Let's see if this post helps in clarifying how these functions work.&lt;br />&lt;br />The first call to &lt;tt>setjmp&lt;/tt> causes the process state (stack, CPU registers, etc.) to be saved in the provided &lt;tt>jmp_buf&lt;/tt> structure and, &lt;i>then&lt;/i>, a value of 0 to be returned. A subsequent call to &lt;tt>longjmp&lt;/tt> with the same &lt;tt>jmp_buf&lt;/tt> structure causes the process to go "back in time" to the state stored in said structure. The way this is useful is that, when going back in time, we tweak the return value of the &lt;tt>setjmp&lt;/tt> call so we can actually run a second (or third or more) path as if nothing had happened.&lt;br />&lt;br />Let's see an example:&lt;pre>#include &amp;lt;setjmp.h&amp;gt;&lt;br />#include &amp;lt;stdio.h&amp;gt;&lt;br />#include &amp;lt;stdlib.h&amp;gt;&lt;br />&lt;br />static jmp_buf buf;&lt;br />&lt;br />static void&lt;br />myfunc(void)&lt;br />{&lt;br /> printf("In the function.n");&lt;br />&lt;br /> ... do some complex stuff ...&lt;br />&lt;br /> /* Go back in time: restore the execution context of setjmp&lt;br /> * but make the call return 1 instead of 0. */&lt;br /> longjmp(buf, 1);&lt;br />&lt;br /> printf("Not reached.n");&lt;br />}&lt;br />&lt;br />int&lt;br />main(void) {&lt;br /> if (setjmp(buf) == 0) {&lt;br /> /* Try block. */&lt;br /> printf("Trying some function that may throw.n");&lt;br /> myfunc();&lt;br /> printf("Not reached.n");&lt;br /> } else {&lt;br /> /* Catch block. */&lt;br /> printf("Exception caught.n");&lt;br /> }&lt;br /> return EXIT_SUCCESS;&lt;br />}&lt;/pre>The example above shows the following when executed:&lt;pre>Trying some function that may throw.&lt;br />In the function.&lt;br />Exception caught.&lt;/pre>So, what happened above? The code starts by calling &lt;tt>setjmp&lt;/tt> to record the execution state and the call returns 0, which causes the first part of the conditional to run. You can think of this clause as the "try" part of an exception-based code. At some point during the execution of &lt;tt>myfunc&lt;/tt>, an error is detected and is "thrown" by a call to &lt;tt>longjmp&lt;/tt> and a value of 1. This causes the process to go back to the execution of &lt;tt>setjmp&lt;/tt> but this time the call returns 1, which causes the second part of the conditional to run. You can think of this second clause as the "catch" part of an exception-based code.&lt;div>&lt;br />&lt;/div>&lt;div>It is still unclear to me what the "execution context" stored in &lt;tt>jmp_buf&lt;/tt> is: the documentation does not explain what kind of resources are correctly unwinded when the call to &lt;tt>longjmp&lt;/tt> is made... which makes me wary of using this technique for exception-like handling purposes. Oh, and this is even less clear in the context of C++ code and, e.g. calls to destructors. Would be nice to expand the description of these APIs in the manual pages.&lt;/div></description></item><item><title>Using RAII to clean up temporary values from a stack</title><link>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</link><pubDate>Mon, 27 Dec 2010 04:06:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</guid><description>For the last couple of days, I have been playing around with the &lt;a href="http://www.lua.org/">Lua&lt;/a> C API and have been writing a thin wrapper library for C++. The main purpose of this auxiliary library is to ensure that global interpreter resources such as the global state or the execution stack are kept consistent in the presence of exceptions &amp;mdash; and, in particular, that none of these are leaked due to programming mistakes when handling error codes.&lt;br />&lt;br />To illustrate this point, let's forget about Lua and consider a simpler case. Suppose we lost the ability to pass arguments and return values from functions in C++ and all we have is a stack that we pass around. With this in mind, we could implement a &lt;tt>multiply&lt;/tt> function as follows:&lt;pre>void multiply(std::stack&lt; int >&amp; context) {&lt;br /> const int arg1 = context.top();&lt;br /> context.pop();&lt;br /> const int arg2 = context.top();&lt;br /> context.pop();&lt;br /> context.push(arg1 * arg2);&lt;br />}&lt;/pre>And we could call our function as this:&lt;pre>std::stack&lt; int > context;&lt;br />context.push(5);&lt;br />context.push(6);&lt;br />multiply(context);&lt;br />const int result = s.top();&lt;br />s.pop();&lt;/pre>In fact, my friends, this is more-or-less what your C/C++ compiler is internally doing when converting code to assembly language. The way the stack is organized to perform calls is known as the &lt;a href="http://en.wikipedia.org/wiki/Calling_conventions">calling conventions&lt;/a> of an ABI (language/platform combination).&lt;br />&lt;br />Anyway, back to our point. One important property of such a stack-based system is that any function that deals with the stack must leave it in a consistent state: if the function pushes temporary values (read: local variables) into the stack, such temporary values must be gone upon return no matter how the function terminates. Otherwise, the caller will not find the stack as it expects, which will surely cause trouble at a later stage. The above example works just fine because our function is extremely simple and does not put anything on the stack.&lt;br />&lt;br />But things get messier when our functions can fail halfway through, and, in particular, if such failures are signaled by exceptions. In these cases, the function will abort abruptly and the function must take care to clean up any values that may still be left on the stack. Let's consider another example:&lt;pre>void magic(std::stack&lt; int >&amp; context) {&lt;br /> const int arg1 = context.top();&lt;br /> context.pop();&lt;br /> const int arg2 = context.top();&lt;br /> context.pop();&lt;br />&lt;br /> context.push(arg1 * arg2);&lt;br /> context.push(arg1 / arg2);&lt;br /> try {&lt;br /> ... do something with the two values on top ...&lt;br />&lt;br /> context.push(arg1 - arg2);&lt;br /> try {&lt;br /> ... do something with the three values on top ...&lt;br /> } catch (...) {&lt;br /> context.pop(); // arg1 - arg2&lt;br /> throw;&lt;br /> }&lt;br /> context.pop();&lt;br /> } catch (...) {&lt;br /> context.pop(); // arg1 / arg2&lt;br /> context.pop(); // arg1 * arg2&lt;br /> throw;&lt;br /> }&lt;br /> context.pop();&lt;br /> context.pop();&lt;br />}&lt;/pre>The above is a completely fictitious and useless function, but serves to illustrate the point. &lt;tt>magic()&lt;/tt> starts by pushing two values on the stack and then performs some computation that reads these two values. It later pushes an additional value and does some more computations on the three temporary values that are on the top of the stack.&lt;br />&lt;br />The "problem" is that the computation code can throw an exception. If it does, we must sanitize the stack to remove the two or three values we have already pushed. Otherwise, the caller will receive the exception, it will assume nothing has happened, and will leak values on the stack (bad thing). To prevent this, we have added a couple of try/catch clauses to capture these possible exceptions and to clean up the already-pushed values before exiting the function. Unfortunately, this gets old very quickly: having to add try/catch statements surrounding every call is boring, ugly, and hard to read (remember that, &lt;i>potentially&lt;/i>, any statement can throw an exception). You can see this in the example above with the two nested try/catch blocks.&lt;br />&lt;br />To mitigate this situation, we can apply a &lt;a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII&lt;/a>-like technique to make popping elements on errors completely transparent and automated. If we can make it transparent, writing the code is easier and reading it is trivial; if we can make it automated, we can be certain that our error paths (rarely tested!) correctly clean up any global state. In C++, destructors are &lt;i>deterministically&lt;/i> executed whenever a variable goes out of scope, so we can use this to our advantage to clean up temporary values. Let's consider this class:&lt;pre>class temp_stack {&lt;br /> std::stack&lt; int >&amp; _stack;&lt;br /> int _pop_count;&lt;br />&lt;br />public:&lt;br /> temp_stack(std::stack&lt; int >&amp; stack_) :&lt;br /> _stack(stack_), _pop_count(0) {}&lt;br />&lt;br /> ~temp_stack(void)&lt;br /> {&lt;br /> while (_pop_count-- > 0)&lt;br /> _stack.pop();&lt;br /> }&lt;br />&lt;br /> void push(int i)&lt;br /> {&lt;br /> _stack.push(i);&lt;br /> _pop_count++;&lt;br /> }&lt;br />};&lt;/pre>With this, we can rewrite our function as:&lt;pre>void magic(std::stack&lt; int >&amp; context) {&lt;br /> const int arg1 = context.top();&lt;br /> context.pop();&lt;br /> const int arg2 = context.top();&lt;br /> context.pop();&lt;br />&lt;br /> temp_stack temp(context);&lt;br />&lt;br /> temp_stack.push(arg1 * arg2);&lt;br /> temp_stack.push(arg1 / arg2);&lt;br /> ... do something with the two values on top ...&lt;br />&lt;br /> temp_stack.push(arg1 - arg2);&lt;br /> ... do something with the three values on top ...&lt;br />&lt;br /> // Yes, we can return now. No need to do manual pop()s!&lt;br />}&lt;/pre>Simple, huh? Our &lt;tt>temp_stack&lt;/tt> function keeps track of how many elements have been pushed on the stack. Whenever the function terminates, be it due to reaching the end of the body or due to an exception thrown anywhere, the &lt;tt>temp_stack&lt;/tt> destructor will remove all elements previously registered from the stack. This ensures that the function leaves the global state (the stack) as it was on entry &amp;mdash; modulo the function parameters consumed as part of the calling conventions.&lt;br />&lt;br />So how does all this play together with Lua? Well, Lua maintains a stack to communicate parameters and return values between C and Lua. Such stack can be managed in a similar way with a RAII class, which makes it very easy to write native functions that deal with the stack and clean it up correctly in all cases. I would like to show you some non-fictitious code right now, but it's not ready yet ;-) But when it is, it will be part of &lt;a href="http://code.google.com/p/kyua/">Kyua&lt;/a>. Stay tuned!&lt;br />&lt;br />And, to conclude: to make C++ code robust, wrap objects that need manual clean up (pointers, file descriptors, etc.) with small wrapper classes that perform such clean up on destruction. These classes are typically fully inlined and contain a single member field, so they do not impose any performance penalty. But, on the contrary, your code can avoid the need of many try/catch blocks, which are tricky to get right and hard to validate. (Unfortunately, this technique cannot be applied in, e.g. Java or Python, because the execution of the class destructors is completely non-deterministic and not guaranteed to happen whatsoever!)</description></item><item><title>Child-process management in C for ATF</title><link>https://jmmv.dev/2009/06/child-process-management-in-c-for-atf.html</link><pubDate>Sun, 21 Jun 2009 13:40:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2009/06/child-process-management-in-c-for-atf.html</guid><description>Let's face it: spawning child processes in Unix is a "mess". Yes, the interfaces involved (fork, wait, pipe) are really elegant and easy to understand, but every single time you need to spawn a new child process to, later on, execute a random command, you have to write quite a bunch of error-prone code to cope with it. If you have ever used any other programming language with higher-level abstraction layers — just check Python's subprocess.Popen — you surely understand what I mean.&lt;div>&lt;br />&lt;div>&lt;div>The current code in ATF has many places were child processes have to be spawned. I recently had to add yet another case of this, and... enough was enough. Since then, I've been working on a C API to spawn child processes from within ATF's internals and just pushed it to the repository. It's still fairly incomplete, but with minor tweaks, it'll keep all the dirty details of process management contained in a single, one-day-to-be-portable module.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>The interface tries to mimic the one that was designed on my Boost.Process Summer of Code project, but in C, which is quite painful. The main idea is to have a fork function to which you pass the subroutine you want to run on the child, the behavior you want for the stdout stream and the behavior you want for the stderr steam. These behaviors can be any of capture (aka create pipes for IPC communcations), silence (aka redirect to /dev/null), redirect to file descriptor and redirect to file. For simplicity, I've omitted stdin. With all this information, the fork function returns you an opaque structure representing the child, from which you can obtain the IPC channels if you requested them and on which you can wait for finalization.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Here is a little example, with tons of details such as error handling or resource finalization removed for simplicity. The code below would spawn "/bin/ls" and store its output in two files named ls.out and ls.err:&lt;/div>&lt;pre>static&lt;br />atf_error_t&lt;br />run_ls(const void *v)&lt;br />{&lt;br /> system("/bin/ls");&lt;br /> return atf_no_error();&lt;br />}&lt;br />&lt;br />static&lt;br />void&lt;br />some_function(...)&lt;br />{&lt;br /> atf_process_stream_t outsb, errsb;&lt;br /> atf_process_child_t child;&lt;br /> atf_process_status_t status;&lt;br />&lt;br /> atf_process_status_init_redirect_path(&amp;amp;outsb, "ls.out");&lt;br /> atf_process_status_init_redirect_path(&amp;amp;errsb, "ls.err");&lt;br />&lt;br /> atf_process_fork(&amp;amp;child, run_ls, &amp;amp;outsb, &amp;amp;errsb, NULL);&lt;br /> ... yeah, here comes the concurrency! ...&lt;br /> atf_process_child_wait(&amp;amp;child, &amp;amp;status);&lt;br />&lt;br /> if (atf_process_status_exited(&amp;amp;status))&lt;br /> printf("Exit: %dn", atf_process_status_exitstatus(&amp;amp;status));&lt;br /> else&lt;br /> printf("Error!");&lt;br />}&lt;/pre>&lt;div>Yeah, quite verbose, huh? Well, it's the price to pay to simulate namespaces and similar other things in C. I'm not too happy with the interface yet, though, because I've already encountered a few gotchas when trying to convert some of the existing old fork calls to the new module. But, should you want to check the whole mess, &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/revision/info/3ba2af4ab1cad67108c3fb1aea15e8e0168667ff">check out the corresponding revision&lt;/a>.&lt;/div>&lt;/div>&lt;/div></description></item><item><title>Making ATF 'compiler-aware'</title><link>https://jmmv.dev/2009/03/making-atf-compiler-aware.html</link><pubDate>Thu, 05 Mar 2009 09:47:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2009/03/making-atf-compiler-aware.html</guid><description>For a long time, ATF has shipped with &lt;a href="http://portal.pc.ac.upc.edu/viewmtn/atf/revision/browse/92e15dcd3de700ceaf558c43ed9de90e3c7d20d5/tests/build">build-time tests for its own header files&lt;/a> to ensure that these files are self-contained and can be included from other sources without having to manually pull in obscure dependencies. However, the way I wrote these tests was a hack since the first day: I use automake to generate a temporary library that builds small source files, each one including one of the public header files. This approach works but has two drawbacks. First, if you do not have the source tree, you cannot reproduce these tests -- and one of ATF's major features is the ability to install tests and reproduce them even if you install from binaries, remember? And second, it's not reusable: I now find myself needing to do this exact same thing in another project... what if I could just use ATF for it?&lt;br />&lt;br />Even if the above were not an issue, build-time checks are a nice thing to have in virtually every project that installs libraries. You need to make sure that the installed library is linkable to new source code and, currently, there is no easy way to do this. As a matter of fact, &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/regress/include/?only_with_tag=MAIN">the NetBSD tree has such tests&lt;/a> and they haven't been migrated to ATF for a reason.&lt;br />&lt;br />I'm trying to implement this in ATF at the moment. However, running the compiler in a transparent way is a tricky thing. Which compiler do you execute? Which flags do you need to pass? How do you provide a portable-enough interface for the callers?&lt;br />&lt;br />The approach I have in mind involves caching the same compiler and flags used to build ATF itself and using those as defaults anywhere ATF needs to run the compiler itself. Then, make ATF provide some helper check functions that call the compiler for specific purposes and hide all the required logic inside them. That should work, I expect. Any better ideas?</description></item><item><title>ATF's error handling in C</title><link>https://jmmv.dev/2008/02/atfs-error-handling-in-c.html</link><pubDate>Sun, 24 Feb 2008 12:52:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2008/02/atfs-error-handling-in-c.html</guid><description>One of the things I miss a lot when writing the C-only code bits of ATF is an easy way to raise and handle errors. In C++, the normal control flow of the execution is not disturbed by error handling because any part of the code is free to notify error conditions by means of exceptions. Unfortunately, C has no such mechanism, so errors must be handled explicitly.&lt;br />&lt;br />At the very beginning I just made functions return integers indicating error codes and reusing the standard error codes of the C library. However, that turned out to be too simple for my needs and, depending on the return value of a function (not an integer), was not easily applicable.&lt;br />&lt;br />What I ended up doing was defining a new type, &lt;tt>atf_error_t&lt;/tt>, which must be returned by all functions that can raise errors. This type is a pointer to a memory region that can vary in contents (and size) depending on the error raised by the code. For example, if the error comes from libc, I mux the original error code and an informative message into the error type so that the original, non-mangled information is available to the caller; or, if the error is caused by the user's misuse of the application, I simply return a string that contains the reason for the failure. The error structure contains a type field that the receiver can query to know which specific information is available and, based on that, cast down the structure to the specific type that contains detailed information. Yes, this is very similar to how you work with exceptions.&lt;br />&lt;br />In the case of no errors, a null pointer is returned. This way checking for an error condition is just a simple pointer check, which is no more expensive than an integer check. However, handling error conditions is more costly, but given that these are rare, it is certainly not a problem.&lt;br />&lt;br />What I don't like too much of this approach is that any other return value must be returned as an output parameter, which makes things a bit confusing. Furthermore, robust code ends up cluttered with error checks all around given that virtually any call to the library can produce an error somewhere. This, together with the lack of RAII modeling, complicates error handling a lot. But I can't think of any other way that could be simpler but, at the same time, as flexible as this one. Ideas? :P&lt;br />&lt;br />More details are available in the &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/1dc8887d38a3001e5465217991b054a4dab3a253/atf-c/error.h">atf-c/error.h&lt;/a> and &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/1dc8887d38a3001e5465217991b054a4dab3a253/atf-c/error.c">atf-c/error.c&lt;/a> files.</description></item><item><title>Rewriting parts of ATF in C</title><link>https://jmmv.dev/2008/02/rewriting-parts-of-atf-in-c.html</link><pubDate>Mon, 18 Feb 2008 05:22:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2008/02/rewriting-parts-of-atf-in-c.html</guid><description>I have spent part of past week and this whole weekend working on a C-only library for ATF test programs. An extremely exhausting task. However, I wanted to do it because there is reluctancy in NetBSD to write test programs in C++, which is understandable, and delaying it more would have made things worse in the future. I found this situation myself some days ago when writing tests for very low level stuff; using C++ there felt clunky, but it was still possible of course.&lt;br />&lt;br />I have had to reimplement lots of stuff that are given for-free in any other, &lt;i>higher&lt;/i>-level (not necessarily &lt;i>high&lt;/i>-level) language. This includes, for example, a "class" to deal with dynamic strings, another one for dynamic linked lists and iterators, a way to propagate errors until the point where they can be managed... and I have spent quite a bit of time debugging crashes due to memory management bugs, something that I rarely encountered in the C++ version.&lt;br />&lt;br />However, the new interface is, I believe, quite neat. This is not because of the language per se, but because the C++ interface has grown "incorrectly". It was the first code in the project and it shows. The C version has been written from the ground up with all the requirements known beforehand, so it is cleaner. This will surely help in cleaning up the C++ version later on, which cannot die anyway.&lt;br />&lt;br />The code for this interface is in a new branch, &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/branch/changes/org.NetBSD.atf.src.c">org.NetBSD.atf.src.c&lt;/a>, and will hopefully make it to ATF 0.5: it still lacks a lot of features, hence why it is not on mainline. Ah, the joys of a distributed VCS: I have been able to develop this experiment locally and privately until it was decent enough to be published, and now it is online with all history available!&lt;br />&lt;br />From now on C++ use will be restricted to the ATF tools inside ATF itself, and to those users who want to use it in their projects. Test cases will be written using the C library except for those that unit-test C++ code.</description></item><item><title>Is assembly code faster than C?</title><link>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</link><pubDate>Mon, 04 Jun 2007 11:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</guid><description>I was reading an &lt;a href="http://hubpages.com/hub/_86_Mac_Plus_Vs_07_AMD_DualCore_You_Wont_Believe_Who_Wins">article&lt;/a> the other day and found an assertion that bugged me. It reads:&lt;br />&lt;blockquote>System 6.0.8 is not only a lot more compact since it has far fewer (mostly useless) features and therefore less code to process, but also because &lt;span style="font-weight: bold;">it was written in assembly code instead of the higher level language C&lt;/span>. The lower the level of the code language, the less processing cycles are required to get something done.&lt;/blockquote>It is not the first time I see someone claiming that writing programs in assembly by hand makes them faster, and I'm sure it is not the last time I'll see this. This assertion is, simply put, wrong.&lt;br />&lt;br />Back in the (good?) old days, processors were very simple: they fetched a instruction from main memory, executed it and once finished (and only then), they fetched the next instruction and repeated the process. On the other hand, compilers were very primitive and their optimization engines were, I dare to say, non-existent. In such scenario, a good programmer could really optimize any program by writing it in assembly instead of in a high-level language: he was able to understand very well how the processor internally behaved and what the outcomes of each machine-level instruction were. Furthermore, he could get rid of all the "bloat" introduced by a compiler.&lt;br />&lt;br />Things have changed a lot since then. Nowadays' processors are very complex devices: they have a very deep execution pipeline that, at a given time, can be executing dozens of instructions at once. They have powerful branch prediction units. They reorder instructions at run time and execute them in an out-of-order way (provided they respect the data dependencies among them). There are memory caches everywhere. So... it is, simply put, almost impossible for a programmer's brain to keep track of all these details and produce efficient code. (And even if he could, the efficiency could be so tied to a specific microprocessor version that it'd be useless in all other cases.)&lt;br />&lt;br />Furthermore, compilers now have much better optimization stages than before and are able keep track of all these processor-specific details. For example, they can reorder instructions on their own or insert prefetching operations at key points to avoid cache misses. They can really do a much better job in converting code to assembly than a programmer would &lt;span style="font-style: italic;">in most cases&lt;/span>.&lt;br />&lt;br />But hey! Of course it is still possible and useful to manually write optimized routines in assembly language &amp;mdash; to make use of SIMD extensions for example &amp;mdash; but these routines tend to be as short and as simple as possible.&lt;br />&lt;br />So, summarizing: it no longer makes sense to write big programs (such as a complete operating systems) in assembly language. Doing that means you lose all the portability gains of a not-so-high-level language such as C and that you will probably do a worse optimization job than a compiler would. Plus well-written and optimized C code can be extremely efficient, as this language is just a very thin layer over assembly.&lt;br />&lt;br />Oh, and back to the original quote. It would have made sense to mention the fact that the Mac Plus was written in assembly if it had been compared with another system &lt;span style="font-style: italic;">of its epoch&lt;/span> written in C. In that case, the argument would have been valid because the compilers were much worse than they are today and the processors were simpler. Just remember that such assertion is, in general, not true any more.</description></item></channel></rss>