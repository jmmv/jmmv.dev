<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on jmmv.dev</title>
    <link>https://jmmv.dev/tags/c/</link>
    <description>Recent content in C on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Feb 2015 17:40:00 -0500</lastBuildDate>
    
	<atom:link href="https://jmmv.dev/tags/c/index/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unused parameters in C and C&#43;&#43;</title>
      <link>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</link>
      <pubDate>Mon, 16 Feb 2015 17:40:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</guid>
      <description>Today I would like to dive into the topic of unused parameters in C and C++: why they may happen and how to properly deal with them—because smart compilers will warn you about their presence should you enable -Wunused-parameter or -Wextra, and even error out if you are brave enough to use -Werror.
Why may unused parameters appear? You would think that unused parameters should never exist: if the parameter is not necessary as an input, it should not be there in the first place!</description>
    </item>
    
    <item>
      <title>Using va_copy to safely pass ap arguments around</title>
      <link>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</link>
      <pubDate>Mon, 12 Sep 2011 22:34:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</guid>
      <description>Update (2014-12-19): The advice provided in this blog post is questionable and, in fact, probably incorrect. The bug described below must have happened for some unrelated reason (like, maybe, reuse of ap), but at this point (three years later!) I do not really remember what was going on here nor have much interest in retrying.
A long time ago, while I was preparing an ATF release, I faced many failing tests and crashes in one of the platforms under test.</description>
    </item>
    
    <item>
      <title>Validating format strings in custom C functions</title>
      <link>https://jmmv.dev/2011/06/validating-format-strings-in-custom-c.html</link>
      <pubDate>Fri, 17 Jun 2011 11:40:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/06/validating-format-strings-in-custom-c.html</guid>
      <description>In C, particularly due to the lack of dynamic strings, it&#39;s common to pass format strings around together with a variable set of arguments. A prototype like this is very common:
void&amp;nbsp;my_printf(const char*, ...);
For the standard printf and similar functions, some compilers will ensure that the variable list of arguments matches the positional parameters in the format string and, if they don&#39;t match, raise a warning. &amp;nbsp;This is, however, just a warning &#34;</description>
    </item>
    
    <item>
      <title>Use explicit conditionals</title>
      <link>https://jmmv.dev/2011/04/use-explicit-conditionals.html</link>
      <pubDate>Sat, 30 Apr 2011 05:29:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/04/use-explicit-conditionals.html</guid>
      <description>In C — or, for that matter, several other languages such as Python or C++ — most native types can be coerced to a boolean type: expressions that deliver integers, pointers or characters are automatically treated as boolean values whenever needed. For example: non-zero integer expression and non-NULL pointers evaluate to true whereas zero or NULL evaluate to false.
Many programmers take advantage of this fact by stating their conditionals like this:</description>
    </item>
    
    <item>
      <title>Error handling in Lua</title>
      <link>https://jmmv.dev/2011/01/error-handling-in-lua.html</link>
      <pubDate>Fri, 07 Jan 2011 08:01:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/error-handling-in-lua.html</guid>
      <description>Some of the methods of the Lua C API can raise errors. To get an initial idea on what these are, take a look at the Functions and Types section and pay attention to the third field of a function description (the one denoted by &#39;x&#39; in the introduction).
Dealing with the errors raised by these functions is tricky, not to say a nightmare. Also, the ridiculously-short documentation on this topic does not help.</description>
    </item>
    
    <item>
      <title>Understanding setjmp/longjmp</title>
      <link>https://jmmv.dev/2011/01/understanding-setjmplongjmp.html</link>
      <pubDate>Sun, 02 Jan 2011 03:22:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/understanding-setjmplongjmp.html</guid>
      <description>For a long time, I have been aware of the existence of the standard C functions setjmp and longjmp and that they can be used to simulate exceptions in C code. However, it wasn&#39;t until yesterday that I had to use them... and it was not trivial. The documentation for these functions tends to be confusing, and understanding them required looking for additional documents and a bit of experimentation. Let&#39;s see if this post helps in clarifying how these functions work.</description>
    </item>
    
    <item>
      <title>Using RAII to clean up temporary values from a stack</title>
      <link>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</link>
      <pubDate>Mon, 27 Dec 2010 04:06:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2010/12/using-raii-to-clean-up-temporary-values.html</guid>
      <description>For the last couple of days, I have been playing around with the Lua C API and have been writing a thin wrapper library for C++. The main purpose of this auxiliary library is to ensure that global interpreter resources such as the global state or the execution stack are kept consistent in the presence of exceptions &amp;mdash; and, in particular, that none of these are leaked due to programming mistakes when handling error codes.</description>
    </item>
    
    <item>
      <title>Child-process management in C for ATF</title>
      <link>https://jmmv.dev/2009/06/child-process-management-in-c-for-atf.html</link>
      <pubDate>Sun, 21 Jun 2009 13:40:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2009/06/child-process-management-in-c-for-atf.html</guid>
      <description>Let&#39;s face it: spawning child processes in Unix is a &#34;mess&#34;. Yes, the interfaces involved (fork, wait, pipe) are really elegant and easy to understand, but every single time you need to spawn a new child process to, later on, execute a random command, you have to write quite a bunch of error-prone code to cope with it. If you have ever used any other programming language with higher-level abstraction layers — just check Python&#39;s subprocess.</description>
    </item>
    
    <item>
      <title>Making ATF &#39;compiler-aware&#39;</title>
      <link>https://jmmv.dev/2009/03/making-atf-compiler-aware.html</link>
      <pubDate>Thu, 05 Mar 2009 09:47:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2009/03/making-atf-compiler-aware.html</guid>
      <description>For a long time, ATF has shipped with build-time tests for its own header files to ensure that these files are self-contained and can be included from other sources without having to manually pull in obscure dependencies. However, the way I wrote these tests was a hack since the first day: I use automake to generate a temporary library that builds small source files, each one including one of the public header files.</description>
    </item>
    
    <item>
      <title>ATF&#39;s error handling in C</title>
      <link>https://jmmv.dev/2008/02/atfs-error-handling-in-c.html</link>
      <pubDate>Sun, 24 Feb 2008 12:52:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2008/02/atfs-error-handling-in-c.html</guid>
      <description>One of the things I miss a lot when writing the C-only code bits of ATF is an easy way to raise and handle errors. In C++, the normal control flow of the execution is not disturbed by error handling because any part of the code is free to notify error conditions by means of exceptions. Unfortunately, C has no such mechanism, so errors must be handled explicitly.
At the very beginning I just made functions return integers indicating error codes and reusing the standard error codes of the C library.</description>
    </item>
    
    <item>
      <title>Rewriting parts of ATF in C</title>
      <link>https://jmmv.dev/2008/02/rewriting-parts-of-atf-in-c.html</link>
      <pubDate>Mon, 18 Feb 2008 05:22:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2008/02/rewriting-parts-of-atf-in-c.html</guid>
      <description>I have spent part of past week and this whole weekend working on a C-only library for ATF test programs. An extremely exhausting task. However, I wanted to do it because there is reluctancy in NetBSD to write test programs in C++, which is understandable, and delaying it more would have made things worse in the future. I found this situation myself some days ago when writing tests for very low level stuff; using C++ there felt clunky, but it was still possible of course.</description>
    </item>
    
    <item>
      <title>Is assembly code faster than C?</title>
      <link>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</link>
      <pubDate>Mon, 04 Jun 2007 11:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</guid>
      <description>I was reading an article the other day and found an assertion that bugged me. It reads:
System 6.0.8 is not only a lot more compact since it has far fewer (mostly useless) features and therefore less code to process, but also because it was written in assembly code instead of the higher level language C. The lower the level of the code language, the less processing cycles are required to get something done.</description>
    </item>
    
  </channel>
</rss>