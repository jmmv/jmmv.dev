<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Onlamp on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/onlamp/index.html</link><description>Recent content in Onlamp on Julio Merino (jmmv.dev)</description><generator>Hugo</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><lastBuildDate>Thu, 01 Mar 2007 09:00:00 +0000</lastBuildDate><atom:link href="https://jmmv.dev/tags/onlamp/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Making NetBSD Multiboot-Compatible</title><link>https://jmmv.dev/2007/03/making-netbsd-multiboot-compatible.html</link><pubDate>Thu, 01 Mar 2007 09:00:00 +0000</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/03/making-netbsd-multiboot-compatible.html</guid><description>&lt;p>&lt;em>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to &lt;a href="https://web.archive.org/web/20070303102352/http://www.onlamp.com/pub/a/bsd/2007/03/01/inside-multiboot.html">find a copy&lt;/a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>The i386 architecture is full of cruft required to maintain compatibility with old machines that go back as far as the 8086 series. Technically speaking, these features aren&amp;rsquo;t necessary anymore because any recent computer based on this architecture uses a full 32-bit operating system that could work perfectly fine without the legacy code. Unfortunately, the compatibility hacks remain in place and hurt the development of new software.&lt;/p></description></item><item><title>Smart Pointers in C++</title><link>https://jmmv.dev/2006/05/smart-pointers-in-cxx.html</link><pubDate>Thu, 04 May 2006 09:00:00 +0000</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2006/05/smart-pointers-in-cxx.html</guid><description>&lt;p>&lt;em>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to &lt;a href="https://web.archive.org/web/20060615153924/http://www.onlamp.com/pub/a/onlamp/2006/05/04/smart-pointers.html">find a copy&lt;/a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>C++, with its complex and complete syntax, is a very versatile language. Because it supports object-oriented capabilities and has powerful object libraries&amp;mdash;such as the STL or Boost&amp;mdash;one can quickly implement robust, high-level systems. On the other hand, thanks to its C roots, C++ allows the implementation of very low-level code. This has advantages but also carries some disadvantages, especially when one attempts to write high-level applications.&lt;/p></description></item><item><title>Lightweight Web Serving With thttpd</title><link>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</link><pubDate>Thu, 13 Oct 2005 09:00:00 +0000</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</guid><description>&lt;p>&lt;em>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to &lt;a href="https://web.archive.org/web/20150910024728/http://www.linuxdevcenter.com/pub/a/bsd/2005/10/13/thttpd.html">find a copy&lt;/a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>The &lt;a href="http://httpd.apache.org/">Apache HTTP Server&lt;/a> is the most popular web server due to its functionality, stability, and maturity. However, this does not make it suitable for all uses: slow machines and embedded systems may have serious problems running it because of its size. Here is where lightweight HTTP servers come into play, as their low-memory footprints deliver decent results without having to swap data back to disk.&lt;/p></description></item><item><title>Making Packager-Friendly Software (part 2)</title><link>https://jmmv.dev/2005/04/making-packager-friendly-software-2.html</link><pubDate>Thu, 28 Apr 2005 09:00:00 +0000</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2005/04/making-packager-friendly-software-2.html</guid><description>&lt;p>&lt;em>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to &lt;a href="https://web.archive.org/web/20150910045605/http://www.linuxdevcenter.com/pub/a/onlamp/2005/04/28/packaging2.html">find a copy&lt;/a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>My previous article, &lt;a href="https://jmmv.dev/2005/03/making-packager-friendly-software-1.html">Making Packager-Friendly Software (part 1)&lt;/a>, explains why software packaging is sometimes problematic due to real problems in the mainstream sources. It also discusses many issues that affect the distribution files and the configuration scripts (the most visible items when trying out a new program). This part explores the problems found in the build infrastructure and the code itself.&lt;/p></description></item><item><title>Making Packager-Friendly Software (part 1)</title><link>https://jmmv.dev/2005/03/making-packager-friendly-software-1.html</link><pubDate>Thu, 31 Mar 2005 09:00:00 +0000</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2005/03/making-packager-friendly-software-1.html</guid><description>&lt;p>&lt;em>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to &lt;a href="https://web.archive.org/web/20150910045646/http://www.linuxdevcenter.com/pub/a/onlamp/2005/03/31/packaging.html">find a copy&lt;/a> in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>A package maintainer, or packager, is a person who creates packages for software projects. He eventually finds common problems in these projects, resulting in a complex packaging process and a final package that is a nightmare to maintain. These little flaws exist because in most cases the original developers are not packagers, so they are not aware of them. In other words, if you do not know something is wrong, you cannot fix it.&lt;/p></description></item></channel></rss>