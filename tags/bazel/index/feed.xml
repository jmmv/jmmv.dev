<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bazel on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/bazel/index/</link><description>Recent content in bazel on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Oct 2024 08:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/bazel/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>BazelCon 2024 recap</title><link>https://jmmv.dev/2024/10/bazelcon-2024-recap.html</link><pubDate>Tue, 22 Oct 2024 08:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/10/bazelcon-2024-recap.html</guid><description>Just like that, BazelCon 2024 came and went. So&amp;hellip; it&amp;rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is A LOT to cover, but everything is here in just one article!</description><enclosure url="https://jmmv.dev/images/2024-10-22-bazelcon.jpg" length="362903" type="image/jpeg"/></item><item><title>Bazel interview at Software Engineering Daily</title><link>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</link><pubDate>Thu, 21 Dec 2023 09:50:00 +0100</pubDate><guid>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</guid><description>Just a bit over 2 months ago, on October 5th, 2023, Jordi Mon Companys interviewed me about Bazel for an episode in the Software Engineering Daily podcast. The episode finally came out on December 18th, 2023, so here is your announcement to stop by and listen to it!
Cover image (and link) to the Bazel interview in Software Engineering Daily. If you don&amp;rsquo;t have time to listen to the whole 45 minutes, or if you want to get a sense of what you will get out of it, here is a recap of everything we touched on.</description></item><item><title>Strings, encodings, NULs and Bazel</title><link>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</link><pubDate>Sun, 03 Dec 2023 10:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</guid><description>Just yesterday, Twitter user @vkrajacic wrote:
Advice for new C programmers: &amp;ldquo;Avoid null-terminated strings; they&amp;rsquo;re outdated, inefficient and impractical.&amp;rdquo;
Create your own type with basic functions. It&amp;rsquo;s not that hard, and it goes a long way. One of the benefits of this approach, among others, is slicing without copying.
This suggestion has its merits and I understand where it is coming from: performance. You see: the traditional way to represent strings in C is to use NUL-terminated byte arrays.</description><enclosure url="https://jmmv.dev/images/2023-12-03-threads.jpg" length="588993" type="image/jpeg"/></item><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item><item><title>BazelCon 2023 et al. trip report</title><link>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</link><pubDate>Mon, 30 Oct 2023 03:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</guid><description>&lt;p>I&amp;rsquo;m exhausted. I just came back to Seattle from a 10-day trip in which I attended three different Bazel events: the Build Meetup in Reykjavik, the Bazel Community Day in Munich, and BazelCon 2023 in Munich too. Oh, and because I was on the other side of the world, I also paid a visit to my family in Spain.&lt;/p>
&lt;p>Attending these events has been incredibly useful and productive: I got exposure to many ideas and discussions that would just not happen online, I got to build connections with very interesting people and, of course, it has also been super fun too to reconnect with old coworkers and friends.&lt;/p>
&lt;p>This article contains the summary of the things I learned and the things I want to follow up on. These are just a bunch of cleaned-up notes which I took and are in the context of &lt;em>my&lt;/em> work with &lt;a href="https://bazel.build/">Bazel&lt;/a> at &lt;a href="https://www.snowflake.com/">Snowflake&lt;/a> and &lt;em>my&lt;/em> interests on build tools, so this is not endorsed by Snowflake.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-30-bazelcon.jpg" length="662944" type="image/jpeg"/></item><item><title>Build farm visualizations</title><link>https://jmmv.dev/2023/10/build-farm-visualizations.html</link><pubDate>Fri, 20 Oct 2023 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/build-farm-visualizations.html</guid><description>If you have followed our recent infrastructure posts, you know by now that we are actively migrating Snowflake&amp;rsquo;s build to Bazel. What we haven&amp;rsquo;t shared yet is that we have deployed our own Build Barn cluster to support Bazel&amp;rsquo;s remote execution features. We have chosen to run our own build farm service for resource governance and security purposes, but also because the behavior of this system impacts the developer experience so directly that we want to have full in-house control and knowledge of it.</description></item><item><title>Analyzing OOMs in IntelliJ with Bazel</title><link>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</link><pubDate>Sat, 07 Oct 2023 12:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</guid><description>&lt;p>A few months ago, we described how we fixed &lt;a href="https://jmmv.dev/2023/03/addressing-bazel-ooms.html">three different OOM scenarios&lt;/a> in our ongoing migration to the Bazel build system here at Snowflake. Things had been sailing along just fine since then&amp;hellip; but a new issue showed up recently: our &lt;a href="https://ij.bazel.build/">IntelliJ with Bazel (IjwB)&lt;/a> Java project started showing OOMs during its sync phase.&lt;/p>
&lt;p>The reason this issue surfaced now is because, as we continue our migration to Bazel, our IjwB project has grown in size. Months ago, our project only covered a Java binary, but now that we have migrated all of its unit and integration tests as well, the project covers them too. It is common for tests to be more expensive to build and run than the binary they validate&amp;mdash;tests depend on the binary&amp;rsquo;s dependencies &lt;em>plus&lt;/em> many other helper tools for testing&amp;mdash;and these caused the project to grow too big to fit in our development environments. Or did they?&lt;/p></description></item><item><title>Addressing Bazel OOMs</title><link>https://jmmv.dev/2023/03/addressing-bazel-ooms.html</link><pubDate>Thu, 16 Mar 2023 14:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/03/addressing-bazel-ooms.html</guid><description>&lt;p>Here at Snowflake, the Developer Productivity organization (DPE for short) is tackling some important problems we face as a company: namely, lengthening build times and complex development environments. A key strategy we are pursuing to resolve these is the migration of key build processes from CMake and Maven to &lt;a href="https://bazel.build/">Bazel&lt;/a>.&lt;/p>
&lt;p>We are still in the early stages of this migration and cannot yet share many details or a success story, but we can start explaining some of the issues we encounter as we work through this ambitious project.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-03-16-header.jpg" length="1420523" type="image/jpeg"/></item><item><title>Defining build time SLIs and SLOs</title><link>https://jmmv.dev/2021/03/build-time-slis-slos.html</link><pubDate>Fri, 12 Mar 2021 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2021/03/build-time-slis-slos.html</guid><description>Companies grow, and with them do the software projects that support them. It should be no surprise that larger programs require longer build times. And, if I had to guess, you have seen how those build times eventually grow to unbearable levels, reducing productivity and degrading quality. In this post, I examine how we can leverage the common techniques we use for production services&amp;mdash;namely SLIs and SLOs&amp;mdash;to keep build times on track.</description></item><item><title>How does Google keep build times low?</title><link>https://jmmv.dev/2021/02/google-monorepos-and-caching.html</link><pubDate>Fri, 26 Feb 2021 09:50:00 -0800</pubDate><guid>https://jmmv.dev/2021/02/google-monorepos-and-caching.html</guid><description>Monorepos are an interesting beast. If mended properly, they enable a level of uniformity and code quality that is hard to achieve otherwise. If left unattended, however, they become unmanageable monsters of tangled dependencies, slow builds, and frustrating developer experiences. Whether you have a good or bad experience directly depends on the level of engineering support behind the monorepo. Simply put, monorepos require dedicated teams and tools to run nicely. In this post, I will look at how almost-perfect caching plays a key role in keeping build times manageable under such an environment.</description></item><item><title>How does Google avoid clean builds?</title><link>https://jmmv.dev/2020/12/google-no-clean-builds.html</link><pubDate>Thu, 31 Dec 2020 09:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/google-no-clean-builds.html</guid><description>During my 11 years at Google, I can confidently count the number of times I had to do a &amp;ldquo;clean build&amp;rdquo; with one hand: their build system is so robust that incremental builds always work. Phrases like &amp;ldquo;clean everything and try building from scratch&amp;rdquo; are unheard of. So&amp;hellip; you can color me skeptical when someone says that incremental build problems are due to bugs in the build files and not due to a suboptimal build system. The answer lies in having a robust build system, and in this post I&amp;rsquo;ll examine the common causes behind incremental build breakages, what the build system can do to avoid them, and how Bazel accomplishes most of them.</description></item><item><title>The final boss: Bazel's own JNI code</title><link>https://jmmv.dev/2020/10/bazel-jni.html</link><pubDate>Fri, 09 Oct 2020 05:40:00 -0700</pubDate><guid>https://jmmv.dev/2020/10/bazel-jni.html</guid><description>As you might have read elsewhere, I&amp;rsquo;m leaving the Bazel team and Google in about a week. My plan for these last few weeks was to hand things off as cleanly as possible&amp;hellip; but I was also nerd-sniped by a bug that came my way a fortnight ago. Fixing it has been my self-inflicted punishment for leaving, and oh my, it has been painful. Very painful.
Let me tell you the story of this final boss.</description></item><item><title>Bazel output streaming, Ctrl+C, and test flakiness</title><link>https://jmmv.dev/2020/09/bazel-test-streaming-bug.html</link><pubDate>Fri, 18 Sep 2020 07:10:00 -0400</pubDate><guid>https://jmmv.dev/2020/09/bazel-test-streaming-bug.html</guid><description>About two weeks ago, I found a very interesting bug in Bazel&amp;rsquo;s test output streaming functionality while writing tests for a new feature related to Ctrl+C interrupts. I fixed the bug, wrote a test for it, and&amp;hellip; the test itself came back as flaky, which made me find another very subtle bug in the test that needed a one-line fix. This is the story of both.
Bazel has a feature known as test output streaming: by default, Bazel captures the outputs (stdout and stderr) of the tests it runs, saves those in local log files, and tells the user where they are when a test fails.</description></item><item><title>Bazel UI locking and file downloads</title><link>https://jmmv.dev/2020/09/bazel-ui-locking.html</link><pubDate>Tue, 01 Sep 2020 16:40:00 -0400</pubDate><guid>https://jmmv.dev/2020/09/bazel-ui-locking.html</guid><description>&lt;p>About a month ago, I was benchmarking the impact of a new Bazel feature and I noticed that a test build that should have taken only a few seconds took almost 10 minutes. My Internet connection was flaking out indeed, but something else didn&amp;rsquo;t seem right. So I looked and found that Bazel was doing network calls within a critical section, and these were the root cause behind the massive slowdown. But how did we get such an obvious no-no into the codebase? Read on to see how this happened and how gnarly it was to fix!&lt;/p></description></item><item><title>Shipping Bazel's new dynamic scheduler</title><link>https://jmmv.dev/2020/06/shipping-bazel-new-dynamic-scheduler.html</link><pubDate>Fri, 12 Jun 2020 16:00:00 -0400</pubDate><guid>https://jmmv.dev/2020/06/shipping-bazel-new-dynamic-scheduler.html</guid><description>Back in September 2019, I embarked into the task of rewriting Bazel&amp;rsquo;s dynamic scheduler to deal with slow and flaky networks. Initial testing had shown that dynamic builds might become slower, and it was all due to this feature having been designed for a different use case (in-office, high-speed network). We had to fix two different issues in the scheduler.
The first fix was making the downloads of the remote artifacts happen without holding the output lock.</description></item></channel></rss>