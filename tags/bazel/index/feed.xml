<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bazel on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/bazel/index.html</link><description>Recent content in Bazel on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&#150;2025 Julio Merino</copyright><lastBuildDate>Fri, 26 Sep 2025 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/bazel/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>You are holding BUILD files wrong</title><link>https://jmmv.dev/2025/09/you-are-holding-build-files-wrong.html</link><pubDate>Fri, 26 Sep 2025 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/you-are-holding-build-files-wrong.html</guid><description>&lt;p>I&amp;rsquo;ve heard it from people new to Bazel but also from people very familiar with the Bazel ecosystem: BUILD files must go away. And they must go away because they are redundant: they just repeat the dependency information that&amp;rsquo;s already encoded in the in-code import/use statements.&lt;/p>
&lt;p>Hearing this from newcomers to Bazel isn&amp;rsquo;t surprising: after all, most newcomers are used to build tools that provide zero facilities to express dependencies across the sources of your own project. Hearing it from old-timers, however, is disappointing because it misses the point of what BUILD files can truly offer.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-26-you-are-holding-build-files-wrong.jpg" length="87330" type="image/jpeg"/></item><item><title>Bazel and glibc versions</title><link>https://jmmv.dev/2025/09/glibc-versions-bazel.html</link><pubDate>Fri, 19 Sep 2025 00:08:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/glibc-versions-bazel.html</guid><description>&lt;p>Imagine this scenario: your team uses Bazel for fast, distributed C++ builds. A developer builds a change on their workstation, all tests pass, and the change is merged. The CI system picks it up, gets a cache hit from the developer&amp;rsquo;s build, and produces a release artifact. Everything looks green. But when you deploy to production, the service crashes with a mysterious error: &lt;code>version 'GLIBC_2.28' not found&lt;/code>. What went wrong?&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-19-glibc-versions-bazel-cover-image.jpg" length="182393" type="image/jpeg"/></item><item><title>Trusting builds with Bazel remote execution</title><link>https://jmmv.dev/2025/09/bazel-remote-execution.html</link><pubDate>Fri, 12 Sep 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/bazel-remote-execution.html</guid><description>&lt;p>The previous article on &lt;a href="https://jmmv.dev/2025/09/bazel-remote-caching.html">Bazel remote caching&lt;/a> concluded that using &lt;em>just&lt;/em> a remote cache for Bazel builds was suboptimal due to limitations in what can and cannot be cached for security reasons. The reason behind the restrictions was that it is impossible to safely reuse a cache across users. Or is it?&lt;/p>
&lt;p>In this article, we&amp;rsquo;ll see how leveraging remote execution in conjunction with a remote cache opens the door to safely sharing the cache across users. The reason is that remote execution provides a trusted execution environment for actions, and this opens the door to cross-user result sharing. Let&amp;rsquo;s see why and how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-12-bazel-remote-execution-cover-image.jpg" length="147776" type="image/jpeg"/></item><item><title>Understanding Bazel remote caching</title><link>https://jmmv.dev/2025/09/bazel-remote-caching.html</link><pubDate>Fri, 05 Sep 2025 08:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/09/bazel-remote-caching.html</guid><description>&lt;p>The previous article on &lt;a href="https://jmmv.dev/2025/07/bazel-action-determinism.html">Bazel action non-determinism&lt;/a> provided an introduction to actions: what they are, how they are defined, and how they act as the fundamental unit of execution in Bazel. What the article did not mention is that actions are &lt;em>also&lt;/em> the fundamental unit of caching during execution to avoid doing already-done work.&lt;/p>
&lt;p>In this second part of the series, I want to revisit the very basics of how Bazel runs actions and how remote caching (&lt;em>not&lt;/em> remote execution, because that&amp;rsquo;ll come later) works. The goal here is to introduce the &lt;strong>Action Cache (AC)&lt;/strong>, the &lt;strong>Content Addressable Storage (CAS)&lt;/strong>, how they play together, and then have some fun in describing the many ways in which it&amp;rsquo;s possible to poison such a cache in an accidental or malicious manner.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-09-05-bazel-remote-caching-cover-image.jpg" length="969844" type="image/jpeg"/></item><item><title>Bazel and action (non-) determinism</title><link>https://jmmv.dev/2025/07/bazel-action-determinism.html</link><pubDate>Mon, 21 Jul 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/07/bazel-action-determinism.html</guid><description>&lt;p>A key feature of Bazel is its ability to produce fast, reliable builds by caching the output of actions. This system, however, relies on a fundamental principle: build actions must be deterministic. For the most part, Bazel helps ensure that they are, but in the odd cases when they aren&amp;rsquo;t, builds can fail in subtle and frustrating ways, eroding trust in the build system.&lt;/p>
&lt;p>This article is the first in a series on Bazel&amp;rsquo;s execution model. Having explained these concepts many times, I want to provide a detailed reference before explaining a cool solution to a problem I recently developed at work. We will start with action non-determinism, then cover remote caching and execution, and finally, explore the security implications of these features.&lt;/p>
&lt;p>This first article explains what non-determinism is, how it manifests, and how you can diagnose and prevent it in your own builds. Let&amp;rsquo;s begin.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-07-21-bazel-action-determinism-cover.jpg" length="520669" type="image/jpeg"/></item><item><title>Whatever happened to sandboxfs?</title><link>https://jmmv.dev/2025/06/whatever-happened-to-sandboxfs.html</link><pubDate>Wed, 11 Jun 2025 10:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/06/whatever-happened-to-sandboxfs.html</guid><description>&lt;p>Back in 2017&amp;ndash;2020, while I was on the Blaze team at Google, I took on a 20% project that turned into a bit of an obsession: &lt;a href="https://github.com/bazelbuild/sandboxfs">sandboxfs&lt;/a>. Born out of my work supporting iOS development, it was my attempt to solve a persistent pain point that frustrated both internal teams and external users alike: Bazel&amp;rsquo;s &lt;a href="https://github.com/bazelbuild/bazel/issues/8230">poor sandboxing performance on macOS&lt;/a>.&lt;/p>
&lt;p>sandboxfs was a user-space file system designed to efficiently create virtual file hierarchies backed by real files&amp;mdash;a faster alternative to the &amp;ldquo;symlink forests&amp;rdquo; that Bazel uses to prepare per-action sandboxes. The idea was simple: if we could lower sandbox creation overhead, we could make Bazel&amp;rsquo;s sandboxing actually usable on macOS.&lt;/p>
&lt;p>Unfortunately, things didn&amp;rsquo;t play out as I dreamed. Today, sandboxfs is effectively abandoned, and macOS sandboxing performance remains an unsolved problem. In this post, I&amp;rsquo;ll walk you through why I built sandboxfs, what worked, what didn&amp;rsquo;t, and why&amp;mdash;despite its failure&amp;mdash;I still think the core idea holds promise.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-06-11-sandboxfs-cover-concept.png" length="7119929" type="image/jpeg"/></item><item><title>The next generation of Bazel builds</title><link>https://jmmv.dev/2025/03/bazel-next-generation.html</link><pubDate>Mon, 24 Mar 2025 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/03/bazel-next-generation.html</guid><description>&lt;p>Today marks the 10th anniversary of &lt;a href="https://blog.engflow.com/2024/10/01/birth-of-the-bazel/">Bazel&amp;rsquo;s public announcement&lt;/a> so this is the perfect moment to reflect on what the next generation of build systems in the Bazel ecosystem may look like.&lt;/p>
&lt;p>I write this with the inspiration that comes from attending &lt;a href="https://www.linkedin.com/feed/update/urn:li:activity:7295871444343734272/">the first ever conference on Buildbarn&lt;/a>, one of the many remote execution systems for Bazel. In the conference, Ed Schouten, the creator of &lt;a href="https://github.com/buildbarn">Buildbarn&lt;/a>, presented Bonanza: a skunkworks reimagination of Bazel for truly large builds.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-03-24-laptop-vs-datacenter.jpg" length="525451" type="image/jpeg"/></item><item><title>Bazel at Snowflake two years in</title><link>https://jmmv.dev/2025/03/bazel-at-snowflake-two-years-in.html</link><pubDate>Fri, 14 Mar 2025 18:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/03/bazel-at-snowflake-two-years-in.html</guid><description>&lt;p>Two and a half years ago, I &lt;a href="https://jmmv.dev/2022/10/bye-microsoft-hi-snowflake.html">joined Snowflake&lt;/a> to help their mission of migrating to Bazel. I spent the first year of this period as an Individual Contributor (IC) diving deep into the migration tasks, and then I took over the Tech Lead (TL) role of the team to see the project through completion.&lt;/p>
&lt;p>This week, we publicly announced that we completed our migration to Bazel for the largest part of our codebase and we provided details on our journey. I did not publish that article here for obvious reasons, so&amp;hellip; today&amp;rsquo;s entry is going to be a light one: all I want to do is point you at our announcement as well as the various &lt;em>other&lt;/em> related articles that came before it.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-03-14-bazel-at-snowflake-cover.jpg" length="792369" type="image/jpeg"/></item><item><title>BazelCon 2024 recap</title><link>https://jmmv.dev/2024/10/bazelcon-2024-recap.html</link><pubDate>Tue, 22 Oct 2024 08:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2024/10/bazelcon-2024-recap.html</guid><description>Just like that, BazelCon 2024 came and went. So&amp;hellip; it&amp;rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is A LOT to cover, but everything is here in just one article!</description><enclosure url="https://jmmv.dev/images/2024-10-22-bazelcon.jpg" length="362903" type="image/jpeg"/></item><item><title>Bazel interview at Software Engineering Daily</title><link>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</link><pubDate>Thu, 21 Dec 2023 09:50:00 +0100</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html</guid><description>&lt;p>Just a bit over 2 months ago, on October 5th, 2023, Jordi Mon Companys interviewed me about Bazel for an episode in the &lt;a href="https://softwareengineeringdaily.com/">Software Engineering Daily&lt;/a> podcast. The episode finally came out on December 18th, 2023, so here is your announcement to stop by and listen to it!&lt;/p>
&lt;figure>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
&lt;img src="https://jmmv.dev/images/2023-12-21-bazel-interview-cover.jpg" class="with-border" />
&lt;/a>
&lt;figcaption>
&lt;a href="https://softwareengineeringdaily.com/2023/12/18/bonus-episode-bazel-with-julio-merino/" target="_blank">
Cover image (and link) to the Bazel interview in Software Engineering Daily.
&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;p>If you don&amp;rsquo;t have time to listen to the whole 45 minutes, or if you want to get a sense of what you will get out of it, here is a recap of everything we touched on. Every paragraph is annotated with the rough time where the discussion starts so that you can jump right in to whatever interests you the most.&lt;/p></description></item><item><title>Strings, encodings, NULs and Bazel</title><link>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</link><pubDate>Sun, 03 Dec 2023 10:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/12/strings-encodings-nuls-and-bazel.html</guid><description>&lt;p>Just yesterday, &lt;a href="https://twitter.com/vkrajacic/status/1730891609191981305">Twitter user @vkrajacic wrote&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Advice for new C programmers: &amp;ldquo;Avoid null-terminated strings; they&amp;rsquo;re outdated, inefficient and impractical.&amp;rdquo;&lt;/p>
&lt;p>Create your own type with basic functions. It&amp;rsquo;s not that hard, and it goes a long way. One of the benefits of this approach, among others, is slicing without copying.&lt;/p>&lt;/blockquote>
&lt;p>This suggestion has its merits and I understand where it is coming from: &lt;em>performance&lt;/em>. You see: the traditional way to represent strings in C is to use &lt;a href="https://en.wikipedia.org/wiki/Null_character">NUL-terminated byte arrays&lt;/a>. Yet&amp;hellip; this has deemed to be &lt;a href="https://queue.acm.org/detail.cfm?id=2010365">the most expensive one-byte mistake&lt;/a> because of the adverse performance implications that this carries. (NUL, &lt;em>not&lt;/em> NULL, is the better name for the &lt;code>\0&lt;/code> byte by the way.)&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-12-03-threads.jpg" length="588993" type="image/jpeg"/></item><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item><item><title>BazelCon 2023 et al. trip report</title><link>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</link><pubDate>Mon, 30 Oct 2023 03:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/10/bazelcon-2023-et-al-trip-report.html</guid><description>&lt;p>I&amp;rsquo;m exhausted. I just came back to Seattle from a 10-day trip in which I attended three different Bazel events: the Build Meetup in Reykjavik, the Bazel Community Day in Munich, and BazelCon 2023 in Munich too. Oh, and because I was on the other side of the world, I also paid a visit to my family in Spain.&lt;/p>
&lt;p>Attending these events has been incredibly useful and productive: I got exposure to many ideas and discussions that would just not happen online, I got to build connections with very interesting people and, of course, it has also been super fun too to reconnect with old coworkers and friends.&lt;/p>
&lt;p>This article contains the summary of the things I learned and the things I want to follow up on. These are just a bunch of cleaned-up notes which I took and are in the context of &lt;em>my&lt;/em> work with &lt;a href="https://bazel.build/">Bazel&lt;/a> at &lt;a href="https://www.snowflake.com/">Snowflake&lt;/a> and &lt;em>my&lt;/em> interests on build tools, so this is not endorsed by Snowflake.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-30-bazelcon.jpg" length="662944" type="image/jpeg"/></item><item><title>Build farm visualizations</title><link>https://jmmv.dev/2023/10/build-farm-visualizations.html</link><pubDate>Fri, 20 Oct 2023 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/10/build-farm-visualizations.html</guid><description>&lt;p>If you have followed our &lt;a href="https://medium.com/snowflake/tagged/infrastructure">recent infrastructure posts&lt;/a>, you know by now that we are actively migrating Snowflake&amp;rsquo;s build to Bazel. What we haven&amp;rsquo;t shared yet is that we have deployed our own &lt;a href="https://github.com/buildbarn">Build Barn&lt;/a> cluster to support Bazel&amp;rsquo;s remote execution features. We have chosen to run our own build farm service for resource governance and security purposes, but also because the behavior of this system impacts the developer experience so directly that we want to have full in-house control and knowledge of it.&lt;/p></description></item><item><title>Analyzing OOMs in IntelliJ with Bazel</title><link>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</link><pubDate>Sat, 07 Oct 2023 12:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/10/analyzing-ooms-in-intellij-with-bazel.html</guid><description>&lt;p>A few months ago, we described how we fixed &lt;a href="https://jmmv.dev/2023/03/addressing-bazel-ooms.html">three different OOM scenarios&lt;/a> in our ongoing migration to the Bazel build system here at Snowflake. Things had been sailing along just fine since then&amp;hellip; but a new issue showed up recently: our &lt;a href="https://ij.bazel.build/">IntelliJ with Bazel (IjwB)&lt;/a> Java project started showing OOMs during its sync phase.&lt;/p>
&lt;p>The reason this issue surfaced now is because, as we continue our migration to Bazel, our IjwB project has grown in size. Months ago, our project only covered a Java binary, but now that we have migrated all of its unit and integration tests as well, the project covers them too. It is common for tests to be more expensive to build and run than the binary they validate&amp;mdash;tests depend on the binary&amp;rsquo;s dependencies &lt;em>plus&lt;/em> many other helper tools for testing&amp;mdash;and these caused the project to grow too big to fit in our development environments. Or did they?&lt;/p></description></item></channel></rss>