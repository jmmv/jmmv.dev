<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Readability on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/readability/index.html</link><description>Recent content in Readability on Julio Merino (jmmv.dev)</description><generator>Hugo</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><lastBuildDate>Fri, 06 Oct 2023 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/readability/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>5 ways to instantiate Rust structs in tests</title><link>https://jmmv.dev/2023/10/rust-test-structs.html</link><pubDate>Fri, 06 Oct 2023 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/10/rust-test-structs.html</guid><description>&lt;p>I&amp;rsquo;m a big fan of static typing and I&amp;rsquo;ve found that using narrow types for each entity in the object model of my programs reduces errors. Rust is particularly well-suited at this task: its lack of implicit type conversions eliminates surprises, and its ownership semantics allow type transformations with zero cost.&lt;/p>
&lt;p>Unfortunately, (ab)using narrow types in an app&amp;rsquo;s domain is &lt;em>really&lt;/em> annoying when writing tests. While non-test code rarely instantiates new objects&amp;mdash;in the case of a REST service, this would only happen at the service&amp;rsquo;s boundaries&amp;mdash;tests instantiate objects infinitely more times than non-test code. Code patterns that may seem reasonable in non-test code can become unbearable in tests.&lt;/p>
&lt;p>In this post, I want to look into the various ways in which you can instantiate strongly-typed objects. For each, I show examples and describe their pros and cons. And yes, as a matter of fact, I have tried them all before&amp;hellip; and I can&amp;rsquo;t yet make my mind as to which one is best.&lt;/p></description></item><item><title>Tips on formatting Markdown lists</title><link>https://jmmv.dev/2022/07/markdown-lists.html</link><pubDate>Thu, 07 Jul 2022 07:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2022/07/markdown-lists.html</guid><description>Lists are a very common construct in technical documents, which is the kind of material I most often write and &lt;em>review&lt;/em>. But getting complex lists to look right is tricky, especially when authoring them in Markdown. Let&amp;rsquo;s look at a couple of tips to ensure that any list you write will always be correctly formatted with ease.</description></item><item><title>Constructors and evil initializers in C++</title><link>https://jmmv.dev/2021/11/cpp-ctors-vs-init.html</link><pubDate>Wed, 24 Nov 2021 09:15:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2021/11/cpp-ctors-vs-init.html</guid><description>One of the three key tenets of Object Oriented Programming (OOP) is encapsulation: objects contain a state that, when observed from the outside, is always internally-consistent. Unfortunately, C++ codebases where exceptions are forbidden often violate this rule when they separate object initialization from construction. Let&amp;rsquo;s see why that&amp;rsquo;s a problem and how to address it.</description></item><item><title>Definitions and initializations in C++</title><link>https://jmmv.dev/2021/07/cpp-definition-initialization.html</link><pubDate>Mon, 12 Jul 2021 06:20:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2021/07/cpp-definition-initialization.html</guid><description>When reviewing an incoming C++ PR last week, I left a comment along the lines: &amp;ldquo;merge local variable declaration with its initialization&amp;rdquo;. But why? Is this just a stylistic issue or is there something deeper to warrant making the change? Let&amp;rsquo;s look at stack frames, C, and then C++ to answer these questions.</description></item><item><title>Encode your assumptions</title><link>https://jmmv.dev/2019/02/encode-your-assumptions.html</link><pubDate>Thu, 07 Feb 2019 07:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2019/02/encode-your-assumptions.html</guid><description>&lt;p>The point of this post is simple and I&amp;rsquo;ll spoil it from the get go: &lt;strong>every time you make an assumption in a piece of code, make such assumption explicit in the form of an assertion or error check&lt;/strong>. If you cannot do that (are you sure?), then write a detailed comment.&lt;/p>
&lt;p>In fact, I&amp;rsquo;m exceedingly convinced that the amount of assertion-like checks in a piece of code is a good indicator of the programmer&amp;rsquo;s expertise.&lt;/p></description></item><item><title>Shell readability: local</title><link>https://jmmv.dev/2018/03/shell-readability-local.html</link><pubDate>Tue, 13 Mar 2018 11:43:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/03/shell-readability-local.html</guid><description>&lt;p>As most programming languages with support for functions, the shell offers locally-scoped variables. Unfortunately, &lt;em>local variables are not the default&lt;/em>. &lt;strong>You must explicitly declare variables as &lt;code>local&lt;/code>&lt;/strong> and you should &lt;strong>be very strict about doing this&lt;/strong> to prevent subtle but hard-to-diagnose bugs.&lt;/p>
&lt;p>That&amp;rsquo;s it! What else is there to say about this trivial keyword? As it turns out, more than you might think.&lt;/p></description></item><item><title>Shell readability: strict mode</title><link>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</link><pubDate>Fri, 09 Mar 2018 09:40:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</guid><description>&lt;p>Some programming languages have a feature known as &lt;strong>strict mode&lt;/strong>: a setting that makes the language interpreter disallow certain obviously-broken code that would otherwise work. The simplest examples are JavaScript and Perl but, as it turns out, the shell &lt;em>also&lt;/em> has something akin to this feature. The &amp;ldquo;strict mode&amp;rdquo; &lt;em>name&lt;/em>, however, is unofficial, so you won&amp;rsquo;t find many references to it online.&lt;/p>
&lt;p>You can enable the shell&amp;rsquo;s strict mode by doing one of the following:&lt;/p></description></item><item><title>Shell readability: function parameters</title><link>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</link><pubDate>Fri, 02 Mar 2018 06:35:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</guid><description>&lt;p>The shell supports defining functions, which, &lt;a href="https://jmmv.dev/2018/02/shell-readability-main.html">as we learned in the previous post&lt;/a>, you should embrace and use. Unfortunately, they are fairly primitive and their use can, paradoxically, introduce other readability problems.&lt;/p>
&lt;p>One specific problem is that &lt;strong>function parameters are numbered, not named&lt;/strong>, so the risk of cryptic code is high. Let&amp;rsquo;s see why this is a problem.&lt;/p></description></item><item><title>Shell readability: main</title><link>https://jmmv.dev/2018/02/shell-readability-main.html</link><pubDate>Mon, 26 Feb 2018 05:15:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/02/shell-readability-main.html</guid><description>&lt;p>Our team develops &lt;a href="http://bazel.build">Bazel&lt;/a>, a Java-based tool. We do have, however, a significant amount of shell scripting. The percentage is small at only 3.6% of our codebase&amp;hellip; but given the size of our project, that&amp;rsquo;s about 130,000 lines—a lot, really.&lt;/p>
&lt;p>Pretty much nobody likes writing these integration tests in shell. Leaving aside that our infrastructure is clunky, the real problem is that the team at large is not familiar with writing shell per se. Few people are these days actually.&lt;/p></description></item><item><title>Readability: Series wrap-up</title><link>https://jmmv.dev/2013/08/readability-series-wrap-up.html</link><pubDate>Thu, 01 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/readability-series-wrap-up.html</guid><description>&lt;p>That&amp;rsquo;s it! After two months worth of posts, it is time to part with the the readability series. We have covered a lot of ground with these 14 posts: from mundane things such as blank lines and spelling to deeper topics involving dictionaries and global state.&lt;/p>
&lt;p>Before some parting words, here comes the full list of posts on this series. This is your time to catch up with any posts you have not yet read!&lt;/p></description></item><item><title>Readability: Narrow try/catch blocks</title><link>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</link><pubDate>Mon, 29 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</guid><description>&lt;p>&lt;code>Try&lt;/code>/&lt;code>catch&lt;/code> blocks (or &lt;code>try&lt;/code>/&lt;code>except&lt;/code>, or whatever they happen to be named in your favorite language) are the mechanism by which you capture exceptions raised by a chunk of code in a controlled manner. Within that chunk of code, it does not matter which line throws the exception: any exception specified in the &lt;code>catch&lt;/code> statement will be captured, and it is &amp;ldquo;impossible&amp;rdquo; to know at that point where it originated.&lt;/p>
&lt;p>Consider this piece of code:&lt;/p></description></item><item><title>Readability: Don't modify variables</title><link>https://jmmv.dev/2013/07/readability-don-modify-variables.html</link><pubDate>Thu, 25 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-don-modify-variables.html</guid><description>&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment">Single assignment&lt;/a> says that a variable should only be assigned a value once; i.e. a variable should only be &lt;em>initialized&lt;/em> and never modified later. This could be said to be a property of functional programming—never mind that it&amp;rsquo;s used in compiler optimization a damn lot—so it may sound a bit out of scope in a readability post. Not really.&lt;/p>
&lt;p>When you &lt;em>force yourself to avoid modifying already-defined variables&lt;/em>, you will need to find other ways to express your intent. To do so, in general: you will use a high-order construction instead of a loop; you will end up having to define intermediate variables, each with its own descriptive name; or you will move pieces of the code to an auxiliary function, also with a descriptive name.&lt;/p></description></item><item><title>Readability: Conditionals as functions</title><link>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</link><pubDate>Mon, 22 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</guid><description>&lt;p>Conceptually, there are two kinds of conditional statements: ones that compute—or affect the computation of—a value and others that guard the execution of optional code (e.g. functionality enabled by a command-line flag). In this article we will focus on the former kind.&lt;/p>
&lt;p>One way to think of those conditionals is as if they were to represent functions, just written inline. In other words: while it should be possible to move the conditional statement to a separate function, it has not been done because the algorithm is simple enough to not warrant it.&lt;/p></description></item><item><title>Readability: Explicitly state complementary conditions</title><link>https://jmmv.dev/2013/07/readability-explicitly-state.html</link><pubDate>Thu, 18 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-explicitly-state.html</guid><description>&lt;p>In the most basic form, a conditional has two branches and the conditional expression inspects a single variable on entry. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">balance&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BLACK&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">RED&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this little code snippet, the condition &lt;code>balance &amp;gt;= 0&lt;/code> only depends on one variable, and the two branches of the conditional cover all possible values of the input variable. I.e. the first branch covers all cases where the balance is positive or zero, and the second branch covers all cases where the balance is negative. The balance variable cannot have a value not covered by these cases. Easy.&lt;/p></description></item><item><title>Readability: Do not abuse classes as global state</title><link>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</link><pubDate>Mon, 08 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</guid><description>&lt;p>You know that passing state around different functions by using global variables is bad: it results in spaghetti code, it introduces side-effects to your functions and, well, is just bad practice. Then: don&amp;rsquo;t make the same mistake when using classes.&lt;/p>
&lt;p>The form this manifests in code is by having a particular class method (not necessarily the constructor!) initializing a member field and later having other unrelated methods querying the attribute &amp;ldquo;out of the blue&amp;rdquo;.&lt;/p></description></item></channel></rss>