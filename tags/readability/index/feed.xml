<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>readability on Julio Merino (jmmv.dev)</title>
    <link>https://jmmv.dev/tags/readability/index/</link>
    <description>Recent content in readability on Julio Merino (jmmv.dev)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Jul 2021 06:20:00 -0700</lastBuildDate>
    
	<atom:link href="https://jmmv.dev/tags/readability/index/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Definitions and initializations in C&#43;&#43;</title>
      <link>https://jmmv.dev/2021/07/cpp-definition-initialization.html</link>
      <pubDate>Mon, 12 Jul 2021 06:20:00 -0700</pubDate>
      
      <guid>https://jmmv.dev/2021/07/cpp-definition-initialization.html</guid>
      <description>When reviewing an incoming C++ PR last week, I left a comment along the lines: &amp;ldquo;merge local variable declaration with its initialization&amp;rdquo;. But why? Is this just a stylistic issue or is there something deeper to warrant making the change? Let&amp;rsquo;s look at stack frames, C, and then C++ to answer these questions.</description>
    </item>
    
    <item>
      <title>Encode your assumptions</title>
      <link>https://jmmv.dev/2019/02/encode-your-assumptions.html</link>
      <pubDate>Thu, 07 Feb 2019 07:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2019/02/encode-your-assumptions.html</guid>
      <description>The point of this post is simple and I&amp;rsquo;ll spoil it from the get go: every time you make an assumption in a piece of code, make such assumption explicit in the form of an assertion or error check. If you cannot do that (are you sure?), then write a detailed comment.
In fact, I&amp;rsquo;m exceedingly convinced that the amount of assertion-like checks in a piece of code is a good indicator of the programmer&amp;rsquo;s expertise.</description>
    </item>
    
    <item>
      <title>Shell readability: local</title>
      <link>https://jmmv.dev/2018/03/shell-readability-local.html</link>
      <pubDate>Tue, 13 Mar 2018 11:43:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2018/03/shell-readability-local.html</guid>
      <description>&lt;p&gt;As most programming languages with support for functions, the shell offers locally-scoped variables. Unfortunately, &lt;em&gt;local variables are not the default&lt;/em&gt;. &lt;strong&gt;You must explicitly declare variables as &lt;code&gt;local&lt;/code&gt;&lt;/strong&gt; and you should &lt;strong&gt;be very strict about doing this&lt;/strong&gt; to prevent subtle but hard-to-diagnose bugs.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s it! What else is there to say about this trivial keyword? As it turns out, more than you might think.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell readability: strict mode</title>
      <link>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</link>
      <pubDate>Fri, 09 Mar 2018 09:40:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</guid>
      <description>Some programming languages have a feature known as strict mode: a setting that makes the language interpreter disallow certain obviously-broken code that would otherwise work. The simplest examples are JavaScript and Perl but, as it turns out, the shell also has something akin to this feature. The &amp;ldquo;strict mode&amp;rdquo; name, however, is unofficial, so you won&amp;rsquo;t find many references to it online.
You can enable the shell&amp;rsquo;s strict mode by doing one of the following:</description>
    </item>
    
    <item>
      <title>Shell readability: function parameters</title>
      <link>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</link>
      <pubDate>Fri, 02 Mar 2018 06:35:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</guid>
      <description>&lt;p&gt;The shell supports defining functions, which, &lt;a href=&#34;https://jmmv.dev/2018/02/shell-readability-main.html&#34;&gt;as we learned in the previous post&lt;/a&gt;, you should embrace and use. Unfortunately, they are fairly primitive and their use can, paradoxically, introduce other readability problems.&lt;/p&gt;
&lt;p&gt;One specific problem is that &lt;strong&gt;function parameters are numbered, not named&lt;/strong&gt;, so the risk of cryptic code is high. Let&amp;rsquo;s see why this is a problem.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shell readability: main</title>
      <link>https://jmmv.dev/2018/02/shell-readability-main.html</link>
      <pubDate>Mon, 26 Feb 2018 05:15:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2018/02/shell-readability-main.html</guid>
      <description>Our team develops Bazel, a Java-based tool. We do have, however, a significant amount of shell scripting. The percentage is small at only 3.6% of our codebase&amp;hellip; but given the size of our project, that&amp;rsquo;s about 130,000 lines—a lot, really.
Pretty much nobody likes writing these integration tests in shell. Leaving aside that our infrastructure is clunky, the real problem is that the team at large is not familiar with writing shell per se.</description>
    </item>
    
    <item>
      <title>Readability: Series wrap-up</title>
      <link>https://jmmv.dev/2013/08/readability-series-wrap-up.html</link>
      <pubDate>Thu, 01 Aug 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/08/readability-series-wrap-up.html</guid>
      <description>That&amp;rsquo;s it! After two months worth of posts, it is time to part with the the readability series. We have covered a lot of ground with these 14 posts: from mundane things such as blank lines and spelling to deeper topics involving dictionaries and global state.
Before some parting words, here comes the full list of posts on this series. This is your time to catch up with any posts you have not yet read!</description>
    </item>
    
    <item>
      <title>Readability: Narrow try/catch blocks</title>
      <link>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</link>
      <pubDate>Mon, 29 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</guid>
      <description>Try/catch blocks (or try/except, or whatever they happen to be named in your favorite language) are the mechanism by which you capture exceptions raised by a chunk of code in a controlled manner. Within that chunk of code, it does not matter which line throws the exception: any exception specified in the catch statement will be captured, and it is &amp;ldquo;impossible&amp;rdquo; to know at that point where it originated.
Consider this piece of code:</description>
    </item>
    
    <item>
      <title>Readability: Don&#39;t modify variables</title>
      <link>https://jmmv.dev/2013/07/readability-don-modify-variables.html</link>
      <pubDate>Thu, 25 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-don-modify-variables.html</guid>
      <description>Single assignment says that a variable should only be assigned a value once; i.e. a variable should only be initialized and never modified later. This could be said to be a property of functional programming—never mind that it&amp;rsquo;s used in compiler optimization a damn lot—so it may sound a bit out of scope in a readability post. Not really.
When you force yourself to avoid modifying already-defined variables, you will need to find other ways to express your intent.</description>
    </item>
    
    <item>
      <title>Readability: Conditionals as functions</title>
      <link>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</link>
      <pubDate>Mon, 22 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</guid>
      <description>Conceptually, there are two kinds of conditional statements: ones that compute—or affect the computation of—a value and others that guard the execution of optional code (e.g. functionality enabled by a command-line flag). In this article we will focus on the former kind.
One way to think of those conditionals is as if they were to represent functions, just written inline. In other words: while it should be possible to move the conditional statement to a separate function, it has not been done because the algorithm is simple enough to not warrant it.</description>
    </item>
    
    <item>
      <title>Readability: Explicitly state complementary conditions</title>
      <link>https://jmmv.dev/2013/07/readability-explicitly-state.html</link>
      <pubDate>Thu, 18 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-explicitly-state.html</guid>
      <description>In the most basic form, a conditional has two branches and the conditional expression inspects a single variable on entry. For example:
if balance &amp;gt;= 0: color = BLACK else: color = RED In this little code snippet, the condition balance &amp;gt;= 0 only depends on one variable, and the two branches of the conditional cover all possible values of the input variable. I.e. the first branch covers all cases where the balance is positive or zero, and the second branch covers all cases where the balance is negative.</description>
    </item>
    
    <item>
      <title>Readability: Do not abuse classes as global state</title>
      <link>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</link>
      <pubDate>Mon, 08 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</guid>
      <description>You know that passing state around different functions by using global variables is bad: it results in spaghetti code, it introduces side-effects to your functions and, well, is just bad practice. Then: don&amp;rsquo;t make the same mistake when using classes.
The form this manifests in code is by having a particular class method (not necessarily the constructor!) initializing a member field and later having other unrelated methods querying the attribute &amp;ldquo;out of the blue&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Readability: Dictionaries are not data types</title>
      <link>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</link>
      <pubDate>Thu, 04 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</guid>
      <description>Yes: a dictionary is a data type. No: a dictionary is not a way to implement abstract data types; doing so is lazy programming and is asking for trouble later on.
What do I mean by this? In Python and other similar dynamic languages, dictionaries are a mapping of keys to values that have no typing restrictions: the dictionary is heterogeneous, and a single dictionary can contain elements of different types both as its keys and its values.</description>
    </item>
    
    <item>
      <title>Readability: Abuse assertions</title>
      <link>https://jmmv.dev/2013/07/readability-abuse-assertions.html</link>
      <pubDate>Mon, 01 Jul 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/07/readability-abuse-assertions.html</guid>
      <description>Assertions are statements to ensure that a particular condition or state holds true at a certain point in the execution of a program. These checks are usually only performed in debug builds, which means that you must ensure that the expressions in the assertions are side-effect free.
Because assertions are only validated in debug builds, you can abuse them to make your code more readable without impacting performance and without having to write a comment.</description>
    </item>
    
    <item>
      <title>Readability: Avoid comments</title>
      <link>https://jmmv.dev/2013/06/readability-avoid-comments.html</link>
      <pubDate>Thu, 27 Jun 2013 12:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2013/06/readability-avoid-comments.html</guid>
      <description>One of the best things you can do to improve the readability of your code is to avoid comments. &amp;ldquo;Uh, what?&amp;quot;—I hear you say—&amp;ldquo;That goes against all good coding guidelines, which state to heavily comment your code!&amp;rdquo;
Right. Except that the real goal is to have valuable comments only, and doing so is a (very) complex matter. The code should document itself at all times, and be crystal-clear at doing so.</description>
    </item>
    
  </channel>
</rss>