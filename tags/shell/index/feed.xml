<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>shell on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/shell/index/</link><description>Recent content in shell on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 04 Nov 2023 07:50:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/shell/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item><item><title>Unit-testing shell scripts and tools with shtk</title><link>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</link><pubDate>Wed, 11 Oct 2023 08:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</guid><description>&lt;p>While working on this static blog a few days ago, I made a change to its templates that warranted an automated test. I could have written a trivial shell script to do it, but instead I reached out for shtk&amp;rsquo;s unit-testing module. I &lt;a href="https://twitter.com/jmmv/status/1710309896670081083">tweeted about it&lt;/a> right away to just say that you can, in fact, write tests in shell because lots of developers are skeptical about any script longer than 10 lines of code.&lt;/p>
&lt;p>Interestingly, this reply came through: a pointer to a contemporary, under-development library for writing tests in Bash. Which made me think: &amp;ldquo;Hey, I had already done that years ago&amp;hellip; but nobody knows about it. Gotta fix that with a blog post!&amp;rdquo; But first, I had to bring shtk back from its ashes because I had not touched it for more than 6 years and it wasn&amp;rsquo;t read for show and tell. So I did something that I wanted to do back in the day but never did: I put together &lt;a href="https://shtk.jmmv.dev/">a website for shtk&lt;/a> to host its &lt;a href="https://shtk.jmmv.dev/docs.html">reference manual&lt;/a> and I fixed a few obvious rough edges.&lt;/p>
&lt;p>With those tweaks out of the way, we come to this article. In here, I want to show you how writing decent tests in shell is entirely possible and how shtk&amp;rsquo;s testing platform provides unique features to do integration testing of CLI apps written in any language.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-11-shell-hammer-wrench.jpg" length="398237" type="image/jpeg"/></item><item><title>Useless use of GNU</title><link>https://jmmv.dev/2021/08/useless-use-of-gnu.html</link><pubDate>Wed, 25 Aug 2021 09:10:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/useless-use-of-gnu.html</guid><description>The GNU project is the source of the Unix userland utilities used on most Linux distributions. Its compatibility with standards and other Unix systems, or lack thereof, directly impacts the overall portability of any piece of software developed from GNU/Linux installations. Unfortunately, the GNU userland does not closely adhere to standards, and its widespread usage causes little incompatibilities to creep into any software created on GNU/Linux systems. Read on for why this is a problem and the pitfalls you will encounter.</description></item><item><title>test, [, and [[</title><link>https://jmmv.dev/2020/03/test-bracket.html</link><pubDate>Wed, 25 Mar 2020 05:55:00 +0500</pubDate><guid>https://jmmv.dev/2020/03/test-bracket.html</guid><description>A little essay on the amusement or horror that may bring to learn that both test and [ are binaries on your typical Unix system, and that [[ is subject to completely different rules.</description></item><item><title>The /bin/bash baggage of macOS</title><link>https://jmmv.dev/2019/11/macos-bash-baggage.html</link><pubDate>Wed, 20 Nov 2019 23:00:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/macos-bash-baggage.html</guid><description>As you may know, macOS ships with an ancient version of the Bash shell interpreter, 3.2.57. Let&amp;rsquo;s see why that is and why this is a problem.</description></item><item><title>Shell readability: local</title><link>https://jmmv.dev/2018/03/shell-readability-local.html</link><pubDate>Tue, 13 Mar 2018 11:43:00 -0400</pubDate><guid>https://jmmv.dev/2018/03/shell-readability-local.html</guid><description>&lt;p>As most programming languages with support for functions, the shell offers locally-scoped variables. Unfortunately, &lt;em>local variables are not the default&lt;/em>. &lt;strong>You must explicitly declare variables as &lt;code>local&lt;/code>&lt;/strong> and you should &lt;strong>be very strict about doing this&lt;/strong> to prevent subtle but hard-to-diagnose bugs.&lt;/p>
&lt;p>That&amp;rsquo;s it! What else is there to say about this trivial keyword? As it turns out, more than you might think.&lt;/p></description></item><item><title>Shell readability: strict mode</title><link>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</link><pubDate>Fri, 09 Mar 2018 09:40:00 -0400</pubDate><guid>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</guid><description>Some programming languages have a feature known as strict mode: a setting that makes the language interpreter disallow certain obviously-broken code that would otherwise work. The simplest examples are JavaScript and Perl but, as it turns out, the shell also has something akin to this feature. The &amp;ldquo;strict mode&amp;rdquo; name, however, is unofficial, so you won&amp;rsquo;t find many references to it online.
You can enable the shell&amp;rsquo;s strict mode by doing one of the following:</description></item><item><title>Shell readability: function parameters</title><link>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</link><pubDate>Fri, 02 Mar 2018 06:35:00 -0400</pubDate><guid>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</guid><description>&lt;p>The shell supports defining functions, which, &lt;a href="https://jmmv.dev/2018/02/shell-readability-main.html">as we learned in the previous post&lt;/a>, you should embrace and use. Unfortunately, they are fairly primitive and their use can, paradoxically, introduce other readability problems.&lt;/p>
&lt;p>One specific problem is that &lt;strong>function parameters are numbered, not named&lt;/strong>, so the risk of cryptic code is high. Let&amp;rsquo;s see why this is a problem.&lt;/p></description></item><item><title>Shell readability: main</title><link>https://jmmv.dev/2018/02/shell-readability-main.html</link><pubDate>Mon, 26 Feb 2018 05:15:00 -0400</pubDate><guid>https://jmmv.dev/2018/02/shell-readability-main.html</guid><description>Our team develops Bazel, a Java-based tool. We do have, however, a significant amount of shell scripting. The percentage is small at only 3.6% of our codebase&amp;hellip; but given the size of our project, that&amp;rsquo;s about 130,000 lines—a lot, really.
Pretty much nobody likes writing these integration tests in shell. Leaving aside that our infrastructure is clunky, the real problem is that the team at large is not familiar with writing shell per se.</description></item><item><title>Introducing shtk</title><link>https://jmmv.dev/2012/08/introducing-shtk.html</link><pubDate>Wed, 15 Aug 2012 17:39:00 -0400</pubDate><guid>https://jmmv.dev/2012/08/introducing-shtk.html</guid><description>Have you ever wanted to have a collection of ready-to-use modules for shell scripts? I have, particularly because I keep reimplementing the same functions over and over and over and over again whenever I write non-trivial shell scripts, and I'm tired of doing so.
That's why I have just abstracted all the common code in the aforementioned tools and put it into a new package called the "Shell Toolkit", or shtk for short.</description></item></channel></rss>