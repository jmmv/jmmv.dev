<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sre on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/sre/index/</link><description>Recent content in sre on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 26 Aug 2023 07:20:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/sre/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Costs exposed: On-call ticket handling</title><link>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</link><pubDate>Sat, 26 Aug 2023 07:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</guid><description>&lt;p>In the previous post, I proposed that certain engineering practices expose systemic costs and help with planning while other practices hide those same costs and disturb ongoing plans.&lt;/p>
&lt;p>The idea I&amp;rsquo;m trying to convey is hard to communicate in the abstract so, in that post, I used the differences between a monorepo and a multirepo setup as an example. Today, I&amp;rsquo;ll expore a different scenario to support the same idea. I&amp;rsquo;m going to talk about how certain ticket assignment practices during on-call operations can expose service support costs vs. how other practices hide them.&lt;/p>
&lt;p>Keep in mind that, just like in the previous post, I do not want to compare the general merits of one approach vs. the other. The &lt;em>only&lt;/em> thing I want to compare is whether one approach centralizes toil and allows management to quantify its cost vs. how another approach hides toil by smearing it over the whole team in hard-to-quantify ways. Whether management &lt;em>actually does something&lt;/em> to correct the situation once the costs are exposed is a different story.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-26-tickets-phone.jpg" length="539252" type="image/jpeg"/></item><item><title>Fair on-call scheduling</title><link>https://jmmv.dev/2022/01/oncall-scheduling.html</link><pubDate>Mon, 10 Jan 2022 06:40:00 -0800</pubDate><guid>https://jmmv.dev/2022/01/oncall-scheduling.html</guid><description>Being part of an on-call rotation is a requirement for many software job positions and fulfilling this requirement should not come with stress. One process that can cause friction is how a team schedules its on-call shifts. If the on-call scheduling process is haphazard, team members will end up with shifts over their personal plans, and they&amp;rsquo;ll be unhappy. But there are ways to prevent this, which is what this post is about.</description></item><item><title>Principal engineers should be on-call</title><link>https://jmmv.dev/2021/07/principal-engineers-oncall.html</link><pubDate>Wed, 14 Jul 2021 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2021/07/principal-engineers-oncall.html</guid><description>&lt;p>A recent tweet that caught my attention read: &amp;ldquo;principal engineers should be on-call&amp;rdquo;. Of course they should be! I&amp;rsquo;m &amp;ldquo;surprised&amp;rdquo; they aren&amp;rsquo;t everywhere, but I can imagine some reasons to justify their situation. Let&amp;rsquo;s change that in this thread. ðŸ§µ ðŸ‘‡&lt;/p></description></item><item><title>Running a healthy production service</title><link>https://jmmv.dev/2021/06/service-health.html</link><pubDate>Fri, 18 Jun 2021 06:25:00 -1000</pubDate><guid>https://jmmv.dev/2021/06/service-health.html</guid><description>&lt;p>In &lt;a href="https://jmmv.dev/2021/03/oncall-wellbeing.html">a previous thread&lt;/a>, I covered some techniques to approach on-call shifts and maintain &lt;em>your own&lt;/em> well-being. In this thread, I will touch upon the things you can do, as a team, to make &lt;em>your service&lt;/em> more sustainable. ðŸ§µ ðŸ‘‡&lt;/p></description></item><item><title>Tips on well-being while on-call</title><link>https://jmmv.dev/2021/03/oncall-wellbeing.html</link><pubDate>Wed, 10 Mar 2021 09:30:00 -0800</pubDate><guid>https://jmmv.dev/2021/03/oncall-wellbeing.html</guid><description>&lt;p>Last week, I was first-time on-call for a part of Azure Storage. My previous background as an SRE at Google helped me remain calm despite my inexperience. And as we have more first-time on-callers joining soon, I couldn&amp;rsquo;t resist writing some advice for them. Let&amp;rsquo;s start! ðŸ§µ&lt;/p></description></item><item><title>Seeding a file server quickly</title><link>https://jmmv.dev/2021/02/seeding-a-file-server.html</link><pubDate>Fri, 05 Feb 2021 10:00:00 -0800</pubDate><guid>https://jmmv.dev/2021/02/seeding-a-file-server.html</guid><description>Say you want to copy a large collection of files to a file server on your same network. What&amp;rsquo;s the fastest way to do this initial copy? Physically attaching the drive to the server? Maybe, but will the file systems be compatible? What about using the network? If so, which protocol? Read on for more details and how tar plus Netcat delivered the best results.</description></item><item><title>Ensuring system rewrites are truly necessary</title><link>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</link><pubDate>Fri, 24 Jan 2020 17:10:00 +0000</pubDate><guid>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</guid><description>You probably know that software rewrites, while very tempting, are expensive and can be the mistake that kills a project or a company. Yet they are routinely proposed as the solution to all problems. Is there anything you can do to minimize the risk? In this post, I propose that you actively improve the old system to ensure the new system cannot make progress in a haphazard way. This forces the new system to be designed in such a way that delivers breakthrough improvements and not just incremental improvements.</description></item><item><title>The fallacy of forbidding assertions</title><link>https://jmmv.dev/2018/07/forbidden-assertions-fallacy.html</link><pubDate>Tue, 24 Jul 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/07/forbidden-assertions-fallacy.html</guid><description>There are two ways to handle abnormal conditions in a program: errors and assertions.
Errors are a controlled mechanism by which the program propagates details about a faulty condition up the call chainâ€”be it with explicit error return statements or with exceptions. Errors must be used to validate all conditions that might be possible but aren&amp;rsquo;t valid given the context. Examples include: sanitizing any kind of input (as provided by the user or incoming from the network), and handling error codes from system calls or libraries.</description></item></channel></rss>