<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cxx on jmmv.dev</title>
    <link>https://jmmv.dev/tags/cxx/index/</link>
    <description>Recent content in cxx on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Feb 2015 17:40:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/cxx/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unused parameters in C and C&#43;&#43;</title>
      <link>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</link>
      <pubDate>Mon, 16 Feb 2015 17:40:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2015/02/unused-parameters-in-c-and-c.html</guid>
      <description>Today I would like to dive into the topic of unused parameters in C and C++: why they may happen and how to properly deal with themâ€”because smart compilers will warn you about their presence should you enable -Wunused-parameter or -Wextra, and even error out if you are brave enough to use -Werror.
Why may unused parameters appear? You would think that unused parameters should never exist: if the parameter is not necessary as an input, it should not be there in the first place!</description>
    </item>
    
    <item>
      <title>Header files: Avoid C&#43;&#43; &#39;using&#39; directives</title>
      <link>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</link>
      <pubDate>Thu, 05 Dec 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</guid>
      <description>Following up on the previous C++ post, here comes one more thing to consider when writing header files in this language.
using and using namespace The C++ using directive and its more generic using namespace counterpart, allow the programmer to bring a given symbol or all the symbols in a namespace, respectively, into the calling scope. This feature exists to simplify typing and, to some extent, to make the code more readable.</description>
    </item>
    
    <item>
      <title>Header files: C&#43;&#43; ipp files</title>
      <link>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</link>
      <pubDate>Mon, 02 Dec 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</guid>
      <description>Hoping you had a nice holiday break, it is now the time to resume our series on header files with a new topic covering the world of template definitions in C++.
 If you have ever used the Boost libraries, you may have noticed that aside from the regular hpp header files, they also provide a bunch of accompanying ipp files.
ipp files, in the general case, are used to provide the implementation for a template class defined in a corresponding hpp file.</description>
    </item>
    
    <item>
      <title>I don&#39;t really like C&#43;&#43;</title>
      <link>https://jmmv.dev/2012/09/i-dont-really-like-c.html</link>
      <pubDate>Tue, 04 Sep 2012 19:06:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/09/i-dont-really-like-c.html</guid>
      <description>Somebody recently tweeted me this message:
As a strong C++ dev and googler (hopefully with some #golang exposure), what&#39;s your opinion on @rob_pike post? (goo.gl/xlMi4)The answer deserves much more than my original reply included, so here it goes.
First of all, I found Rob&#39;s article quite interesting. Basically, the authors of Go never expected Go to be more widely adopted by Python users than C++ users. In fact, their original goal was to create a replacement for C++ as a systems programming language.</description>
    </item>
    
    <item>
      <title>Exposing a configuration tree through Lua</title>
      <link>https://jmmv.dev/2012/06/exposing-configuration-tree-through-lua.html</link>
      <pubDate>Sat, 02 Jun 2012 20:47:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/06/exposing-configuration-tree-through-lua.html</guid>
      <description>In the previous post, I discussed the&amp;nbsp;type-safe tree data structure&amp;nbsp;that is now in the Kyua codebase, aimed at representing the configuration of the program. In this post, we&#39;ll see how this data structure ties to the parsing of the configuration file.
One goal in the design of the configuration file was to make its contents a simple key/value association (i.e. assigning values to predetermined configuration variables). Of course, the fact that the configuration file is just a Lua script means that additional constructions (conditionals, functions, etc.</description>
    </item>
    
    <item>
      <title>Type-safe, dynamic tree data type</title>
      <link>https://jmmv.dev/2012/05/type-safe-dynamic-tree-data-type.html</link>
      <pubDate>Tue, 29 May 2012 19:06:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/05/type-safe-dynamic-tree-data-type.html</guid>
      <description>The core component of the new configuration library in Kyua is the utils::config::tree class: a type-safe, dynamic tree data type. This class provides a mapping of string keys to arbitrary types: all the nodes of the tree have a textual name, and they can either be inner nodes (no value attached to them), or leaf nodes (an arbitrary type attached as a value to them). The keys represent traversals through such tree, and do this by separating the node names with dots (things of the form root.</description>
    </item>
    
    <item>
      <title>Rethinking Kyua&#39;s configuration system</title>
      <link>https://jmmv.dev/2012/05/rethinking-kyuas-configuration-system.html</link>
      <pubDate>Mon, 28 May 2012 19:48:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/05/rethinking-kyuas-configuration-system.html</guid>
      <description>In the&amp;nbsp;previous blog post, I described the problems that the implementation of the Kyua configuration file parsing and in-memory representation posed. I also hinted that some new code was coming and, after weeks of work, I&#39;m happy to say that it has just landed in the tree!

I really want to get to explaining the nitty-gritty details of the implementation, but I&#39;ll keep these for later. Let&#39;s focus first on what the goals for the new configuration module were, as these drove a lot of the implementation details:Key/value pairs representation: The previous configuration system did this already, and it is a pretty good form for a configuration file because it is a simple, understandable and widespread format.</description>
    </item>
    
    <item>
      <title>Kyua&#39;s configuration system showing its age</title>
      <link>https://jmmv.dev/2012/05/kyuas-configuration-system-showing-its.html</link>
      <pubDate>Sat, 26 May 2012 22:13:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2012/05/kyuas-configuration-system-showing-its.html</guid>
      <description>A couple of years ago, when Kyua was still a newborn, I wrote a very ad-hoc solution for the parsing and representation of its configuration files. The requirements for the configuration were minimal, as there were very few parameters to be exposed to the user. The implementation was quick and simple to allow further progress on other more-important parts of the project. (Yep, quick is an euphemism for dirty: the implementation of the &#34;</description>
    </item>
    
    <item>
      <title>Name your C&#43;&#43; auto-cleaners</title>
      <link>https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html</link>
      <pubDate>Sat, 17 Sep 2011 23:26:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html</guid>
      <description>As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the stack-managed object goes out of scope, it releases the corresponding non-stack-managed object. Smart pointers are just one example of this technique, but so are IO streams too.
Before getting into the point of the article, bear with me for a second while I explain what the&amp;nbsp; stack_cleaner object of Lutok is.</description>
    </item>
    
    <item>
      <title>Introducing Lutok: A lightweight C&#43;&#43; API for Lua</title>
      <link>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</link>
      <pubDate>Thu, 15 Sep 2011 15:18:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</guid>
      <description>It has finally happened. Lutok is the result of what was promised in the &#34;Splitting utils::lua from Kyua&#34; web post.
Quoting the project web page:
Lutok provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua. These wrappers make intensive use of RAII to prevent resource leakage, expose C++-friendly data types, report errors by means of exceptions and ensure that the Lua stack is always left untouched in the face of errors.</description>
    </item>
    
    <item>
      <title>Splitting utils::lua from Kyua</title>
      <link>https://jmmv.dev/2011/09/splitting-utilslua-from-kyua.html</link>
      <pubDate>Sat, 03 Sep 2011 09:43:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/splitting-utilslua-from-kyua.html</guid>
      <description>If you remember a post from January titled C++ interface to Lua for Kyua (wow, time flies), the Kyua codebase includes a small library to wrap the native Lua C library into a more natural C++ interface. You can take a look at the current code as of r129.
Quoting the previous post:
The utils::lua library provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua.</description>
    </item>
    
    <item>
      <title>Injecting C&#43;&#43; functions into Lua</title>
      <link>https://jmmv.dev/2011/01/injecting-c-functions-into-lua.html</link>
      <pubDate>Mon, 17 Jan 2011 11:09:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/injecting-c-functions-into-lua.html</guid>
      <description>The C++ interface to Lua implemented in Kyua exposes a lua::state class that wraps the lower-level lua_State* type. This class completely hides the internal C type of Lua to ensure that all calls that affect the state go through the lua::state class.
Things get a bit messy when we want to inject native functions into the Lua environment. These functions follow the prototype represented by the lua_CFunction type:typedef int (*lua_CFunction)(lua_State*);Now, let&#39;s consider this code:int</description>
    </item>
    
    <item>
      <title>Error handling in Lua: the Kyua approach</title>
      <link>https://jmmv.dev/2011/01/error-handling-in-lua-kyua-approach.html</link>
      <pubDate>Fri, 14 Jan 2011 03:04:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/error-handling-in-lua-kyua-approach.html</guid>
      <description>About a week ago, I detailed the different approaches I encountered to deal with errors raised by the Lua C API. Later, I announced the new C++ interface for Lua implemented within Kyua. And today, I would like to talk about the specific mechanism I implemented in this library to deal with the Lua errors.
The first thing to keep in mind is that the whole purpose of Lua in the context of Kyua is to parse configuration files.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; interface to Lua for Kyua</title>
      <link>https://jmmv.dev/2011/01/c-interface-to-lua.html</link>
      <pubDate>Sat, 08 Jan 2011 08:17:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/c-interface-to-lua.html</guid>
      <description>Finally! After two weeks of holidays work, I have finally been able to submit Kyua&#39;s r39: a generic library that implements a C++ interface to Lua. The code is hosted in the utils/lua/ subdirectory.
From the revision description:The utils::lua library provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua. These wrappers make intensive use of RAII to prevent resource leakage, expose C++-friendly data types, report errors by means of exceptions and ensure that the Lua stack is always left untouched in the face of errors.</description>
    </item>
    
    <item>
      <title>Error handling in Lua</title>
      <link>https://jmmv.dev/2011/01/error-handling-in-lua.html</link>
      <pubDate>Fri, 07 Jan 2011 08:01:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2011/01/error-handling-in-lua.html</guid>
      <description>Some of the methods of the Lua C API can raise errors. To get an initial idea on what these are, take a look at the Functions and Types section and pay attention to the third field of a function description (the one denoted by &#39;x&#39; in the introduction).
Dealing with the errors raised by these functions is tricky, not to say a nightmare. Also, the ridiculously-short documentation on this topic does not help.</description>
    </item>
    
  </channel>
</rss>
