<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/python/index.html</link><description>Recent content in Python on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Thu, 04 Jul 2013 12:00:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/tags/python/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Readability: Dictionaries are not data types</title><link>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</link><pubDate>Thu, 04 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</guid><description>&lt;p>Yes: a dictionary is a data type. No: a dictionary is not a way to implement abstract data types; doing so is lazy programming and is asking for trouble later on.&lt;/p>
&lt;p>What do I mean by this? In Python and other similar dynamic languages, dictionaries are a mapping of keys to values that have no typing restrictions: the dictionary is heterogeneous, and a single dictionary can contain elements of different types both as its keys and its values. To make things worse, the syntax of the language makes it incredibly easy to create and populate dictionaries (unlike, say, in C++). Combine these two facts together and the temptation to abuse a dictionary to implement a structured data type is high.&lt;/p></description></item><item><title>Readability: Document your types</title><link>https://jmmv.dev/2013/06/readability-document-your-types.html</link><pubDate>Mon, 24 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-document-your-types.html</guid><description>&lt;p>Wow. The previous post titled &lt;a href="https://jmmv.dev/2013/06/self-interview-after-leaving-netbsd.html">Self-interview after leaving the NetBSD board&lt;/a> has turned out to be, by far, the most popular article in this blog. The feedback so far has been positive and I owe all of you a follow-up post. However, writing such post will take a while and content must keep flowing. So let&amp;rsquo;s get back to the &lt;a href="http://julipedia.meroh.net/search/label/readability">readability series&lt;/a> for now.&lt;/p>
&lt;hr>
&lt;p>In dynamically-typed languages&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, variable and function definitions do not state the type of their arguments. This is quite convenient when writing code, but results in very hard to read &amp;ldquo;stuff&amp;rdquo; later on. Consider this snippet:&lt;/p></description></item><item><title>Readability: Blocks and variable scoping</title><link>https://jmmv.dev/2013/06/readability-blocks-and-variable-scoping.html</link><pubDate>Thu, 06 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-blocks-and-variable-scoping.html</guid><description>&lt;p>In a dynamically-typed language, it is common for the scoping semantics of a variable to be wider than a single code block. For example: in at least Python and the shell, it is the case that a variable defined &lt;em>anywhere&lt;/em> within a function —even inside conditionals or loops— is reachable anywhere in the function from there on.&lt;/p>
&lt;p>To illustrate what this means, consider this snippet in which we define a function to compute the CPU requirements needed in a database system to support a set of tables:&lt;/p></description></item><item><title>Silencing the output of Python's subprocess.Popen</title><link>https://jmmv.dev/2009/01/silencing-output-of-pythons.html</link><pubDate>Mon, 05 Jan 2009 07:02:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2009/01/silencing-output-of-pythons.html</guid><description>I'm learning Python these days while writing an script to automate the testing of ATF under multiple virtual machines. I had this code in a shell script, but it is so ugly and clumsy that I don't even dare to add it to the repository. Hopefully, the new version in Python will be more robust and versatile enough to be published.&lt;br />&lt;br />One of the things I've been impressed by is the &lt;tt>subprocess&lt;/tt> module and, in special, its &lt;tt>Popen&lt;/tt> class. By using this class, it is trivial to spawn subprocesses and perform some IPC with them. Unfortunately, &lt;tt>Popen&lt;/tt> does not provide any way to silence the output of the children. As I see it, it'd be nice if you'd pass an &lt;tt>IGNORE&lt;/tt> flag as the stdout/stderr behavior, much like you can currently set those to &lt;tt>PIPE&lt;/tt> or set stderr to &lt;tt>STDOUT&lt;/tt>.&lt;br />&lt;br />The following trivial module implements this idea. It extends &lt;tt>Popen&lt;/tt> so that the callers can pass the &lt;tt>IGNORE&lt;/tt> value to the stdout/stderr arguments. (Yes, it is trivial but it is also one of the first Python code I write so... it may contain obviously non-Pythonic, ugly things.) The idea is that this exposes the same interface so that it can be used as a drop-in replacement. OK, OK, it lacks some methods and the constructor does not match the original signature, but this is enough for my current use cases!&lt;br />&lt;br />&lt;pre>import subprocess&lt;br />&lt;br />&lt;br />IGNORE = -3&lt;br />STDOUT = subprocess.STDOUT&lt;br />assert IGNORE != STDOUT, "IGNORE constant is invalid"&lt;br />&lt;br />&lt;br />class Popen(subprocess.Popen):&lt;br /> """Extension of subprocess.Popen with built-in support&lt;br /> for silencing the output channels of a child process"""&lt;br />&lt;br /> __null = None&lt;br />&lt;br /> def __init__(self, args, stdout = None, stderr = None):&lt;br /> subprocess.Popen.__init__(self, args = args,&lt;br /> stdout = self._channel(stdout),&lt;br /> stderr = self._channel(stderr))&lt;br />&lt;br /> def __del__(self):&lt;br /> self._close_null()&lt;br />&lt;br /> def wait(self):&lt;br /> r = subprocess.Popen.wait(self)&lt;br /> self._close_null()&lt;br /> return r&lt;br />&lt;br /> def _null_instance(self):&lt;br /> if self.__null == None:&lt;br /> self.__null = open("/dev/null", "w")&lt;br /> return self.__null&lt;br />&lt;br /> def _close_null(self):&lt;br /> if self.__null != None:&lt;br /> self.__null.close()&lt;br /> self.__null = None&lt;br /> assert self.__null == None, &lt;br /> "Inconsistent internal state"&lt;br />&lt;br /> def _channel(self, behavior):&lt;br /> if behavior == IGNORE:&lt;br /> return self._null_instance()&lt;br /> else:&lt;br /> return behavior&lt;/pre>By the way, &lt;a href="http://mail.python.org/pipermail/python-dev/2006-June/065868.html">somebody else suggested this same thing&lt;/a> a while ago. Don't know why it hasn't been implemented in the mainstream &lt;tt>subprocess&lt;/tt> module.</description></item></channel></rss>