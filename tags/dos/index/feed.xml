<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dos on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/dos/index/</link><description>Recent content in dos on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Feb 2024 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/dos/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Beyond the 1 MB barrier in DOS</title><link>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</link><pubDate>Wed, 07 Feb 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html</guid><description>&lt;p>In &lt;a href="https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html">&amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;&lt;/a>, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.&lt;/p>
&lt;p>I know I promised that this follow-up article would be about DJGPP, but before getting into &lt;em>that&lt;/em> review, I realized I had to take another detour to cover three more topics. Namely: &lt;em>unreal mode&lt;/em>, which I intentionally ignored to not derail the post; &lt;em>LOADALL&lt;/em>, which I didn&amp;rsquo;t know about until you readers mentioned it; and &lt;em>DOS extenders&lt;/em>, which I was planning to describe in the DJGPP article but they are a better fit for this one.&lt;/p>
&lt;p>So&amp;hellip; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&amp;rsquo;ll go over assembly code for a step-by-step jump into unreal mode.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-07-80386-dos.jpg" length="152971" type="image/jpeg"/></item><item><title>From 0 to 1 MB in DOS</title><link>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</link><pubDate>Wed, 17 Jan 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/01/from-0-to-1-mb-in-dos.html</guid><description>&lt;p>Since the last article on &lt;a href="https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html">the text-based IDEs of old&lt;/a>, I&amp;rsquo;ve been meaning to write about the GCC port to DOS, namely &lt;a href="https://www.delorie.com/djgpp/">DJGPP&lt;/a>. As I worked on the draft for that topic, I realized that there is a ton of ground to cover to set the stage so I took most of the content on memory management out and wrote this separate post.&lt;/p>
&lt;p>This article is a deep dive on how DOS had to pull out tricks to maximize the use of the very limited 1 MB address space of the 8086. Those tricks could exist because of the features later introduced by the 80286 and the 80386, but these were just clutches to paper over the fact that DOS could not leverage the real improvements provided by protected mode.&lt;/p>
&lt;p>This detour is long but I hope you&amp;rsquo;ll enjoy it as much as I enjoyed researching the topic. I&amp;rsquo;ll walk you through the changes in the x86 architecture over time, starting with the 8086 and ending in the 80386, and how DOS kept up along the way. I&amp;rsquo;ll conclude with a peek into DOS&amp;rsquo; own &lt;tt>MEM&lt;/tt> and MemMaker utilities. I must omit details to keep the text manageable in size though, so please excuse the lack of detail in some areas; just follow the links to external documentation to learn more.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-01-17-8086-dos.jpg" length="220943" type="image/jpeg"/></item></channel></rss>