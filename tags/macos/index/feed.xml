<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Macos on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/macos/index.html</link><description>Recent content in Macos on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Jul 2021 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/macos/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>macOS keyboard shortcuts for Windows</title><link>https://jmmv.dev/2021/07/macos-ahk.html</link><pubDate>Wed, 07 Jul 2021 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2021/07/macos-ahk.html</guid><description>&lt;p>Are you a macOS user occasionally dealing with Windows systems or trying to switch platforms? Are you a Windows user that believes that the Windows-native keyboard shortcuts are objectively bad? Are you annoyed by something as simple as copy/pasting text not working consistently across apps?&lt;/p>
&lt;p>If so, this post will equip you with an &lt;a href="https://www.autohotkey.com/">AutoHotkey&lt;/a> configuration file that brings macOS keyboard shortcuts to Windows. Read on.&lt;/p></description></item><item><title>Running codesign over SSH with a new key</title><link>https://jmmv.dev/2020/05/codesign-and-ssh.html</link><pubDate>Fri, 29 May 2020 15:30:00 -0400</pubDate><guid>https://jmmv.dev/2020/05/codesign-and-ssh.html</guid><description>&lt;p>I just spent sometime between 30 minutes and 1 hour convincing the Mac Pro that sits in my office to successfully &lt;code>codesign&lt;/code> an iOS app via Bazel. This was after having to update the signing key to a newer one and after rebooting the machine due to the macOS 10.15.5 upgradeâ€”all remotely thanks to COVID-19.&lt;/p>
&lt;p>The build of the app was failing with an &lt;code>errSecInternalComponent&lt;/code> error printed by &lt;code>codesign&lt;/code>. It is not the first time I face this, but in all previous cases, I had either been at the computer to click through security popups, had had functional Chrome Remote Desktop access, or did not have to install a new signing key remotely.&lt;/p></description></item><item><title>macOS terminal stalls running a binary</title><link>https://jmmv.dev/2020/03/macos-stuck-terminal-fuse-exec.html</link><pubDate>Mon, 23 Mar 2020 21:20:00 +0500</pubDate><guid>https://jmmv.dev/2020/03/macos-stuck-terminal-fuse-exec.html</guid><description>&lt;p>Here I am, confined to my apartment due to the COVID-19 pandemic and without having posted anything for almost two months. Fortunately, my family and I are still are in good condition, and I&amp;rsquo;m even more fortunate to have a job that can employ me remotely without problems. Or can they?&lt;/p>
&lt;p>For over a year, my team and I have been working on allowing our mobile engineers to work from their laptops (as opposed to from their powerful workstations). And guess what: now, more than ever, this has become super-important: making our engineering workforce productive when working remotely is a challenge, sure, but is also an amazing opportunity for the feature we&amp;rsquo;ve been developing for over a year.&lt;/p></description></item><item><title>The /bin/bash baggage of macOS</title><link>https://jmmv.dev/2019/11/macos-bash-baggage.html</link><pubDate>Wed, 20 Nov 2019 23:00:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/macos-bash-baggage.html</guid><description>As you may know, macOS ships with an ancient version of the Bash shell interpreter, 3.2.57. Let&amp;rsquo;s see why that is and why this is a problem.</description></item><item><title>Waiting for process groups, macOS edition</title><link>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</link><pubDate>Fri, 15 Nov 2019 11:00:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</guid><description>&lt;p>In the previous posts, we saw why &lt;a href="https://jmmv.dev/2019/11/wait-for-process-group.html">waiting for a process group is complicated&lt;/a> and we covered a specific, bullet-proof mechanism to &lt;a href="https://jmmv.dev/2019/11/wait-for-process-group-linux.html">accomplish this on Linux&lt;/a>. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (&lt;a href="https://github.com/bazelbuild/bazel/issues/10245">#10245&lt;/a>) is the following: given a process group, wait for all of its processes to fully terminate.&lt;/p>
&lt;p>macOS has a bunch of fancy features that &lt;a href="https://jmmv.dev/2019/03/macos-threads-qos-and-bazel.html">other systems do not have&lt;/a>, but process control is not among them. We do not have features like Linux&amp;rsquo;s child subreaper or PID namespaces to keep track of process groups. Therefore, we&amp;rsquo;ll have to roll our own. And the only way to do this is to scan the process table looking for processes with the desired process group identifier (PGID) and waiting until they are gone.&lt;/p></description></item><item><title>A quick glance at macOS' sandbox-exec</title><link>https://jmmv.dev/2019/11/macos-sandbox-exec.html</link><pubDate>Fri, 01 Nov 2019 20:10:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/macos-sandbox-exec.html</guid><description>&lt;p>macOS includes a sandboxing mechanism to closely control what processes can do on the system. Sandboxing can restrict file system accesses on a path level, control which host/port pairs can be reached over the network, limit which binaries can be executed, and much more. All applications installed via the App Store are subject to sandboxing.&lt;/p>
&lt;p>This sandboxing functionality is exposed via the &lt;code>sandbox-exec(1)&lt;/code> command-line utility, which unfortunately has been listed as deprecated for at least the last two major versions of macOS. It is still there, however, and the supplemental manual pages like &lt;code>sandbox(7)&lt;/code> or &lt;code>sandboxd(8)&lt;/code> do not mention the deprecation&amp;hellip; which makes me think that the new &lt;a href="https://developer.apple.com/app-sandboxing/">App Sandboxing&lt;/a> feature is built on the same kernel subsystem as &lt;code>sandbox-exec(1)&lt;/code>.&lt;/p></description></item><item><title>Optimizing tree deletions in Bazel</title><link>https://jmmv.dev/2019/03/optimizing-tree-deletions.html</link><pubDate>Fri, 22 Mar 2019 15:00:00 +0100</pubDate><guid>https://jmmv.dev/2019/03/optimizing-tree-deletions.html</guid><description>&lt;p>Bazel likes creating very deep and large trees on disk during a build. One example is the output tree, which naturally contains all the artifacts of your build. Another, more problematic example is the symlink forest trees created for every action when sandboxing is enabled. As garbage gets created, it must be deleted.&lt;/p>
&lt;p>It turns out, however, that deleting file system trees can be very expensive&amp;mdash;and especially so on macOS. In fact, calls to our &lt;code>deleteTree&lt;/code> algorithm routinely showed up in my profiling runs when trying to diagnose slowdowns using the &lt;a href="https://blog.bazel.build/2019/02/01/dynamic-spawn-scheduler.html">dynamic scheduler&lt;/a>. One thing I quickly wondered is: why can I easily catch Bazel stuck in the tree deletion but I can never catch it busily creating such a tree? Is tree deletion inherently slow or are we doing something stupid?&lt;/p></description></item><item><title>Darwin's QoS service classes and performance</title><link>https://jmmv.dev/2019/03/macos-threads-qos-and-bazel.html</link><pubDate>Wed, 06 Mar 2019 17:30:00 +0100</pubDate><guid>https://jmmv.dev/2019/03/macos-threads-qos-and-bazel.html</guid><description>&lt;p>Since the publication of Bazel a few years ago, users have reported (and I myself have experienced) general slowdowns when Bazel is running on Macs: things like the window manager stutter and others like the web browser cannot load new pages. Similarly, after the introduction of the &lt;a href="https://blog.bazel.build/2019/02/01/dynamic-spawn-scheduler.html">dynamic spawn scheduler&lt;/a>, some users reported &lt;em>slower&lt;/em> builds than pure remote or pure local builds, which made no sense.&lt;/p>
&lt;p>All along we guessed that these problems were caused by Bazel&amp;rsquo;s abuse of system threads, as it used to spawn 200 &lt;em>runnable&lt;/em> threads during analysis and used to run 200 concurrent compiler subprocesses. We tackled the problem by reducing Bazel&amp;rsquo;s abuse (e.g. &lt;a href="https://github.com/bazelbuild/bazel/commit/ac880418885061d1039ad6b3d8c28949782e02d6">commit ac88041&lt;/a>) of system resources&amp;hellip; and while we saw an improvement, the issue remained.&lt;/p></description></item><item><title>Open files limit, macOS, and the JVM</title><link>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</link><pubDate>Tue, 29 Jan 2019 17:15:00 -0500</pubDate><guid>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</guid><description>&lt;p>Bazel&amp;rsquo;s original &lt;a href="https://www.dictionary.com/browse/raison-d-etre">raison d&amp;rsquo;etre&lt;/a> was to support Google&amp;rsquo;s monorepo. A consequence of using a monorepo is that some builds will become very large. And large builds can be very resource hungry, especially when using a tool like Bazel that tries to parallelize as many actions as possible for efficiency reasons. There are many resource types in a system, but today I&amp;rsquo;d like to focus on the number of open files at any given time (&lt;code>nofiles&lt;/code>).&lt;/p></description></item><item><title>Easy pkgsrc on macOS with pkg_comp 2.0</title><link>https://jmmv.dev/2017/02/pkg_comp-2.0-tutorial-macos.html</link><pubDate>Thu, 23 Feb 2017 17:36:54 -0500</pubDate><guid>https://jmmv.dev/2017/02/pkg_comp-2.0-tutorial-macos.html</guid><description>&lt;p>This is a tutorial to guide you through the &lt;a href="https://jmmv.dev/2017/02/introducing-pkg_comp-2.0.html">shiny new pkg_comp 2.0&lt;/a> on macOS &lt;a href="https://github.com/jmmv/pkg_comp/blob/master/INSTALL.md#using-the-macos-installer">using the macOS-specific self-installer&lt;/a>.&lt;/p>
&lt;p>&lt;strong>Goals:&lt;/strong> to use pkg_comp 2.0 to build a binary repository of all the packages you are interested in; to keep the repository fresh on a daily basis; and to use that repository with pkgin to maintain your macOS system up-to-date and secure.&lt;/p></description></item><item><title>How to add the Mac OS X screensaver to the dock</title><link>https://jmmv.dev/2013/11/how-to-add-mac-os-x-screensaver-to-dock.html</link><pubDate>Thu, 07 Nov 2013 12:00:00 -0500</pubDate><guid>https://jmmv.dev/2013/11/how-to-add-mac-os-x-screensaver-to-dock.html</guid><description>&lt;p>For various reasons, I have trained myself to lock my computer's screen as soon as I vacate my seat every single time. This may seem annoying to some, but once you get used to it it becomes second nature. The reason I do this is to prevent the chance of a malicious coworker (or "guest") to steal my credentials at work.&lt;/p> &lt;p>However, Mac OS X has traditionally not made this simple. As far as I know, the only easy way to manually launch the screensaver was (and still is) to define a hot corner to put the display to sleep. Frankly, I don't want a hot corner action for this, if only because I already have assigned other actions to every corner of my screen. However, an icon in the dock would be very convenient... and this post teaches you the non-obvious way to achieve it.&lt;/p></description></item><item><title>Reinstalled Mac OS X in multiple partitions, again</title><link>https://jmmv.dev/2008/07/reinstalled-mac-os-x-in-multiple.html</link><pubDate>Sat, 05 Jul 2008 06:31:00 -0400</pubDate><guid>https://jmmv.dev/2008/07/reinstalled-mac-os-x-in-multiple.html</guid><description>Past weekend, for some strange reason, I decided to dump all the MBP's hard disk contents and start again from scratch. But this time I decided to split the disk into multiple partitions for Mac OS X, to avoid external fragmentation slowdowns as much as possible.&lt;br />&lt;br />I &lt;a href="http://julipedia.blogspot.com/2007/01/install-mac-os-x-over-multiple-volumes.html">already did such a thing&lt;/a> back when the MBP was new. At that time, I created a partition for the system files and another for the user data. However, that setup was not too optimal and, when I got the 7200RPM hard disk drive six months later, I reinstalled again in a single partition. Just for convenience.&lt;br />&lt;br />But external fragmentation hurts performance a lot, specially in my case because I need to keep lots of small files (the NetBSD source tree, for example) and files that get fragmented very easily (sparse virtual machine disks). These end up spreading the files everywhere on the physical disk, and as a result the system slows down considerably. I even bought iDefrag and it does a good job at optimizing the disk layout... but the results were not as impressive as I expected.&lt;br />&lt;br />This time I reinstalled using the following layout:&lt;br />&lt;ul>&lt;li>System: Mounted on /, HFS+ case insensitive, 30GB.&lt;/li>&lt;li>Users: Mounted on /Users, HFS+ case insensitive, 50GB.&lt;/li>&lt;li>Windows: Not mounted, NTFS, 40GB.&lt;/li>&lt;li>Projects: Mounted on /Users/jmmv/Projects, HFS+ case sensitive, 30GB.&lt;/li>&lt;/ul>Windows had to go before Projects so that the MBR partition table was constructed correctly; otherwise Windows failed to start after installation. The Projects partition holds those small files as well as the virtual machines. And Users keeps all the personal stuff such as photos, music and documents, which are mostly static.&lt;br />&lt;br />Using this layout, the machine really feels a lot faster. Applications start quickly, programs that deal with personal data such as iPhoto and iTunes load the library faster, and I don't have to deal with stupid disk images to keep things sequential on disk. However, the price to pay for such layout is convenience, because now the free disk space is spread in multiple partitions.</description></item><item><title>Getting started with Cocoa</title><link>https://jmmv.dev/2007/09/getting-started-with-cocoa.html</link><pubDate>Tue, 11 Sep 2007 13:53:00 -0400</pubDate><guid>https://jmmv.dev/2007/09/getting-started-with-cocoa.html</guid><description>I recently subscribed to the &lt;a href="http://www.planetcocoa.org/">Planet Cocoa&lt;/a> aggregator and it has already brought me some interesting articles. Today, there was an excellent one titled &lt;a href="http://andymatuschak.org/articles/2007/09/09/getting-started-with-cocoa-a-friendlier-approach/">Getting started with Cocoa: a friendlier approach&lt;/a> posted at Andy Matuschak's blog: &lt;a href="http://andymatuschak.org/articles/category/programming/">Square Signals&lt;/a>.&lt;br />&lt;br />This post guides you through your first steps with Cocoa. Its basic aim is making you gain enough &lt;i>intuition&lt;/i> to let you guide yourself through Cocoa documentation in the future. If you have ever programmed in, e.g. Java, you know what this means: you first need to have some basic knowledge of the whole platform to get started and, at that point, you can do almost anything by driving to the API documentation and searching for what you need &amp;mdash; even if you had no clue on how to accomplish your task before.&lt;br />&lt;br />Attacking the in-depth documentation directly is hard because it overwhelms you with details that are not important to the beginner. Plus it does not show you the big picture.&lt;br />&lt;br />I am by no means a Cocoa expert yet (in fact I'm very much a beginner), so this post will be extremely helpful to me, at least; thanks Andy! I hope it is to you too in case you wanted to begin programming for Mac OS X.</description></item><item><title>Hibernating a Mac</title><link>https://jmmv.dev/2007/07/hibernating-mac.html</link><pubDate>Sat, 28 Jul 2007 08:35:00 -0400</pubDate><guid>https://jmmv.dev/2007/07/hibernating-mac.html</guid><description>Mac OS X has supported for a very long time putting Macs to sleep. This is a must-have feature for laptops, but is also convenient for desktop machines. However, it hasn't been since the transition to Intel-based Macs that it also supports &lt;span style="font-style: italic;">hibernation&lt;/span>, also called &lt;span style="font-style: italic;">deep sleep&lt;/span>. When entering the hibernation mode, the system stores all memory contents to disk as well as the status of the devices. It then powers off the machine completely. Later on, the on-disk copy is used to restore the machine to its previous state when it is powered on. It takes longer than resuming from sleep status, but all your applications will be there as you left them.&lt;br />&lt;br />Now, every time you put your Intel Mac to sleep it is also preparing itself to hibernate. This is why Intel Macs take longer than PowerPC-based ones to enter the sleep mode. This way, if the machine's battery drains completely in the case of notebooks, or the machine is unplugged in the case of desktops, the machine will be able to quickly recover itself to a safe state and you won't lose data.&lt;br />&lt;br />As I &lt;a href="http://julipedia.blogspot.com/2007/07/processor-speed-and-desktop-usage.html">mentioned yesterday&lt;/a>, I've been running my MacBook Pro for a while without the battery, so I had an easy chance to experiment hibernation. And it's marvelous. No flaws so far.&lt;br />&lt;br />The thing is that I always powered down my Mac at night. The reason is that putting it to sleep during the whole night consumed few but enough battery to require a recharge next morning to bring it back to 100%, so I didn't do it. But now I usually put it to hibernate; this way, on the next boot, I can continue work straight from where I left it and I don't have to restart any applications.&lt;br />&lt;br />Now... putting a Mac notebook into this mode is painful if you have to remove the battery every time to force it to enter hibernation mode, and unfortunately Mac OS X does not have any "Hibernate" option. But... there is this sweet DashBoard widget called &lt;a href="http://deepsleep.free.fr/">Deep Sleep&lt;/a> that lets you do exactly that! No more boots from cold state any more :-)</description></item><item><title>New Processor preferences panel in Mac OS X</title><link>https://jmmv.dev/2007/07/new-processor-preferences-panel-in-mac.html</link><pubDate>Sun, 01 Jul 2007 07:45:00 -0400</pubDate><guid>https://jmmv.dev/2007/07/new-processor-preferences-panel-in-mac.html</guid><description>Some days ago I updated my system to the latest version of Mac OS X Tiger, 10.4.10. It hasn't been until today that I realized that there is a new cool preferences panel called &lt;i>Processor&lt;/i>:&lt;br />&lt;br />&lt;a href="http://2.bp.blogspot.com/_xLbGV919cEE/RoeUfAAM38I/AAAAAAAAABE/-ueppW9G5P4/s1600-h/systemprefs.png">&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="https://jmmv.dev/images/2007-07-01-systemprefs.png" />&lt;/a>It looks like this:&lt;br />&lt;br />&lt;a href="http://2.bp.blogspot.com/_xLbGV919cEE/RoeUfAAM37I/AAAAAAAAAA8/8SyoqC4G84k/s1600-h/procsprefpane.png">&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="https://jmmv.dev/images/2007-07-01-procsprefpane.png" />&lt;/a>As you can see, it gives information about each processor in the machine and also lets you disable any processor you want.&lt;br />&lt;br />There is also another "hidden" window, accessible from the menu bar control after you have enabled it. It is called the &lt;i>Processor palette&lt;/i> and looks like this:&lt;br />&lt;br />&lt;a href="http://1.bp.blogspot.com/_xLbGV919cEE/RoeUewAM36I/AAAAAAAAAA0/VPiLWElqQFQ/s1600-h/procspalette.png">&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="https://jmmv.dev/images/2007-07-01-procspalette.png" />&lt;/a>I already monitor the processor activity by using the &lt;i>Activity Monitor&lt;/i>'s dock icon, which is much more compact, but this one is nice :-)&lt;br />&lt;br />&lt;span style="font-weight: bold;">Edit (16:22)&lt;/span>: Rui Paulo writes in a comment that this is available if you install Xcode. It turns out I have had Xcode installed for ages, but my installation did not contain the CHUD tools. I recently added them to the system, which must be the reason behind this new item in the system preferences. So... this is not related to the 10.4.10 update I mentioned at first.</description></item></channel></rss>