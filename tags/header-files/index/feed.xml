<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Header-Files on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/header-files/index.html</link><description>Recent content in Header-Files on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2024 Julio Merino</copyright><lastBuildDate>Wed, 01 Jan 2014 17:00:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/header-files/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Header files: Series wrap-up</title><link>https://jmmv.dev/2014/01/header-files-series-wrap-up.html</link><pubDate>Wed, 01 Jan 2014 17:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2014/01/header-files-series-wrap-up.html</guid><description>&lt;p>Happy New Year!&lt;/p>
&lt;p>Let me welcome 2014 with a very simple post to wrap up the &lt;a href="http://julipedia.meroh.net/search/label/header-files">header files series&lt;/a> as is customary so that you have all relevant links in a single place for future reference:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jmmv.dev/2013/11/header-files-series-introduction.html">Series introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/11/header-files-multiple-inclusion.html">Multiple-inclusion protection&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/11/header-files-self-containment.html">Self-containment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/12/header-files-c-ipp-files.html">C++ ipp files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html">Avoid C++ &amp;ldquo;using&amp;rdquo; directives&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html">Poor man&amp;rsquo;s replacement for modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/12/header-files-qualify-your-identifiers.html">Qualify your identifiers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/12/header-files-poor-compilation-times-in-c.html">Poor compilation times in C++&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>As I mentioned a couple of posts ago, I am quite busy these days spending my limited free time on Kyua-related hacking, which means you should expect a less constant blogging pace. In particular, I do not have any more &amp;ldquo;post series&amp;rdquo; in the queue so upcoming posts will be more varied in content! Hope you will enjoy them anyway.&lt;/p></description></item><item><title>Header files: Poor compilation times in C++</title><link>https://jmmv.dev/2013/12/header-files-poor-compilation-times-in-c.html</link><pubDate>Mon, 30 Dec 2013 10:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/12/header-files-poor-compilation-times-in-c.html</guid><description>&lt;p>Have you ever wondered why building C++ code is so awfully slow and, apparently, compilation times haven&amp;rsquo;t gotten any better over the course of many years?&lt;/p>
&lt;p>Wonder no more. This article on &lt;a href="http://www.drdobbs.com/cpp/c-compilation-speed/228701711">C++ Compilation Speed&lt;/a> published on August 17, 2010 on Dr. Dobb&amp;rsquo;s delves into the problem. Mind you, a major cause of such slowdowns are header files and the fact that they are a &lt;a href="https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html">horrible replacement for a modules system&lt;/a>. I felt that such article fit these series perfectly well, so here it goes.&lt;/p></description></item><item><title>Header files: Qualify your identifiers</title><link>https://jmmv.dev/2013/12/header-files-qualify-your-identifiers.html</link><pubDate>Fri, 27 Dec 2013 13:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/12/header-files-qualify-your-identifiers.html</guid><description>&lt;p>Apologies for the long pause in the &lt;a href="http://julipedia.meroh.net/search/label/header-files">header files series&lt;/a> and in blogging in general. With the holidays in between and, especially, with my refreshed energy to do stuff in the FreeBSD and Kyua camps, I haven&amp;rsquo;t had any reasonable amount of time to write. And, sincerely, with my very limited free time I really cannot cover it all. So&amp;hellip; these days, coding it is thus expect a reduced blogging pace!&lt;/p></description></item><item><title>Header files: Poor man's replacement for modules</title><link>https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html</link><pubDate>Mon, 09 Dec 2013 23:30:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html</guid><description>&lt;p>I don&amp;rsquo;t like header files and, especially, I don&amp;rsquo;t like having to use them to implement modules. When you have used a language that sports real modules—pretty much anything other than C or sh—, header files feel primitive. Well, they actually &lt;em>are&lt;/em> primitive.&lt;/p>
&lt;p>But what do I mean by &amp;ldquo;real modules&amp;rdquo;?&lt;/p>
&lt;h1 id="modules">Modules!&lt;/h1>
&lt;p>In a language that supports modules, a module is a collection of related data types and code exposed via &lt;em>a well-defined set of symbols encapsulated in a single container (name)&lt;/em>. In other words: the effect of importing a module is simply getting a single reference to that module.&lt;/p></description></item><item><title>Header files: Avoid C++ 'using' directives</title><link>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</link><pubDate>Thu, 05 Dec 2013 12:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</guid><description>&lt;p>Following up on the previous C++ post, here comes one more thing to consider when writing header files in this language.&lt;/p>
&lt;h1 id="using-and-using-namespace">&lt;code>using&lt;/code> and &lt;code>using namespace&lt;/code>&lt;/h1>
&lt;p>The C++ &lt;code>using&lt;/code> directive and its more generic &lt;code>using namespace&lt;/code> counterpart, allow the programmer to bring a given symbol or all the symbols in a namespace, respectively, into the calling scope. This feature exists to simplify typing and, to some extent, to make the code more readable. (It may have come into existence to simplify the porting of old, non-ISO C++ code to modern C++, but that&amp;rsquo;s just a guess.)&lt;/p></description></item><item><title>Header files: C++ ipp files</title><link>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</link><pubDate>Mon, 02 Dec 2013 12:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</guid><description>&lt;p>Hoping you had a nice holiday break, it is now the time to resume our series on header files with a new topic covering the world of template definitions in C++.&lt;/p>
&lt;hr>
&lt;p>If you have ever used the &lt;a href="http://www.boost.org/">Boost libraries&lt;/a>, you may have noticed that aside from the regular &lt;code>hpp&lt;/code> header files, they also provide a bunch of accompanying &lt;code>ipp&lt;/code> files.&lt;/p>
&lt;p>&lt;strong>&lt;code>ipp&lt;/code> files, in the general case, are used to provide the implementation for a template class defined in a corresponding &lt;code>hpp&lt;/code> file.&lt;/strong> This stems from the fact that, in C++, the &lt;em>code&lt;/em> for such template definitions must be available whenever the class is instantiated, and this in turn means that the template definitions cannot be placed in separate modules as is customary with non-template classes. In other words: putting the template definitions in &lt;code>cpp&lt;/code> files just does not work. (I hear the C++ standards committee wants to &amp;ldquo;fix&amp;rdquo; this but I forget the details now and cannot find a reference.)&lt;/p></description></item><item><title>Header files: Self-containment</title><link>https://jmmv.dev/2013/11/header-files-self-containment.html</link><pubDate>Mon, 25 Nov 2013 12:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/11/header-files-self-containment.html</guid><description>&lt;h1 id="the-rule">The rule&lt;/h1>
&lt;p>The mere fact of &lt;em>including&lt;/em> a given header file, without including any other beforehand, should not be enough of a reason for the &lt;em>build&lt;/em> to break. This means that the header file should be self-contained, and for this to be the case, such header file has to pull in any dependencies that it &lt;strong>explicitly requires&lt;/strong> (and no more).&lt;/p>
&lt;p>Interestingly, note that this does &lt;em>not&lt;/em> mean that a header file must include &lt;em>everything&lt;/em> it may ever need to be fully &lt;em>usable&lt;/em>.&lt;/p></description></item><item><title>Header files: Multiple-inclusion protection</title><link>https://jmmv.dev/2013/11/header-files-multiple-inclusion.html</link><pubDate>Thu, 21 Nov 2013 12:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/11/header-files-multiple-inclusion.html</guid><description>&lt;p>Let&amp;rsquo;s start the series with something simple: the basic structure of header files and why and how to protect against multiple inclusion.&lt;/p>
&lt;h1 id="the-rule">The rule&lt;/h1>
&lt;p>The basic use of header files is to provide symbol declarations for functions and globals. Because multiple declarations of a given symbol in a single translation unit are a syntax error, you have to defensively structure your header files to not redefine anything in case they are included multiple times.&lt;/p></description></item><item><title>Header files: Series introduction</title><link>https://jmmv.dev/2013/11/header-files-series-introduction.html</link><pubDate>Mon, 18 Nov 2013 22:30:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/11/header-files-series-introduction.html</guid><description>&lt;p>As I started typing a supposedly-simple post on header files, I realized that what I was explaining could easily be split into various posts and significantly extended with additional content, so here comes a new (short) series on these special little files in the need of careful attention.&lt;/p>
&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Header_file">Quoting the Wikipedia&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>A &lt;strong>header file&lt;/strong> is a file that allows programmers to separate certain elements of a program&amp;rsquo;s source code into reusable files. Header files commonly contain forward declarations of classes, subroutines, variables, and other identifiers. Programmers who wish to declare standardized identifiers in more than one source file can place such identifiers in a single header file, which other code can then include whenever the header contents are required. This is to keep the interface in the header separate from the implementation.&lt;/p></description></item></channel></rss>