<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>header-files on jmmv.dev</title>
    <link>https://jmmv.dev/tags/header-files/index/</link>
    <description>Recent content in header-files on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jan 2014 17:00:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/header-files/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Header files: Series wrap-up</title>
      <link>https://jmmv.dev/2014/01/header-files-series-wrap-up.html</link>
      <pubDate>Wed, 01 Jan 2014 17:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2014/01/header-files-series-wrap-up.html</guid>
      <description>Happy New Year!
Let me welcome 2014 with a very simple post to wrap up the header files series as is customary so that you have all relevant links in a single place for future reference:
 Series introduction Multiple-inclusion protection Self-containment C++ ipp files Avoid C++ &amp;ldquo;using&amp;rdquo; directives Poor man&amp;rsquo;s replacement for modules Qualify your identifiers Poor compilation times in C++  As I mentioned a couple of posts ago, I am quite busy these days spending my limited free time on Kyua-related hacking, which means you should expect a less constant blogging pace.</description>
    </item>
    
    <item>
      <title>Header files: Poor compilation times in C&#43;&#43;</title>
      <link>https://jmmv.dev/2013/12/header-files-poor-compilation-times-in-c.html</link>
      <pubDate>Mon, 30 Dec 2013 10:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-poor-compilation-times-in-c.html</guid>
      <description>Have you ever wondered why building C++ code is so awfully slow and, apparently, compilation times haven&amp;rsquo;t gotten any better over the course of many years?
Wonder no more. This article on C++ Compilation Speed published on August 17, 2010 on Dr. Dobb&amp;rsquo;s delves into the problem. Mind you, a major cause of such slowdowns are header files and the fact that they are a horrible replacement for a modules system.</description>
    </item>
    
    <item>
      <title>Header files: Qualify your identifiers</title>
      <link>https://jmmv.dev/2013/12/header-files-qualify-your-identifiers.html</link>
      <pubDate>Fri, 27 Dec 2013 13:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-qualify-your-identifiers.html</guid>
      <description>Apologies for the long pause in the header files series and in blogging in general. With the holidays in between and, especially, with my refreshed energy to do stuff in the FreeBSD and Kyua camps, I haven&amp;rsquo;t had any reasonable amount of time to write. And, sincerely, with my very limited free time I really cannot cover it all. So&amp;hellip; these days, coding it is thus expect a reduced blogging pace!</description>
    </item>
    
    <item>
      <title>Header files: Poor man&#39;s replacement for modules</title>
      <link>https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html</link>
      <pubDate>Mon, 09 Dec 2013 23:30:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-poor-mans-replacement-for.html</guid>
      <description>I don&amp;rsquo;t like header files and, especially, I don&amp;rsquo;t like having to use them to implement modules. When you have used a language that sports real modules—pretty much anything other than C or sh—, header files feel primitive. Well, they actually are primitive.
But what do I mean by &amp;ldquo;real modules&amp;rdquo;?
Modules! In a language that supports modules, a module is a collection of related data types and code exposed via a well-defined set of symbols encapsulated in a single container (name).</description>
    </item>
    
    <item>
      <title>Header files: Avoid C&#43;&#43; &#39;using&#39; directives</title>
      <link>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</link>
      <pubDate>Thu, 05 Dec 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-avoid-c-using-directives.html</guid>
      <description>Following up on the previous C++ post, here comes one more thing to consider when writing header files in this language.
using and using namespace The C++ using directive and its more generic using namespace counterpart, allow the programmer to bring a given symbol or all the symbols in a namespace, respectively, into the calling scope. This feature exists to simplify typing and, to some extent, to make the code more readable.</description>
    </item>
    
    <item>
      <title>Header files: C&#43;&#43; ipp files</title>
      <link>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</link>
      <pubDate>Mon, 02 Dec 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/12/header-files-c-ipp-files.html</guid>
      <description>Hoping you had a nice holiday break, it is now the time to resume our series on header files with a new topic covering the world of template definitions in C++.
 If you have ever used the Boost libraries, you may have noticed that aside from the regular hpp header files, they also provide a bunch of accompanying ipp files.
ipp files, in the general case, are used to provide the implementation for a template class defined in a corresponding hpp file.</description>
    </item>
    
    <item>
      <title>Header files: Self-containment</title>
      <link>https://jmmv.dev/2013/11/header-files-self-containment.html</link>
      <pubDate>Mon, 25 Nov 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/11/header-files-self-containment.html</guid>
      <description>The rule The mere fact of including a given header file, without including any other beforehand, should not be enough of a reason for the build to break. This means that the header file should be self-contained, and for this to be the case, such header file has to pull in any dependencies that it explicitly requires (and no more).
Interestingly, note that this does not mean that a header file must include everything it may ever need to be fully usable.</description>
    </item>
    
    <item>
      <title>Header files: Multiple-inclusion protection</title>
      <link>https://jmmv.dev/2013/11/header-files-multiple-inclusion.html</link>
      <pubDate>Thu, 21 Nov 2013 12:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/11/header-files-multiple-inclusion.html</guid>
      <description>Let&amp;rsquo;s start the series with something simple: the basic structure of header files and why and how to protect against multiple inclusion.
The rule The basic use of header files is to provide symbol declarations for functions and globals. Because multiple declarations of a given symbol in a single translation unit are a syntax error, you have to defensively structure your header files to not redefine anything in case they are included multiple times.</description>
    </item>
    
    <item>
      <title>Header files: Series introduction</title>
      <link>https://jmmv.dev/2013/11/header-files-series-introduction.html</link>
      <pubDate>Mon, 18 Nov 2013 22:30:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2013/11/header-files-series-introduction.html</guid>
      <description>As I started typing a supposedly-simple post on header files, I realized that what I was explaining could easily be split into various posts and significantly extended with additional content, so here comes a new (short) series on these special little files in the need of careful attention.
Quoting the Wikipedia:
 A header file is a file that allows programmers to separate certain elements of a program&amp;rsquo;s source code into reusable files.</description>
    </item>
    
  </channel>
</rss>
