<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unix on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/unix/index/</link><description>Recent content in unix on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 17 Nov 2023 08:50:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/tags/unix/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>SSH agent forwarding and tmux done right</title><link>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</link><pubDate>Fri, 17 Nov 2023 08:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</guid><description>The SSH agent is a little daemon that holds your private keys in memory. This is particularly handy when your keys are protected by a passphrase: you can unlock and add your keys to the agent once and, from then on, any SSH client such as ssh(1) can interact with the keys without asking you for the passphrase again.
The SSH agent becomes even handier when you primarily work on a remote workstation over SSH.</description></item><item><title>Useless use of GNU</title><link>https://jmmv.dev/2021/08/useless-use-of-gnu.html</link><pubDate>Wed, 25 Aug 2021 09:10:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/useless-use-of-gnu.html</guid><description>The GNU project is the source of the Unix userland utilities used on most Linux distributions. Its compatibility with standards and other Unix systems, or lack thereof, directly impacts the overall portability of any piece of software developed from GNU/Linux installations. Unfortunately, the GNU userland does not closely adhere to standards, and its widespread usage causes little incompatibilities to creep into any software created on GNU/Linux systems. Read on for why this is a problem and the pitfalls you will encounter.</description></item><item><title>Argument processing in Unix and Windows</title><link>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</link><pubDate>Mon, 02 Nov 2020 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</guid><description>Let&amp;rsquo;s continue our dive into the very interesting topic of how Unix (or Linux or what have you) and Windows differ regarding argument processing. And by that I mean: how a program (the caller) communicates the set of arguments to pass to another program (the callee) at execution time, how the callee receives such arguments, and what are the consequences of each design.</description></item><item><title>Flags parsing in PowerShell (vs. Unix)</title><link>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</link><pubDate>Wed, 28 Oct 2020 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</guid><description>The way PowerShell handles flags in scripts (aka cmdlets) differs completely from what Unix shells do. These differences allow PowerShell to gain insight on how scripts have to be executed, which in turn can deliver a better interactive user experience. Read on for a comparison while wearing Unix-tinted glasses.</description></item><item><title>A tour of directories as system-wide databases</title><link>https://jmmv.dev/2020/08/database-directories.html</link><pubDate>Fri, 21 Aug 2020 07:30:00 -0400</pubDate><guid>https://jmmv.dev/2020/08/database-directories.html</guid><description>In the previous post, we saw how .d directories permit programmatic edits to system-wide configuration with ease. But this same concept can be applied to other kinds of tracking. Let&amp;rsquo;s dive into a few examples ranging from desktop menu entries to the package manager&amp;rsquo;s database itself.</description></item><item><title>Configuration files and .d directories</title><link>https://jmmv.dev/2020/08/config-files-vs-directories.html</link><pubDate>Mon, 17 Aug 2020 07:00:00 -0400</pubDate><guid>https://jmmv.dev/2020/08/config-files-vs-directories.html</guid><description>Have you ever wondered why an increasing number of programs are configured by placing small files in .d directories instead of by just editing a single file? Have you ever wondered why these .d directories seem to proliferate in Linux installations? Read on to understand what these are and why they are useful.</description></item><item><title>Waiting for process groups, macOS edition</title><link>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</link><pubDate>Fri, 15 Nov 2019 11:00:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</guid><description>In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (#10245) is the following: given a process group, wait for all of its processes to fully terminate.
macOS has a bunch of fancy features that other systems do not have, but process control is not among them.</description></item><item><title>Waiting for process groups, Linux edition</title><link>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</link><pubDate>Thu, 14 Nov 2019 11:30:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</guid><description>In the previous post, we saw why waiting for a process group to terminate is important (at least in the context of Bazel), and we also saw why this is a difficult thing to do in a portable manner. So today, let&amp;rsquo;s dive into how to do this properly on a Linux system.
On Linux, we have two routes: using the child subreaper feature or using PID namespaces. We&amp;rsquo;ll focus on the former because that&amp;rsquo;s what we&amp;rsquo;ll use to fix (#10245) the process wrapper1, and because they are sufficient to fully address our problem.</description></item><item><title>Waiting for process groups, introduction</title><link>https://jmmv.dev/2019/11/wait-for-process-group.html</link><pubDate>Tue, 12 Nov 2019 14:20:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group.html</guid><description>Process groups are a feature of Unix systems to group related processes under a common identifier, known as the PGID. Using the PGID, one can look for these related process and send signals in unison to them. This is typically used by shell interpreters to manage processes.
For example, let&amp;rsquo;s launch a shell command that puts two sleep invocations in the background (those with the 10- and 20-second delays) and then sleeps the direct child (with a 5-second delay)&amp;mdash;while also putting the whole invocation in the background so that we can inspect what&amp;rsquo;s going on:</description></item><item><title>Bazel's process-wrapper helper tool</title><link>https://jmmv.dev/2019/11/bazel-process-wrapper.html</link><pubDate>Fri, 08 Nov 2019 15:30:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/bazel-process-wrapper.html</guid><description>As strange as it may sound, a very important job of any build tool is to orchestrate the execution of lots of other programs&amp;mdash;and Bazel is no exception.
Once Bazel has finished loading and analyzing the build graph, Bazel enters the execution phase. In this phase, the primary thing that Bazel does is walk the graph looking for actions to execute. Then, for each action, Bazel invokes its commands&amp;mdash;things like compiler and linker invocations&amp;mdash;as subprocesses.</description></item><item><title>Safely restoring the previous working directory</title><link>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</link><pubDate>Sat, 21 Sep 2019 15:47:41 +0000</pubDate><guid>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</guid><description>The current working directory, or CWD for short, is a process-wide property. It is good practice to treat the CWD as read-only because it is essentially global state: if you change the CWD of your process at any point, any relative paths you might have stored in memory1 will stop working. I learned this first many years ago when using the Boost.Filesystem library: I could not find a function to change the CWD and that was very much intentional for this reason.</description></item><item><title>#! /usr/bin/env considered harmful</title><link>https://jmmv.dev/2016/09/env-considered-harmful.html</link><pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate><guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid><description>Many programming guides recommend to begin scripts with the #! /usr/bin/env shebang in order to to automatically locate the necessary interpreter. For example, for a Python script you would use #! /usr/bin/env python, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.
The reason for this recommendation is that /usr/bin/env python will search the PATH for a program called python and execute the first one found&amp;hellip; and that usually works fine on one&amp;rsquo;s own machine.</description></item><item><title>set -e and set -x</title><link>https://jmmv.dev/2010/01/set-e-and-set-x.html</link><pubDate>Sun, 24 Jan 2010 16:52:00 -0500</pubDate><guid>https://jmmv.dev/2010/01/set-e-and-set-x.html</guid><description>If you write shell scripts, you definitely need to know about two nice features that can be enabled through the set builtin:
set -e: Enables checking of all commands. If a command exits with an error and the caller does not check such error, the script aborts immediately. Enabling this will make your scripts more robust. But don&amp;rsquo;t wait until your script is &amp;ldquo;complete&amp;rdquo; to set the flag as an afterthought, because it will be a nightmare to fix the scrip to work with this feature enabled.</description></item><item><title>Doesn't 'ls f*' do what you expect?</title><link>https://jmmv.dev/2006/12/doesnt-ls-d-f-do-what-you-expect.html</link><pubDate>Tue, 19 Dec 2006 09:14:00 -0500</pubDate><guid>https://jmmv.dev/2006/12/doesnt-ls-d-f-do-what-you-expect.html</guid><description>If you have ever ran ls on a directory whose contents don't fit on screen, you may have tried to list only a part of it by passing a wildcard to the command. For example, if you were only interested in all directory entries starting with an f, you might have tried ls f*. But did that do what you expected? Most likely not if any of those matching entries was a directory.</description></item><item><title>Lightweight Web Serving With thttpd</title><link>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</link><pubDate>Thu, 13 Oct 2005 09:00:00 +0000</pubDate><guid>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</guid><description>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
The Apache HTTP Server is the most popular web server due to its functionality, stability, and maturity.</description></item></channel></rss>