<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unix on jmmv.dev</title>
    <link>https://jmmv.dev/tags/unix/index/</link>
    <description>Recent content in unix on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Nov 2020 06:30:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/tags/unix/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Argument processing in Unix and Windows</title>
      <link>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</link>
      <pubDate>Mon, 02 Nov 2020 06:30:00 -0800</pubDate>
      
      <guid>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</guid>
      <description>Let&amp;rsquo;s continue our dive into the very interesting topic of how Unix (or Linux or what have you) and Windows differ regarding argument processing. And by that I mean: how a program (the caller) communicates the set of arguments to pass to another program (the callee) at execution time, how the callee receives such arguments, and what are the consequences of each design.
NOTE: Pay attention to this post because this is interview-level material for a systems internals session!</description>
    </item>
    
    <item>
      <title>Flags parsing in PowerShell (vs. Unix)</title>
      <link>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</link>
      <pubDate>Wed, 28 Oct 2020 06:45:00 -0700</pubDate>
      
      <guid>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</guid>
      <description>One of my personal goals with my new position at Microsoft is to learn more about Windows and its ecosystem. As you know, I&amp;rsquo;m a systems person and I&amp;rsquo;ve been in the Unix and macOS realm for the last&amp;hellip; 22 years or so. During this time, I&amp;rsquo;ve certainly touched Windows here and there but, for the most part, a lot of it remains a mystery to me.
Yesterday already, I uncovered a couple of interesting things worth discussing.</description>
    </item>
    
    <item>
      <title>A tour of directories as system-wide databases</title>
      <link>https://jmmv.dev/2020/08/database-directories.html</link>
      <pubDate>Fri, 21 Aug 2020 07:30:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/08/database-directories.html</guid>
      <description>In &amp;ldquo;[Configuration files and .d directories]({{ relref &amp;ldquo;config-files-vs-directories.md&amp;rdquo; }})&amp;rdquo;, we learned how .d directories permit programmatic edits to system-wide configuration with ease. But this same concept&amp;mdash;using directories with many individual files within instead of a single gigantic file&amp;mdash;can be applied to other kinds of system-wide tracking.
I know it&amp;rsquo;s a stretch, but if it helps you in these modern times, you can think of a directory as a NoSQL database or a key/value store where each file represents a row/key and its contents represent the value of that entity.</description>
    </item>
    
    <item>
      <title>Configuration files and .d directories</title>
      <link>https://jmmv.dev/2020/08/config-files-vs-directories.html</link>
      <pubDate>Mon, 17 Aug 2020 07:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/08/config-files-vs-directories.html</guid>
      <description>Have you ever wondered why an increasing number of programs are configured by placing small files in .d directories instead of by just editing a single file?
Have you ever wondered why these .d directories seem to proliferate in UnixLinux installations? Because a pretty bare-bones Debian installation (WSL) shows&amp;hellip; a ton of them:
debian:/etc&amp;gt; ls -ld *.d */*.d drwxr-xr-x 1 root root 4096 Aug 14 22:23 apparmor.d drwxr-xr-x 1 root root 4096 Aug 9 08:10 apt/apt.</description>
    </item>
    
    <item>
      <title>Waiting for process groups, macOS edition</title>
      <link>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</link>
      <pubDate>Fri, 15 Nov 2019 11:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</guid>
      <description>In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (#10245) is the following: given a process group, wait for all of its processes to fully terminate.
macOS has a bunch of fancy features that other systems do not have, but process control is not among them.</description>
    </item>
    
    <item>
      <title>Waiting for process groups, Linux edition</title>
      <link>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</link>
      <pubDate>Thu, 14 Nov 2019 11:30:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</guid>
      <description>In the previous post, we saw why waiting for a process group to terminate is important (at least in the context of Bazel), and we also saw why this is a difficult thing to do in a portable manner. So today, let&amp;rsquo;s dive into how to do this properly on a Linux system.
On Linux, we have two routes: using the child subreaper feature or using PID namespaces. We&amp;rsquo;ll focus on the former because that&amp;rsquo;s what we&amp;rsquo;ll use to fix (#10245) the process wrapper1, and because they are sufficient to fully address our problem.</description>
    </item>
    
    <item>
      <title>Waiting for process groups, introduction</title>
      <link>https://jmmv.dev/2019/11/wait-for-process-group.html</link>
      <pubDate>Tue, 12 Nov 2019 14:20:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/11/wait-for-process-group.html</guid>
      <description>Process groups are a feature of Unix systems to group related processes under a common identifier, known as the PGID. Using the PGID, one can look for these related process and send signals in unison to them. This is typically used by shell interpreters to manage processes.
For example, let&amp;rsquo;s launch a shell command that puts two sleep invocations in the background (those with the 10- and 20-second delays) and then sleeps the direct child (with a 5-second delay)&amp;mdash;while also putting the whole invocation in the background so that we can inspect what&amp;rsquo;s going on:</description>
    </item>
    
    <item>
      <title>Bazel&#39;s process-wrapper helper tool</title>
      <link>https://jmmv.dev/2019/11/bazel-process-wrapper.html</link>
      <pubDate>Fri, 08 Nov 2019 15:30:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/11/bazel-process-wrapper.html</guid>
      <description>As strange as it may sound, a very important job of any build tool is to orchestrate the execution of lots of other programs&amp;mdash;and Bazel is no exception.
Once Bazel has finished loading and analyzing the build graph, Bazel enters the execution phase. In this phase, the primary thing that Bazel does is walk the graph looking for actions to execute. Then, for each action, Bazel invokes its commands&amp;mdash;things like compiler and linker invocations&amp;mdash;as subprocesses.</description>
    </item>
    
    <item>
      <title>Safely restoring the previous working directory</title>
      <link>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</link>
      <pubDate>Sat, 21 Sep 2019 15:47:41 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</guid>
      <description>The current working directory, or CWD for short, is a process-wide property. It is good practice to treat the CWD as read-only because it is essentially global state: if you change the CWD of your process at any point, any relative paths you might have stored in memory1 will stop working. I learned this first many years ago when using the Boost.Filesystem library: I could not find a function to change the CWD and that was very much intentional for this reason.</description>
    </item>
    
    <item>
      <title>#! /usr/bin/env considered harmful</title>
      <link>https://jmmv.dev/2016/09/env-considered-harmful.html</link>
      <pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate>
      
      <guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid>
      <description>Many programming guides recommend to begin scripts with the #! /usr/bin/env shebang in order to to automatically locate the necessary interpreter. For example, for a Python script you would use #! /usr/bin/env python, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.
The reason for this recommendation is that /usr/bin/env python will search the PATH for a program called python and execute the first one found&amp;hellip; and that usually works fine on one&amp;rsquo;s own machine.</description>
    </item>
    
    <item>
      <title>set -e and set -x</title>
      <link>https://jmmv.dev/2010/01/set-e-and-set-x.html</link>
      <pubDate>Sun, 24 Jan 2010 16:52:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2010/01/set-e-and-set-x.html</guid>
      <description>If you write shell scripts, you definitely need to know about two nice features that can be enabled through the set builtin:
  set -e: Enables checking of all commands. If a command exits with an error and the caller does not check such error, the script aborts immediately. Enabling this will make your scripts more robust. But don&amp;rsquo;t wait until your script is &amp;ldquo;complete&amp;rdquo; to set the flag as an afterthought, because it will be a nightmare to fix the scrip to work with this feature enabled.</description>
    </item>
    
    <item>
      <title>Doesn&#39;t &#39;ls f*&#39; do what you expect?</title>
      <link>https://jmmv.dev/2006/12/doesnt-ls-d-f-do-what-you-expect.html</link>
      <pubDate>Tue, 19 Dec 2006 09:14:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2006/12/doesnt-ls-d-f-do-what-you-expect.html</guid>
      <description>If you have ever ran ls on a directory whose contents don&#39;t fit on screen, you may have tried to list only a part of it by passing a wildcard to the command. For example, if you were only interested in all directory entries starting with an f, you might have tried ls f*. But did that do what you expected? Most likely not if any of those matching entries was a directory.</description>
    </item>
    
    <item>
      <title>Lightweight Web Serving With thttpd</title>
      <link>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</link>
      <pubDate>Thu, 13 Oct 2005 09:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2005/10/lightweight-web-serving-with-thttpd.html</guid>
      <description>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
 The Apache HTTP Server is the most popular web server due to its functionality, stability, and maturity.</description>
    </item>
    
    <item>
      <title>Making Packager-Friendly Software (part 2)</title>
      <link>https://jmmv.dev/2005/04/making-packager-friendly-software-2.html</link>
      <pubDate>Thu, 28 Apr 2005 09:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2005/04/making-packager-friendly-software-2.html</guid>
      <description>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
 My previous article, Making Packager-Friendly Software (part 1), explains why software packaging is sometimes problematic due to real problems in the mainstream sources.</description>
    </item>
    
    <item>
      <title>Making Packager-Friendly Software (part 1)</title>
      <link>https://jmmv.dev/2005/03/making-packager-friendly-software-1.html</link>
      <pubDate>Thu, 31 Mar 2005 09:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2005/03/making-packager-friendly-software-1.html</guid>
      <description>This article first appeared on this date in O&amp;rsquo;Reilly&amp;rsquo;s ONLamp.com online publication. The content was deleted sometime in 2019 but I was lucky enough to find a copy in the WayBack Machine. I reformatted the text to fit the style of this site and fixed broken links, but otherwise the content is a verbatim reproduction of what was originally published.
 A package maintainer, or packager, is a person who creates packages for software projects.</description>
    </item>
    
  </channel>
</rss>
