<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unix on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/unix/index/</link><description>Recent content in unix on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Oct 2024 09:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/unix/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>The costs of the i386 to x86-64 upgrade</title><link>https://jmmv.dev/2024/10/x86-64-programming-models.html</link><pubDate>Mon, 07 Oct 2024 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/10/x86-64-programming-models.html</guid><description>&lt;p>If you read my previous article on &lt;a href="https://jmmv.dev/2024/09/dos-memory-models.html">DOS memory models&lt;/a>, you may have dismissed everything I wrote as &amp;ldquo;legacy cruft from the 1990s that nobody cares about any longer&amp;rdquo;. After all, computers have evolved from sporting 8-bit processors to 64-bit processors and, on the way, the amount of memory that these computers can leverage has grown orders of magnitude: the 8086, a 16-bit machine with a 20-bit address space, could only use 1MB of memory while today&amp;rsquo;s 64-bit machines can theoretically access 16EB.&lt;/p>
&lt;p>All of this growth has been in service of ever-growing programs. But&amp;hellip; even if programs are now more sophisticated than they were before, do they all &lt;em>really&lt;/em> require access to a 64-bit address space? Has the growth from 8 to 64 bits been a net positive in performance terms?&lt;/p>
&lt;p>Let&amp;rsquo;s try to answer those questions to find some very surprising answers. But first, some theory.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-10-07-x86-64-cover-image.jpg" length="992004" type="image/jpeg"/></item><item><title>Windows NT vs. Unix: A design comparison</title><link>https://jmmv.dev/2024/09/windows-nt-vs-unix-design.html</link><pubDate>Mon, 09 Sep 2024 08:30:00 -0700</pubDate><guid>https://jmmv.dev/2024/09/windows-nt-vs-unix-design.html</guid><description>Over the years, I&amp;rsquo;ve repeatedly heard that Windows NT is a very advanced operating system and, being a Unix person myself, it has bothered me to not know why. I&amp;rsquo;ve been meaning to answer this question for years and I can do so now, which means I want to present you my findings.
My desire to know about NT&amp;rsquo;s internals started in 2006 when I applied to the Google Summer of Code program to develop Boost.</description><enclosure url="https://jmmv.dev/images/2024-09-09-windows-nt-vs-unix-design.jpg" length="1049554" type="image/jpeg"/></item><item><title>Picking glibc versions at runtime</title><link>https://jmmv.dev/2024/08/glibc-versions-runtime.html</link><pubDate>Sun, 11 Aug 2024 10:15:00 +0200</pubDate><guid>https://jmmv.dev/2024/08/glibc-versions-runtime.html</guid><description>In a recent work discussion, I came across an argument that didn&amp;rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a modern glibc. The justifications were that using LD_LIBRARY_PATH to load a different glibc didn&amp;rsquo;t work and statically linking glibc wasn&amp;rsquo;t possible either.
But&amp;hellip; running a program against a version of glibc that&amp;rsquo;s different from the one installed on the system seems like a pretty standard requirement, doesn&amp;rsquo;t it?</description><enclosure url="https://jmmv.dev/images/2024-08-11-glibc-versions-runtime-dynamic.png" length="36593" type="image/jpeg"/></item><item><title>SSH agent forwarding and tmux done right</title><link>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</link><pubDate>Fri, 17 Nov 2023 08:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html</guid><description>The SSH agent is a little daemon that holds your private keys in memory. This is particularly handy when your keys are protected by a passphrase: you can unlock and add your keys to the agent once and, from then on, any SSH client such as ssh(1) can interact with the keys without asking you for the passphrase again.
The SSH agent becomes even handier when you primarily work on a remote workstation over SSH.</description></item><item><title>Useless use of GNU</title><link>https://jmmv.dev/2021/08/useless-use-of-gnu.html</link><pubDate>Wed, 25 Aug 2021 09:10:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/useless-use-of-gnu.html</guid><description>The GNU project is the source of the Unix userland utilities used on most Linux distributions. Its compatibility with standards and other Unix systems, or lack thereof, directly impacts the overall portability of any piece of software developed from GNU/Linux installations. Unfortunately, the GNU userland does not closely adhere to standards, and its widespread usage causes little incompatibilities to creep into any software created on GNU/Linux systems. Read on for why this is a problem and the pitfalls you will encounter.</description></item><item><title>Argument processing in Unix and Windows</title><link>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</link><pubDate>Mon, 02 Nov 2020 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/11/cmdline-args-unix-vs-windows.html</guid><description>Let&amp;rsquo;s continue our dive into the very interesting topic of how Unix (or Linux or what have you) and Windows differ regarding argument processing. And by that I mean: how a program (the caller) communicates the set of arguments to pass to another program (the callee) at execution time, how the callee receives such arguments, and what are the consequences of each design.</description></item><item><title>Flags parsing in PowerShell (vs. Unix)</title><link>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</link><pubDate>Wed, 28 Oct 2020 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2020/10/powershell-cmdlet-params.html</guid><description>The way PowerShell handles flags in scripts (aka cmdlets) differs completely from what Unix shells do. These differences allow PowerShell to gain insight on how scripts have to be executed, which in turn can deliver a better interactive user experience. Read on for a comparison while wearing Unix-tinted glasses.</description></item><item><title>A tour of directories as system-wide databases</title><link>https://jmmv.dev/2020/08/database-directories.html</link><pubDate>Fri, 21 Aug 2020 07:30:00 -0400</pubDate><guid>https://jmmv.dev/2020/08/database-directories.html</guid><description>In the previous post, we saw how .d directories permit programmatic edits to system-wide configuration with ease. But this same concept can be applied to other kinds of tracking. Let&amp;rsquo;s dive into a few examples ranging from desktop menu entries to the package manager&amp;rsquo;s database itself.</description></item><item><title>Configuration files and .d directories</title><link>https://jmmv.dev/2020/08/config-files-vs-directories.html</link><pubDate>Mon, 17 Aug 2020 07:00:00 -0400</pubDate><guid>https://jmmv.dev/2020/08/config-files-vs-directories.html</guid><description>Have you ever wondered why an increasing number of programs are configured by placing small files in .d directories instead of by just editing a single file? Have you ever wondered why these .d directories seem to proliferate in Linux installations? Read on to understand what these are and why they are useful.</description></item><item><title>Waiting for process groups, macOS edition</title><link>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</link><pubDate>Fri, 15 Nov 2019 11:00:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group-darwin.html</guid><description>In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (#10245) is the following: given a process group, wait for all of its processes to fully terminate.
macOS has a bunch of fancy features that other systems do not have, but process control is not among them.</description></item><item><title>Waiting for process groups, Linux edition</title><link>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</link><pubDate>Thu, 14 Nov 2019 11:30:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group-linux.html</guid><description>In the previous post, we saw why waiting for a process group to terminate is important (at least in the context of Bazel), and we also saw why this is a difficult thing to do in a portable manner. So today, let&amp;rsquo;s dive into how to do this properly on a Linux system.
On Linux, we have two routes: using the child subreaper feature or using PID namespaces. We&amp;rsquo;ll focus on the former because that&amp;rsquo;s what we&amp;rsquo;ll use to fix (#10245) the process wrapper1, and because they are sufficient to fully address our problem.</description></item><item><title>Waiting for process groups, introduction</title><link>https://jmmv.dev/2019/11/wait-for-process-group.html</link><pubDate>Tue, 12 Nov 2019 14:20:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/wait-for-process-group.html</guid><description>Process groups are a feature of Unix systems to group related processes under a common identifier, known as the PGID. Using the PGID, one can look for these related process and send signals in unison to them. This is typically used by shell interpreters to manage processes.
For example, let&amp;rsquo;s launch a shell command that puts two sleep invocations in the background (those with the 10- and 20-second delays) and then sleeps the direct child (with a 5-second delay)&amp;mdash;while also putting the whole invocation in the background so that we can inspect what&amp;rsquo;s going on:</description></item><item><title>Bazel's process-wrapper helper tool</title><link>https://jmmv.dev/2019/11/bazel-process-wrapper.html</link><pubDate>Fri, 08 Nov 2019 15:30:00 +0000</pubDate><guid>https://jmmv.dev/2019/11/bazel-process-wrapper.html</guid><description>As strange as it may sound, a very important job of any build tool is to orchestrate the execution of lots of other programs&amp;mdash;and Bazel is no exception.
Once Bazel has finished loading and analyzing the build graph, Bazel enters the execution phase. In this phase, the primary thing that Bazel does is walk the graph looking for actions to execute. Then, for each action, Bazel invokes its commands&amp;mdash;things like compiler and linker invocations&amp;mdash;as subprocesses.</description></item><item><title>Safely restoring the previous working directory</title><link>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</link><pubDate>Sat, 21 Sep 2019 15:47:41 +0000</pubDate><guid>https://jmmv.dev/2019/09/safe-chdir-to-previous.html</guid><description>The current working directory, or CWD for short, is a process-wide property. It is good practice to treat the CWD as read-only because it is essentially global state: if you change the CWD of your process at any point, any relative paths you might have stored in memory1 will stop working. I learned this first many years ago when using the Boost.Filesystem library: I could not find a function to change the CWD and that was very much intentional for this reason.</description></item><item><title>#! /usr/bin/env considered harmful</title><link>https://jmmv.dev/2016/09/env-considered-harmful.html</link><pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate><guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid><description>Many programming guides recommend to begin scripts with the #! /usr/bin/env shebang in order to to automatically locate the necessary interpreter. For example, for a Python script you would use #! /usr/bin/env python, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.
The reason for this recommendation is that /usr/bin/env python will search the PATH for a program called python and execute the first one found&amp;hellip; and that usually works fine on one&amp;rsquo;s own machine.</description></item></channel></rss>