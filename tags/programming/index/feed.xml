<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/programming/index/</link><description>Recent content in programming on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 31 Aug 2023 07:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/programming/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Costs exposed: Frameworks</title><link>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</link><pubDate>Thu, 31 Aug 2023 07:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</guid><description>&lt;p>&lt;a href="https://jmmv.dev/2023/06/fast-machines-slow-machines.html">&amp;ldquo;Fast machines, slow machines&amp;rdquo;&lt;/a>&amp;hellip; ah, the post that spawned these series. As I frantically typed that article while replying to angry tweets, the thought came to mind: software engineering as a whole is hyper-focused on lowering the costs to write new code, yet there is a disregard for the costs that these improvements bring to other disciplines in a company on even to end users.&lt;/p>
&lt;p>So, in this series finale, I want to compare how some choices that apparently lower development costs actually increase costs elsewhere. I also want to highlight how, if we made different decisions during development, we could possibly expose those extra costs early on. This is beneficial because exposing costs upfront allows us to make tough choices when there is still a chance of changing course.&lt;/p>
&lt;p>To make things specific, I will look at how the use of modern frameworks that facilitate development can end up hurting performance, reliability, and usability. So let&amp;rsquo;s start with a three-part rant first (sorry) and then let&amp;rsquo;s look at what we might do.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-31-dirt-pile.jpg" length="773447" type="image/jpeg"/></item><item><title>Costs exposed: On-call ticket handling</title><link>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</link><pubDate>Sat, 26 Aug 2023 07:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</guid><description>&lt;p>In the previous post, I proposed that certain engineering practices expose systemic costs and help with planning while other practices hide those same costs and disturb ongoing plans.&lt;/p>
&lt;p>The idea I&amp;rsquo;m trying to convey is hard to communicate in the abstract so, in that post, I used the differences between a monorepo and a multirepo setup as an example. Today, I&amp;rsquo;ll expore a different scenario to support the same idea. I&amp;rsquo;m going to talk about how certain ticket assignment practices during on-call operations can expose service support costs vs. how other practices hide them.&lt;/p>
&lt;p>Keep in mind that, just like in the previous post, I do not want to compare the general merits of one approach vs. the other. The &lt;em>only&lt;/em> thing I want to compare is whether one approach centralizes toil and allows management to quantify its cost vs. how another approach hides toil by smearing it over the whole team in hard-to-quantify ways. Whether management &lt;em>actually does something&lt;/em> to correct the situation once the costs are exposed is a different story.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-26-tickets-phone.jpg" length="539252" type="image/jpeg"/></item><item><title>Costs exposed: Monorepo vs. multirepo</title><link>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</link><pubDate>Wed, 23 Aug 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</guid><description>&lt;p>In software engineering organizations, there are certain practices that keep costs under control even if those &lt;em>seem&lt;/em> more expensive at first. Unfortunately, because such practices &lt;em>feel&lt;/em> more expensive, teams choose to keep their status quo even when they know it is suboptimal. This choice ends up hurting productivity and morale because planned work is continuously interrupted, which in turn drags project completion.&lt;/p>
&lt;p>The reason I say &lt;em>seem&lt;/em> and not &lt;em>are&lt;/em> is because the alternatives to these cost-exposing practices also suffer from costs. The difference is that, while the former surface costs, leading to the need to allocate time and people to infrastructure work, the latter keeps the costs smeared over teams and individuals in ways that are difficult to account and plan for.&lt;/p>
&lt;p>To illustrate what I&amp;rsquo;m trying to say, I&amp;rsquo;ll present three different scenarios in which this opinion applies. All of these case studies come from past personal experiences while working in different teams and projects. The first one covered in this post is about the adoption of a monorepo vs. the use of multiple different repositories. The other two will come in follow-up articles.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-23-freebsd-gnome-repos.png" length="162711" type="image/jpeg"/></item><item><title>A failed experiment with Rust static dispatch</title><link>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</link><pubDate>Sun, 06 Aug 2023 05:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</guid><description>&lt;p>Initial versions of the EndBASIC Service, and therefore initial versions of EndTRACKER, used dynamic dispatch to support abstract definitions of system services such as the database they talk to and the clock they use. This looked like a bunch of &lt;tt>Arc&lt;dyn Foo>&lt;/tt> objects passed around and was done to support extremely fast unit testing.&lt;/p>
&lt;p>When I generalized the core logic of these services into the III-IV framework, I decided to experiment with a switch to static dispatch. The rationale was that using static dispatch better aligns with the design of well-regarded crates in the Rust ecosystem, and also because I wanted to avoid unnecessary runtime costs in the foundational pieces of my web services.&lt;/p>
&lt;p>Let me tell you that this decision was a huge mistake and that the experiment has utterly failed. Using static dispatch has been a constant source of frustration due to the difficulty in passing types around and reasoning about trait bounds. The situation had gotten so bad that I dreaded adding new functionality to my services whenever a change to a statically-typed &lt;tt>struct&lt;/tt> was needed, because that meant adding yet another type parameter and plumbing it through tens of source files.&lt;/p>
&lt;p>In lieu of the difficulties, which eventually turned into blockers to implementing new features, I made the choice of going back to dynamic dispatch. The goal was to gain ergonomics at the expense of a supposedly-negligible runtime cost. Let me tell you about the problems I faced, the refactoring journey, and some measurements I gathered after the rewrite.&lt;/p></description></item><item><title>Unit-testing a web service in Rust</title><link>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</link><pubDate>Fri, 07 Jul 2023 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</guid><description>&lt;p>One of the things I'm most proud of the Rust web services I have written is how I can run their tests with zero setup and within milliseconds, all while making me confident that "main" can always be shipped to production. I've previously touched upon how this all works in other articles, but it's time for a deep dive.&lt;/p>
&lt;p>To make things specific, I'll be describing the testing infrastructure of EndTRACKER, the EndBASIC Service, and the sample key/value store app of III-IV. These services are all structured in three separate layers, and I'll be covering the testing strategy for each of them.&lt;/p></description></item><item><title>Useless use of GNU</title><link>https://jmmv.dev/2021/08/useless-use-of-gnu.html</link><pubDate>Wed, 25 Aug 2021 09:10:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/useless-use-of-gnu.html</guid><description>The GNU project is the source of the Unix userland utilities used on most Linux distributions. Its compatibility with standards and other Unix systems, or lack thereof, directly impacts the overall portability of any piece of software developed from GNU/Linux installations. Unfortunately, the GNU userland does not closely adhere to standards, and its widespread usage causes little incompatibilities to creep into any software created on GNU/Linux systems. Read on for why this is a problem and the pitfalls you will encounter.</description></item><item><title>Should the browser use all available memory?</title><link>https://jmmv.dev/2021/08/using-all-memory-as-a-cache.html</link><pubDate>Thu, 12 Aug 2021 09:30:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/using-all-memory-as-a-cache.html</guid><description>We have all seen discussions go like this: someone first complains that an application like Google Chrome is wasteful because it uses multiple GBs of memory. Someone else comes along and says that memory is there to be used for speed and therefore this is the correct behavior: if the computer has multiple GBs of free memory, an application such as Chrome should make use of all the available memory in the form of a cache to be as responsive as possible. Makes sense, right? Yes, it does makes sense&amp;mdash;as long as Chrome is the only application running. Let&amp;rsquo;s explore why this is not a great idea.</description></item><item><title>EndBASIC 0.6 release announcement</title><link>https://jmmv.dev/2021/02/endbasic-0.6.html</link><pubDate>Fri, 19 Feb 2021 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2021/02/endbasic-0.6.html</guid><description>After a very active month of development since the 0.5 announcement, it is time to welcome EndBASIC 0.6!
This new 0.6 release is super-exciting for three reasons:
preliminary GPIO support in the standard library specifically tailored to the Raspberry Pi; multidimensional array support in the language; and availability of binary releases for the most common platforms. You can dive right in by:
visiting https://repl.endbasic.dev/ for an interactive session, reading more about the project at https://www.</description></item><item><title>Embedding EndBASIC into a (Rust) program</title><link>https://jmmv.dev/2021/01/embedding-endbasic.html</link><pubDate>Tue, 26 Jan 2021 07:20:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/embedding-endbasic.html</guid><description>One thing that bothers me quite a lot about various language implementations is that the core of their interpreter isn&amp;rsquo;t clearly separate from their standard library. This makes it hard to embed those interpreters into other programs because it&amp;rsquo;s not obvious how to limit their side-effects and because the interpreter dependency can be heavy. In this post, we will see how EndBASIC&amp;rsquo;s design tries hard to keep the core as small as possible, and we will see some examples on how to use EndBASIC from Rust and vice versa.</description></item><item><title>EndBASIC 0.5 release announcement</title><link>https://jmmv.dev/2021/01/endbasic-0.5.html</link><pubDate>Sun, 24 Jan 2021 08:00:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/endbasic-0.5.html</guid><description>A month has passed since the 0.4.0 announcement so it is about time to say hello to yet another EndBASIC release because 0.5.0 is here! So, what&amp;rsquo;s new? Not much&amp;hellip; unless you look under the covers, in which case a &lt;em>ton&lt;/em> has changed. About 30% of the codebase has been affected in one way or another to improve general quality, so read on to see how.</description></item><item><title>EndBASIC 0.4 release announcement</title><link>https://jmmv.dev/2020/12/endbasic-0.4.html</link><pubDate>Fri, 25 Dec 2020 19:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/endbasic-0.4.html</guid><description>About a month ago and after a long hiatus, I published EndBASIC 0.3 and the adrenaline rush that came with it got my wheels spinning again full-steam ahead. So here I am today, ready to announce the 0.4 release. But&amp;hellip; &amp;ldquo;what could have possibly changed in just a month of someone&amp;rsquo;s free time&amp;rdquo;, you wonder? Enough, actually!
EndBASIC 0.4 is the release that fulfills my original goal of being able to run a &amp;ldquo;guess the number&amp;rdquo; game.</description></item><item><title>Unit-testing a console app (a text editor)</title><link>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</link><pubDate>Tue, 08 Dec 2020 10:00:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</guid><description>The most notable feature in EndBASIC 0.3 is its new full-screen console-based text editor. In this post, I describe why it is important and useful to unit-test a console app like this, and I will dive into how to implement unit tests that catch regressions and inefficiencies. Code samples are in Rust, but the concepts presented here are applicable to any language with minimal data abstraction facilities.</description></item><item><title>Using the builder pattern to define test scenarios</title><link>https://jmmv.dev/2020/12/builder-pattern-for-tests.html</link><pubDate>Fri, 04 Dec 2020 09:40:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/builder-pattern-for-tests.html</guid><description>&lt;p>I&amp;rsquo;ve been playing with the builder patter to express test scenarios in a succinct and declarative manner. I&amp;rsquo;ve liked the outcome and feel that this design can yield to pretty good test code, so I&amp;rsquo;ll dig through this idea here. Note that, while this post and the associated code talk about Rust, &lt;strong>the ideas presented here apply to any language&lt;/strong>. So don&amp;rsquo;t leave just because I said Rust!&lt;/p></description></item><item><title>EndBASIC 0.3 is here</title><link>https://jmmv.dev/2020/11/endbasic-0.3.html</link><pubDate>Sun, 29 Nov 2020 12:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/11/endbasic-0.3.html</guid><description>After a 6-month long hiatus caused by me hunting and changing jobs and cities, I am pleased to announce the release of EndBASIC 0.3! The Thanksgiving break has been as fruitful as I had hoped 😁
There are two major changes in this release.
The first is the official debut of the web-based interface. I introduced this months ago and have had it running on a &amp;ldquo;push on green&amp;rdquo; model, which means that the web deployment of EndBASIC is always tracking Git HEAD.</description></item><item><title>Bridging the web gap in EndBASIC</title><link>https://jmmv.dev/2020/05/bridging-the-web-gap-endbasic.html</link><pubDate>Sat, 30 May 2020 08:50:00 -0400</pubDate><guid>https://jmmv.dev/2020/05/bridging-the-web-gap-endbasic.html</guid><description>After a ton of work, a lot of which was unexpected, I am ecstatic to announce that EndBASIC is now a reality on the web! The whole language interpreter can now run as a fully client-side web app on a computer, on a tablet&amp;hellip; and even on a phone. Yes: the whole thing, which is written in Rust (94%), works in a modern browser with just a tiny bit of JavaScript glue (1%).</description></item></channel></rss>