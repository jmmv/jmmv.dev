<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/programming/index.html</link><description>Recent content in Programming on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 11 Aug 2024 10:15:00 +0200</lastBuildDate><atom:link href="https://jmmv.dev/tags/programming/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Picking glibc versions at runtime</title><link>https://jmmv.dev/2024/08/glibc-versions-runtime.html</link><pubDate>Sun, 11 Aug 2024 10:15:00 +0200</pubDate><guid>https://jmmv.dev/2024/08/glibc-versions-runtime.html</guid><description>&lt;p>In a recent work discussion, I came across an argument that didn&amp;rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a modern glibc. The justifications were that using &lt;code>LD_LIBRARY_PATH&lt;/code> to load a different glibc didn&amp;rsquo;t work and statically linking glibc wasn&amp;rsquo;t possible either.&lt;/p>
&lt;p>But&amp;hellip; running a program against a version of glibc that&amp;rsquo;s different from the one installed on the system seems like a pretty standard requirement, doesn&amp;rsquo;t it? Consider this: how do the developers of glibc test their changes? glibc has existed for much longer than containers have. And before containers existed, they surely weren&amp;rsquo;t testing glibc changes by installing modified versions of the library over the system-wide one and YOLOing it.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-08-11-glibc-versions-runtime-dynamic.png" length="36593" type="image/jpeg"/></item><item><title>To C or not to C</title><link>https://jmmv.dev/2024/02/to-c-or-not-to-c.html</link><pubDate>Wed, 21 Feb 2024 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2024/02/to-c-or-not-to-c.html</guid><description>&lt;p>Over the last few days, there has been this&amp;hellip; debate over at Twitter sparked by a claim that you cannot be a good programmer without knowing C. You obviously can be one, but there is some nuance in what &amp;ldquo;knowing&amp;rdquo; C is truly about. Here is my take on the matter.&lt;/p>
&lt;p>Let me repeat this first: of course you can be a perfectly good programmer without knowing C. Knowing &lt;em>a language&lt;/em> doesn&amp;rsquo;t make or break a programmer, and there are great programmers out there that don&amp;rsquo;t touch C. &lt;em>However&lt;/em>, knowing C says something about your &lt;em>journey&lt;/em>.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-02-21-to-c-or-not-to-c.png" length="326255" type="image/jpeg"/></item><item><title>Code reviews: A success story</title><link>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</link><pubDate>Tue, 21 Nov 2023 13:50:00 -0800</pubDate><guid>https://jmmv.dev/2023/11/code-reviews-a-success-story.html</guid><description>&lt;p>Code reviews have a bad rep: they are antagonistic in nature and, sometimes, pure red tape. Some argue that they are bad practice; others say that peer programming is better. And while these &lt;em>may&lt;/em> be true, I want to tell you a story about a case where code reviews worked well!&lt;/p>
&lt;p>Meet X: a junior engineer in the Bazel team circa 2018, tasked to implement two features: A and B. As you may know, Google is big into code reviews&amp;mdash;and their tooling for this is awesome; believe me&amp;mdash;so this was the standard process for X to get his code checked in.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-21-code-review.png" length="134980" type="image/jpeg"/></item><item><title>5 ways to instantiate Rust structs in tests</title><link>https://jmmv.dev/2023/10/rust-test-structs.html</link><pubDate>Fri, 06 Oct 2023 09:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/10/rust-test-structs.html</guid><description>&lt;p>I&amp;rsquo;m a big fan of static typing and I&amp;rsquo;ve found that using narrow types for each entity in the object model of my programs reduces errors. Rust is particularly well-suited at this task: its lack of implicit type conversions eliminates surprises, and its ownership semantics allow type transformations with zero cost.&lt;/p>
&lt;p>Unfortunately, (ab)using narrow types in an app&amp;rsquo;s domain is &lt;em>really&lt;/em> annoying when writing tests. While non-test code rarely instantiates new objects&amp;mdash;in the case of a REST service, this would only happen at the service&amp;rsquo;s boundaries&amp;mdash;tests instantiate objects infinitely more times than non-test code. Code patterns that may seem reasonable in non-test code can become unbearable in tests.&lt;/p>
&lt;p>In this post, I want to look into the various ways in which you can instantiate strongly-typed objects. For each, I show examples and describe their pros and cons. And yes, as a matter of fact, I have tried them all before&amp;hellip; and I can&amp;rsquo;t yet make my mind as to which one is best.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-06-rust-test-structs.png" length="138979" type="image/jpeg"/></item><item><title>Good performance is not just big O</title><link>https://jmmv.dev/2023/09/performance-is-not-big-o.html</link><pubDate>Fri, 08 Sep 2023 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/09/performance-is-not-big-o.html</guid><description>&lt;p>Having a fast and responsive app is orthogonal to &amp;ldquo;knowing your big &lt;i>O&lt;/i>s&amp;rdquo;. Unfortunately, most tech companies over-emphasize algorithms in interviews and downplay systems knowledge, and I believe that&amp;rsquo;s one reason behind sluggish apps and bloated systems.&lt;/p>
&lt;p>I&amp;rsquo;ve seen this play out repeatedly. Interviewers ask a LeetCode-style coding question, which is then followed by the ritual of discussing time and memory complexity. Candidates ace the answers. But then&amp;hellip; their &amp;ldquo;real&amp;rdquo; code suffers from subtle yet impactful performance problems.&lt;/p>
&lt;p>Focusing on big &lt;em>O&lt;/em> complexity rarely matters in most apps. Sure, it&amp;rsquo;s important to think about your algorithmic choices, but there are so many more details to worry about that have a direct impact on app performance and responsiveness. Let&amp;rsquo;s look at a bunch of them!&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-09-08-speed-bumps-limit.jpg" length="372231" type="image/jpeg"/></item><item><title>Costs exposed: Frameworks</title><link>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</link><pubDate>Thu, 31 Aug 2023 07:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</guid><description>&lt;p>&lt;a href="https://jmmv.dev/2023/06/fast-machines-slow-machines.html">&amp;ldquo;Fast machines, slow machines&amp;rdquo;&lt;/a>&amp;hellip; ah, the post that spawned these series. As I frantically typed that article while replying to angry tweets, the thought came to mind: software engineering as a whole is hyper-focused on lowering the costs to write new code, yet there is a disregard for the costs that these improvements bring to other disciplines in a company on even to end users.&lt;/p>
&lt;p>So, in this series finale, I want to compare how some choices that apparently lower development costs actually increase costs elsewhere. I also want to highlight how, if we made different decisions during development, we could possibly expose those extra costs early on. This is beneficial because exposing costs upfront allows us to make tough choices when there is still a chance of changing course.&lt;/p>
&lt;p>To make things specific, I will look at how the use of modern frameworks that facilitate development can end up hurting performance, reliability, and usability. So let&amp;rsquo;s start with a three-part rant first (sorry) and then let&amp;rsquo;s look at what we might do.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-31-dirt-pile.jpg" length="773447" type="image/jpeg"/></item><item><title>Costs exposed: On-call ticket handling</title><link>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</link><pubDate>Sat, 26 Aug 2023 07:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</guid><description>&lt;p>In the previous post, I proposed that certain engineering practices expose systemic costs and help with planning while other practices hide those same costs and disturb ongoing plans.&lt;/p>
&lt;p>The idea I&amp;rsquo;m trying to convey is hard to communicate in the abstract so, in that post, I used the differences between a monorepo and a multirepo setup as an example. Today, I&amp;rsquo;ll expore a different scenario to support the same idea. I&amp;rsquo;m going to talk about how certain ticket assignment practices during on-call operations can expose service support costs vs. how other practices hide them.&lt;/p>
&lt;p>Keep in mind that, just like in the previous post, I do not want to compare the general merits of one approach vs. the other. The &lt;em>only&lt;/em> thing I want to compare is whether one approach centralizes toil and allows management to quantify its cost vs. how another approach hides toil by smearing it over the whole team in hard-to-quantify ways. Whether management &lt;em>actually does something&lt;/em> to correct the situation once the costs are exposed is a different story.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-26-tickets-phone.jpg" length="539252" type="image/jpeg"/></item><item><title>Costs exposed: Monorepo vs. multirepo</title><link>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</link><pubDate>Wed, 23 Aug 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</guid><description>&lt;p>In software engineering organizations, there are certain practices that keep costs under control even if those &lt;em>seem&lt;/em> more expensive at first. Unfortunately, because such practices &lt;em>feel&lt;/em> more expensive, teams choose to keep their status quo even when they know it is suboptimal. This choice ends up hurting productivity and morale because planned work is continuously interrupted, which in turn drags project completion.&lt;/p>
&lt;p>The reason I say &lt;em>seem&lt;/em> and not &lt;em>are&lt;/em> is because the alternatives to these cost-exposing practices also suffer from costs. The difference is that, while the former surface costs, leading to the need to allocate time and people to infrastructure work, the latter keeps the costs smeared over teams and individuals in ways that are difficult to account and plan for.&lt;/p>
&lt;p>To illustrate what I&amp;rsquo;m trying to say, I&amp;rsquo;ll present three different scenarios in which this opinion applies. All of these case studies come from past personal experiences while working in different teams and projects. The first one covered in this post is about the adoption of a monorepo vs. the use of multiple different repositories. The other two will come in follow-up articles.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-23-freebsd-gnome-repos.png" length="162711" type="image/jpeg"/></item><item><title>A failed experiment with Rust static dispatch</title><link>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</link><pubDate>Sun, 06 Aug 2023 05:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</guid><description>&lt;p>Initial versions of the EndBASIC Service, and therefore initial versions of EndTRACKER, used dynamic dispatch to support abstract definitions of system services such as the database they talk to and the clock they use. This looked like a bunch of &lt;tt>Arc&lt;dyn Foo>&lt;/tt> objects passed around and was done to support extremely fast unit testing.&lt;/p>
&lt;p>When I generalized the core logic of these services into the III-IV framework, I decided to experiment with a switch to static dispatch. The rationale was that using static dispatch better aligns with the design of well-regarded crates in the Rust ecosystem, and also because I wanted to avoid unnecessary runtime costs in the foundational pieces of my web services.&lt;/p>
&lt;p>Let me tell you that this decision was a huge mistake and that the experiment has utterly failed. Using static dispatch has been a constant source of frustration due to the difficulty in passing types around and reasoning about trait bounds. The situation had gotten so bad that I dreaded adding new functionality to my services whenever a change to a statically-typed &lt;tt>struct&lt;/tt> was needed, because that meant adding yet another type parameter and plumbing it through tens of source files.&lt;/p>
&lt;p>In lieu of the difficulties, which eventually turned into blockers to implementing new features, I made the choice of going back to dynamic dispatch. The goal was to gain ergonomics at the expense of a supposedly-negligible runtime cost. Let me tell you about the problems I faced, the refactoring journey, and some measurements I gathered after the rewrite.&lt;/p></description></item><item><title>Unit-testing a web service in Rust</title><link>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</link><pubDate>Fri, 07 Jul 2023 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</guid><description>&lt;p>One of the things I'm most proud of the Rust web services I have written is how I can run their tests with zero setup and within milliseconds, all while making me confident that "main" can always be shipped to production. I've previously touched upon how this all works in other articles, but it's time for a deep dive.&lt;/p>
&lt;p>To make things specific, I'll be describing the testing infrastructure of EndTRACKER, the EndBASIC Service, and the sample key/value store app of III-IV. These services are all structured in three separate layers, and I'll be covering the testing strategy for each of them.&lt;/p></description></item><item><title>Useless use of GNU</title><link>https://jmmv.dev/2021/08/useless-use-of-gnu.html</link><pubDate>Wed, 25 Aug 2021 09:10:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/useless-use-of-gnu.html</guid><description>The GNU project is the source of the Unix userland utilities used on most Linux distributions. Its compatibility with standards and other Unix systems, or lack thereof, directly impacts the overall portability of any piece of software developed from GNU/Linux installations. Unfortunately, the GNU userland does not closely adhere to standards, and its widespread usage causes little incompatibilities to creep into any software created on GNU/Linux systems. Read on for why this is a problem and the pitfalls you will encounter.</description></item><item><title>Should the browser use all available memory?</title><link>https://jmmv.dev/2021/08/using-all-memory-as-a-cache.html</link><pubDate>Thu, 12 Aug 2021 09:30:00 -0700</pubDate><guid>https://jmmv.dev/2021/08/using-all-memory-as-a-cache.html</guid><description>We have all seen discussions go like this: someone first complains that an application like Google Chrome is wasteful because it uses multiple GBs of memory. Someone else comes along and says that memory is there to be used for speed and therefore this is the correct behavior: if the computer has multiple GBs of free memory, an application such as Chrome should make use of all the available memory in the form of a cache to be as responsive as possible. Makes sense, right? Yes, it does makes sense&amp;mdash;as long as Chrome is the only application running. Let&amp;rsquo;s explore why this is not a great idea.</description></item><item><title>EndBASIC 0.6 release announcement</title><link>https://jmmv.dev/2021/02/endbasic-0.6.html</link><pubDate>Fri, 19 Feb 2021 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2021/02/endbasic-0.6.html</guid><description>&lt;p>After a very active month of development since the &lt;a href="https://jmmv.dev/2021/01/endbasic-0.5.html">0.5 announcement&lt;/a>, it is time to welcome EndBASIC 0.6!&lt;/p>
&lt;p>This new 0.6 release is super-exciting for three reasons:&lt;/p>
&lt;ul>
&lt;li>preliminary GPIO support in the standard library specifically tailored to the Raspberry Pi;&lt;/li>
&lt;li>multidimensional array support in the language; and&lt;/li>
&lt;li>availability of binary releases for the most common platforms.&lt;/li>
&lt;/ul>
&lt;p>You can dive right in by:&lt;/p>
&lt;ul>
&lt;li>visiting &lt;a href="https://repl.endbasic.dev/">https://repl.endbasic.dev/&lt;/a> for an interactive session,&lt;/li>
&lt;li>reading more about the project at &lt;a href="https://www.endbasic.dev/">https://www.endbasic.dev/&lt;/a>, or&lt;/li>
&lt;li>downloading and installing any of the new &lt;a href="https://github.com/endbasic/endbasic/releases/tag/endbasic-0.6.0">prebuilt binaries&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>But stick around and continue reading if you are interested in many more details about these major changes 😉&lt;/p></description></item><item><title>Embedding EndBASIC into a (Rust) program</title><link>https://jmmv.dev/2021/01/embedding-endbasic.html</link><pubDate>Tue, 26 Jan 2021 07:20:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/embedding-endbasic.html</guid><description>One thing that bothers me quite a lot about various language implementations is that the core of their interpreter isn&amp;rsquo;t clearly separate from their standard library. This makes it hard to embed those interpreters into other programs because it&amp;rsquo;s not obvious how to limit their side-effects and because the interpreter dependency can be heavy. In this post, we will see how EndBASIC&amp;rsquo;s design tries hard to keep the core as small as possible, and we will see some examples on how to use EndBASIC from Rust and vice versa.</description></item><item><title>EndBASIC 0.5 release announcement</title><link>https://jmmv.dev/2021/01/endbasic-0.5.html</link><pubDate>Sun, 24 Jan 2021 08:00:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/endbasic-0.5.html</guid><description>A month has passed since the 0.4.0 announcement so it is about time to say hello to yet another EndBASIC release because 0.5.0 is here! So, what&amp;rsquo;s new? Not much&amp;hellip; unless you look under the covers, in which case a &lt;em>ton&lt;/em> has changed. About 30% of the codebase has been affected in one way or another to improve general quality, so read on to see how.</description></item></channel></rss>