<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Assembly on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/assembly/index.html</link><description>Recent content in Assembly on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Mon, 04 Jun 2007 11:00:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/tags/assembly/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Is assembly code faster than C?</title><link>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</link><pubDate>Mon, 04 Jun 2007 11:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/06/is-assembly-code-faster-than-c.html</guid><description>I was reading an &lt;a href="http://hubpages.com/hub/_86_Mac_Plus_Vs_07_AMD_DualCore_You_Wont_Believe_Who_Wins">article&lt;/a> the other day and found an assertion that bugged me. It reads:&lt;br />&lt;blockquote>System 6.0.8 is not only a lot more compact since it has far fewer (mostly useless) features and therefore less code to process, but also because &lt;span style="font-weight: bold;">it was written in assembly code instead of the higher level language C&lt;/span>. The lower the level of the code language, the less processing cycles are required to get something done.&lt;/blockquote>It is not the first time I see someone claiming that writing programs in assembly by hand makes them faster, and I'm sure it is not the last time I'll see this. This assertion is, simply put, wrong.&lt;br />&lt;br />Back in the (good?) old days, processors were very simple: they fetched a instruction from main memory, executed it and once finished (and only then), they fetched the next instruction and repeated the process. On the other hand, compilers were very primitive and their optimization engines were, I dare to say, non-existent. In such scenario, a good programmer could really optimize any program by writing it in assembly instead of in a high-level language: he was able to understand very well how the processor internally behaved and what the outcomes of each machine-level instruction were. Furthermore, he could get rid of all the "bloat" introduced by a compiler.&lt;br />&lt;br />Things have changed a lot since then. Nowadays' processors are very complex devices: they have a very deep execution pipeline that, at a given time, can be executing dozens of instructions at once. They have powerful branch prediction units. They reorder instructions at run time and execute them in an out-of-order way (provided they respect the data dependencies among them). There are memory caches everywhere. So... it is, simply put, almost impossible for a programmer's brain to keep track of all these details and produce efficient code. (And even if he could, the efficiency could be so tied to a specific microprocessor version that it'd be useless in all other cases.)&lt;br />&lt;br />Furthermore, compilers now have much better optimization stages than before and are able keep track of all these processor-specific details. For example, they can reorder instructions on their own or insert prefetching operations at key points to avoid cache misses. They can really do a much better job in converting code to assembly than a programmer would &lt;span style="font-style: italic;">in most cases&lt;/span>.&lt;br />&lt;br />But hey! Of course it is still possible and useful to manually write optimized routines in assembly language &amp;mdash; to make use of SIMD extensions for example &amp;mdash; but these routines tend to be as short and as simple as possible.&lt;br />&lt;br />So, summarizing: it no longer makes sense to write big programs (such as a complete operating systems) in assembly language. Doing that means you lose all the portability gains of a not-so-high-level language such as C and that you will probably do a worse optimization job than a compiler would. Plus well-written and optimized C code can be extremely efficient, as this language is just a very thin layer over assembly.&lt;br />&lt;br />Oh, and back to the original quote. It would have made sense to mention the fact that the Mac Plus was written in assembly if it had been compared with another system &lt;span style="font-style: italic;">of its epoch&lt;/span> written in C. In that case, the argument would have been valid because the compilers were much worse than they are today and the processors were simpler. Just remember that such assertion is, in general, not true any more.</description></item></channel></rss>