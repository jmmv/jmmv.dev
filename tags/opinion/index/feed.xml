<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>opinion on jmmv.dev</title>
    <link>https://jmmv.dev/tags/opinion/index/</link>
    <description>Recent content in opinion on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Dec 2020 09:30:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/tags/opinion/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How does Google avoid clean builds?</title>
      <link>https://jmmv.dev/2020/12/google-no-clean-builds.html</link>
      <pubDate>Thu, 31 Dec 2020 09:30:00 -0800</pubDate>
      
      <guid>https://jmmv.dev/2020/12/google-no-clean-builds.html</guid>
      <description>During my 11 years at Google, I can confidently count the number of times I had to do a &amp;ldquo;clean build&amp;rdquo; with one hand: their build system is so robust that incremental builds always work. Phrases like &amp;ldquo;clean everything and try building from scratch&amp;rdquo; are unheard of. So&amp;hellip; you can color me skeptical when someone says that incremental build problems are due to bugs in the build files and not due to a suboptimal build system. The answer lies in having a robust build system, and in this post I&amp;rsquo;ll examine the common causes behind incremental build breakages, what the build system can do to avoid them, and how Bazel accomplishes most of them.</description>
    </item>
    
    <item>
      <title>Windows Subsystem for Linux: The lost potential</title>
      <link>https://jmmv.dev/2020/11/wsl-lost-potential.html</link>
      <pubDate>Fri, 13 Nov 2020 07:50:00 -0800</pubDate>
      
      <guid>https://jmmv.dev/2020/11/wsl-lost-potential.html</guid>
      <description>If you have followed Windows 10 at all during the last few years, you know that the Windows Subsystem for Linux, or WSL for short, is the hot topic among developers. You can finally run your Linux tooling on Windows as a first class citizen, which means you no longer have to learn PowerShell or, god forbid, suffer through the ancient CMD.EXE console.
Unfortunately, not everything is as rosy as it sounds.</description>
    </item>
    
    <item>
      <title>pkgdb belongs in libdata, not var</title>
      <link>https://jmmv.dev/2020/08/pkgdb-libdata-var.html</link>
      <pubDate>Wed, 26 Aug 2020 08:55:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/08/pkgdb-libdata-var.html</guid>
      <description>The pkgsrc package database, which by default lives in /var/db/pkg/, should not be there. Instead, it should be under /usr/pkg/libdata/pkgdb/. The same applies to FreeBSD&amp;rsquo;s and OpenBSD&amp;rsquo;s ports and also Debian&amp;rsquo;s dpkg, but I&amp;rsquo;ll focus on pkgsrc because it&amp;rsquo;s the system I know best. Let&amp;rsquo;s see why the current default is suboptimal and why libdata is a good alternative.</description>
    </item>
    
    <item>
      <title>rc.d belongs in libexec, not etc</title>
      <link>https://jmmv.dev/2020/08/rcd-libexec-etc.html</link>
      <pubDate>Mon, 24 Aug 2020 06:30:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/08/rcd-libexec-etc.html</guid>
      <description>The scripts that live under /etc/rc.d/ in FreeBSD, NetBSD, and OpenBSD are in the wrong place. They all should live in /libexec/rc.d/ because they are code, not configuration. Let&amp;rsquo;s look at the history of these systems to see how we got here, why this is problematic, and how things would look like in a better world.</description>
    </item>
    
  </channel>
</rss>
