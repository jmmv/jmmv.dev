<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/security/index.html</link><description>Recent content in Security on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Jul 2023 16:30:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/security/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>ldd(1) and untrusted binaries</title><link>https://jmmv.dev/2023/07/ldd-untrusted-binaries.html</link><pubDate>Sat, 01 Jul 2023 16:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/ldd-untrusted-binaries.html</guid><description>While diagnosing a non-determinism Bazel issue at work, I had to compare the dynamic libraries used by two builds of the same binary. To do so, I used &lt;code>ldd(1)&lt;/code> and I had to refer to its manual page to understand details of the output I had never paid attention to before. What I saw will surprise you: &lt;code>ldd&lt;/code> can end up &lt;em>running&lt;/em> the binary given to it, thus making it unsafe against untrusted binaries. Read on for the history I could find around this issue and what alternatives you have.</description></item></channel></rss>