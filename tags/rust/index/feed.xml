<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/rust/index/</link><description>Recent content in rust on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Aug 2023 05:30:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/rust/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>A failed experiment with Rust static dispatch</title><link>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</link><pubDate>Sun, 06 Aug 2023 05:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</guid><description>&lt;p>Initial versions of the EndBASIC Service, and therefore initial versions of EndTRACKER, used dynamic dispatch to support abstract definitions of system services such as the database they talk to and the clock they use. This looked like a bunch of &lt;tt>Arc&lt;dyn Foo>&lt;/tt> objects passed around and was done to support extremely fast unit testing.&lt;/p>
&lt;p>When I generalized the core logic of these services into the III-IV framework, I decided to experiment with a switch to static dispatch. The rationale was that using static dispatch better aligns with the design of well-regarded crates in the Rust ecosystem, and also because I wanted to avoid unnecessary runtime costs in the foundational pieces of my web services.&lt;/p>
&lt;p>Let me tell you that this decision was a huge mistake and that the experiment has utterly failed. Using static dispatch has been a constant source of frustration due to the difficulty in passing types around and reasoning about trait bounds. The situation had gotten so bad that I dreaded adding new functionality to my services whenever a change to a statically-typed &lt;tt>struct&lt;/tt> was needed, because that meant adding yet another type parameter and plumbing it through tens of source files.&lt;/p>
&lt;p>In lieu of the difficulties, which eventually turned into blockers to implementing new features, I made the choice of going back to dynamic dispatch. The goal was to gain ergonomics at the expense of a supposedly-negligible runtime cost. Let me tell you about the problems I faced, the refactoring journey, and some measurements I gathered after the rewrite.&lt;/p></description></item><item><title>Unit-testing a web service in Rust</title><link>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</link><pubDate>Fri, 07 Jul 2023 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</guid><description>&lt;p>One of the things I'm most proud of the Rust web services I have written is how I can run their tests with zero setup and within milliseconds, all while making me confident that "main" can always be shipped to production. I've previously touched upon how this all works in other articles, but it's time for a deep dive.&lt;/p>
&lt;p>To make things specific, I'll be describing the testing infrastructure of EndTRACKER, the EndBASIC Service, and the sample key/value store app of III-IV. These services are all structured in three separate layers, and I'll be covering the testing strategy for each of them.&lt;/p></description></item><item><title>A persistent task queue in Rust</title><link>https://jmmv.dev/2023/06/iii-iv-task-queue.html</link><pubDate>Fri, 23 Jun 2023 06:35:00 -0700</pubDate><guid>https://jmmv.dev/2023/06/iii-iv-task-queue.html</guid><description>A couple of posts ago, I described why I built custom email subscriptions for this blog. I briefly mentioned that there is new automation that scrapes the RSS feed and sends new post notifications to you all. Today, it&amp;rsquo;s time to look into how this all works and how this is based on a new persistent task queuing service in Rust. The queue handles tasks to periodically scrape the RSS feed and schedule emails, all with various quota enforcers and retry policies in place. Read on for the design requirements and constraints of the task queue, how the client and worker Rust APIs look like, and how this all can be made to work inside the Azure Functions serverless runtime for minimal deployment hassle and cost.</description></item><item><title>From AST to bytecode execution in EndBASIC</title><link>https://jmmv.dev/2022/11/endbasic-bytecode.html</link><pubDate>Tue, 22 Nov 2022 06:50:00 -0700</pubDate><guid>https://jmmv.dev/2022/11/endbasic-bytecode.html</guid><description>&lt;p>Since its inception two years ago, the EndBASIC interpreter has been using an AST-based execution
engine. And during all this time, people have mocked the language for not allowing &lt;code>10 GOTO 10&lt;/code>.
Well, fear not: the upcoming 0.10 release has full support for &lt;code>GOTO&lt;/code> and &lt;code>GOSUB&lt;/code>, features that
were made possible by moving to a bytecode-based interpreter. Let&amp;rsquo;s take a peek at what the
problems were and how I addressed them.&lt;/p></description></item><item><title>Rust is hard, yes, but does it matter?</title><link>https://jmmv.dev/2022/05/rust-is-hard-but-does-it-matter.html</link><pubDate>Fri, 06 May 2022 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2022/05/rust-is-hard-but-does-it-matter.html</guid><description>Rust is infamous for having a steep learning curve. The borrow checker, preferred idioms and design patterns, the meaning of core traits&amp;hellip; these are all things one must learn before being proficient with the language and able to write code with ease. So, yes, Rust is hard, but does it matter in practical terms? Can we expect large-ish teams to succeed when adopting the language? I&amp;rsquo;d like to think that it does not matter much and that some initial difficulties in bringing people up to speed can pay off in the medium term.</description></item><item><title>Do Rust devs hate Go devs?</title><link>https://jmmv.dev/2022/04/do-rust-devs-hate-go-devs.html</link><pubDate>Fri, 29 Apr 2022 09:50:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/do-rust-devs-hate-go-devs.html</guid><description>&lt;p>Earlier this week, a 2-year old post titled &lt;a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">I want off Mr. Golang&amp;rsquo;s wild ride&lt;/a> by &lt;a href="https://fasterthanli.me/">@fasterthanlime&lt;/a> made the news rounds &lt;em>again&lt;/em>. This post raises a bunch of concerns on the Go language and is posted from the perspective of someone who prefers Rust. And, just yesterday, I noticed &lt;a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang">a comment on Twitter by @FiloSottile&lt;/a> that, paraphrased, reads &amp;ldquo;&lt;em>Why is there so much hatred towards Go, especially from Rust developers?&lt;/em>&amp;rdquo;.&lt;/p>
&lt;p>I wish I could answer this question with a &amp;ldquo;no, there isn&amp;rsquo;t&amp;rdquo;, but that would be a lie: in any large community, there will certainly be hateful people/opinions. If you have encountered such flamebait, I&amp;rsquo;m sorry, and I&amp;rsquo;m not here to defend it. What I&amp;rsquo;m here to do is look at the possible truth behind the claim that Rust developers dislike Go, and I wanted to elaborate on this based on my personal experience.&lt;/p></description></item><item><title>Rust traits and dependency injection</title><link>https://jmmv.dev/2022/04/rust-traits-and-dependency-injection.html</link><pubDate>Fri, 22 Apr 2022 09:30:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/rust-traits-and-dependency-injection.html</guid><description>Dependency injection is one of my favorite design patterns to develop highly-testable and modular code. Unfortunately, applying this pattern by taking Rust traits as arguments to public functions has unintended consequences on the visibility of private symbols. If you are not careful, most of your crate-internal APIs might need to become public just because you needed to parameterize a function with a trait. Let&amp;rsquo;s look at why this happens and what we can do about it.</description></item><item><title>Introducing db_logger</title><link>https://jmmv.dev/2022/04/introducing-db-logger.html</link><pubDate>Tue, 12 Apr 2022 08:30:00 -0700</pubDate><guid>https://jmmv.dev/2022/04/introducing-db-logger.html</guid><description>Over the last couple of weeks, I have been modernizing the codebase of the EndBASIC cloud service by applying many of the learnings I got from the development of EndTRACKER. The latter was a fork of the former and thus the foundations were the same, but as I iterated on the latter more recently, I got to refine my approach to writing a REST API in Rust.
During this refactoring process, there was a small piece of the system that routinely got in the way for various reasons.</description></item><item><title>EndBASIC 0.6 release announcement</title><link>https://jmmv.dev/2021/02/endbasic-0.6.html</link><pubDate>Fri, 19 Feb 2021 06:30:00 -0800</pubDate><guid>https://jmmv.dev/2021/02/endbasic-0.6.html</guid><description>After a very active month of development since the 0.5 announcement, it is time to welcome EndBASIC 0.6!
This new 0.6 release is super-exciting for three reasons:
preliminary GPIO support in the standard library specifically tailored to the Raspberry Pi; multidimensional array support in the language; and availability of binary releases for the most common platforms. You can dive right in by:
visiting https://repl.endbasic.dev/ for an interactive session, reading more about the project at https://www.</description></item><item><title>Embedding EndBASIC into a (Rust) program</title><link>https://jmmv.dev/2021/01/embedding-endbasic.html</link><pubDate>Tue, 26 Jan 2021 07:20:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/embedding-endbasic.html</guid><description>One thing that bothers me quite a lot about various language implementations is that the core of their interpreter isn&amp;rsquo;t clearly separate from their standard library. This makes it hard to embed those interpreters into other programs because it&amp;rsquo;s not obvious how to limit their side-effects and because the interpreter dependency can be heavy. In this post, we will see how EndBASIC&amp;rsquo;s design tries hard to keep the core as small as possible, and we will see some examples on how to use EndBASIC from Rust and vice versa.</description></item><item><title>EndBASIC 0.5 release announcement</title><link>https://jmmv.dev/2021/01/endbasic-0.5.html</link><pubDate>Sun, 24 Jan 2021 08:00:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/endbasic-0.5.html</guid><description>A month has passed since the 0.4.0 announcement so it is about time to say hello to yet another EndBASIC release because 0.5.0 is here! So, what&amp;rsquo;s new? Not much&amp;hellip; unless you look under the covers, in which case a &lt;em>ton&lt;/em> has changed. About 30% of the codebase has been affected in one way or another to improve general quality, so read on to see how.</description></item><item><title>Enforcing code health via GitHub Actions</title><link>https://jmmv.dev/2021/01/github-actions-code-health.html</link><pubDate>Fri, 08 Jan 2021 09:50:00 -0800</pubDate><guid>https://jmmv.dev/2021/01/github-actions-code-health.html</guid><description>It is no secret that, in software development, the edit+build+test cycle must be as short as possible. The delay between saving a file and seeing the results has to be minimal and in the order of a few seconds, or else developers lose focus and productivity suffers.
It&amp;rsquo;s equally important to ensure that the code is held to certain quality standards. Compiler warnings, for example, are part of any compilation and catch a set of common problems.</description></item><item><title>EndBASIC 0.4 release announcement</title><link>https://jmmv.dev/2020/12/endbasic-0.4.html</link><pubDate>Fri, 25 Dec 2020 19:30:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/endbasic-0.4.html</guid><description>About a month ago and after a long hiatus, I published EndBASIC 0.3 and the adrenaline rush that came with it got my wheels spinning again full-steam ahead. So here I am today, ready to announce the 0.4 release. But&amp;hellip; &amp;ldquo;what could have possibly changed in just a month of someone&amp;rsquo;s free time&amp;rdquo;, you wonder? Enough, actually!
EndBASIC 0.4 is the release that fulfills my original goal of being able to run a &amp;ldquo;guess the number&amp;rdquo; game.</description></item><item><title>Unit-testing a console app (a text editor)</title><link>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</link><pubDate>Tue, 08 Dec 2020 10:00:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</guid><description>The most notable feature in EndBASIC 0.3 is its new full-screen console-based text editor. In this post, I describe why it is important and useful to unit-test a console app like this, and I will dive into how to implement unit tests that catch regressions and inefficiencies. Code samples are in Rust, but the concepts presented here are applicable to any language with minimal data abstraction facilities.</description></item><item><title>Using the builder pattern to define test scenarios</title><link>https://jmmv.dev/2020/12/builder-pattern-for-tests.html</link><pubDate>Fri, 04 Dec 2020 09:40:00 -0800</pubDate><guid>https://jmmv.dev/2020/12/builder-pattern-for-tests.html</guid><description>&lt;p>I&amp;rsquo;ve been playing with the builder patter to express test scenarios in a succinct and declarative manner. I&amp;rsquo;ve liked the outcome and feel that this design can yield to pretty good test code, so I&amp;rsquo;ll dig through this idea here. Note that, while this post and the associated code talk about Rust, &lt;strong>the ideas presented here apply to any language&lt;/strong>. So don&amp;rsquo;t leave just because I said Rust!&lt;/p></description></item></channel></rss>