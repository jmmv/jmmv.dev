<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>featured on jmmv.dev</title>
    <link>https://jmmv.dev/tags/featured/index/</link>
    <description>Recent content in featured on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Dec 2020 10:00:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/tags/featured/index/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unit-testing a console app (a text editor)</title>
      <link>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</link>
      <pubDate>Tue, 08 Dec 2020 10:00:00 -0800</pubDate>
      
      <guid>https://jmmv.dev/2020/12/unit-testing-a-console-app.html</guid>
      <description>The most notable feature in EndBASIC 0.3 is its new full-screen console-based text editor. In this post, I describe why it is important and useful to unit-test a console app like this, and I will dive into how to implement unit tests that catch regressions and inefficiencies. Code samples are in Rust, but the concepts presented here are applicable to any language with minimal data abstraction facilities.</description>
    </item>
    
    <item>
      <title>Windows Subsystem for Linux: The lost potential</title>
      <link>https://jmmv.dev/2020/11/wsl-lost-potential.html</link>
      <pubDate>Fri, 13 Nov 2020 07:50:00 -0800</pubDate>
      
      <guid>https://jmmv.dev/2020/11/wsl-lost-potential.html</guid>
      <description>If you have followed Windows 10 at all during the last few years, you know that the Windows Subsystem for Linux, or WSL for short, is the hot topic among developers. You can finally run your Linux tooling on Windows as a first class citizen, which means you no longer have to learn PowerShell or, god forbid, suffer through the ancient CMD.EXE console.
Unfortunately, not everything is as rosy as it sounds.</description>
    </item>
    
    <item>
      <title>Farewell, Google; hello, Microsoft!</title>
      <link>https://jmmv.dev/2020/10/bye-google-hi-microsoft.html</link>
      <pubDate>Mon, 19 Oct 2020 06:00:00 -0700</pubDate>
      
      <guid>https://jmmv.dev/2020/10/bye-google-hi-microsoft.html</guid>
      <description>After a little over 11 years, it&amp;rsquo;s time for a much longed change: I&amp;rsquo;m leaving Google and I&amp;rsquo;m joining Microsoft as a Principal Software Engineer for Azure. These job changes are effective as of this week, but my family and I already moved from New York City to Redmond, WA about three weeks ago. Read on for a recap on my tenure at Google, the whys behind my departure, and how I ended up choosing the position in Microsoft Azure after mulling over offers from Facebook, Twitter, and Microsoft.</description>
    </item>
    
    <item>
      <title>Configuration files and .d directories</title>
      <link>https://jmmv.dev/2020/08/config-files-vs-directories.html</link>
      <pubDate>Mon, 17 Aug 2020 07:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/08/config-files-vs-directories.html</guid>
      <description>Have you ever wondered why an increasing number of programs are configured by placing small files in .d directories instead of by just editing a single file? Have you ever wondered why these .d directories seem to proliferate in Linux installations? Read on to understand what these are and why they are useful.</description>
    </item>
    
    <item>
      <title>Bridging the web gap in EndBASIC</title>
      <link>https://jmmv.dev/2020/05/bridging-the-web-gap-endbasic.html</link>
      <pubDate>Sat, 30 May 2020 08:50:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/05/bridging-the-web-gap-endbasic.html</guid>
      <description>After a ton of work, a lot of which was unexpected, I am ecstatic to announce that EndBASIC is now a reality on the web! The whole language interpreter can now run as a fully client-side web app on a computer, on a tablet&amp;hellip; and even on a phone. Yes: the whole thing, which is written in Rust (94%), works in a modern browser with just a tiny bit of JavaScript glue (1%).</description>
    </item>
    
    <item>
      <title>Hello, EndBASIC!</title>
      <link>https://jmmv.dev/2020/04/hello-endbasic.html</link>
      <pubDate>Wed, 22 Apr 2020 09:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/04/hello-endbasic.html</guid>
      <description>Introducing EndBASIC, a new interpreter for a BASIC-like language that is inspired by Amstrad&amp;rsquo;s Locomotive BASIC 1.1 and Microsoft&amp;rsquo;s QuickBASIC 4.5. Like the former, EndBASIC intends to provide an interactive environment that seamlessly merges coding with immediate visual feedback. Like the latter, EndBASIC offers higher-level programming constructs and strong typing. The main idea behind EndBASIC is to provide a playground for learning the foundations of programming in a simplified environment.</description>
    </item>
    
    <item>
      <title>Ensuring system rewrites are truly necessary</title>
      <link>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</link>
      <pubDate>Fri, 24 Jan 2020 17:10:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</guid>
      <description>You probably know that software rewrites, while very tempting, are expensive and can be the mistake that kills a project or a company. Yet they are routinely proposed as the solution to all problems. Is there anything you can do to minimize the risk? In this post, I propose that you actively improve the old system to ensure the new system cannot make progress in a haphazard way. This forces the new system to be designed in such a way that delivers breakthrough improvements and not just incremental improvements.</description>
    </item>
    
    <item>
      <title>Sample REST interface in Rust and Go</title>
      <link>https://jmmv.dev/2019/09/rest-api-rust-go.html</link>
      <pubDate>Fri, 27 Sep 2019 06:45:40 +0500</pubDate>
      
      <guid>https://jmmv.dev/2019/09/rest-api-rust-go.html</guid>
      <description>Over the summer, I prototyped a bunch of web apps whose ideas had been floating in my mind for a long time. I spent some time reading through REST API documentation pages and, as part of these exercises, implemented sample RESTful web services in both Go and Rust. (Just for context, the last time I wrote a web app was in high school&amp;hellip; and it involved PHP, MySQL, and I think IE6?</description>
    </item>
    
    <item>
      <title>Darwin&#39;s QoS service classes and performance</title>
      <link>https://jmmv.dev/2019/03/macos-threads-qos-and-bazel.html</link>
      <pubDate>Wed, 06 Mar 2019 17:30:00 +0100</pubDate>
      
      <guid>https://jmmv.dev/2019/03/macos-threads-qos-and-bazel.html</guid>
      <description>Since the publication of Bazel a few years ago, users have reported (and I myself have experienced) general slowdowns when Bazel is running on Macs: things like the window manager stutter and others like the web browser cannot load new pages. Similarly, after the introduction of the dynamic spawn scheduler, some users reported slower builds than pure remote or pure local builds, which made no sense.
All along we guessed that these problems were caused by Bazel&amp;rsquo;s abuse of system threads, as it used to spawn 200 runnable threads during analysis and used to run 200 concurrent compiler subprocesses.</description>
    </item>
    
    <item>
      <title>Hello, sandboxfs 0.1.0</title>
      <link>https://jmmv.dev/2019/02/sandboxfs-0-1-0.html</link>
      <pubDate>Tue, 05 Feb 2019 09:00:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2019/02/sandboxfs-0-1-0.html</guid>
      <description>I am pleased to announce that the first release of sandboxfs, 0.1.0, is finally here! You can download the sources and prebuilt binaries from the 0.1.0 release page and you can read the installation instructions for more details.
The journey to this first release has been a long one. sandboxfs was first conceived over two years ago, was first announced in August 2017, showed its first promising results in April 2018, and has been undergoing a rewrite from Go to Rust.</description>
    </item>
    
    <item>
      <title>Rust vs. Go</title>
      <link>https://jmmv.dev/2018/07/rust-vs-go.html</link>
      <pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate>
      
      <guid>https://jmmv.dev/2018/07/rust-vs-go.html</guid>
      <description>There is no good answer to this question: people tend to put Go and Rust in the same bucket because they were released at around the same time, because Rust&amp;rsquo;s release felt like a response to Go&amp;rsquo;s, and because they are marketed to similar audiences.  They are, however, vastly different.  So let&amp;rsquo;s give in and compare them anyway.</description>
    </item>
    
    <item>
      <title>Stick to your project&#39;s core language in your tests</title>
      <link>https://jmmv.dev/2018/03/stick-to-projects-core-language-in-tests.html</link>
      <pubDate>Tue, 27 Mar 2018 10:00:00 +0900</pubDate>
      
      <guid>https://jmmv.dev/2018/03/stick-to-projects-core-language-in-tests.html</guid>
      <description>&lt;p&gt;&lt;em&gt;This post is a short, generalized summary of the preceeding two. I believe those two posts put readers off due to their massive length and the fact that they were seemingly tied to Bazel and Java, thus failing to communicate the larger point I wanted to make. Let&amp;rsquo;s try to distill their key points here in a language- and project-agnostic manner.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</description>
    </item>
    
    <item>
      <title>Shell readability: strict mode</title>
      <link>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</link>
      <pubDate>Fri, 09 Mar 2018 09:40:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2018/03/shell-readability-strict-mode.html</guid>
      <description>Some programming languages have a feature known as strict mode: a setting that makes the language interpreter disallow certain obviously-broken code that would otherwise work. The simplest examples are JavaScript and Perl but, as it turns out, the shell also has something akin to this feature. The &amp;ldquo;strict mode&amp;rdquo; name, however, is unofficial, so you won&amp;rsquo;t find many references to it online.
You can enable the shell&amp;rsquo;s strict mode by doing one of the following:</description>
    </item>
    
    <item>
      <title>Introducing pkg_comp 2.0 (and sandboxctl 1.0)</title>
      <link>https://jmmv.dev/2017/02/introducing-pkg_comp-2.0.html</link>
      <pubDate>Fri, 17 Feb 2017 16:37:06 -0500</pubDate>
      
      <guid>https://jmmv.dev/2017/02/introducing-pkg_comp-2.0.html</guid>
      <description>Announcing the launch of pkg_comp 2.0, how this differs from the 1.x series, why there was a rewrite, what sandboxctl 1.0 is, and more.</description>
    </item>
    
    <item>
      <title>#! /usr/bin/env considered harmful</title>
      <link>https://jmmv.dev/2016/09/env-considered-harmful.html</link>
      <pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate>
      
      <guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid>
      <description>Many programming guides recommend to begin scripts with the #! /usr/bin/env shebang in order to to automatically locate the necessary interpreter. For example, for a Python script you would use #! /usr/bin/env python, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.
The reason for this recommendation is that /usr/bin/env python will search the PATH for a program called python and execute the first one found&amp;hellip; and that usually works fine on one&amp;rsquo;s own machine.</description>
    </item>
    
  </channel>
</rss>
