<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Announce on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/announce/index.html</link><description>Recent content in Announce on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2024 Julio Merino</copyright><lastBuildDate>Sat, 28 Feb 2015 15:06:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/announce/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Kyua turns parallel</title><link>https://jmmv.dev/2015/02/kyua-turns-parallel.html</link><pubDate>Sat, 28 Feb 2015 15:06:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2015/02/kyua-turns-parallel.html</guid><description>&lt;p>After three months of intensive work on &lt;a href="http://github.com/jmmv/kyua/">Kyua&lt;/a>'s &lt;tt>executor&lt;/tt> Git branch, I am happy to announce that the new execution engine, whose crown feature is the &lt;i>ability to run test cases in parallel&lt;/i>, has just &lt;a href="https://github.com/jmmv/kyua/commit/7197e51b8a86b8f2a031b50f8486b0cd3e952460">landed in &lt;tt>master&lt;/tt>&lt;/a> and &lt;a href="https://travis-ci.org/jmmv/kyua/builds/52557397">passes all self-tests&lt;/a>!&lt;/p> &lt;p>You can head over to &lt;a href="https://github.com/jmmv/kyua/commit/7197e51b8a86b8f2a031b50f8486b0cd3e952460">the commit message&lt;/a> for more details on the merge, read &lt;a href="https://github.com/jmmv/kyua/blob/7197e51b8a86b8f2a031b50f8486b0cd3e952460/NEWS">the NEWS entries&lt;/a>, and skim throught the history of the &lt;tt>executor&lt;/tt> branch to understand how this feature has been built.&lt;/p></description></item><item><title>shtk 1.6 is now available</title><link>https://jmmv.dev/2014/11/shtk-16-is-now-available.html</link><pubDate>Mon, 17 Nov 2014 15:28:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2014/11/shtk-16-is-now-available.html</guid><description>&lt;p>The &lt;a href="https://github.com/jmmv/shtk/">Shell Toolkit&lt;/a>, or shtk for short, is a little project I &lt;a href="https://jmmv.dev/2012/08/introducing-shtk.html">introduced back in August of 2008&lt;/a> to support other tools such as &lt;a href="http://blog.netbsd.org/tnf/entry/introducing_sysbuild_and_sysupgrade">sysbuild and sysupgrade&lt;/a>. Since that time, the project has seen little activity because it did not have much to offer and because shtk's public interface was not documented (hence making it impossible for developers to get started with shtk).&lt;/p> &lt;p>Well, both are changing &lt;i>today&lt;/i> with the brand-new release of &lt;a href="https://github.com/jmmv/shtk/releases/tag/shtk-1.6">shtk 1.6&lt;/a>:&lt;/p></description></item><item><title>Joining the FreeBSD committer ranks</title><link>https://jmmv.dev/2013/11/joining-freebsd-committer-ranks.html</link><pubDate>Mon, 04 Nov 2013 12:00:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/11/joining-freebsd-committer-ranks.html</guid><description>&lt;p>About 11 years ago, I had the honor of becoming part of the NetBSD developer team. A week ago, the same offer was extended to me for FreeBSD and I could not refuse it... so, as of two days ago, &lt;a href="http://www.freebsd.org/news/newsflash.html#event20131102:01">I am &lt;tt>jmmv&lt;/tt> at FreeBSD and will be working in &lt;tt>src&lt;/tt>&lt;/a>!&lt;/p> &lt;p>But how have I ended up here? The story goes back in time...&lt;/p> &lt;p>&lt;b>My beginnings with FreeBSD&lt;/b>&lt;/p> &lt;p>FreeBSD was the first BSD system I tried after spending a couple of years with Linux. I was able to do so because one of the PC magazines that my father used to buy in 1999 came with a copy of FreeBSD 3.2 — pretty advanced stuff for a magazine compared to today's standards, huh? However, that first experience did not go very well: the system felt really sluggish... only because I did not know that I had to enable the magic &lt;tt>softdep&lt;/tt> option. So I gave up.&lt;/p></description></item><item><title>Introducing shtk</title><link>https://jmmv.dev/2012/08/introducing-shtk.html</link><pubDate>Wed, 15 Aug 2012 17:39:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2012/08/introducing-shtk.html</guid><description>Have you ever wanted to have a collection of ready-to-use modules for shell scripts? I have, particularly because I keep reimplementing the same functions over and over and over and over again whenever I write non-trivial shell scripts, and I'm tired of doing so.&lt;br />&lt;br />That's why I have just abstracted all the common code in the aforementioned tools and &lt;a href="http://mail-index.netbsd.org/pkgsrc-changes/2012/08/15/msg077072.html">put it into a new package called the "Shell Toolkit", or shtk for short&lt;/a>. Yeah, this name sounds very pretentious but, really, I don't intend this to be anything big. The only thing I want to do is simplify my life when implementing shell scripts, and hope that other people might find the modules useful. So far, I have taken the generic (and common!) code from sysbuild and sysupgrade, reconciled a few tiny divergences, and moved it into this new shtk package.&lt;br />&lt;br class="Apple-interchange-newline" />In reality, writing something like shtk is sin-borderline. I really should not be using shell scripting for the kind of tools I am implementing (they deserve better data structures and better error checking than what shell provides, for example). However, shell scripting is incredible convenient to get reasonably-good implementations of such tools with minimal effort, and is the only scripting language available in NetBSD's base system. (Yes, yes, there is Lua, but my limited knowledge of Lua would not let me write these tools in any decent manner nor in any reasonable time.)&lt;br />&lt;div>&lt;br />&lt;/div>So, what's in shtk? There are a few functions to deal with command lines (error/warning reporting and such things), some trivial stuff to deal with lists, a bunch of code to interact with cvs and, what I like the most, a module to implement configuration files with some kind of key/value validation.&lt;br />&lt;br />At the moment, shtk can only be found in pkgsrc under &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/devel/shtk?only_with_tag=MAIN">pkgsrc/devel/shtk&lt;/a>&amp;nbsp;and I don't currently have any plans to make it more widely available. If there are enough people interested in that with real needs, I could reconsider, but the maintenance effort would be non-trivial.&lt;br />&lt;br />To showcase the features of shtk, I have updated the sysbuild and sysupgrade packages to depend on this new toolkit while at the same time dropping all this duplicate supporting code. It's a good thing that I wrote exhaustive tests for all possible code paths, because the migration from the built-in modules to shtk was riddled with subtleties that would have impacted end users otherwise.&lt;br />&lt;br />Now... time to really consider taking the task of rewriting pkg_comp in a more&amp;nbsp;maintainable&amp;nbsp;style so that I can add the features I have wished for for many years (like OS X support).</description></item><item><title>Introducing sysupgrade for NetBSD</title><link>https://jmmv.dev/2012/08/introducing-sysupgrade.html</link><pubDate>Mon, 06 Aug 2012 13:32:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2012/08/introducing-sysupgrade.html</guid><description>Over the last two weeks, you might have had fun &lt;a href="https://jmmv.dev/2012/07/introducing-sysbuild-for-netbsd.html">rolling your own NetBSD binary releases with sysbuild&lt;/a>. But what fun is that if you have no trivial way of upgrading your existing NetBSD installation to a newer version?&lt;br />&lt;br />Upgrading NetBSD to a newer version from distribution sets generally looks like the following;&lt;br />&lt;ol>&lt;li>Fetch new distribution sets (or roll your own).&lt;/li>&lt;li>Upgrade the kernel.&lt;/li>&lt;li>Unpack the distribution sets over the root directory, without fat-fingering the command and unpacking &lt;tt>etc.tgz&lt;/tt> along the way.&lt;/li>&lt;li>Use &lt;tt>etcupdate&lt;/tt> to merge new changes to configuration files.&lt;/li>&lt;li>Use &lt;tt>postinstall&lt;/tt> to validate the upgraded system.&lt;/li>&lt;/ol>&lt;b>Simple? Yes. Easy? No.&lt;/b> The above procedure is obscure to anyone new to NetBSD. (Actually, if you tell anybody that the way to upgrade your machine is by unpacking tarballs over &lt;tt>/&lt;/tt> will stare at you thinking you are kidding. It's 2012.) "Jokes" aside, what is worse is that the procedure is quite monotonous and, therefore, it is very easy for the administrator to make a trivial mistake along the way and screw up a running system. (Been there, done that... multiple times.)&lt;br />&lt;br />Machines are made to automate trivial and repetitive tasks like the above, and they are actually very good at that. Over the years, I have performed NetBSD updates manually and later written crappy, unreliable scripts to do the upgrades for me. These scripts have never been reusable and they haven't dealt with error conditions gracefully. Furthermore, because these scripts live in my home directory, I have to remember to carry them around every time I set up a new NetBSD box.&lt;br />&lt;br />It was about time I sat down and rewrote my custom scripts into something more "decent". Something with documentation, with a configuration file, and with tests.&lt;br />&lt;br />So today, and for all the reason above, I am &lt;a href="http://mail-index.netbsd.org/pkgsrc-changes/2012/08/06/msg076544.html">introducing sysupgrade&lt;/a>.&lt;br />&lt;br />sysupgrade is a script that automates (trivializes) the whole process of upgrading an existing NetBSD installation to a newer release,&amp;nbsp;be it the currently-running system or a non-live system. sysupgrade does so by following the steps outlined above and is coordinated by a configuration file. You can find the tool in &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysupgrade/?only_with_tag=MAIN">&lt;span id="goog_1890316919">&lt;/span>pkgsrc/sysutils/sysupgrade&lt;span id="goog_1890316920">&lt;/span>&lt;/a>, next to sysbuild. The bundled &lt;tt>sysupgrade(8)&lt;/tt> and &lt;tt>sysupgrade.conf(5)&lt;/tt> manual pages, and the default &lt;tt>sysupgrade.conf&lt;/tt> configuration file should get you started and hopefully answer most of your questions.&lt;br />&lt;br />For the impatient, the following command would upgrade your machine to the specified version target:&lt;br />&lt;br />&lt;tt>$ sysupgrade auto &lt;/tt>&lt;br />&lt;tt>&amp;nbsp; &amp;nbsp; ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-&amp;lt;X.Y.Z&amp;gt;/$(uname -m)&lt;/tt>&lt;br />&lt;br />At the moment, please consider sysupgrade to be experimental. It works well for me on my various machines (running both NetBSD 6.0 BETA and -current), and I have been using the upgrade procedure outlined above for years without issues. However, as with any shiny-new software, be careful. If you use NetBSD on a virtual machine, take a snapshot before running this tool; I don't think your machine is going to blow up, but better safe than sorry!&lt;br />&lt;br />Enjoy, and feedback very welcome!&lt;br />&lt;br />PS: There is lots of room for improvement. The &lt;tt>TODO&lt;/tt> file in the package directory includes some of the ideas I'd like to work on later.</description></item><item><title>Introducing sysbuild for NetBSD</title><link>https://jmmv.dev/2012/07/introducing-sysbuild-for-netbsd.html</link><pubDate>Wed, 25 Jul 2012 08:26:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2012/07/introducing-sysbuild-for-netbsd.html</guid><description>NetBSD's build system is close to awesome: after checking a source tree out from CVS on virtually any Unix-like operating sytem, building a full NetBSD release for any of the supported platforms is as simple as running the &lt;tt>build.sh&lt;/tt> script with the right arguments.&lt;br />&lt;br />There are, however, a few things that would deserve automation in this process, but that are not in &lt;tt>build.sh&lt;/tt>'s domain to solve. These are:&lt;br />&lt;ul>&lt;li>&lt;span style="background-color: white;">Fetching and keeping the source tree up to date: interacting with CVS is still the responsibility of the user.&lt;/span>&lt;/li>&lt;li>&lt;span style="background-color: white;">Simplifying the call to &lt;tt>build.sh&lt;/tt>: this script takes a ton of arguments, and running it by hand quickly becomes "annoying". It would be nice if all the desired values to its arguments where stored elsewhere and picked up automatically. (&lt;tt>mk.conf&lt;/tt> may not always be the right choice.)&lt;/span>&lt;/li>&lt;li>&lt;span style="background-color: white;">Plugging into your crontab(5) for easy periodic rebuilds of NetBSD, &lt;i>with proper reporting of failures&lt;/i>. Upgrading a live system from source is a major supported mechanism (particularly for NetBSD-current), so having a way to keep fresh release files around is welcome.&lt;/span>&lt;/li>&lt;li>Performing such daily rebuilds of NetBSD as a dedicated unprivileged user.&lt;/li>&lt;/ul>&lt;div>To anybody familiar with NetBSD, it is obvious that all the above items are "simple enough" to solve one by one; however, doing them by hand &lt;i>gets old very quickly&lt;/i> — machines exist to make our life easier, don't they? I know I am not the only one that has custom local wrapper scripts around &lt;tt>build.sh&lt;/tt>, and I also know that my scripts were ad-hoc, ugly and non-reusable. (Also, of course, anybody new to NetBSD will certainly not find any of the above trivial, but that's secondary.)&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>To this end, I have written a script that automates all the aforementioned steps in a single tool, driven by configuration files that specify what to do. &lt;b>Enter &lt;tt>sysbuild&lt;/tt>.&lt;/b>&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;h2> My setup&lt;/h2>&lt;div>These days, my main NetBSD development box is a virtual machine. For a couple of years, I have been carrying around this virtual machine across machines and slowly tuning its configuration to suit my needs. The way I work is the following:&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">I keep a read-write copy of the sources under my home directory, which is the one I use for my development work. This copy is accompanied by&amp;nbsp;&lt;/span>&lt;span style="background-color: white;">a script in my home directory that, given a machine type, updates the sources and rebuilds NetBSD for that machine type, using a known directory layout within my home directory.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">I also&amp;nbsp;&lt;/span>&lt;span style="background-color: white;">keep a read-only copy of the sources under &lt;tt>/usr/src&lt;/tt>, checked out from anoncvs.&amp;nbsp;&lt;/span>&lt;span style="background-color: white;">This copy is used by the dedicated "builder" system user to perform dedicated rebuilds of NetBSD.&amp;nbsp;&lt;/span>&lt;span style="background-color: white;">The "builder" user also has a custom script (but different than the other one!) that updates &lt;tt>/usr/src&lt;/tt>, rebuilds NetBSD for the machine types I am interested in, records full logs to files and places the build results into a shared network drive. Lastly, t&lt;/span>&lt;span style="background-color: white;">he dedicated "builder" user has a cron job that runs the previous script overnight.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;div>The purpose of this dual setup is to always have a fresh release build somewhere in the system, built from pristine sources, while at the same time allowing me to do my development work in a tree that I could break at any time.&lt;/div>&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Unfortunately, the size of the virtual disk of my development box has become too small for my current needs, and in order to fix this I prefer to start afresh. The thought of having to set up this whole scheme all over again, &lt;i>by hand&lt;/i>, is what triggered the creation of &lt;tt>sysbuild&lt;/tt>.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;h2> Getting started&lt;/h2>&lt;div>&lt;tt>sysbuild&lt;/tt> lives in pkgsrc under the &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysbuild/?only_with_tag=MAIN">pkgsrc/sysutils/sysbuild&lt;/a> directory. This package provides the main script, tests, sample configuration files and the extensive manual page. Installing the script is as easy as installing any other package, and I would recommend reading its documentation now.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Once installed, &lt;tt>sysbuild&lt;/tt> should be ready to use out of the box assuming that you have write access to &lt;tt>/usr/src&lt;/tt>. Simply typing &lt;tt>sysbuild build&lt;/tt> from anywhere in the system will cause the source tree to be updated and a release for your current platform to be built.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>If you wish to customize the behavior of &lt;tt>sysbuild&lt;/tt>, copy &lt;tt>/usr/pkg/etc/sysbuild/default.conf&lt;/tt> to &lt;tt>~/.sysbuild/default.conf&lt;/tt> and edit the latter. The tool will pick it up on the next execution and use your new configuration settings. You can, of course, manage a variety of configurations in case you want to do different builds (say -current and 6.x).&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;h2> Setting up a daily cron job&lt;/h2>&lt;div>The&amp;nbsp;&lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/sysutils/sysbuild-user/?only_with_tag=MAIN" style="background-color: white;">pkgsrc/sysutils/sysbuild-user&lt;/a>&lt;span style="background-color: white;">&amp;nbsp;package is a convenience bundle that manages a "sysbuild" unprivileged user in the system and installs a sample crontab to perform the desired periodic rebuilds of NetBSD. This crontab uses the &lt;tt>sysbuild4cron&lt;/tt> script, which is a very simple utility to run &lt;tt>sysbuild&lt;/tt>, store its output in a file, and send an error report any time the execution fails.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">Simply installing the package will cause the creation of the "sysbuild" user and the configuration of this sample cron job. Follow the instructions provided by the package in its &lt;tt>MESSAGE&lt;/tt> file to tune the behavior of any of these.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;h2> &lt;span style="background-color: white;">Concluding trivia&lt;/span>&lt;/h2>&lt;div>&lt;span style="background-color: white;">Yes, these scripts are extremely tied to my particular workflow and use cases, although I don't think my needs are that special. However, I have attempted to come up with a generic-enough script and configuration file to allow the addition of new features.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">You may notice that &lt;tt>sysbuild&lt;/tt>'s version is 2.0 and not 1.0. While preparing the script for addition to &lt;tt>pkgsrc&lt;/tt>, &lt;tt>cvs add&lt;/tt> barfed that I was re-adding previously-deleted files. Uh hum, what a surprise! Upon reading the CVS log of the package's &lt;tt>Makefile&lt;/tt>, I found that 10 years ago &lt;a href="http://mail-index.netbsd.org/netbsd-users/2002/11/15/0003.html">I already wrote&lt;/a> this exact same script and that two years after &lt;a href="http://mail-index.netbsd.org/tech-pkg/2004/05/19/0001.html">it got deleted&lt;/a> because it stopped working. I had completely forgotten about this! However, seeing &lt;tt>pkg_comp&lt;/tt>'s messy code (which was written around the same time), I imagine that the previous implementation of this idea was messy; I don't dare to look at the previous code.&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">&lt;br />&lt;/span>&lt;/div>&lt;div>&lt;span style="background-color: white;">Enjoy!&lt;/span>&lt;/div></description></item><item><title>Introducing Lutok: A lightweight C++ API for Lua</title><link>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</link><pubDate>Thu, 15 Sep 2011 15:18:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html</guid><description>It has finally happened. &lt;a href="http://code.google.com/p/lutok/">Lutok&lt;/a> is the result of what was promised in the "&lt;a href="https://jmmv.dev/2011/09/splitting-utilslua-from-kyua.html">Splitting utils::lua from Kyua&lt;/a>" web post.&lt;br />&lt;br />Quoting the project web page:&lt;br />&lt;blockquote>Lutok provides thin C++ wrappers around the Lua C API to ease the interaction between C++ and Lua. These wrappers make intensive use of RAII to prevent resource leakage, expose C++-friendly data types, report errors by means of exceptions and ensure that the Lua stack is always left untouched in the face of errors. The library also provides a small subset of miscellaneous utility functions built on top of the wrappers.&lt;br />&lt;br />Lutok focuses on providing a clean and safe C++ interface; the drawback is that it is not suitable for performance-critical environments. In order to implement error-safe C++ wrappers on top of a Lua C binary library, Lutok adds several layers or abstraction and error checking that go against the original spirit of the Lua C API and thus degrade performance.&lt;br />&lt;br />Lutok was originally developed within Kyua but was later split into its own project to make it available to general developers.&lt;/blockquote>Coming up with a name for this project was quite an odyssey, and is what has delayed is release more than I wanted. My original candidate was "luawrap" which, although not very original, was to-the-point and easy to understand. Unfortunately, that name did not clear with the legal department and I had to propose several other names, some of which were not acceptable either. Eventually, I settled with "Lutok", which comes from "LUa TOolKit".&lt;br />&lt;br />At this point, the source tree of Lutok provides pretty much the same code as the &lt;tt>utils::lua&lt;/tt> module of Kyua. While it may be enough to get you started, I'm pretty sure you will lack some functions in the &lt;tt>state&lt;/tt> class. If that is the case, don't hesitate to file a bug report to let me know what is missing.&lt;br />&lt;br />In case you missed the link above, the project page is here: &lt;a href="http://code.google.com/p/lutok/">Lutok in Google Code&lt;/a>.</description></item></channel></rss>