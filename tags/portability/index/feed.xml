<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>portability on Julio Merino (jmmv.dev)</title>
    <link>https://jmmv.dev/tags/portability/index/</link>
    <description>Recent content in portability on Julio Merino (jmmv.dev)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Jan 2019 17:15:00 -0500</lastBuildDate>
    
	<atom:link href="https://jmmv.dev/tags/portability/index/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Open files limit, macOS, and the JVM</title>
      <link>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</link>
      <pubDate>Tue, 29 Jan 2019 17:15:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</guid>
      <description>Bazel&amp;rsquo;s original raison d&amp;rsquo;etre was to support Google&amp;rsquo;s monorepo. A consequence of using a monorepo is that some builds will become very large. And large builds can be very resource hungry, especially when using a tool like Bazel that tries to parallelize as many actions as possible for efficiency reasons. There are many resource types in a system, but today I&amp;rsquo;d like to focus on the number of open files at any given time (nofiles).</description>
    </item>
    
    <item>
      <title>#! /usr/bin/env considered harmful</title>
      <link>https://jmmv.dev/2016/09/env-considered-harmful.html</link>
      <pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate>
      
      <guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid>
      <description>Many programming guides recommend to begin scripts with the #! /usr/bin/env shebang in order to to automatically locate the necessary interpreter. For example, for a Python script you would use #! /usr/bin/env python, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.
The reason for this recommendation is that /usr/bin/env python will search the PATH for a program called python and execute the first one found&amp;hellip; and that usually works fine on one&amp;rsquo;s own machine.</description>
    </item>
    
    <item>
      <title>Using va_copy to safely pass ap arguments around</title>
      <link>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</link>
      <pubDate>Mon, 12 Sep 2011 22:34:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</guid>
      <description>Update (2014-12-19): The advice provided in this blog post is questionable and, in fact, probably incorrect. The bug described below must have happened for some unrelated reason (like, maybe, reuse of ap), but at this point (three years later!) I do not really remember what was going on here nor have much interest in retrying.
A long time ago, while I was preparing an ATF release, I faced many failing tests and crashes in one of the platforms under test.</description>
    </item>
    
    <item>
      <title>Forget about test(1)&#39;s == operator</title>
      <link>https://jmmv.dev/2010/04/forget-about-test1s-operator.html</link>
      <pubDate>Sat, 24 Apr 2010 17:24:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2010/04/forget-about-test1s-operator.html</guid>
      <description>Some implementations of test(1), in an attempt to be smart, provide non-standard operators such as ==. Please forget about those: they make your scripts non-portable and a pain to use in other systems. Why? Because, due to the way the shell works, failures in calls to test(1) will often just result in an error message (which may not be seen due to other output) and the script will happily continue running even if it missed to perform some important operation.</description>
    </item>
    
    <item>
      <title>Always define an else clause for portability #ifdefs</title>
      <link>https://jmmv.dev/2010/04/always-define-else-clause-for.html</link>
      <pubDate>Thu, 22 Apr 2010 09:51:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2010/04/always-define-else-clause-for.html</guid>
      <description>If you use #ifdef conditionals in your code to check for portability features, be sure to always define a catch-all else clause that actually does something, even if this something is to error out.
Consider the following code snippet, quoted from gamin&#39;s tests/testing.c file:if (arg != NULL) {
#ifdef HAVE_SETENV
setenv(&#34;GAM_CLIENT_ID&#34;, arg, 1);
#elif HAVE_PUTENV
char *client_id = malloc (strlen (arg) + sizeof &#34;GAM_CLIENT_ID=&#34;);
if (client_id)
{
strcpy (client_id, &#34;GAM_CLIENT_ID=&#34;);</description>
    </item>
    
    <item>
      <title>unlink(2) can actually remove directories</title>
      <link>https://jmmv.dev/2008/02/unlink2-can-actually-remove-directories.html</link>
      <pubDate>Sun, 03 Feb 2008 10:42:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2008/02/unlink2-can-actually-remove-directories.html</guid>
      <description>I have always thought that unlink(2) was meant to remove files only but, yesterday, SunOS (SXDE 200709) proved my wrong. I was sanity-checking the source tree for the imminent ATF 0.4 release under this platform, which is always scary, and the tests for the atf::fs::remove function were failing &amp;mdash; only when run as root.
The failure happened in the cleanup phase of the test case, in which ATF attempts to recursively remove the temporary work directory.</description>
    </item>
    
    <item>
      <title>How to kill a tree of processes</title>
      <link>https://jmmv.dev/2008/01/how-to-kill-tree-of-processes.html</link>
      <pubDate>Wed, 16 Jan 2008 17:31:00 -0500</pubDate>
      
      <guid>https://jmmv.dev/2008/01/how-to-kill-tree-of-processes.html</guid>
      <description>Yesterday I mentioned the need for a way to kill a tree of processes in order to effectively implement timeouts for test cases. Let&#39;s see how the current algorithmÂ in ATF works:
The root process is stopped by sending a SIGSTOP to it so that it cannot spawn any new children while being processed.Get the whole list of active processes and filter them to only get those that are direct children of the root process.</description>
    </item>
    
    <item>
      <title>SoC: Prototypes for basename and dirname</title>
      <link>https://jmmv.dev/2007/06/soc-prototypes-for-basename-and-dirname.html</link>
      <pubDate>Thu, 28 Jun 2007 17:22:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2007/06/soc-prototypes-for-basename-and-dirname.html</guid>
      <description>Today, I&#39;ve attempted to build atf on a NetBSD 4.0_BETA2 system I&#39;ve been setting up in a spare box I had around, as opposed to the Mac OS X system I&#39;m using for daily development. The build failed due to some well-understood problems, but there was an annoying one with respect to some calls to the standard XPG basename(3) and dirname(3) functions.
According to the Mac OS X manual pages for those functions, they are supposed to take a const char * argument.</description>
    </item>
    
  </channel>
</rss>