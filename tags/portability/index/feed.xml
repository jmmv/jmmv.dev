<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Portability on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/portability/index.html</link><description>Recent content in Portability on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Tue, 29 Jan 2019 17:15:00 -0500</lastBuildDate><atom:link href="https://jmmv.dev/tags/portability/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Open files limit, macOS, and the JVM</title><link>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</link><pubDate>Tue, 29 Jan 2019 17:15:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2019/01/open-files-limit-macos-and-jvm.html</guid><description>&lt;p>Bazel&amp;rsquo;s original &lt;a href="https://www.dictionary.com/browse/raison-d-etre">raison d&amp;rsquo;etre&lt;/a> was to support Google&amp;rsquo;s monorepo. A consequence of using a monorepo is that some builds will become very large. And large builds can be very resource hungry, especially when using a tool like Bazel that tries to parallelize as many actions as possible for efficiency reasons. There are many resource types in a system, but today I&amp;rsquo;d like to focus on the number of open files at any given time (&lt;code>nofiles&lt;/code>).&lt;/p></description></item><item><title>#! /usr/bin/env considered harmful</title><link>https://jmmv.dev/2016/09/env-considered-harmful.html</link><pubDate>Wed, 14 Sep 2016 07:07:46 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2016/09/env-considered-harmful.html</guid><description>&lt;p>Many programming guides recommend to begin scripts with the &lt;code>#! /usr/bin/env&lt;/code> &lt;a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang&lt;/a> in order to to automatically locate the necessary interpreter. For example, for a Python script you would use &lt;code>#! /usr/bin/env python&lt;/code>, and then the saying goes, the script would &amp;ldquo;just work&amp;rdquo; on any machine with Python installed.&lt;/p>
&lt;p>The reason for this recommendation is that &lt;code>/usr/bin/env python&lt;/code> will search the &lt;code>PATH&lt;/code> for a program called &lt;code>python&lt;/code> and execute the first one found&amp;hellip; and that usually works fine &lt;em>on one&amp;rsquo;s own machine&lt;/em>.&lt;/p></description></item><item><title>Using va_copy to safely pass ap arguments around</title><link>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</link><pubDate>Mon, 12 Sep 2011 22:34:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2011/09/using-vacopy-to-safely-pass-ap.html</guid><description>&lt;p>&lt;b>Update (2014-12-19)&lt;/b>: The advice provided in this blog post is questionable and, in fact, probably incorrect. The bug described below must have happened for some unrelated reason (like, maybe, reuse of &lt;tt>ap&lt;/tt>), but at this point (three years later!) I do not really remember what was going on here nor have much interest in retrying.&lt;/p>A long time ago, while I was preparing an ATF release, I faced many failing tests and crashes in one of the platforms under test. My memory told me this was a problem in OpenSolaris, but the &lt;a href="http://www.blogger.com/mtn-host.prjek.net/viewmtn/atf/revision/info/655c6c51f2155076f482a038042c67fd25adc934">repository logs&lt;/a> say that the problem really happened in Fedora 8 x86_64.&lt;br />The problem manifested itself as segmentation faults pretty much everywhere, and I could trace such crashes down to pieces of code like the following, of which the C code of ATF is full of:&lt;br />&lt;pre>void&lt;br />foo_fmt(const char *fmt, ...)&lt;br />{&lt;br /> va_list ap;&lt;br />&lt;br /> va_start(ap, fmt);&lt;br /> foo_ap(fmt, ap);&lt;br /> va_end(ap);&lt;br />}&lt;br />&lt;br />void&lt;br />foo_ap(const char *fmt, va_list ap)&lt;br />{&lt;br /> char buf[128];&lt;br />&lt;br /> vsnprintf(buf, sizeof(buf), fmt, ap);&lt;br />&lt;br /> ... now, do something with buf ...&lt;br />}&lt;/pre>The codebase of ATF provides &lt;tt>_fmt&lt;/tt> and &lt;tt>_ap&lt;/tt> variants for many functions to give more flexibility to the caller and, as shown above, the &lt;tt>_fmt&lt;/tt> variant just relies on the &lt;tt>_ap&lt;/tt> variant to do the real work.&lt;br />Now, the crashes that appeared from the code above seemed to come from the call that consumes the &lt;tt>ap&lt;/tt> argument, which in this case is &lt;tt>vsnprintf&lt;/tt>. Interestingly, though, all the tests in other platforms but Linux x86_64 worked just fine, and this included OpenSolaris, other Linux distributions, some BSDs and even different hardware platforms.&lt;br />As it turned out, you &lt;b>cannot blindly pass &lt;tt>ap&lt;/tt> arguments around&lt;/b> because they are not "normal" parameters (even though, unfortunately, they look like so!). In most platforms, the &lt;tt>ap&lt;/tt> element will be just an "absolute" pointer to the stack, so passing the variable to an inner function calls is fine because the caller's stack has not been destroyed yet and, therefore, the pointer is still valid. But... the &lt;tt>ap&lt;/tt> argument can have other representations. It'd be an offset to the stack instead of a pointer, or it'd be a data structure that holds all the variable parameters. If, for example, the &lt;tt>ap&lt;/tt> argument held an offset, passing it to an inner function call would make such offset point to "garbage" because the stack would have been grown due to the new call frame. (I haven't investigated what specific representation is x86_64 using.)&lt;br />The solution is to use the &lt;tt>va_copy&lt;/tt> function to generate a new &lt;tt>ap&lt;/tt> object that is valid for the current stack frame. This is easy, so as an example, we have to rewrite the &lt;tt>foo_ap&lt;/tt> function above as follows:&lt;br />&lt;pre>void&lt;br />foo_ap(const char *fmt, va_list ap)&lt;br />{&lt;br /> char buf[128];&lt;br /> va_list ap2;&lt;br />&lt;br /> va_copy(ap2, ap);&lt;br /> vsnprintf(buf, sizeof(buf), fmt, ap2);&lt;br /> va_end(ap2);&lt;br />&lt;br /> ... now, do something with buf ...&lt;br />}&lt;/pre>This duplication of the &lt;tt>ap&lt;/tt> argument pointing to the variable list of arguments ensures that &lt;tt>ap2&lt;/tt> can be safely used from the new stack frame.</description></item><item><title>Forget about test(1)'s == operator</title><link>https://jmmv.dev/2010/04/forget-about-test1s-operator.html</link><pubDate>Sat, 24 Apr 2010 17:24:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2010/04/forget-about-test1s-operator.html</guid><description>Some implementations of test(1), in an attempt to be smart, provide non-standard operators such as &lt;tt>==&lt;/tt>. Please forget about those: they make your scripts non-portable and a pain to use in other systems. Why? Because, due to the way the shell works, failures in calls to test(1) will often just result in an error message (which may not be seen due to other output) and the script will happily continue running even if it missed to perform some important operation.&lt;br />&lt;br />So... just use the standard equality operators:&lt;br />&lt;ul>&lt;li>&lt;tt>=&lt;/tt> for string equality comparison.&lt;/li>&lt;li>&lt;tt>-eq&lt;/tt> for numeric equality comparison.&lt;/li>&lt;/ul>Note that whenever I refer to test(1), I'm also talking about the &lt;tt>[ ... ]&lt;/tt> construction in conditionals.&lt;br />&lt;br />Also, please note that this also affects configure scripts, and the problem in these appears much more commonly than in other scripts!</description></item><item><title>Always define an else clause for portability #ifdefs</title><link>https://jmmv.dev/2010/04/always-define-else-clause-for.html</link><pubDate>Thu, 22 Apr 2010 09:51:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2010/04/always-define-else-clause-for.html</guid><description>If you use &lt;tt>#ifdef&lt;/tt> conditionals in your code to check for portability features, be sure to always define a catch-all else clause that actually does something, even if this something is to error out.&lt;br />&lt;br />Consider the following code snippet, quoted from gamin's &lt;tt>tests/testing.c&lt;/tt> file:&lt;pre>if (arg != NULL) {&lt;br />#ifdef HAVE_SETENV&lt;br /> setenv("GAM_CLIENT_ID", arg, 1);&lt;br />#elif HAVE_PUTENV&lt;br /> char *client_id = malloc (strlen (arg) + sizeof "GAM_CLIENT_ID=");&lt;br /> if (client_id)&lt;br /> {&lt;br /> strcpy (client_id, "GAM_CLIENT_ID=");&lt;br /> strcat (client_id, arg);&lt;br /> putenv (client_id);&lt;br /> }&lt;br />#endif /* HAVE_SETENV */&lt;br />}&lt;br />ret = FAMOpen(&amp;amp;(testState.fc));&lt;/pre>The &lt;tt>FAMOpen&lt;/tt> method queries the &lt;tt>GAM_CLIENT_ID&lt;/tt> environment variable to set up the connections parameters to the FAM server. If the variable is not defined, the connection will still work, even though it will use some default internal value. In the test code above, the variable is explicitly set to let the tests use a separate server instance.&lt;br />&lt;br />Now, did you notice that we have to conditional branches? One for &lt;tt>setenv&lt;/tt> and one for &lt;tt>putenv&lt;/tt>? It seems reasonable to assume that one or the other must be present on any Unix system. Unfortunately, this is flawed:&lt;br />&lt;ul>&lt;li>What happens if the code forgets to include &lt;tt>config.h&lt;/tt>?&lt;/li>&lt;li>What happens if the configure script fails to detect &lt;i>both&lt;/i> &lt;tt>setenv&lt;/tt> and &lt;tt>putenv&lt;/tt>? This is not that uncommon, given how some configure scripts are written.&lt;/li>&lt;li>What happens if neither &lt;tt>setenv&lt;/tt> nor &lt;tt>putenv&lt;/tt> are available?&lt;br />&lt;/li>&lt;/ul>The answer to the three questions is: in the above code snippet, the code &lt;tt>builds just fine&lt;/tt> but will misbehave at run time: neither &lt;tt>HAVE_SETENV&lt;/tt> nor &lt;tt>HAVE_PUTENV&lt;/tt> are defined, so the code will not be able to define the required environment variable. However, &lt;tt>FAMOpen&lt;/tt> will later be called and it will not behave as expected because the variable has not been set.&lt;br />&lt;br />Note that this code snippet is just an example. I have seen many more instances of this exact same problem with worse consequences than the above. Read: they were not part of the test code, but just part of the regular code path.&lt;br />&lt;br />So how do you implement the above in a saner way? You have two alternatives:&lt;br />&lt;ul>&lt;li>Add an &lt;tt>#else&lt;/tt> clause that contains a fallback implementation. In the case above, we could, for example, prefer to use &lt;tt>setenv&lt;/tt> if present because it has a nicer interface, and fall back to &lt;tt>putenv&lt;/tt> if not found.&lt;br />This has a disadvantage though: if you forget to include &lt;tt>config.h&lt;/tt> or the configure script cannot correctly detect one of the possible implementations (even when present), you will always use the fallback implementation.&lt;/li>&lt;li>Keep each possible implementation correctly protected by a conditional, but add a &lt;tt>#else&lt;/tt> clause that raises an error at &lt;i>build time&lt;/i>. This will make sure that you never forget to define at least one of the portability macros for any reason. This is the preferred approach.&lt;/li>&lt;/ul>Following the second suggestion above, the code would get the following structure: &lt;pre>#if defined(HAVE_SETENV)&lt;br />setenv(...);&lt;br />#elif defined(HAVE_PUTENV)&lt;br />putenv(...);&lt;br />#else&lt;br /># error "Don't know how to set environment variables."&lt;br />#endif&lt;/pre>With this code, we can be sure that the code will not build if none of the possible implementations are selected. We can later proceed to investigate why that happened.</description></item><item><title>unlink(2) can actually remove directories</title><link>https://jmmv.dev/2008/02/unlink2-can-actually-remove-directories.html</link><pubDate>Sun, 03 Feb 2008 10:42:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2008/02/unlink2-can-actually-remove-directories.html</guid><description>I have always thought that unlink(2) was meant to remove files only but, yesterday, SunOS (&lt;a href="http://developers.sun.com/sxde/">SXDE&lt;/a> 200709) proved my wrong. I was sanity-checking the source tree for the imminent &lt;a href="http://www.NetBSD.org/~jmmv/atf/">ATF&lt;/a> 0.4 release under this platform, which is always scary, and the tests for the &lt;tt>atf::fs::remove&lt;/tt> function were failing &amp;mdash; only when run as root.&lt;br />&lt;br />The failure happened in the cleanup phase of the test case, in which ATF attempts to recursively remove the temporary work directory. When it attempted to remove one of the directories inside it, it failed with a ENOENT message, which in SunOS may mean that the directory is not empty. Strangely, when inspecting the left-over work tree, that directory was indeed empty and it could not be removed with &lt;tt>rm -rf&lt;/tt> nor with &lt;tt>rmdir&lt;/tt>.&lt;br />&lt;br />The manual page for &lt;tt>unlink(2)&lt;/tt> finally gave me the clue of what was happening:&lt;blockquote>If the path argument is a directory and the filesystem supports unlink() and unlinkat() on directories, the directory is unlinked from its parent with no cleanup being performed. In UFS, the disconnected directory will be found the next time the filesystem is checked with fsck(1M). The unlink() and unlinkat() functions will not fail simply because a directory is not empty. The user with appropriate privileges can orphan a non-empty directory without generating an error message.&lt;/blockquote>The solution was easy: as my custom &lt;tt>remove&lt;/tt> function is supposed to remove files only, I added a check before the call to &lt;tt>unlink(2)&lt;/tt> to ensure that the path name does not point to a directory. Not the prettiest possibility (because it is subject to race-conditions even though it is not critical), but it works.</description></item><item><title>How to kill a tree of processes</title><link>https://jmmv.dev/2008/01/how-to-kill-tree-of-processes.html</link><pubDate>Wed, 16 Jan 2008 17:31:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2008/01/how-to-kill-tree-of-processes.html</guid><description>&lt;a href="http://julipedia.blogspot.com/2008/01/implementing-timeouts-for-test-cases.html">Yesterday&lt;/a> I mentioned the need for a way to kill a tree of processes in order to effectively implement timeouts for test cases. Let's see how the &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/f51b4c7f694ff98e0e303743797eb3cccb6f9ea4/atf/procs.cpp">current algorithm&lt;/a> in ATF works:&lt;br />&lt;div>&lt;ol>&lt;li>The root process is stopped by sending a SIGSTOP to it so that it cannot spawn any new children while being processed.&lt;/li>&lt;li>Get the whole list of active processes and filter them to only get those that are direct children of the root process.&lt;/li>&lt;li>Iterate over all the direct children and repeat from 1, recursively.&lt;/li>&lt;li>Send the real desired signal (typically SIGTERM) to the root process.&lt;/li>&lt;/ol>&lt;div>There are two major caveats in the above algorithm. First, point 2. There is no standard way to get the list of processes of a Unix system, so I have had to code three different implementations so far for this trivial requirement: one for NetBSD's KVM, one for Mac OS X's sysctl kern.proc node and one for Linux's procfs.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Then, and the worst one, comes in point 4. Some systems (Linux and Mac OS X so far) do not seem to allow one to send a signal to a stopped process. Well, strictly speaking they allow it, but the second signal seems to be simply ignored whereas under NetBSD the process' execution is resumed and the signal is delivered. I do not know which behavior is right.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>If we cannot send the signal to the stopped process, we can run into a race condition: we have to wake it up by sending a SIGCONT and then deliver the signal, but in between these events the process may have spawned new children that we are not aware of.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>&lt;i>Still&lt;/i>, being able to send a signal to a stopped process does not completely resolve the race condition. If we are sending a signal that the user can reprogram (such as SIGTERM), that process may fork another one before exiting, and thus we'd not kill this one.  But... well... this is impossible to resolve with the existing kernel APIs as far as I can tell.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>One solution to this problem is killing a timed-out test by using SIGKILL instead of SIGTERM. SIGKILL could work on any case because means &lt;i>die immediately&lt;/i>, without giving a chance to the process to mess with it. Therefore SIGCONT would not be needed in any case &amp;mash;because you can simply kill a stopped process and it will die immediately as expected&amp;mdash; and the process would not have a chance to spawn any more children after it had been stopped.&lt;/div>&lt;div>&lt;br />&lt;/div>&lt;div>Blah, after writing this I wonder why I went with all the complexity of dealing with signals that are not SIGKILL... say over-engineering if you want...&lt;/div>&lt;/div></description></item><item><title>SoC: Prototypes for basename and dirname</title><link>https://jmmv.dev/2007/06/soc-prototypes-for-basename-and-dirname.html</link><pubDate>Thu, 28 Jun 2007 17:22:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/06/soc-prototypes-for-basename-and-dirname.html</guid><description>Today, I've attempted to build atf on a NetBSD 4.0_BETA2 system I've been setting up in a spare box I had around, as opposed to the Mac OS X system I'm using for daily development. The build failed due to some well-understood problems, but there was an annoying one with respect to some calls to the standard XPG basename(3) and dirname(3) functions.&lt;br />&lt;br />According to the Mac OS X manual pages for those functions, they are supposed to take a &lt;tt>const char *&lt;/tt> argument. However, the NetBSD versions of these functions take a plain &lt;tt>char *&lt;/tt> parameter instead &amp;mdash; i.e., &lt;i>not&lt;/i> a &lt;i>constant&lt;/i> pointer.&lt;br />&lt;br />After Googling for some references and with advice from joerg@, I got the answer: it turns out that the XPG versions&lt;sup>1&lt;/sup> of basename and dirname &lt;i>can&lt;/i> modify the input string by trimming trailing directory separators (even though the current implementation in NetBSD does not do that). This makes no sense to me, but it's what the XPG4.2 and POSIX.1 standards specify.&lt;br />&lt;br />I've resolved this issue by simply re-implementing basename and dirname (which I wanted to do anyway), making my own versions take and return constant strings. And to make things safer, I've added a check to the configure script that verifies if the basename and dirname implementations take a constant pointer and, in that (incorrect) case, use the standard functions to sanity-check the results of my own by means of an assertion.&lt;br />&lt;br />&lt;sup>1&lt;/sup> How not, the GNU libc library provides its own variations of basename and dirname. However, including &lt;tt>libgen.h&lt;/tt> forces the usage of the XPG versions.</description></item></channel></rss>