<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hardware on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/hardware/index.html</link><description>Recent content in Hardware on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&#150;2025 Julio Merino</copyright><lastBuildDate>Fri, 28 Feb 2025 16:15:00 -0800</lastBuildDate><atom:link href="https://jmmv.dev/tags/hardware/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Hardware autoconf: ACPI &amp; Device Tree</title><link>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</link><pubDate>Fri, 28 Feb 2025 16:15:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</guid><description>&lt;p>If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&amp;mdash;say a sound card or a network card&amp;mdash;had physical switches or jumpers in it. These switches configured the card&amp;rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.&lt;/p>
&lt;p>But that wasn&amp;rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software &lt;em>which&lt;/em> specific cards you had and how you had configured them. Remember &lt;code>SET BLASTER=A220 I5 D1 H5&lt;/code>? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.&lt;/p>
&lt;p>Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus &lt;a href="https://wiki.osdev.org/ISA">ISA &amp;ldquo;Plug and Play&amp;rdquo;&lt;/a>, or PnP for short, was born in the early 1990s&amp;mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&amp;rsquo;s scene where we just attach devices to external USB connectors and things &amp;ldquo;magically work&amp;rdquo;.&lt;/p>
&lt;p>But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-02-28-jumpers.jpg" length="89630" type="image/jpeg"/></item><item><title>Hardware autoconf: ACPI &amp; Device Tree</title><link>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</link><pubDate>Fri, 28 Feb 2025 16:15:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2025/02/hardware-autoconfiguration.html</guid><description>&lt;p>If you grew up in the PC scene during the 1980s or early 1990s, you know how painful it was to get hardware to work. And if you did not witness that (lucky you) here is how it went: every piece of hardware in your PC&amp;mdash;say a sound card or a network card&amp;mdash;had physical switches or jumpers in it. These switches configured the card&amp;rsquo;s I/O address space, interrupts, and DMA ports, and you had to be careful to select values that did not overlap with other cards.&lt;/p>
&lt;p>But that wasn&amp;rsquo;t all. Once you had configured the physical switches, you had to tell the operating system and/or software &lt;em>which&lt;/em> specific cards you had and how you had configured them. Remember &lt;code>SET BLASTER=A220 I5 D1 H5&lt;/code>? This DOS environment variable told programs which specific Sound Blaster you had installed and which I/O settings you had selected via its jumpers.&lt;/p>
&lt;p>Not really fun. It was common to have hardware conflicts that yielded random lock-ups, and thus &lt;a href="https://wiki.osdev.org/ISA">ISA &amp;ldquo;Plug and Play&amp;rdquo;&lt;/a>, or PnP for short, was born in the early 1990s&amp;mdash;a protocol for the legacy ISA bus to enumerate its devices and to configure their settings via software. Fast-forward to today&amp;rsquo;s scene where we just attach devices to external USB connectors and things &amp;ldquo;magically work&amp;rdquo;.&lt;/p>
&lt;p>But how? How does the kernel know which physical devices exist and how does it know which of the many device drivers it contains can handle each device? Enter the world of hardware discovery.&lt;/p></description><enclosure url="https://jmmv.dev/images/2025-02-28-jumpers.jpg" length="89630" type="image/jpeg"/></item><item><title>Synology DS923+ vs. FreeBSD w/ZFS</title><link>https://jmmv.dev/2024/12/synology-ds923-vs-freebsd.html</link><pubDate>Fri, 13 Dec 2024 09:10:00 -0800</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2024/12/synology-ds923-vs-freebsd.html</guid><description>&lt;p>My interest in storage is longstanding&amp;mdash;I loved playing with different file systems in my early Unix days and then I worked on Google&amp;rsquo;s and Microsoft&amp;rsquo;s distributed storage solutions&amp;mdash;and, about four years ago, I started running a home-grown NAS leveraging FreeBSD and its excellent ZFS support. I first hosted the server on a PowerMac G5 and then upgraded it to an overkill 72-core ThinkStation that I snapped second-hand for a great price.&lt;/p>
&lt;p>But as stable and low maintenance as FreeBSD is, running day-to-day services myself is not my idea of &amp;ldquo;fun&amp;rdquo;. This drove me to replace this machine&amp;rsquo;s routing functionality with a dedicated pfSense box a year ago and, for similar reasons, I have been curious about dedicated NAS solutions.&lt;/p>
&lt;p>I was pretty close to buying a second-hand NAS from the work classifieds channel when a Synology marketing person (hi Kyle!) contacted me to offer a partnership: they&amp;rsquo;d ship me &lt;a href="https://sy.to/hekgh">one of their devices&lt;/a> for free in exchange for me publishing a few articles about it. Given my interest to drive-test one of these appliances without committing to buying one (they ain&amp;rsquo;t cheap and I wasn&amp;rsquo;t convinced I wanted to get rid of my FreeBSD-based solution), I was game.&lt;/p>
&lt;p>And you guessed right: this article is one of those I promised to write but, before you stop reading, the answer is no. This post is &lt;em>not&lt;/em> sponsored by Synology and has not been reviewed nor approved by them. The content here, including any opinions, are purely my own. And what I want do do here is compare how the Synology appliance stacks against my home-built FreeBSD server.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-12-13-ds923-and-thinkstation.jpg" length="329916" type="image/jpeg"/></item><item><title>The costs of the i386 to x86-64 upgrade</title><link>https://jmmv.dev/2024/10/x86-64-programming-models.html</link><pubDate>Mon, 07 Oct 2024 09:00:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2024/10/x86-64-programming-models.html</guid><description>&lt;p>If you read my previous article on &lt;a href="https://jmmv.dev/2024/09/dos-memory-models.html">DOS memory models&lt;/a>, you may have dismissed everything I wrote as &amp;ldquo;legacy cruft from the 1990s that nobody cares about any longer&amp;rdquo;. After all, computers have evolved from sporting 8-bit processors to 64-bit processors and, on the way, the amount of memory that these computers can leverage has grown orders of magnitude: the 8086, a 16-bit machine with a 20-bit address space, could only use 1MB of memory while today&amp;rsquo;s 64-bit machines can theoretically access 16EB.&lt;/p>
&lt;p>All of this growth has been in service of ever-growing programs. But&amp;hellip; even if programs are now more sophisticated than they were before, do they all &lt;em>really&lt;/em> require access to a 64-bit address space? Has the growth from 8 to 64 bits been a net positive in performance terms?&lt;/p>
&lt;p>Let&amp;rsquo;s try to answer those questions to find some very surprising answers. But first, some theory.&lt;/p></description><enclosure url="https://jmmv.dev/images/2024-10-07-x86-64-cover-image.jpg" length="992004" type="image/jpeg"/></item><item><title>Recovering two old Macs</title><link>https://jmmv.dev/2007/07/recovering-two-old-macs.html</link><pubDate>Mon, 16 Jul 2007 05:57:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2007/07/recovering-two-old-macs.html</guid><description>Wow, it has already been three years since &lt;a href="http://jvprat.com/">a friend&lt;/a> an I found a couple of old Macintoshes in a trash container&lt;sup>1&lt;/sup>. Each of us picked one, and maybe a year ago or so I gave mine to him as I had no space at home to keep it. Given that he did not use them and that I enjoy playing with old hardware, I exchanged those two machines by an old Pentium 3 I had laying around :-) The plan is to install NetBSD-current on at least one of them and some other system (or NetBSD version) in the other one to let me ensure ATF is really portable to bizarre hardware (running sane systems, though).&lt;br />&lt;br />The machines are these:&lt;br />&lt;ul>&lt;li>A &lt;a href="http://www.everymac.com/systems/apple/mac_performa/stats/mac_performa_475.html">Performa 475&lt;/a>: Motorola 68040 LC, 4MB of RAM, 250MB SCSI hard disk, no CD-ROM, Ethernet card.&lt;br />&lt;/li>&lt;li>A &lt;a href="http://www.everymac.com/systems/apple/mac_performa/stats/mac_performa_630.html">Performa 630&lt;/a>: Motorola 68040 LC, 40MB of RAM, 500-something IDE hard disk (will replace it with something bigger), CD-ROM, Ethernet card.&lt;/li>&lt;/ul>I originally kept the Performa 630 and already played with it when we found the machines. Among other things, I &lt;a href="http://julipedia.blogspot.com/2004/07/build-your-own-pram-battery.html">replaced the PRAM battery&lt;/a> with a home-grown solution, added support to &lt;a href="http://julipedia.blogspot.com/2004/07/changing-netbsds-console-colors.html">change the NetBSD's console colors&lt;/a> (because the black on white default on NetBSD/mac68k is annoying to say the least) and imported the &lt;a href="http://julipedia.blogspot.com/2004/09/netbsdmac68k-soft-float-support.html">softfloat support for this platform&lt;/a>.&lt;br />&lt;br />Then, the turn for Performa 475 came past week. When I tried to boot it, it failed miserably. I could hear the typical Mac's boot-time chime, but after that the screen was black and the machine was completely unresponsive. After Googling a bit, I found that the black screen could be caused by the dead PRAM battery, but I assumed that the machine could still work; the thing is I could not hear the hard disk at all, and therefore was reluctant to put a new battery in it. Anyway, I finally bought the battery (very expensive, around 7â‚¬!), put it in and the machine booted!&lt;br />&lt;br />Once it was up, I noticed that there was a huge amount of software installed: Microsoft Office, LaTeX tools, Internet utilities (including Netscape Navigator), etc. And then, when checking what hardware was on the machine I was really, really surprised. All these programs were working with &lt;i>only&lt;/i> 250MB of hard disk space and 4MB of RAM! &lt;a href="http://julipedia.blogspot.com/2006/12/software-bloat.html">Software bloat&lt;/a> nowadays? Maybe...&lt;br />&lt;br />Well, if I want this second machine to be usable, I'll have to find some more RAM for it. But afterwards I hope it'll be able to run another version of NetBSD or maybe a Linux system.&lt;br />&lt;br />&lt;sup>1&lt;/sup> That also reminds me that this blog is three years old too!</description></item><item><title>Hard disks and S.M.A.R.T.</title><link>https://jmmv.dev/2006/12/hard-disks-and-smart.html</link><pubDate>Mon, 04 Dec 2006 11:46:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2006/12/hard-disks-and-smart.html</guid><description>Old hard disks exposed a lot of their internals to the operating system: in order to request a data block from the drive, the system had to specify the exact cylinder, head and sector (CHS) where it was located (as happens with floppy disks). This structure became unsustainable as drives got larger (due to some limits in the BIOS calls) and more intelligent.&lt;br />&lt;br />Current hard disks are little (and complex) specific-purpose machines that work in LBA mode (not CHS). Oversimplifying, when presented a sector number and an operation, they read or write the corresponding block &lt;i>wherever it physically is&lt;/i> &amp;mdash; i.e. the operating system needn't care any more about the physical location of that sector in the disk. (They do provide CHS values to the BIOS, but they are fake and do not cover the whole disk size.) This is very interesting because the drive can automatically remap a failing sector to a different position if needed, thus correcting some serious errors in a transparent fashion (more on this below).&lt;br />&lt;br />Furthermore, "new" disks also have a very interesting diagnostic feature known as S.M.A.R.T. This interface keeps track of internal disk status information, which can be queried by the user, and also provides a way to ask the drive to run some self-tests.&lt;br />&lt;br />If you are wondering how I discovered this, it is because I recently had two hard disks fail (one in my desktop PC and the one in the iBook) reporting physical read errors. I thought I had to replace them but using &lt;a href="http://smartmontools.sourceforge.net/">smartmontools&lt;/a> and dd(1) I was able to resolve the problems. Just try a &lt;tt>smartctl -a /dev/disk0&lt;/tt> on your system and be impressed by the amount of detailed information it prints! (This should be harmless but I take no responsibility if it fails for you in some way.)&lt;br />&lt;br />First of all I started by running an exhaustive surface test on the drive by using the &lt;tt>smartctl -t long /dev/disk0&lt;/tt>. It is interesting to note that the test is performed by the drive itself, without interaction with the operating system; if you try it you will see that not even the hard disk led blinks, which means that the test does not "emit" any data through the ATA bus. Anyway. The test ended prematurely due to the read errors and reported the first failing sector; this can be seen by using &lt;tt>smartctl -l selftest /dev/disk0&lt;/tt>.&lt;br />&lt;br />With the failing sector at hand (which was also reported in dmesg when it was first encountered by the operating system), I wrote some data over it with dd(1) hoping that the drive could remap it to a new place. This should have worked according to the instructions at smartmontools' web site, but it didn't. The sector kept failing and the disk kept reporting that it still had some sectors pending to be remapped (the Reallocated_Sector_Ct attribute). (I now think this was because I didn't use a big-enough block size to do the write, so at some point dd(1) tried to read some data and failed.)&lt;br />&lt;br />After a lot of testing, I decided to wipe out the whole disk (also using dd(1)) hoping that at some point the writes could force the disk to remap a sector. And it worked! After a full pass S.M.A.R.T. reported that there were no more sectors to be remapped and that several ones were moved. Let's now hope that no more bad sectors appear... but the desktop disk has been working fine since the "fixes" for over a month and has not developed any more problems.&lt;br />&lt;br />All in all a very handy tool for testing your computer health. It is recommended that you read the full smartctl(1) manual page before trying it; it contains important information, specially if you are new to S.M.A.R.T. as I were.</description></item></channel></rss>