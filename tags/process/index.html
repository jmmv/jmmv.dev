<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Process - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Process - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Process - Julio Merino (jmmv.dev)"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.136.5"><meta property="og:url" content="https://jmmv.dev/tags/process/index.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/tags/process/index.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Posts: Process</h1><p>Showing 4 posts</p></div></div><div class=container><div class=row><div class=col-md-9><div class="media my-4"><img class=mr-3 src=/octicons/note.svg width=32px height=32px><div class=media-body><h2 class=mt-0><a href=/2009/01/silencing-output-of-pythons.html>Silencing the output of Python's subprocess.Popen</a></h2><p>I'm learning Python these days while writing an script to automate the testing of ATF under multiple virtual machines. I had this code in a shell script, but it is so ugly and clumsy that I don't even dare to add it to the repository. Hopefully, the new version in Python will be more robust and versatile enough to be published.
One of the things I've been impressed by is the subprocess module and, in special, its Popen class. By using this class, it is trivial to spawn subprocesses and perform some IPC with them. Unfortunately, Popen does not provide any way to silence the output of the children. As I see it, it'd be nice if you'd pass an IGNORE flag as the stdout/stderr behavior, much like you can currently set those to PIPE or set stderr to STDOUT.
The following trivial module implements this idea. It extends Popen so that the callers can pass the IGNORE value to the stdout/stderr arguments. (Yes, it is trivial but it is also one of the first Python code I write so... it may contain obviously non-Pythonic, ugly things.) The idea is that this exposes the same interface so that it can be used as a drop-in replacement. OK, OK, it lacks some methods and the constructor does not match the original signature, but this is enough for my current use cases!
import subprocess
IGNORE = -3
STDOUT = subprocess.STDOUT
assert IGNORE != STDOUT, "IGNORE constant is invalid"
class Popen(subprocess.Popen):
"""Extension of subprocess.Popen with built-in support
for silencing the output channels of a child process"""
__null = None
def __init__(self, args, stdout = None, stderr = None):
subprocess.Popen.__init__(self, args = args,
stdout = self._channel(stdout),
stderr = self._channel(stderr))
def __del__(self):
self._close_null()
def wait(self):
r = subprocess.Popen.wait(self)
self._close_null()
return r
def _null_instance(self):
if self.__null == None:
self.__null = open("/dev/null", "w")
return self.__null
def _close_null(self):
if self.__null != None:
self.__null.close()
self.__null = None
assert self.__null == None, "Inconsistent internal state"
def _channel(self, behavior):
if behavior == IGNORE:
return self._null_instance()
else:
return behaviorBy the way, somebody else suggested this same thing a while ago. Don't know why it hasn't been implemented in the mainstream subprocess module.</p><p class=text-muted>January 5, 2009
&#183;
Tags:
&lt;a href="/tags/process">process&lt;/a>, &lt;a href="/tags/python">python&lt;/a><br><a class=text-reset href=/2009/01/silencing-output-of-pythons.html>Continue reading (about
2 minutes)</a></p></div></div><div class="media my-4"><img class=mr-3 src=/octicons/note.svg width=32px height=32px><div class=media-body><h2 class=mt-0><a href=/2008/01/testing-process-tree-killing-algorithm.html>Testing the process-tree killing algorithm</a></h2><p>Now that you know the procedure to kill a process tree, I can explain how the automated tests for this feature work. In fact, writing the tests is what was harder due to all the race conditions that popped up and due to my rusty knowledge of tree algorithms.
Basically, the testing procedure works like this:Spawn a complete tree of processes based on a configurable degree D and height H.Make each child tell the root process its PID so that the root process can have a list of all its children, be them direct or indirect, for control purposes.Wait until all children have reported their PID and are ready to be killed.Execute the kill-tree algorithm on the root process.Wait until the children have died.Check that none of the PIDs gathered in point 2 are still alive (which could be, but reparented to init(8) if they were not properly killed). If some are, the recursive kill failed.The tricky parts were 3 and 5.
In point 3, we have to wait until all children have been spawned. Doing so for direct children is easy because we spawned them, but indirect ones are a bit more difficult. What I do is create a pipe for each of the children that will be spawned (because given D and H I can know how many nodes there will be) and then each child uses the appropriate pipe to report its PID to the parent when it has finished initialization and thus is ready to be safely killed. The parent then just reads from all the pipes and gets all the PIDs.
But what do I mean with safely killed? Preliminary versions of the code just ran through the children's code and then exited, leaving them in zombie status. This worked in some situations but broke in others. I had to change this to block all children in a wait loop and then, when killed, take care to do a correct wait for all of its respective children, if any. This made sure that all children remained valid until the attempt to kill them.
In point 5, we have to wait until the direct children have returned so that we can be sure that the signals were delivered and processed before attempting to see if there is any process left. (Yes, if the algorithm fails to kill them we will be stalled at that point.) Given that each children can be safely killed as explained above, this wait will do a recursive wait along all the process tree making sure that everything is cleaned up before we do the final checks for non-killed PIDs.
This all sounds very simple and, in fact, looking at the final code it is. But it certainly was not easy at all to write, basically because the code grew in ugly ways and the algorithms were much more complex than they ought to be.</p><p class=text-muted>January 17, 2008
&#183;
Tags:
&lt;a href="/tags/atf">atf&lt;/a>, &lt;a href="/tags/process">process&lt;/a><br><a class=text-reset href=/2008/01/testing-process-tree-killing-algorithm.html>Continue reading (about
3 minutes)</a></p></div></div><div class="media my-4"><img class=mr-3 src=/octicons/note.svg width=32px height=32px><div class=media-body><h2 class=mt-0><a href=/2008/01/how-to-kill-tree-of-processes.html>How to kill a tree of processes</a></h2><p>Yesterday I mentioned the need for a way to kill a tree of processes in order to effectively implement timeouts for test cases. Let's see how the current algorithm in ATF works:
The root process is stopped by sending a SIGSTOP to it so that it cannot spawn any new children while being processed.Get the whole list of active processes and filter them to only get those that are direct children of the root process.Iterate over all the direct children and repeat from 1, recursively.Send the real desired signal (typically SIGTERM) to the root process.There are two major caveats in the above algorithm. First, point 2. There is no standard way to get the list of processes of a Unix system, so I have had to code three different implementations so far for this trivial requirement: one for NetBSD's KVM, one for Mac OS X's sysctl kern.proc node and one for Linux's procfs.
Then, and the worst one, comes in point 4. Some systems (Linux and Mac OS X so far) do not seem to allow one to send a signal to a stopped process. Well, strictly speaking they allow it, but the second signal seems to be simply ignored whereas under NetBSD the process' execution is resumed and the signal is delivered. I do not know which behavior is right.
If we cannot send the signal to the stopped process, we can run into a race condition: we have to wake it up by sending a SIGCONT and then deliver the signal, but in between these events the process may have spawned new children that we are not aware of.
Still, being able to send a signal to a stopped process does not completely resolve the race condition. If we are sending a signal that the user can reprogram (such as SIGTERM), that process may fork another one before exiting, and thus we'd not kill this one. But... well... this is impossible to resolve with the existing kernel APIs as far as I can tell.
One solution to this problem is killing a timed-out test by using SIGKILL instead of SIGTERM. SIGKILL could work on any case because means die immediately, without giving a chance to the process to mess with it. Therefore SIGCONT would not be needed in any case &mash;because you can simply kill a stopped process and it will die immediately as expected&mdash; and the process would not have a chance to spawn any more children after it had been stopped.
Blah, after writing this I wonder why I went with all the complexity of dealing with signals that are not SIGKILL... say over-engineering if you want...</p><p class=text-muted>January 16, 2008
&#183;
Tags:
&lt;a href="/tags/atf">atf&lt;/a>, &lt;a href="/tags/portability">portability&lt;/a>, &lt;a href="/tags/process">process&lt;/a><br><a class=text-reset href=/2008/01/how-to-kill-tree-of-processes.html>Continue reading (about
3 minutes)</a></p></div></div><div class="media my-4"><img class=mr-3 src=/octicons/note.svg width=32px height=32px><div class=media-body><h2 class=mt-0><a href=/2008/01/implementing-timeouts-for-test-cases.html>Implementing timeouts for test cases</a></h2><p>One of the pending to-do entries for ATF 0.4 is (was, mostly) the ability to define a timeout for a test case after which it is forcibly terminated. The idea behind this feature is to prevent broken tests from stalling the whole test suite run, something that is already needed by the factor(6) tests in NetBSD. Given that I want to release this version past weekend, I decided to work on this instead of delaying it because... you know, this sounds pretty simple, right? Hah!
What I did first was to implement this feature for C++ test programs and added tests for it. So far, so good. It effectively was easy to do: just program an alarm in the test program driver and, when it fires, kill the subprocess that is executing the current test case. Then log an appropriate error message.
The tests for this feature deserve some explanation. What I do is: program a timeout and then make the test case's body sleep for a period of time. I try different values for the two timers and if the timeout is smaller than the sleeping period, then the test must fail or otherwise there is a problem.
The next step was to implement this in the shell interface, and this is where things got tricky. I did a quick and dirty implementation, and it seemed to make the same tests I added for the C++ interface pass. However, when running the bootstrap testsuite, it got stalled at the cleanup part. Upon further investigation, I noticed that there were quite a lot of sleep(1) processes running when the testsuite was stalled, and killing them explicitly let the process continue. You probably noticed were the problem was already.
When writing a shell program, you are forking and executing external utilities constantly, and sleep(1) is one of them. It turns out that in my specific test case, the shell interpreter is just waiting for the sleep subprocess to finish (whereas in the C++ version everything happens in a single process). And, killing a process does not kill its children. There you go. My driver was just killing the main process of the test case, but not everything else that was running; hence, it did not die as expected, and things got stalled until the subprocesses also died.
Solving this was the fun part. The only effective way to make this work is to kill the test case's main process and, recursively, all of its children. But killing a tree of processes is not an easy thing to do: there is no system interface to do it, there is no portable interface to get a list of children and I'm yet unsure if this can be done without race conditions. I reserve the explanation of the recursive-kill algorithm I'm using for a future post.
After some days of work, I've got this working under Mac OS X and also have got automated tests to ensure that it effectively works (which were the hardest part by far). But as I foresaw, it fails miserably under NetBSD: the build was broken, which was easy to fix, but now it also fails at runtime, something that I have not diagnosed yet. Aah, the joys of Unix...</p><p class=text-muted>January 15, 2008
&#183;
Tags:
&lt;a href="/tags/atf">atf&lt;/a>, &lt;a href="/tags/netbsd">netbsd&lt;/a>, &lt;a href="/tags/process">process&lt;/a><br><a class=text-reset href=/2008/01/implementing-timeouts-for-test-cases.html>Continue reading (about
3 minutes)</a></p></div></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2024
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi90YWdzL3Byb2Nlc3MvaW5kZXguaHRtbA==/stamp.gif" style=display:none></noscript></body></html>