<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tmpfs on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/tmpfs/index.html</link><description>Recent content in Tmpfs on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 28 Jul 2007 04:07:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/tags/tmpfs/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>SoC: Status report</title><link>https://jmmv.dev/2007/07/soc-status-report_28.html</link><pubDate>Sat, 28 Jul 2007 04:07:00 -0400</pubDate><guid>https://jmmv.dev/2007/07/soc-status-report_28.html</guid><description>It has already been a week since the &lt;a href="http://julipedia.blogspot.com/2007/07/soc-atf-self-testing.html">last SoC-related post&lt;/a>, so I owe you an status report.&lt;br />&lt;br />Development has continued at a constant rate and, despite I work a lot on the project, it may seem to advance slowly from an external point of view. The thing is that getting the ATF core components complete and right is a tough job! Just look at the &lt;a href="http://mtn-host.prjek.net/viewmtn/atf/revision/file/1e5eacfc5e17dffcf1c5c64cb781c770b68d1d35/TODO">current and incomplete TODO list &lt;/a>to see what I mean.&lt;br />&lt;br />Some things worth to note:&lt;br />&lt;ul>&lt;li>The NetBSD cross-build tool-chain no longer requires a C++ compiler to build the atf-compile host tool. I wrote a simplified version in POSIX shell to be used as the host tool alone (not to be installed). This is also used by the ATF's distfile to allow "cross-building" its own test programs.&lt;br />&lt;/li>&lt;li>Improved the cleanup procedure of the test case's work directories by handling mount points in them. This is done through a new tool called atf-cleanup.&lt;/li>&lt;li>Added a property to allow test cases specify if they require root privileges or not.&lt;br />&lt;/li>&lt;li>Many bug fixes, cleanups and new test cases; these are driving development right now.&lt;/li>&lt;/ul>On the NetBSD front, there have also been several cosmetic improvements and bug fixes, but most importantly I've converted the &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/regress/sys/fs/tmpfs/">tmpfs' test suite&lt;/a> to ATF. This conversion is what has spotted many bugs and missing features in ATF's code. The TODO file has grown basically due to this.&lt;br />&lt;br />So, at the moment, both the &lt;tt>regress/bin&lt;/tt> and &lt;tt>regress/sys/fs/tmpfs&lt;/tt> trees in NetBSD have been converted to ATF. I think that's enough for now and that I should focus on adding the necessary features to ATF to improve these tests. One of these is to add support for a configuration file to let the user specify how certain tests should behave; e.g. how to become root or which specific file system to use for certain tests.&lt;br />&lt;br />I also have a partial implementation to add a "fork" property to test cases to execute them in subprocesses. This way they will be able to mess all they want with the open file descriptors without disturbing the main test program. But to get here, I first need to clean up the reporting of test case's results.&lt;br />&lt;br />On the other hand, I also started preparing manual pages for the user tools as some of them should remain fairly stable at this point.</description></item><item><title>tmpfs added to FreeBSD</title><link>https://jmmv.dev/2007/06/tmpfs-added-to-freebsd.html</link><pubDate>Fri, 22 Jun 2007 10:59:00 -0400</pubDate><guid>https://jmmv.dev/2007/06/tmpfs-added-to-freebsd.html</guid><description>A bit more than a year ago, I reported that &lt;a href="http://julipedia.blogspot.com/2006/04/tmpfs-on-freebsd.html">tmpfs was being ported to FreeBSD&lt;/a> from NetBSD (remember that tmpfs was my Google SoC 2005 project and was integrated into NetBSD soon after the program ended). And Juan Romero Pardines has just brought to my attention that tmpfs is already part of FreeBSD-current! This is really cool :-)&lt;br />&lt;br />The code was imported to FreeBSD-current on the 16th as seen in the &lt;a href="http://lists.freebsd.org/pipermail/cvs-src/2007-June/079922.html">commit mail&lt;/a>, so I suppose it will be part of the next major version (7.0). I have to thank Rohit Jalan, Howard Su and Glen Leeder for their efforts in this area.&lt;br />&lt;br />Some more details are given in their &lt;a href="http://wiki.freebsd.org/TMPFS">TMPFS wiki page&lt;/a>.&lt;br />&lt;br />&lt;span style="font-weight: bold;">Edit (June 23)&lt;/span>: Mentioned where tmpfs is being ported from!</description></item><item><title>tmpfs marked non-experimental</title><link>https://jmmv.dev/2006/11/tmpfs-marked-non-experimental.html</link><pubDate>Sat, 11 Nov 2006 14:16:00 -0500</pubDate><guid>https://jmmv.dev/2006/11/tmpfs-marked-non-experimental.html</guid><description>The implementation of an efficient memory-based file system (tmpfs) for NetBSD was my Google Summer of Code 2005 project. After the program was over, the code was &lt;a href="http://julipedia.blogspot.com/2005/09/tmpfs-project-merged-into-netbsd.html">committed to the repository&lt;/a> and some other developers (specially YAMAMOTO Takashi) did several fixes and improvements in it. However, several problems remained in it that prevented tagging it release quality (see &lt;a href="http://mail-index.netbsd.org/tech-kern/2006/10/22/0005.html">this thread&lt;/a>).&lt;br />&lt;br />Finally I found some time to deal with most of them, something that has kept me busy for around three weeks (and which I should have done much, much earlier). All the issues that were resolved are detailed in &lt;a href="http://mail-index.netbsd.org/tech-kern/2006/11/09/0005.html">this other post&lt;/a>.&lt;br />&lt;br />There still are some problems in the code (which code doesn't have any?) but these do not prevent tmpfs from working fine. Of course they should be addressed in the future but people is already enjoying tmpfs in their installations and have been requesting its activation by default for a long time.&lt;br />&lt;br />Hence, after core@'s blessing, I'm proud to announce that tmpfs has been &lt;a href="http://mail-index.netbsd.org/tech-kern/2006/11/11/0008.html">marked non-experimental&lt;/a> and is now enabled by default in the GENERIC kernels of amd64, i386, macppc and sparc64. Other platforms will probably follow soon.&lt;br />&lt;br />The next logical step is to replace mfs with tmpfs wherever the former is used (e.g. in sysinst) but more testing is required before this happens. And this is what 4.0_BETA will allow users to do :-) Enjoy!&lt;br />&lt;a href="http://mail-index.netbsd.org/tech-kern/2006/11/11/0008.html"> &lt;/a></description></item><item><title>Making vnd(4) work with tmpfs</title><link>https://jmmv.dev/2006/11/making-vnd4-work-with-tmpfs.html</link><pubDate>Thu, 09 Nov 2006 10:49:00 -0500</pubDate><guid>https://jmmv.dev/2006/11/making-vnd4-work-with-tmpfs.html</guid><description>vnd(4) is the virtual disk driver found in NetBSD. It provides a disk-like interface to files which allows you to treat them as if they were disks. This is useful, for example, when a file holds a file system image (e.g. the typical ISO-9660 files) and you want to inspect its contents.&lt;br />&lt;br />Up until now vnd(4) used the vnode's &lt;tt>bmap&lt;/tt> and &lt;tt>strategy&lt;/tt> operations to access the backing file. These operate at the block-level and therefore do not involve any system-wide caches; this is why they were used (see below). Unfortunately, some file systems (e.g. tmpfs and smbfs) do not implement these operations so vnd could not work with files stored inside them.&lt;br />&lt;br />One of the possible fixes to resolve this problem was to make vnd(4) use the regular &lt;tt>read&lt;/tt> and &lt;tt>write&lt;/tt> operations; these act on a higher (byte) level and are so fundamental that must be implemented by all file systems. The disadvantage is that all data that flows through these two methods ends up in the buffer cache. (If I understand it correctly, this is problematic because vnd itself will also push a copy of the same data into the cache thus ending up with duplicates in there.)&lt;br />&lt;br />Despite that minor problem, I believe it is better to have vnd(4) working in all cases even if that involves some performance penalty in some situations (which can be fixed anyway by implementing the missing operations later on). So this is what I have done: vnd(4) will now use read and write for those files stored in file systems where &lt;tt>bmap&lt;/tt> and &lt;tt>strategy&lt;/tt> are not available and continue to use the latter two if they are present (as it has always done).&lt;br />&lt;br />Some more information can be found in the &lt;a href="http://mail-index.netbsd.org/source-changes/2006/11/09/0032.html">CVS commit&lt;/a> and its corresponding &lt;a href="http://www.netbsd.org/cgi-bin/query-pr-single.pl?number=34882">bug report&lt;/a>.</description></item><item><title>NetBSD's KNF: Prefixes for struct members</title><link>https://jmmv.dev/2006/04/netbsds-knf-prefixes-for-struct.html</link><pubDate>Tue, 18 Apr 2006 14:59:00 -0400</pubDate><guid>https://jmmv.dev/2006/04/netbsds-knf-prefixes-for-struct.html</guid><description>The NetBSD coding &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/share/misc/style?rev=HEAD">style guide&lt;/a>, also known as Kernel Normal Form (KNF), suggests to prefix a &lt;tt>struct&lt;/tt>'s members with a string that represents the structure they belong to. For example: all &lt;tt>struct tmpfs_node&lt;/tt> members are prefixed by &lt;tt>tn_&lt;/tt> and all &lt;tt>struct wsdisplay_softc&lt;/tt> members start with &lt;tt>sc_&lt;/tt>. But why there is such a rule? After all, the style guide does not mention the reasons behind this.&lt;br />&lt;br />The first reason is clarity. When accessing a structure instance, whose name may be &lt;i>anything&lt;/i>, seeing a known prefix in the attribute helps in determining the variable's type. For example, if I see &lt;tt>foo-&amp;gt;sc_flags&lt;/tt>, I know that &lt;tt>foo&lt;/tt> is an instance of some &lt;tt>softc&lt;/tt> structure. As happens with all clarity guidelines, this is subjective.&lt;br />&lt;br />But there is another reason, which is not more technical. Using unprefixed names pollutes the global namespace, a specially dangerous situation if the structure belongs to a public header. Why? Because of the preprocessor &amp;mdash; that thing that should have never existed &amp;mdash; or more specifically, the &lt;i>macros&lt;/i> provided by it.&lt;br />&lt;br />Let's see an example: consider a &lt;tt>foo.h&lt;/tt> file that does this:&lt;pre>#ifndef _FOO_H_&lt;br />#define _FOO_H_&lt;br />&lt;br />struct foo {&lt;br /> int locked;&lt;br />};&lt;br />&lt;br />#endif&lt;/pre>And now take the following innocent piece of code:&lt;pre>#define locked 1&lt;br />#include &amp;lt;foo.h&amp;gt;&lt;/pre>Any attempt to access &lt;tt>struct foo&lt;/tt>'s &lt;tt>locked&lt;/tt> member will fail later on because of the macro definition. Prefixing the variable mitigates this situation.</description></item><item><title>tmpfs on FreeBSD</title><link>https://jmmv.dev/2006/04/tmpfs-on-freebsd.html</link><pubDate>Fri, 14 Apr 2006 10:45:00 -0400</pubDate><guid>https://jmmv.dev/2006/04/tmpfs-on-freebsd.html</guid><description>It has just been brought to my attention that &lt;a href="http://download.purpe.com/tmpfs/index.html">tmpfs is being ported to FreeBSD&lt;/a> by Rohit Jalan. These are good news: more eyes looking at the code (even if it has been modified to work on another OS) means that more bugs can be catched.</description></item><item><title>SoC: Introductory article to tmpfs</title><link>https://jmmv.dev/2006/02/soc-introductory-article-to-tmpfs.html</link><pubDate>Sat, 11 Feb 2006 05:21:00 -0500</pubDate><guid>https://jmmv.dev/2006/02/soc-introductory-article-to-tmpfs.html</guid><description>&lt;a href="http://www.ddj.com/">Dr. Dobb's Journal&lt;/a> is running a set of mini-articles promoting Summer of Code projects. Next month's issue includes the &lt;a href="http://www.ddj.com/documents/s=9985/ddj0603g/0603g.html">tmpfs' introductory article&lt;/a>, written by me and William Studenmund, the project's mentor.&lt;br />&lt;br />Looks like you have to register to access the full article; previous issues used to have them publically available. Personally, I'm going to wait for the printed version :-)</description></item><item><title>File systems documentation for review</title><link>https://jmmv.dev/2006/01/file-systems-documentation-for-review.html</link><pubDate>Fri, 27 Jan 2006 06:42:00 -0500</pubDate><guid>https://jmmv.dev/2006/01/file-systems-documentation-for-review.html</guid><description>My Summer of Code project, tmpfs, promised that I would write documentation describing how file systems work in NetBSD (and frankly, I think this point had to do a lot with my proposal being picked up). I wrote such documentation during August but I failed to make it public &amp;mdash; my mentor and I first thought about making it an article (which would have delayed it anyway) but soon after it became apparent that that structure was inappropriate.&lt;br />&lt;br />Anyway, I proposed myself to deal with the documentation whenever I had enough free time to rewrite most of it and restructure its sections to make it somewhat decent. And guess what, this is what I started to do some days (a week?) ago. So... &lt;a href="http://www.NetBSD.org/~jmmv/guide/">here is the so-promised documentation&lt;/a>!&lt;br />&lt;br />Be aware that this is still &lt;a href="http://mail-index.netbsd.org/netbsd-docs/2006/01/27/0000.html">just for review&lt;/a>. The documentation will end up either being part of The NetBSD Guide or being a "design and implementation" guide on its own.&lt;br />&lt;br />Also note that there is still much work to do. Many sections are not yet written. In fact, I started writing the general ideas to get into file system development because, once you know the basics, learning other stuff is relatively easy by looking at existing manual pages and code. Of course, the document should eventually be completed, specially to avoid having to reverse-engineer code.&lt;br />&lt;br />I'll seize this post to state something: the lack of documentation is a serious problem in most open source projects, specially those that have some kind of extensibility. Many developers don't like to write documentation and, what is worse, they think it's useless, that other developers will happily read the existing code to understand how things work. Wrong! If you are willing to extend some program, you want &lt;i>its interface to be clearly defined and documented&lt;/i>; if there is no need to look at the code (except for carefully done examples), even better. FWIW, reading the program's code can be dangerous because you may get things wrong and end up relying on implementation details. So, write documentation, even if it is tough and difficult (I know, it can be &lt;i>very difficult&lt;/i>, but don't you like challenges? ;-).</description></item><item><title>NetBSD: File system directories, part 2</title><link>https://jmmv.dev/2005/11/netbsd-file-system-directories-part-2.html</link><pubDate>Fri, 18 Nov 2005 10:17:00 -0500</pubDate><guid>https://jmmv.dev/2005/11/netbsd-file-system-directories-part-2.html</guid><description>In the &lt;a href="http://julipedia.blogspot.com/2005/11/netbsd-file-system-directories-part-1.html">first part&lt;/a>, we saw what a directory is and gave some fuzzy ideas on how it is implemented. Let's now outline the most common operations run on directories: &lt;tt>lookup&lt;/tt> and &lt;tt>readdir&lt;/tt>.&lt;br />&lt;br />The &lt;tt>lookup&lt;/tt> operation receives a path component name (a string without slashes) and returns the node pointed to by this name within the directory, assuming, of course, that the entry exists. Otherwise, it tells the caller that the entry is missing or incorrect (i.e., not a directory). This operation takes advantage of the &lt;a href="http://netbsd.gw.com/cgi-bin/man-cgi?namecache++NetBSD-current">name cache&lt;/a> because it must be fast; keep in mind that lookups are executed extremely often.&lt;br />&lt;br />The implementation of the &lt;tt>lookup&lt;/tt> operation, however, is very complex. It is cluttered by a weird locking protocol and has a lot of special cases. These include &lt;i>access advices&lt;/i>, a technique used to tell the operation what kind of lookup is happening: a creation, a removal, a rename or a simple lookup. UFS uses these to locate empty holes in the directory while looking for an entry, among other things. tmpfs uses it to avoid two lookups for the same file on some operations, such as the creation.&lt;br />&lt;br />On the other hand, we have the &lt;tt>readdir&lt;/tt> operation, the one used to read the contents of a directory. This operation is conceptually simple, as all it has to do is read as much entries as possible from the offset given to it. These entries are returned in a standard format, described in &lt;a href="http://netbsd.gw.com/cgi-bin/man-cgi?getdents++NetBSD-current">getdents(2)&lt;/a>.&lt;br />&lt;br />However, there is a tricky thing in &lt;tt>readdir&lt;/tt>: the &lt;i>cookies&lt;/i>. They are used by the NFS server to map directory entries to offsets within it so that further lookups can be done in a more efficient manner. For each entry returned by &lt;tt>readdir&lt;/tt>, a cookie is also returned that specifies its physical offset inside the directory. A further call to this operation using the cookie's value could restart the read at the point where the entry lives.&lt;br />&lt;br />It is also interesting to note that some file systems return fake cookies because they do not have physical offsets within them &amp;mdash; in other words, they are not stored on disk. This happens in, e.g., tmpfs or kernfs.&lt;br />&lt;br />Post suggested by Pavel Cahyna.</description></item><item><title>NetBSD: File system directories, part 1</title><link>https://jmmv.dev/2005/11/netbsd-file-system-directories-part-1.html</link><pubDate>Thu, 17 Nov 2005 06:41:00 -0500</pubDate><guid>https://jmmv.dev/2005/11/netbsd-file-system-directories-part-1.html</guid><description>A file-system directory is an object that maps file names to nodes (i-nodes in UFS terminology). When given a file name, the directory must be able to tell whether it has that name or not and return the node number attached to it. File names are not stored in the nodes themselves as this allows for hard link creation flawlessly: you can have multiple directory entries pointing to the same file with no extra cost.&lt;br />&lt;br />Let's see a very simple directory implementation, coming from &lt;a href="http://www.NetBSD.org/">NetBSD&lt;/a>'s tmpfs (see &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/fs/tmpfs/tmpfs.h?rev=HEAD&amp;content-type=text/x-cvsweb-markup">tmpfs.h&lt;/a>). This file system implements directories by using a linked list (&lt;tt>struct tmpfs_dir&lt;/tt>) of directory entries (&lt;tt>struct tmpfs_dirent&lt;/tt>). These structures look like:&lt;pre>struct tmpfs_dirent {&lt;br /> TAILQ_ENTRY(tmpfs_dirent) td_entries;&lt;br /> uint16_t td_namelen;&lt;br /> char *td_name;&lt;br /> struct tmpfs_node *td_node;&lt;br />};&lt;br />TAILQ_HEAD(tmpfs_dir, tmpfs_dirent);&lt;/pre>Of special interest are the &lt;tt>td_name&lt;/tt> field, which holds the entry name (file name), and the &lt;tt>td_node&lt;/tt> pointer, which points to the file system node related to this directory entry (UFS could use i-node numbers instead).&lt;br />&lt;br />This implementation is really simple as it is completely backed by virtual memory; adding and removing entries is as easy as allocating a memory block and modifying the linked list accordingly. It could, of course, be more complex if it used a B+ tree or some other structure instead.&lt;br />&lt;br />However, on-disk file systems do extra tasks to optimize directory accesses. For example, when an entry is removed, it is marked as deleted using a special flag but it is not really removed from disk, because shrinking the directory could be expensive. Similarly, new entries overwrite previously deleted entries, if possible.&lt;br />&lt;br />In the next post, we will outline how some directory operations (such as &lt;tt>lookup&lt;/tt> and &lt;tt>readdir&lt;/tt>) work.&lt;br />&lt;br />Post suggested by Pavel Cahyna.</description></item><item><title>SoC: Payment received</title><link>https://jmmv.dev/2005/10/soc-payment-received.html</link><pubDate>Mon, 24 Oct 2005 07:07:00 -0400</pubDate><guid>https://jmmv.dev/2005/10/soc-payment-received.html</guid><description>Being part of &lt;a href="http://soc.blubb.com/">Planet SoC&lt;/a>, I think it is a good idea to post this: I've just received &lt;a href="http://www.google.com/">Google&lt;/a>'s cheque for my Summer of Code 2005 tmpfs project! I'm happy :-)&lt;br />&lt;br />Unfortunately, due to some tax issues, Google has withhold a 30% of the original payment. I hope to be able to ask for a refund the next year...</description></item><item><title>NFS exports lists rototill</title><link>https://jmmv.dev/2005/09/nfs-exports-lists-rototill.html</link><pubDate>Fri, 23 Sep 2005 08:35:00 -0400</pubDate><guid>https://jmmv.dev/2005/09/nfs-exports-lists-rototill.html</guid><description>&lt;p>After two weeks of work, the NFS exports lists rototill that I briefly outlined in &lt;a href="http://www.livejournal.com/users/jmmv/43121.html">this past post&lt;/a> is finished and committed into &lt;a href="http://www.netbsd.org/">NetBSD&lt;/a>'s source tree. Believe it or not, the whole set of changes was triggered by a XXX mark in mountd(8)'s code (in other words, fixing code marked as such is not always trivial).&lt;/p> &lt;p>In the past, when a file system wanted to support NFS, it had to include two fields in a fixed position of its mount arguments structure due to the broken way in which mountd(8) handled the mount(2) calls. Furthermore, each file system had to deal internally with the NFS exports list, duplicating code among all NFS-aware file systems; this feature was clearly generic, so it had to be placed in an upper generalization level. At last, you had to use the mount(2) system call in a wired way to change the exports.&lt;/p></description></item><item><title>Linker's link sets</title><link>https://jmmv.dev/2005/09/linkers-link-sets.html</link><pubDate>Sun, 18 Sep 2005 08:19:00 -0400</pubDate><guid>https://jmmv.dev/2005/09/linkers-link-sets.html</guid><description>&lt;p>I don't know about other linkers, but GNU ld provides a very useful feature: &lt;i>link sets&lt;/i>. A link set is a list of symbols constructed during &lt;i>link time&lt;/i> which can then be inspected in regular code. This is very interesting in situations when you want to initialize several subsystems from a centralized place but don't know which of these will be available; that is, you don't know which ones will be in the final binary.&lt;/p></description></item><item><title>Interface to change NFS exports</title><link>https://jmmv.dev/2005/09/interface-to-change-nfs-exports.html</link><pubDate>Sun, 11 Sep 2005 07:48:00 -0400</pubDate><guid>https://jmmv.dev/2005/09/interface-to-change-nfs-exports.html</guid><description>&lt;p>While adding NFS support to tmpfs, I found how &lt;a href="http://www.netbsd.org/">NetBSD&lt;/a> currently manages NFS exports from userland. The interface is, IMHO, scary. As NetBSD aims for clean code and design, it must be fixed.&lt;/p> &lt;p>See my &lt;a href="http://mail-index.netbsd.org/tech-kern/2005/09/11/0001.html">mail to the tech-kern@ mailing list&lt;/a> for more details on the issue and a preliminary patch.&lt;/p>&lt;p class="mobile-post">&lt;/p></description></item><item><title>tmpfs: Project merged into NetBSD</title><link>https://jmmv.dev/2005/09/tmpfs-project-merged-into-netbsd.html</link><pubDate>Sat, 10 Sep 2005 17:13:00 -0400</pubDate><guid>https://jmmv.dev/2005/09/tmpfs-project-merged-into-netbsd.html</guid><description>&lt;p>After listening to many queries from developers asking when tmpfs could be integrated into &lt;a href="http://www.netbsd.org/">NetBSD&lt;/a>, I finally imported the code into the CVS repository. I'm really happy about this :-) Development will be simplified from now on and it will be a lot easier for interested parties to test the code. Please &lt;a href="http://mail-index.netbsd.org/tech-kern/2005/09/10/0004.html">read the announcement&lt;/a> for more information.&lt;/p> &lt;p>I'd like to comment now some of the improvements I've been doing during the past days, which mostly addressed optimization. I started by removing the storage of &lt;tt>.&lt;/tt> and &lt;tt>..&lt;/tt> directory entries from directories, generating them on the fly when requested. This was done for three reasons. First, to remove redundancy: as &lt;tt>.&lt;/tt> points to the directory itself, the entry can always be generated; similarly, &lt;tt>..&lt;/tt> can be generated from the pointer to the parent directory stored in the nodes. Secondly, to simplify the code: there were multiple assertions to ensure that these entries were correct and there was code to update them on file-system changes; this code was hard to understand and, as you can see, avoidable. Lastly, to reduce memory consumption: this removed around 1KB of storage from each directory (given to a change I've done recently, this gain is lower, because entries are now a lot smaller, but still this saves 40 bytes from each directory).&lt;/p></description></item></channel></rss>