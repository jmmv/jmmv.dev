<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shtk on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/tags/shtk/index.html</link><description>Recent content in Shtk on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2025 Julio Merino</copyright><lastBuildDate>Sat, 04 Nov 2023 07:50:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/tags/shtk/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>End-to-end tool testing with Bazel and shtk</title><link>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</link><pubDate>Sat, 04 Nov 2023 07:50:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html</guid><description>&lt;p>If you use Bazel, your project is of moderate size. And because your project is of moderate size, it almost-certainly builds one or more binaries, at least one of which is a CLI tool. But let&amp;rsquo;s face it: you don&amp;rsquo;t have end-to-end testing for those tools, do you?&lt;/p>
&lt;p>I&amp;rsquo;m &lt;em>sure&lt;/em> you have split the binary&amp;rsquo;s &lt;code>main&lt;/code> function into its own file so that the rest of the tool can be put in a library, and I&amp;rsquo;m &lt;em>extra-sure&lt;/em> that you have unit tests for such library. But&amp;hellip; those tests do little to verify the functionality and quality of the tool &lt;em>as experienced by the end user&lt;/em>. Consider: What exactly does the tool print to the console on success? Does it show errors nicely when they happen, or does it dump internal stack traces? How does it handle unknown flags or bad arguments? Is the built-in help message nicely rendered when your terminal is really wide? What if the terminal is narrow?&lt;/p>
&lt;p>You must write end-to-end tests for your tools but, usually, that isn’t easy to do. Until today. Combining shtk with Bazel via the new &lt;code>rules_shtk&lt;/code> ruleset makes it trivial to write tests that verify the behavior of your CLI tools&amp;mdash;no matter what language they are written in&amp;mdash;and in this article I’m going to show you how.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-11-04-bazel-clamp.jpg" length="572746" type="image/jpeg"/></item><item><title>Unit-testing shell scripts and tools with shtk</title><link>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</link><pubDate>Wed, 11 Oct 2023 08:30:00 -0700</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2023/10/unit-testing-with-shtk.html</guid><description>&lt;p>While working on this static blog a few days ago, I made a change to its templates that warranted an automated test. I could have written a trivial shell script to do it, but instead I reached out for shtk&amp;rsquo;s unit-testing module. I &lt;a href="https://twitter.com/jmmv/status/1710309896670081083">tweeted about it&lt;/a> right away to just say that you can, in fact, write tests in shell because lots of developers are skeptical about any script longer than 10 lines of code.&lt;/p>
&lt;p>Interestingly, this reply came through: a pointer to a contemporary, under-development library for writing tests in Bash. Which made me think: &amp;ldquo;Hey, I had already done that years ago&amp;hellip; but nobody knows about it. Gotta fix that with a blog post!&amp;rdquo; But first, I had to bring shtk back from its ashes because I had not touched it for more than 6 years and it wasn&amp;rsquo;t read for show and tell. So I did something that I wanted to do back in the day but never did: I put together &lt;a href="https://shtk.jmmv.dev/">a website for shtk&lt;/a> to host its &lt;a href="https://shtk.jmmv.dev/docs.html">reference manual&lt;/a> and I fixed a few obvious rough edges.&lt;/p>
&lt;p>With those tweaks out of the way, we come to this article. In here, I want to show you how writing decent tests in shell is entirely possible and how shtk&amp;rsquo;s testing platform provides unique features to do integration testing of CLI apps written in any language.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-10-11-shell-hammer-wrench.jpg" length="398237" type="image/jpeg"/></item><item><title>Shell readability: function parameters</title><link>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</link><pubDate>Fri, 02 Mar 2018 06:35:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/03/shell-readability-function-parameters.html</guid><description>&lt;p>The shell supports defining functions, which, &lt;a href="https://jmmv.dev/2018/02/shell-readability-main.html">as we learned in the previous post&lt;/a>, you should embrace and use. Unfortunately, they are fairly primitive and their use can, paradoxically, introduce other readability problems.&lt;/p>
&lt;p>One specific problem is that &lt;strong>function parameters are numbered, not named&lt;/strong>, so the risk of cryptic code is high. Let&amp;rsquo;s see why this is a problem.&lt;/p></description></item><item><title>Shell readability: main</title><link>https://jmmv.dev/2018/02/shell-readability-main.html</link><pubDate>Mon, 26 Feb 2018 05:15:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2018/02/shell-readability-main.html</guid><description>&lt;p>Our team develops &lt;a href="http://bazel.build">Bazel&lt;/a>, a Java-based tool. We do have, however, a significant amount of shell scripting. The percentage is small at only 3.6% of our codebase&amp;hellip; but given the size of our project, that&amp;rsquo;s about 130,000 lines—a lot, really.&lt;/p>
&lt;p>Pretty much nobody likes writing these integration tests in shell. Leaving aside that our infrastructure is clunky, the real problem is that the team at large is not familiar with writing shell per se. Few people are these days actually.&lt;/p></description></item><item><title>shtk 1.6 is now available</title><link>https://jmmv.dev/2014/11/shtk-16-is-now-available.html</link><pubDate>Mon, 17 Nov 2014 15:28:00 -0500</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2014/11/shtk-16-is-now-available.html</guid><description>&lt;p>The &lt;a href="https://github.com/jmmv/shtk/">Shell Toolkit&lt;/a>, or shtk for short, is a little project I &lt;a href="https://jmmv.dev/2012/08/introducing-shtk.html">introduced back in August of 2008&lt;/a> to support other tools such as &lt;a href="http://blog.netbsd.org/tnf/entry/introducing_sysbuild_and_sysupgrade">sysbuild and sysupgrade&lt;/a>. Since that time, the project has seen little activity because it did not have much to offer and because shtk's public interface was not documented (hence making it impossible for developers to get started with shtk).&lt;/p> &lt;p>Well, both are changing &lt;i>today&lt;/i> with the brand-new release of &lt;a href="https://github.com/jmmv/shtk/releases/tag/shtk-1.6">shtk 1.6&lt;/a>:&lt;/p></description></item><item><title>'Hello GitHub!' say shtk, sysbuild and sysupgrade</title><link>https://jmmv.dev/2013/07/hello-github-say-shtk-sysbuild-and.html</link><pubDate>Sun, 28 Jul 2013 20:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/hello-github-say-shtk-sysbuild-and.html</guid><description>&lt;p>Over a year ago, I developed two command line utilities for NetBSD (sysbuild and sysupgrade) and a supporting library for the two tools (shtk). These were all introduced in their corresponding blog posts &amp;mdash;&lt;a href="https://jmmv.dev/2012/07/introducing-sysbuild-for-netbsd.html">Introducing sysbuild for NetBSD&lt;/a>, &lt;a href="https://jmmv.dev/2012/08/introducing-sysupgrade.html">Introducing sysupgrade for NetBSD&lt;/a> and &lt;a href="https://jmmv.dev/2012/08/introducing-shtk.html">Introducing shtk&lt;/a>&amp;mdash; and since then I have heard good comments about them.&lt;/p> &lt;p>About a couple of weeks ago, I started working on the much-needed rewrite of pkg_comp and a supporting standalone tool. I was using the same development methodology as with the other three projects: putting all the code in pkgsrc and implementing the build system from the package's &lt;tt>Makefile&lt;/tt>. Along the way, this became increasingly annoying to the point where I could not stand it any more. pkgsrc is a packaging system, not a development platform. Developing a project within it is difficult due to the indirections between the outer &lt;tt>Makefile&lt;/tt> and the work directory, and the expected workflow of working with packages. &lt;p>A separate issue is that having the source code in pkgsrc prevents the distribution of the packages as standalone tools for third-party operating systems. (Mind you: I've recently started building NetBSD from Linux and FreeBSD and missed sysbuild dearly.) It's hard and ugly (but not impossible) to generate tarballs for the sources in pkgsrc that can later be hosted elsewhere... and, even if doing that, using pkgsrc as the master tree for the code would seem backwards.&lt;/p></description></item><item><title>Introducing shtk</title><link>https://jmmv.dev/2012/08/introducing-shtk.html</link><pubDate>Wed, 15 Aug 2012 17:39:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2012/08/introducing-shtk.html</guid><description>Have you ever wanted to have a collection of ready-to-use modules for shell scripts? I have, particularly because I keep reimplementing the same functions over and over and over and over again whenever I write non-trivial shell scripts, and I'm tired of doing so.&lt;br />&lt;br />That's why I have just abstracted all the common code in the aforementioned tools and &lt;a href="http://mail-index.netbsd.org/pkgsrc-changes/2012/08/15/msg077072.html">put it into a new package called the "Shell Toolkit", or shtk for short&lt;/a>. Yeah, this name sounds very pretentious but, really, I don't intend this to be anything big. The only thing I want to do is simplify my life when implementing shell scripts, and hope that other people might find the modules useful. So far, I have taken the generic (and common!) code from sysbuild and sysupgrade, reconciled a few tiny divergences, and moved it into this new shtk package.&lt;br />&lt;br class="Apple-interchange-newline" />In reality, writing something like shtk is sin-borderline. I really should not be using shell scripting for the kind of tools I am implementing (they deserve better data structures and better error checking than what shell provides, for example). However, shell scripting is incredible convenient to get reasonably-good implementations of such tools with minimal effort, and is the only scripting language available in NetBSD's base system. (Yes, yes, there is Lua, but my limited knowledge of Lua would not let me write these tools in any decent manner nor in any reasonable time.)&lt;br />&lt;div>&lt;br />&lt;/div>So, what's in shtk? There are a few functions to deal with command lines (error/warning reporting and such things), some trivial stuff to deal with lists, a bunch of code to interact with cvs and, what I like the most, a module to implement configuration files with some kind of key/value validation.&lt;br />&lt;br />At the moment, shtk can only be found in pkgsrc under &lt;a href="http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/devel/shtk?only_with_tag=MAIN">pkgsrc/devel/shtk&lt;/a>&amp;nbsp;and I don't currently have any plans to make it more widely available. If there are enough people interested in that with real needs, I could reconsider, but the maintenance effort would be non-trivial.&lt;br />&lt;br />To showcase the features of shtk, I have updated the sysbuild and sysupgrade packages to depend on this new toolkit while at the same time dropping all this duplicate supporting code. It's a good thing that I wrote exhaustive tests for all possible code paths, because the migration from the built-in modules to shtk was riddled with subtleties that would have impacted end users otherwise.&lt;br />&lt;br />Now... time to really consider taking the task of rewriting pkg_comp in a more&amp;nbsp;maintainable&amp;nbsp;style so that I can add the features I have wished for for many years (like OS X support).</description></item></channel></rss>