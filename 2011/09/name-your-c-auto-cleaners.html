<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Name your C++ auto-cleaners - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Name your C++ auto-cleaners - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Name your C++ auto-cleaners - Julio Merino (jmmv.dev)"><meta name=description content='As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the stack-managed object goes out of scope, it releases the corresponding non-stack-managed object. Smart pointers are just one example of this technique, but so are IO streams too.
Before getting into the point of the article, bear with me for a second while I explain what the&nbsp; stack_cleaner object of Lutok is. The "stack cleaner" takes a reference to a Lua state and records the height of the Lua stack on creation. When the object is destroyed (which happens when the declaring function exits), the stack is returned to its previous height thus ensuring it is clean. It is always a good idea for a function to prevent side-effects by leaving its outside world as it was ‚Äî and, like it or not, the Lua state is part of the outside world because it is an input/output parameter to many functions.
Let&#39;s consider a piece of code without using the stack cleaner:
void
my_function(lutok::state& state, const int foo)
{
&nbsp;&nbsp;&nbsp; state.push_integer(foo);&nbsp;&nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp;&nbsp; if (bar != 3) {
&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1); &nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");
&nbsp; &nbsp; }
&nbsp; &nbsp; state.pop(1);
}
Note that we have had to call state.pop(1) from "all" exit points of the function to ensure that the stack is left unmodified upon return of my_function. Also note that "all exit points" may not be accurate: in a language that supports exceptions, any statement may potentially raise an exception so to be really safe we should do:
void
my_function(lutok::state& state, const int foo)
{
&nbsp;&nbsp;&nbsp; state.push_integer(foo);
&nbsp; &nbsp; try { &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (bar != 3 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");
&nbsp; &nbsp; } catch (...) {
&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1);
&nbsp; &nbsp; &nbsp; &nbsp; throw;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; state.pop(1);
}
... which gets old very quickly. Writing this kind of code is error-prone and boring.
With an "auto-cleaner" object such as the stack_cleaner, we can simplify our code like this:
void
my_function(lutok::state& state, const int foo)
{
&nbsp; &nbsp; lutok::stack_cleaner cleaner(state);
&nbsp;&nbsp;&nbsp; state.push_integer(foo);
&nbsp;&nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp;&nbsp; if (bar != 3) &nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!"); }
And we leave the boring task of determining when to actually call state.pop(1) to the compiler and the runtime environment. In this particular case, no matter how the my_function terminates, we ensure that the Lua stack will be left as the same size as it was before.
But, as I said earlier, all this was just an introduction to the idea that made me write this post.
When you declare an auto-cleaner object of any kind, be sure to give it a name. It has happened to me a few times already that I have written the following construct:
lutok::stack_cleaner(state);
... which is syntactically correct, harmless and "looks good" if you don&#39;t look closely. The compiler will chew along just fine because, even though we are declaring an anonymous object, its constructor and destructor may be doing who-knows-what, so their code must be called and thus the "unused variable" warning cannot really be raised.
However this does not give us the desired behavior. The cleaner object will be constructed and destructed in the same statement without having a chance to wrap any of the following code, because its scope is just the statement in which it was defined. In other words, the cleaner will have absolutely no effect on the rest of the function and thus will be useless.
So, moral of the story: always give a name to your auto-cleaner objects so that their scope is correctly defined and their destructor is run when you actually expect:
lutok::stack_cleaner ANY_NAME_HERE(state);'><meta property="og:description" content='As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the stack-managed object goes out of scope, it releases the corresponding non-stack-managed object. Smart pointers are just one example of this technique, but so are IO streams too.
Before getting into the point of the article, bear with me for a second while I explain what the&nbsp; stack_cleaner object of Lutok is. The "stack cleaner" takes a reference to a Lua state and records the height of the Lua stack on creation. When the object is destroyed (which happens when the declaring function exits), the stack is returned to its previous height thus ensuring it is clean. It is always a good idea for a function to prevent side-effects by leaving its outside world as it was ‚Äî and, like it or not, the Lua state is part of the outside world because it is an input/output parameter to many functions.
Let&#39;s consider a piece of code without using the stack cleaner:
void
my_function(lutok::state& state, const int foo)
{
&nbsp;&nbsp;&nbsp; state.push_integer(foo);&nbsp;&nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp;&nbsp; if (bar != 3) {
&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1); &nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");
&nbsp; &nbsp; }
&nbsp; &nbsp; state.pop(1);
}
Note that we have had to call state.pop(1) from "all" exit points of the function to ensure that the stack is left unmodified upon return of my_function. Also note that "all exit points" may not be accurate: in a language that supports exceptions, any statement may potentially raise an exception so to be really safe we should do:
void
my_function(lutok::state& state, const int foo)
{
&nbsp;&nbsp;&nbsp; state.push_integer(foo);
&nbsp; &nbsp; try { &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (bar != 3 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");
&nbsp; &nbsp; } catch (...) {
&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1);
&nbsp; &nbsp; &nbsp; &nbsp; throw;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; state.pop(1);
}
... which gets old very quickly. Writing this kind of code is error-prone and boring.
With an "auto-cleaner" object such as the stack_cleaner, we can simplify our code like this:
void
my_function(lutok::state& state, const int foo)
{
&nbsp; &nbsp; lutok::stack_cleaner cleaner(state);
&nbsp;&nbsp;&nbsp; state.push_integer(foo);
&nbsp;&nbsp;&nbsp; ... do something else in the state ...
&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();
&nbsp;&nbsp;&nbsp; if (bar != 3) &nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!"); }
And we leave the boring task of determining when to actually call state.pop(1) to the compiler and the runtime environment. In this particular case, no matter how the my_function terminates, we ensure that the Lua stack will be left as the same size as it was before.
But, as I said earlier, all this was just an introduction to the idea that made me write this post.
When you declare an auto-cleaner object of any kind, be sure to give it a name. It has happened to me a few times already that I have written the following construct:
lutok::stack_cleaner(state);
... which is syntactically correct, harmless and "looks good" if you don&#39;t look closely. The compiler will chew along just fine because, even though we are declaring an anonymous object, its constructor and destructor may be doing who-knows-what, so their code must be called and thus the "unused variable" warning cannot really be raised.
However this does not give us the desired behavior. The cleaner object will be constructed and destructed in the same statement without having a chance to wrap any of the following code, because its scope is just the statement in which it was defined. In other words, the cleaner will have absolutely no effect on the rest of the function and thus will be useless.
So, moral of the story: always give a name to your auto-cleaner objects so that their scope is correctly defined and their destructor is run when you actually expect:
lutok::stack_cleaner ANY_NAME_HERE(state);'><meta property="twitter:description" content="As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.147.8"><meta property="og:url" content="https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2011/09/name-your-c-auto-cleaners.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.24b518a51730830025491ef7734bba072a9461f33c61bc812443fd003a8d4901.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Name your C++ auto-cleaners</h1><p>September 17, 2011 &#183;
About 4 minutes
&#183;
Tags:
<a href=/tags/cxx>cxx</a>, <a href=/tags/lua>lua</a>, <a href=/tags/lutok>lutok</a></p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article>As you may already know, RAII is a very powerful and popular pattern in the C++ language. With RAII, you can wrap non-stack-managed resources into a stack-managed object such that, when the stack-managed object goes out of scope, it releases the corresponding non-stack-managed object. <a href="http://onlamp.com/pub/a/onlamp/2006/05/04/smart-pointers.html?page=1">Smart pointers</a> are just one example of this technique, but so are IO streams too.<br><br>Before getting into the point of the article, bear with me for a second while I explain what the&nbsp; <a href=http://code.google.com/p/lutok/source/browse/trunk/stack_cleaner.hpp><tt>stack_cleaner</tt></a> object of <a href=http://code.google.com/p/lutok/>Lutok</a> is. The "stack cleaner" takes a reference to a Lua state and records the height of the Lua stack on creation. When the object is destroyed (which happens when the declaring function exits), the stack is returned to its previous height thus ensuring it is clean. It is always a good idea for a function to prevent side-effects by leaving its outside world as it was ‚Äî and, like it or not, the Lua state is part of the outside world because it is an input/output parameter to many functions.<br><br>Let's consider a piece of code <i>without</i> using the stack cleaner:<br><br><pre>void<br>my_function(lutok::state&amp; state, const int foo)<br>{<br>&nbsp;&nbsp;&nbsp; state.push_integer(foo);</pre><pre>&nbsp;&nbsp;&nbsp; ... do something else in the state ...<br>&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();<br>&nbsp;&nbsp;&nbsp; if (bar != 3) {<br>&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1); <br>&nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; state.pop(1);<br><br>}</pre><br>Note that we have had to call <tt>state.pop(1)</tt> from "all" exit points of the function to ensure that the stack is left unmodified upon return of <tt>my_function</tt>. Also note that "all exit points" may not be accurate: in a language that supports exceptions, any statement may potentially raise an exception so to be really safe we should do:<br><br><pre>void<br>my_function(lutok::state&amp; state, const int foo)<br>{<br>&nbsp;&nbsp;&nbsp; state.push_integer(foo);<br>&nbsp; &nbsp; try { <br>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ... do something else in the state ...<br>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; const int bar = state.to_integer();<br>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (bar != 3 <br>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!");<br>&nbsp; &nbsp; } catch (...) {<br>&nbsp; &nbsp; &nbsp; &nbsp; state.pop(1);<br>&nbsp; &nbsp; &nbsp; &nbsp; throw;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; state.pop(1);<br>}</pre><br>... which gets old very quickly. Writing this kind of code is error-prone and boring.<br><br>With an "auto-cleaner" object such as the <tt>stack_cleaner</tt>, we can simplify our code like this:<br><br><pre>void<br>my_function(lutok::state&amp; state, const int foo)<br>{<br>&nbsp; &nbsp; lutok::stack_cleaner cleaner(state);<br><br>&nbsp;&nbsp;&nbsp; state.push_integer(foo);<br>&nbsp;&nbsp;&nbsp; ... do something else in the state ...<br>&nbsp;&nbsp;&nbsp; const int bar = state.to_integer();<br>&nbsp;&nbsp;&nbsp; if (bar != 3) <br>&nbsp; &nbsp; &nbsp; &nbsp; throw std::runtime_error("Invalid data!"); <br>}</pre><br>And we leave the boring task of determining when to actually call <tt>state.pop(1)</tt> to the compiler and the runtime environment. In this particular case, no matter how the <tt>my_function</tt> terminates, we ensure that the Lua stack will be left as the same size as it was before.<br><br>But, as I said earlier, all this was just an introduction to the idea that made me write this post.<br><br>When you declare an auto-cleaner object of any kind, <i>be sure to give it a name</i>. It has happened to me a few times already that I have written the following construct:<br><br><pre>lutok::stack_cleaner(state);</pre><br>... which is syntactically correct, harmless and "looks good" if you don't look closely. The compiler will chew along just fine because, even though we are declaring an anonymous object, its constructor and destructor may be doing who-knows-what, so their code must be called and thus the "unused variable" warning cannot really be raised.<br><br><b>However</b> this does not give us the desired behavior. The cleaner object will be constructed and destructed in the same statement without having a chance to wrap any of the following code, because its scope is just the statement in which it was defined. In other words, the cleaner will have absolutely no effect on the rest of the function and thus will be useless.<br><br>So, moral of the story: always give a name to your auto-cleaner objects so that their scope is correctly defined and their destructor is run when you actually expect:<br><br><pre>lutok::stack_cleaner ANY_NAME_HERE(state);</pre></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2011/09/introducing-lutok-lightweight-c-api-for.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2011/09/kyua-weekly-status-report-db-designdoc.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Name+your+C%2B%2B+auto-cleaners&amp;url=https%3A%2F%2Fjmmv.dev%2F2011%2F09%2Fname-your-c-auto-cleaners.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Name+your+C%2B%2B+auto-cleaners&amp;u=https%3A%2F%2Fjmmv.dev%2F2011%2F09%2Fname-your-c-auto-cleaners.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Name+your+C%2B%2B+auto-cleaners+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2011%2F09%2Fname-your-c-auto-cleaners.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.jmmv.dev/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDExLzA5L25hbWUteW91ci1jLWF1dG8tY2xlYW5lcnMuaHRtbA==/stamp.gif" style=display:none></noscript></body></html>