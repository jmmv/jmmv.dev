<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Why do I know shell, and how can you? - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Why do I know shell, and how can you? - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Why do I know shell, and how can you? - Julio Merino (jmmv.dev)"><meta name=description content="&amp;ldquo;Why do you know so much shell?&amp;rdquo; is a question I&amp;rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I was &amp;ldquo;forced&amp;rdquo; to write tools in it for a while and, because of that, I made a conscious effort to learn the language and get better at it.
You see, most people that write shell don&amp;rsquo;t want to deal with it. They stitch together whatever works into a script and call it a day, making a bunch of spaghetti even if it goes against the coding best practices they already know. And when they encounter some odd syntax they don&amp;rsquo;t recognize, their reaction is to say &amp;ldquo;this has to be rewritten in Python!&amp;rdquo; instead of taking a breath and trying to really understand what&amp;rsquo;s going on. It doesn&amp;rsquo;t help that plenty of senior engineers scoff at shell scripts.
And it is true: the shell is arcane and has many flaws as a programming language. I don&amp;rsquo;t want to convince you to start writing new tools in it. But the shell is also an incredible rapid prototyping language, and you can use it to solve business problems really quickly and with surprisingly little code. If you pause for a second to learn it, you&amp;rsquo;ll realize that you can bend tradition and write maintainable shell code too. Hear out how I got into writing so much shell and how you can get better at it too.
"><meta property="og:description" content="&amp;ldquo;Why do you know so much shell?&amp;rdquo; is a question I&amp;rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I was &amp;ldquo;forced&amp;rdquo; to write tools in it for a while and, because of that, I made a conscious effort to learn the language and get better at it.
You see, most people that write shell don&amp;rsquo;t want to deal with it. They stitch together whatever works into a script and call it a day, making a bunch of spaghetti even if it goes against the coding best practices they already know. And when they encounter some odd syntax they don&amp;rsquo;t recognize, their reaction is to say &amp;ldquo;this has to be rewritten in Python!&amp;rdquo; instead of taking a breath and trying to really understand what&amp;rsquo;s going on. It doesn&amp;rsquo;t help that plenty of senior engineers scoff at shell scripts.
And it is true: the shell is arcane and has many flaws as a programming language. I don&amp;rsquo;t want to convince you to start writing new tools in it. But the shell is also an incredible rapid prototyping language, and you can use it to solve business problems really quickly and with surprisingly little code. If you pause for a second to learn it, you&amp;rsquo;ll realize that you can bend tradition and write maintainable shell code too. Hear out how I got into writing so much shell and how you can get better at it too.
"><meta property="twitter:description" content="&amp;ldquo;Why do you know so much shell?&amp;rdquo; is a question I&amp;rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2023/11/why-do-i-know-shell-and-how-can-you.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2023-11-10-sh-manpage.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2023-11-10-sh-manpage.jpg"><meta property="og:image:alt" content="The sh(1) manual page from NetBSD sitting on top of a bunch of orange-colored leaves."><meta property="twitter:image:alt" content="The sh(1) manual page from NetBSD sitting on top of a bunch of orange-colored leaves."><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDIzLzExL3doeS1kby1pLWtub3ctc2hlbGwtYW5kLWhvdy1jYW4teW91Lmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/why-do-i-know-shell-and-how-can-you")</script><header class=site-header><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Why do I know shell, and how can you?</h1><p>November 10, 2023 &#183;
About 7 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/personal-story>personal-story</a>, <a href=/tags/shell>shell</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/why-do-i-know-shell-and-how-can-you>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2023-11-10-sh-manpage.jpg style=max-width:100%><figcaption>The sh(1) manual page from NetBSD sitting on top of a bunch of orange-colored leaves.</figcaption></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p><em>&ldquo;Why do you know so much shell?&rdquo;</em> is a question I&rsquo;m getting a lot at work lately. So yeah, why? And how can you learn it too? There is no secret here: I know the shell well because I was &ldquo;forced&rdquo; to write tools in it for a while and, because of that, I made a conscious effort to learn the language and get better at it.</p><p>You see, most people that write shell don&rsquo;t want to deal with it. They stitch together whatever works into a script and call it a day, making a bunch of spaghetti even if it goes against the coding best practices they already know. And when they encounter some odd syntax they don&rsquo;t recognize, their reaction is to say &ldquo;this has to be rewritten in Python!&rdquo; instead of taking a breath and trying to really understand what&rsquo;s going on. It doesn&rsquo;t help that plenty of senior engineers scoff at shell scripts.</p><p>And it is true: the shell is arcane and has many flaws as a programming language. I don&rsquo;t want to convince you to start writing new tools in it. But the shell is also an incredible rapid prototyping language, and you can use it to solve business problems really quickly and with surprisingly little code. If you pause for a second to learn it, you&rsquo;ll realize that you can bend tradition and write maintainable shell code too. Hear out how I got into writing so much shell and how you can get better at it too.</p><h1 id=the-constraints-of-the-bsd-systems>The constraints of the BSD systems</h1><p>In the late 1990s, I discovered Linux and, soon after, the BSDs. I had a brief stint with OpenBSD and FreeBSD at first, but by the early 2000s, I had settled on <a href=https://www.NetBSD.org/>NetBSD</a> as my daily driver. My dream had always been to create my own operating system, but the more I learned and tried to write one, the more I realized I wasn&rsquo;t up to the task yet. Thus NetBSD was the perfect fit for me: all my hardware worked on it, but the system had enough rough edges that I saw the opportunity to become a contributor to a real operating system.</p><p>NetBSD&mdash;and all the BSDs really&mdash;are full operating system distributions. Unlike Linux, the source code for their kernel, user space tools, and documentation lives in a single source tree (monorepo!) maintained by a single group of developers. This source tree is known as <em>the base system</em> and every other third-party app comes via the ports system&mdash;or <a href=https://www.pkgsrc.org/>pkgsrc</a> in NetBSD-specific parlance. If this is hard to imagine, visualize your typical Windows installation: when you perform a fresh install of Windows 7 (not 10 or 11 because these get random junk auto-added), what you get is a collection of software that Microsoft has itself developed and chosen to be the basis to form Windows; everything you add to it later on, be it from Microsoft or other vendors, is not part of that base installation.</p><p>A constraint of this arrangement is that the code in a BSD base system is self-hosting: i.e. the base system must be able to build itself so it must <a href=/2015/10/compilers-in-the-bsd-base-system.html>include the compilers</a> and interpreters required to build and run its code. In NetBSD during the early 2000s, this meant choosing between C, C++, and shell. Lua has been added as a fourth choice since.</p><p>It is of course possible to write tools for a BSD system in any language that&rsquo;s not in the base system, but doing so means that the tool is relegated to live in the ports system. To make matters worse, the common practice in the BSDs was to build everything from source&mdash;pre-built binary packages existed but were inflexible and usually stale&mdash;and thus users frowned upon heavy dependencies. If your tiny tool required Perl or Python, for example, it would be dead on arrival because of the heavy tax imposed by the interpreter: if I recall correctly, building Perl on my Pentium II took something like 15 minutes, and building it on a 68k Mac I had took hours.</p><h1 id=contributing-tools-to-netbsd>Contributing tools to NetBSD</h1><p>See where this is going? I was the primary maintainer of Gnome 2.x on NetBSD and, as part of this work, I ended writing all sorts of tools to simplify the maintenance of the packages and the system as a whole. I wrote things like <a href=/software/sysbuild.html>sysbuild</a>, <a href=/software/pkg_comp.html>pkg_comp</a>, <a href=http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/pkgtools/pkg_alternatives/>pkg_alternatives</a>, <a href=http://cvsweb.netbsd.org/bsdweb.cgi/pkgsrc/pkgtools/dfdisk/>dfdisk</a>, <a href=/2022/06/autoconf-caching.html>autoswc</a>, <a href=/software/etcutils.html>etcutils</a>&mldr; and even <a href=/2022/05/remembering-buildtool.html>my own build system</a>.</p><p>And to write such tools&mldr; which language could I use? I wanted my tools to feel part of the base system and I didn&rsquo;t want to have to pay the heavy price of Perl or Python. I could have used C, but&mldr; well, let&rsquo;s just say that C is a terrible choice for automation tools. I could have used C++, but people <em>also</em> hated it for its long compile times and the fact that, back in the pre-C++11 era, it wasn&rsquo;t much better than C and compilers were really bad at supporting standards. And I could use the shell which, as ugly as it was, made programs immediately installable under any of the tens of hardware platforms that NetBSD supported, no matter how slow they were.</p><p>So that&rsquo;s how I ended up writing shell. The shell was the only realistic option I had to write the tools I wanted to write. And you know what? My scripts were bad at first, full of the problems I opened this article with. But with practice, a principled approach to writing shell <del>scripts</del> programs, and an open mind to see the shell as &ldquo;yet another programming language&rdquo;, it turned out to be not a terrible idea in retrospect.</p><p>My biggest shell program today is probably <a href=/2017/02/introducing-pkg_comp-2.0.html>pkg_comp2</a>. If I count the lines of its source code plus its two dependencies (<a href=/software/sandboxctl.html>sandboxctl</a> and <a href=https://shtk.jmmv.dev/>shtk</a>), it comes to about 15,000 SLOC. More than half of those are unit and integration tests, just as commonly happens in &ldquo;real software&rdquo;, which shows that shell programs can mimic the good development practices of other languages. Just take a moment and skim through <a href=https://github.com/jmmv/pkg_comp/blob/28dc346ade09bd620f1ec3c6ad43b98f412deaa9/pkg_comp.sh>pkg_comp.sh</a>. Does this look like your regular spaghetti shell code to you?</p><h1 id=how-you-can-get-better-at-the-shell>How you can get better at the shell</h1><p>I could probably write a whole book on this topic&mdash;and I&rsquo;ve thought about doing so&mldr; would you read it?&mdash;but all I can do right now is give you some ideas:</p><ol><li><p><strong>Read about the language.</strong> The shell is small. Once I decided I wanted to get better at the shell, I just opened the <a href=https://man.netbsd.org/sh.1><code>sh(1)</code> manual page</a> and read it. It will take you less than 1 hour to go through the whole document. You might choose to <em>also</em> read the Bash manual page&mdash;and you probably should, particularly to become aware of its many <a href=/2021/08/useless-use-of-gnu.html>unnecessary non-standard features</a>.</p></li><li><p><strong>Familiarize yourself with the Unix toolchain.</strong> Yes, the shell language is really simple, but that comes at a price: many of the things you want to do will require invoking tools like <code>grep</code>, <code>sed</code>, <code>find</code>&mldr; Which is fine because that&rsquo;s the core idea behind the Unix toolchain&mdash;small, composable tools&mdash;but that means you need to know those tools too. The more tools you know about, the better your scripts will be. Think of these tools as the &ldquo;standard library&rdquo; for the shell. Manual pages are not in fashion&mldr; but getting comfortable in navigating them will prove to be a useful skill.</p></li><li><p><strong>Understand how process creation (<code>fork</code> vs. <code>exec</code>) and <a href=/2020/11/cmdline-args-unix-vs-windows.html>argument passing</a> work in Unix.</strong> The shell is primarily designed to interact with subprocesses, so knowing these topics in detail is <em>crucial</em> to truly understand how quoting, globs, redirections, and pipelines work, and also to understand the difference between built-in and external commands. For example, do you know <a href=/2020/03/test-bracket.html>how <code>test</code>, <code>[</code> and <code>[[</code> differ</a>?</p></li><li><p><strong>Write shell scripts following the good programming practices you already know.</strong> Avoid global variables. Factor code into functions. Minimize side-effects. <a href=/2023/10/unit-testing-with-shtk.html>Write unit and/or integration tests.</a> And be unconditionally strict: e.g. double-quote all variable expansions to correctly handle whitespace characters, even if in most cases you may not need to do so.</p></li><li><p><strong>Think in terms of data flow.</strong> The shell is about combining tools as pipelines, not writing your usual imperative for loops. The more you can reason about solving problems with pipelines, the simpler and more performant your scripts will be. Functional programming FTW!</p></li><li><p><strong>Read Google&rsquo;s <a href=https://google.github.io/styleguide/shellguide.html>Shell Style Guide</a>.</strong> While I don&rsquo;t necessarily agree with everything it has to say, especially around stylistic details, the &ldquo;Features and bugs&rdquo; and &ldquo;Calling commands&rdquo; sections are particularly interesting.</p></li><li><p><strong>Use <a href=https://www.shellcheck.net/>ShellCheck</a>.</strong></p></li><li><p>And finally, <strong>take a look at my <a href=/2018/02/shell-readability-main.html>short readability series on the shell</a> from 2013.</strong></p></li></ol></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2023/11/end-to-end-tool-testing-with-bazel.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2023/11/ssh-agent-forwarding-and-tmux-done.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Why+do+I+know+shell%2C+and+how+can+you%3F&amp;url=https%3A%2F%2Fjmmv.dev%2F2023%2F11%2Fwhy-do-i-know-shell-and-how-can-you.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Why+do+I+know+shell%2C+and+how+can+you%3F&amp;u=https%3A%2F%2Fjmmv.dev%2F2023%2F11%2Fwhy-do-i-know-shell-and-how-can-you.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Why+do+I+know+shell%2C+and+how+can+you%3F+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2023%2F11%2Fwhy-do-i-know-shell-and-how-can-you.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>