<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>The IDEs we had 30 years ago... and we lost - Julio Merino (jmmv.dev)</title><meta property="og:title" content="The IDEs we had 30 years ago... and we lost - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="The IDEs we had 30 years ago... and we lost - Julio Merino (jmmv.dev)"><meta name=description content="I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we had. Having gained more knowledge throughout the years, it is now really fun to pick up DOSBox to re-experience those programs and compare them with our current state of affairs.
This time around, I want to look at the pure text-based IDEs that we had in that era before Windows eclipsed the PC industry. I want to do this because those IDEs had little to envy from the IDEs of today&amp;mdash;yet it feels as if we went through a dark era where we lost most of those features for years and they are only resurfacing now.
If anything, stay for a nostalgic ride back in time and a little rant on &amp;ldquo;bloat&amp;rdquo;. But, more importantly, read on to gain perspective on what existed before so that you can evaluate future feature launches more critically.
"><meta property="og:description" content="I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we had. Having gained more knowledge throughout the years, it is now really fun to pick up DOSBox to re-experience those programs and compare them with our current state of affairs.
This time around, I want to look at the pure text-based IDEs that we had in that era before Windows eclipsed the PC industry. I want to do this because those IDEs had little to envy from the IDEs of today&amp;mdash;yet it feels as if we went through a dark era where we lost most of those features for years and they are only resurfacing now.
If anything, stay for a nostalgic ride back in time and a little rant on &amp;ldquo;bloat&amp;rdquo;. But, more importantly, read on to gain perspective on what existed before so that you can evaluate future feature launches more critically.
"><meta property="twitter:description" content="I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2023/12/the-ides-we-had-30-years-ago.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDIzLzEyL3RoZS1pZGVzLXdlLWhhZC0zMC15ZWFycy1hZ28uaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/the-ides-we-had-30-years-ago-and")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>The IDEs we had 30 years ago... and we lost</h1><p>December 25, 2023 &#183;
About 12 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/history>history</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/the-ides-we-had-30-years-ago-and>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>I grew up learning to program in the late 1980s / early 1990s. Back then, I did not fully comprehend what I was doing and why the tools I used were impressive given the constraints of the hardware we had. Having gained more knowledge throughout the years, it is now really fun to pick up DOSBox to re-experience those programs and compare them with our current state of affairs.</p><p>This time around, I want to look at the pure text-based IDEs that we had in that era before Windows eclipsed the PC industry. I want to do this because those IDEs had little to envy from the IDEs of today&mdash;yet it feels as if we went through a dark era where we lost most of those features for years and they are only resurfacing now.</p><p>If anything, stay for a nostalgic ride back in time and a little rant on &ldquo;bloat&rdquo;. But, more importantly, read on to gain perspective on what existed before so that you can evaluate future feature launches more critically.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=first-editors-and-tuis>First editors and TUIs</h1><p>In the 1990s, almost every DOS program you ran had a full-screen Text User Interface (TUI) which sported text-based windows, drop shadows, colors, and mouse support. Here is just one example:</p><figure><img src=/images/2023-12-25-edit-com-colors.png class=with-border><figcaption>The MS-DOS Editor (aka <tt>EDIT.COM</tt>) with one of its settings dialog open. Note the menu bar, the rich dialog with list selectors and buttons, and the status bar documenting navigation shortcuts.</figcaption></figure><p>Each program was its own island because its interface was unique to the program. However, they were all so similar in how they looked like&mdash;80x25 characters didn&rsquo;t leave much room for uniqueness&mdash;and how they worked that the differences didn&rsquo;t really get in the way of usability and discoverability. Once you learned that the Alt key opened the menus and that Tab moved across input fields and buttons, you could navigate almost any program with ease.</p><p>But let&rsquo;s talk about editors. MS-DOS shipped with a TUI text editor since version 5 (1991), which <a href=/2023/12/a-cli-text-editor-in-my-windows.html>I previously covered in a recent article</a> and is shown above. This editor &ldquo;worked&rdquo;, but it was really inconvenient for coding: you needed to exit the editor to compile and run your code, and when you re-ran the editor, you&rsquo;d have to navigate back to where you were before.</p><p>&ldquo;In my house&rdquo;, we used something called <a href=https://en.wikipedia.org/wiki/Borland_Sidekick>SideKick Plus</a> (1984), which wasn&rsquo;t really a code editor: it was more of a Personal Information Management (PIM) system with a built-in notepad. The cool thing about it, however, was that it was a Terminate and Stay Resident (TSR) program, which meant that it loaded in the background and you could bring it up at any time by pressing Ctrl+Alt.</p><figure><img src=/images/2023-12-25-sidekick-plus.png class=with-border><figcaption>SideKick Plus' main screen after pressing Ctrl+Alt to bring it up. Note how DOS remains in the background.</figcaption></figure><p>Think of this TSR feature as rudimentary multitasking for an OS that did <em>not</em> have multitasking. This was really effective because quickly switching between code editing and building is critical for an efficient inner development loop. (And by the way, this past experience explains the design of the <a href=https://www.endbasic.dev/docs.html#intro-first>code editing flow in EndBASIC</a>. I did not implement the equivalent of Ctrl+Alt, but I&rsquo;ve considered it many times.)</p><p>By this point, however, real IDEs had already existed for a few years. Turbo Pascal 1.0 (1983) shows the beginning of an integrated experience, although it did not feature its iconic TUI yet. QuickBASIC 2.0 (1986) shows more of a &ldquo;traditional&rdquo; TUI (the same as <code>EDIT.COM</code>, because they are the same editor), and MS-DOS 5 came with QBasic, a reduced version of QuickBASIC that didn&rsquo;t allow compiling to native code but that had the same look.</p><h1 id=the-borland-turbo-series>The Borland Turbo series</h1><p>The crown jewel of IDEs, in my opinion, were the later Borland Turbo series, which included Turbo C++ (1990), Turbo Assembler and Turbo Pascal. These IDEs were language specific, but they had full-screen TUIs and were extremely powerful.</p><p>Here, take a look at what we had. Syntax highlighting:</p><figure><img src=/images/2023-12-25-turbo-cpp-syntax-highlighting.png class=with-border><figcaption>Borland Turbo C++ showing a "Hello World" program to demonstrate syntax highlighting.</figcaption></figure><p>Compiler integration and diagnostics:</p><figure><img src=/images/2023-12-25-turbo-cpp-warnings.png class=with-border><figcaption>Borland Turbo C++ after compiling a program, showing a warning because I did not return a value from <tt>main()</tt>.</figcaption></figure><p>Integrated project and build system management:</p><figure><img src=/images/2023-12-25-turbo-cpp-project.png class=with-border><figcaption>Borland Turbo C++ showing its project management and multi-window features. In the picture, you can see two C++ source files, with one depending on the other, and the project window listing all files that need to be compiled together.</figcaption></figure><p>A debugger with breakpoints, stack traces, and the like:</p><figure><img src=/images/2023-12-25-turbo-cpp-debugger.png class=with-border><figcaption>Borland Turbo C++ showing a debugging session with a program that contains multiple functions, a breakpoint, and the current call stack.</figcaption></figure><p>And even a full reference manual:</p><figure><img src=/images/2023-12-25-turbo-cpp-help.png class=with-border><figcaption>Borland Turbo C++ showing its integrated help system, with the "Hello World" program in the background and the help for <tt>printf</tt>.</figcaption></figure><p>Remember: all of this in the early 1990s&mdash;a little over 30 years ago at the time of this writing.</p><p>I was an avid user of Turbo C++, with which I learned a lot. I remember using their <code>conio.h</code> libraries to implement TUIs of my own, and then their builtin <code>graphics.h</code> libraries to play with implementing GUIs. And note: this was <em>without the Internet</em>. There was no option for many to just &ldquo;look up how things worked&rdquo; in Stack Overflow: the IDE had to be discoverable right away (which it was) and self-contained to offer you a complete development experience.</p><h1 id=what-about-linux-back-then>What about Linux back then?</h1><p>Now take a moment to compare this scene with Linux in the early 1990s.</p><p>In Linux, almost every program was <em>also</em> text based, but those programs did not come with a full-screen TUI. It just wasn&rsquo;t &ldquo;the Unix way&rdquo;. I remember watching the X11 configuration tool (<a href=https://www.xfree86.org/3.3.6/QuickStart3.html><code>XF86Setup</code></a>) or the OpenBSD installer and feeling shocked by how simplistic those were: me, a young teenager with barely any &ldquo;real&rdquo; coding experience, had written better-looking programs already.</p><p>In any case, this didn&rsquo;t stop me from my quest to <em>not</em> use Windows. I continued to learn the ways of Linux and soon faced the &ldquo;best&rdquo; editors recommended by every book and community online: Vim and Emacs. And I could not understand why they were praised. Using these was like stepping back into the past. They were full-screen programs indeed, but they seemed pretty arcane. Vim did have syntax highlighting but it was far from being an IDE. Emacs could be configured to integrate with some code assisting features and the like, but it was far from being &ldquo;fire and forget&rdquo; like the Turbo family of IDEs.</p><p>Just look at the default Emacs configuration <em>today</em>, which hasn&rsquo;t changed much (if at all) since then. It does have windows, but they aren&rsquo;t decorated. It didn&rsquo;t have colors (and now barely has), because why? It didn&rsquo;t use to have mouse support. It <em>does</em> have a menu bar though, but it is just a gimmick? If you press <tt>M-`</tt> as the instructions tell you, you face a truly strange interface to navigate the menu&mdash;which makes one wonder why they even bothered to waste a full line of screen real state to show a menu bar that does nothing.</p><figure><img src=/images/2023-12-25-emacs-menubar.png class=with-border><figcaption>A fresh installation of Emacs in the console, with the standard welcome screen in the background and the "menu" open after pressing <tt>M-`</tt>.</figcaption></figure><p>Now try giving this to anyone with little coding experience and getting them to create, compile, and debug a program. They will have trouble just navigating the editor, and they won&rsquo;t find any of the features that would allow for project management or compiler integration.</p><p>For comparison, in writing this post, I fired up Turbo C++ in DOSBox and I was able to create a &ldquo;hello world&rdquo; project and navigate the environment in minutes&mdash;all without prior knowledge (everything I had known has been forgotten by now). The environment is intuitive and, as an IDE, integrated all around.</p><h1 id=contemporary-tui-ides>Contemporary TUI IDEs</h1><p>Anyhow. Let&rsquo;s forget about the past and look at what we have today in TUI-land. I don&rsquo;t want to look at GUIs because&mldr; well, Visual Basic was the pinnacle of graphics programming and we don&rsquo;t have that either anymore&mdash;which is also a topic for another day. (Well, OK, you have <a href=https://gambas.sourceforge.net/>Gambas</a>&mldr; but who knows about it?)</p><p>The closest more-modern equivalent to the Borland Turbo C++ environment is <a href=https://directory.fsf.org/wiki/RHIDE>RHIDE</a>. As you can see in the picture below, it looks incredibly similar&mdash;and you&rsquo;d be forgiven if you thought this <em>is</em> Turbo C++. Unfortunately, it is DOS-only and seems to be mostly abandoned by now with its latest release dated 7 years ago.</p><figure><img src=/images/2023-12-25-rhide.png class=with-border><figcaption>The RHIDE IDE showing the same "hello world" program as before, with no errors nor warnings after compilation.</figcaption></figure><p>Then we have <a href=https://www.freepascal.org/>Free Pascal</a>. This is the closest you&rsquo;ll get to the old experience but with a modern codebase, running natively on Unix systems and leveraging terminals of any size.</p><figure><img src=/images/2023-12-25-free-pascal.png class=with-border><figcaption>The Free Pascal IDE with a trivial "hello world" program and overlapping windows for a built-in ASCII table and a calculator.</figcaption></figure><p>And lastly we have <a href=https://qb64.com/>QB64</a>. This closely resembles Microsoft QuickBasic but&mldr; don&rsquo;t let it trick you: even though it looks like a TUI, it is actually a GUI application that simulates a TUI. You cannot run QB64 in a terminal.</p><figure><img src=/images/2023-12-25-qb64.png class=with-border><figcaption>The QB64 IDE, which looks textual but is actually a graphical program.</figcaption></figure><p>Both Free Pascal and QB64 are maintained and under relatively-active development, with their most recent releases in 2021&mldr; but they are mostly ignored because they expose arcane languages that most people have no interest in these days.</p><h1 id=real-contemporary-console-ides>&ldquo;Real&rdquo; contemporary console IDEs</h1><p>So what are we left with for <em>modern</em> languages today?</p><p>The state of the art seems to be <a href=https://neovim.io/>Neovim</a>, <a href=https://github.com/doomemacs/doomemacs>Doom Emacs</a>, or even <a href=https://helix-editor.com/>Helix</a>. These editors are very powerful and, thanks to various plugins, offer reasonable IDE-like experiences. That said, if you ask me, none of these provide the same kind of experience that the previous Borland products offered: their interfaces are obscure and, due to their multi-language nature, they work OK for almost everything but they aren&rsquo;t great for anything. &ldquo;Jack of all trades, master of none&rdquo; if you will.</p><p>In any case, the preferred &ldquo;simple&rdquo; TUI editor, based on what I observed in the deranged <a href=https://github.com/microsoft/terminal/discussions/16440>microsoft/terminal#16440</a> discussion, seems to be&mldr; <a href=https://www.nano-editor.org/>GNU Nano</a>&mldr; which OK, it works, but first: it&rsquo;s no IDE, and second, to me this looks like WordStar. Yeah, I know it isn&rsquo;t WordStar: if you want WordStar, the closest you&rsquo;ll find is <a href=https://joe-editor.sourceforge.io/>Joe</a>, but the <em>looks</em> of Nano remind me of my first experiences with a word processor back in the CP/M days. Here, look:</p><figure><img src=/images/2023-12-25-nano.png class=with-border><figcaption>The GNU Nano editor in its default setup, with an empty file open.</figcaption></figure><p>So even though we <em>do</em> have powerful console editors these days, they don&rsquo;t quite offer the same usable experience we had 30 years ago. In fact, it feels like during these 30 years, we regressed in many ways, and only now are reaching feature parity with some of the features we used to have.</p><p>It is natural that TUIs diminished in popularity once graphical OSes gained traction, and it is somewhat interesting that they are making a comeback just now. As for why, I think we have to thank the invention of <a href=https://microsoft.github.io/language-server-protocol/>LSP</a> for most of the recent progress in this area. TUI editors were &ldquo;on hold&rdquo; for many years because building IDE features for them was a lot of effort and their small maintainer base could not afford to implement them. LSP unlocked access to existing language-specific integrations and reinfused interest in the old-and-trusty Vim and Emacs. Hopefully, the upcoming <a href=https://build-server-protocol.github.io/>BSP</a> will do even more to make these TUIs more IDE-like.</p><h1 id=why-tui-ides-anyway>Why TUI IDEs anyway?</h1><p>It is fair to ask &ldquo;Who cares? Every desktop and laptop runs a graphical OS now!&rdquo;</p><p>And it&rsquo;s a good question. In general, you probably <em>don&rsquo;t</em> want a TUI IDE. If VSCode is your jam, its remoting abilities are superb and VSCode has a reasonably good graphical interface without being a full-blown IDE. But there are a few things that VSCode doesn&rsquo;t give us.</p><p>The first is that a TUI IDE is excellent for work on remote machines&mdash;even better than VSCode. You can SSH into <em>any</em> machine with ease and launch the IDE. <a href=/2015/09/my-coding-workflow.html>Combine it with tmux and you get &ldquo;full&rdquo; multitasking.</a> Yes, you could instead use a remote desktop client instead of SSH, but I&rsquo;ve always found them clunky due to lag and the improper integration with the local desktop shortcuts.</p><p>The second is that <a href=https://code.visualstudio.com/docs/remote/faq#_why-arent-the-remote-development-extensions-or-their-components-open-source>VSCode&rsquo;s remote extensions are <em>not</em> open source</a>, which isn&rsquo;t a major problem&mldr; except for the fact that they don&rsquo;t work on, say, FreeBSD and there is no way to fix them. So this makes it impossible for me to remote into my primary development server with VSCode.</p><p>And the third is&mldr; reduced resource consumption.</p><h1 id=bloat-everywhere>Bloat everywhere</h1><p>I can&rsquo;t leave without ranting about &ldquo;bloat&rdquo; for a little bit. Borland Turbo C++, with all its bells and whistles (the UI, the C++ toolchain, the integrated manuals&mldr;), is less than 9 MB after installation and ran within 640kb of RAM.</p><p>For comparison, Helix is 16 MB on disk, which is pretty impressive (and honestly unexpected), but Doom Emacs is about 500 MBs and consumes many MBs of RAM. Note, however, that none of these numbers account for the language toolchains or help systems, and toolchains nowadays rank in the GBs of disk space.</p><p>To get &ldquo;real&rdquo; IDEs, we have to jump to graphical programs like IntelliJ or VSCode. VSCode, for example, is about 350 MBs on disk (surprisingly less than Doom Emacs) but it will eat your computer for lunch: it&rsquo;s Electron after all. I have noticed very significant savings in laptop battery life by dropping VSCode and moving to Doom Emacs.</p><p>So the question I want to part with is: have we advanced <em>much</em> in 30 years? Modern IDEs have some better refactoring tools, better features, and support more languages, but fundamentally&mldr; they haven&rsquo;t changed much. The only major difference that we are <em>starting</em> to see might be AI-assisted coding, but this is a feature mostly provided by a remote service, not even by the installed code!</p><p>And that&rsquo;s all for today. On my side, I&rsquo;ll happily continue using <em>all of</em> Doom Emacs, Vim, VSCode, and IntelliJ depending on the situation. Merry Christmas if this is your thing!</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2023/12/bazel-interview-at-software-engineering.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2023/12/links-december-2023-edition.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=The+IDEs+we+had+30+years+ago...+and+we+lost&amp;url=https%3A%2F%2Fjmmv.dev%2F2023%2F12%2Fthe-ides-we-had-30-years-ago.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=The+IDEs+we+had+30+years+ago...+and+we+lost&amp;u=https%3A%2F%2Fjmmv.dev%2F2023%2F12%2Fthe-ides-we-had-30-years-ago.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=The+IDEs+we+had+30+years+ago...+and+we+lost+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2023%2F12%2Fthe-ides-we-had-30-years-ago.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>