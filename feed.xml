<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julio Merino</title>
    <link>http://julio.meroh.net/</link>
    <description>Recent content on Julio Merino</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jun 2018 09:00:00 -0400</lastBuildDate>
    
	<atom:link href="http://julio.meroh.net/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust review: The ecosystem</title>
      <link>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</link>
      <pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</guid>
      <description>In this part of the review, I would like to focus on Rust&amp;rsquo;s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust&amp;rsquo;s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let&amp;rsquo;s look at some.
The standard library The std library feels generally well-thought out and full of features.</description>
    </item>
    
    <item>
      <title>Rust review: The book</title>
      <link>http://julio.meroh.net/2018/06/rust-review-book.html</link>
      <pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-book.html</guid>
      <description>&amp;ldquo;The Rust Programming Language&amp;rdquo; is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let&amp;rsquo;s cover these, but first, some background.
A couple of years ago, right after getting started with Rust, I tried to go through the book&amp;rsquo;s first few chapters. It all sounded cool&amp;hellip; but the first edition of the book moved at a glacially slow pace because it covered things in excruciating detail.</description>
    </item>
    
    <item>
      <title>Rust review: The match keyword</title>
      <link>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</link>
      <pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</guid>
      <description>A commonly-acclaimed feature of Rust is its match keyword: a &amp;ldquo;conditional on steroids&amp;rdquo;. match lets you take the value of an expression and compare it against a bunch of values—or, more generally, patterns.
As you write and read Rust, you will notice that this keyword is used everywhere because it&amp;rsquo;s the way to access certain types, like Option values or error codes.
For example:
matchnode.get_parent(){// node is an Option&amp;lt;Something&amp;gt;. Some(parent)=&amp;gt;{// Do something with &amp;#34;parent&amp;#34;, which we know points to a node.</description>
    </item>
    
    <item>
      <title>Rust review: Expressions, expressions, expressions</title>
      <link>http://julio.meroh.net/2018/06/rust-review-expressions.html</link>
      <pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-expressions.html</guid>
      <description>Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a &amp;ldquo;pragmatic Haskell&amp;rdquo; or as a &amp;ldquo;well-balanced mixture between C++ and Haskell&amp;ldquo;.
One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.</description>
    </item>
    
    <item>
      <title>Rust review: Learning curve</title>
      <link>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</link>
      <pubDate>Fri, 08 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</guid>
      <description>Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I&amp;rsquo;ll try to convince you that the curve does feel steep, but it isn&amp;rsquo;t when taken into perspective.
Let&amp;rsquo;s first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.</description>
    </item>
    
    <item>
      <title>Rust review: Protect the data</title>
      <link>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</link>
      <pubDate>Tue, 05 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</guid>
      <description>The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.
I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil&amp;rsquo;s MutexLock) was the panacea. (I&amp;rsquo;m a fan of RAII in C++ by the way, in case you haven&amp;rsquo;t noticed.)</description>
    </item>
    
    <item>
      <title>Rust review: The borrow checker</title>
      <link>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</link>
      <pubDate>Fri, 01 Jun 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</guid>
      <description>Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that&amp;rsquo;s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality&amp;hellip; the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.</description>
    </item>
    
    <item>
      <title>Rust review: Immutable by default</title>
      <link>http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html</link>
      <pubDate>Tue, 29 May 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html</guid>
      <description>Let&amp;rsquo;s start the deep dive by looking into a powerful feature of Rust: all variables and references are immutable by default unless qualified with mut.
To understand why this is important, let&amp;rsquo;s cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the const qualifier everywhere: if something ain&amp;rsquo;t mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc.</description>
    </item>
    
    <item>
      <title>Rust review: Introduction</title>
      <link>http://julio.meroh.net/2018/05/rust-review-introduction.html</link>
      <pubDate>Fri, 25 May 2018 09:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/05/rust-review-introduction.html</guid>
      <description>I had been meaning to learn Rust since I first toyed with Go a couple of years ago. During this period, I&amp;rsquo;ve written a non-trivial amount of Go code both inside and outside Google, but never found the chance to sit back and learn Rust.
This changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would not work on any personal or work projects for the 2-week long vacation.</description>
    </item>
    
    <item>
      <title>A few extra system calls... and you lose 1% build time</title>
      <link>http://julio.meroh.net/2018/04/bazel-xcode-locations-cache.html</link>
      <pubDate>Mon, 30 Apr 2018 13:45:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/04/bazel-xcode-locations-cache.html</guid>
      <description>Blaze—the variant of Bazel used internally at Google—was originally designed to build the Google monorepo. One of the beauties of sticking to a monorepo is code reuse, but this has the unfortunate side-effect of dependency bloat. As a result, Bazel and Blaze have evolved to support ever-increasingly-bigger pieces of software.
The growth of the projects built by Bazel and Blaze has had the unsurprising consequence that our engineers all now have high-end workstations with access to massive amounts of distributed resources.</description>
    </item>
    
    <item>
      <title>Preliminary sandboxfs support in Bazel</title>
      <link>http://julio.meroh.net/2018/04/preliminary-sandboxfs-support-in-bazel.html</link>
      <pubDate>Fri, 13 Apr 2018 15:30:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/04/preliminary-sandboxfs-support-in-bazel.html</guid>
      <description>During the summer of last year, I hosted an intern who implemented sandboxfs: a FUSE-based file system that exposes an arbitrary view of the host&amp;rsquo;s file system under the mount point. At the end of his internship, we had a functional sandboxfs implementation and some draft patches for integration in Bazel.
The goal of sandboxfs in the context of Bazel is to improve the performance of builds when action sandboxing is enabled.</description>
    </item>
    
    <item>
      <title>Stick to your project&#39;s core language in your tests</title>
      <link>http://julio.meroh.net/2018/03/stick-to-projects-core-language-in-tests.html</link>
      <pubDate>Tue, 27 Mar 2018 10:00:00 +0900</pubDate>
      
      <guid>http://julio.meroh.net/2018/03/stick-to-projects-core-language-in-tests.html</guid>
      <description>&lt;p&gt;&lt;em&gt;This post is a short, generalized summary of the preceeding two. I believe those two posts put readers off due to their massive length and the fact that they were seemingly tied to Bazel and Java, thus failing to communicate the larger point I wanted to make. Let&amp;rsquo;s try to distill their key points here in a language- and project-agnostic manner.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A case for writing Bazel&#39;s integration tests in Java, part 2</title>
      <link>http://julio.meroh.net/2018/03/bazel-tests-in-java-part-2.html</link>
      <pubDate>Mon, 19 Mar 2018 08:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/03/bazel-tests-in-java-part-2.html</guid>
      <description>In part 1 of this series, I made the case that you should run away from the shell when writing integration tests for your software and that you should embrace the primary language of your project to write those.
Depending on the language you are using, doing this will mean significant more work upfront to lay out the foundations for your tests, but this work will pay off. You may also feel that the tests could be more verbose than if they were in shell, though that&amp;rsquo;s not necessarily the case.</description>
    </item>
    
    <item>
      <title>A case for writing Bazel&#39;s integration tests in Java, part 1</title>
      <link>http://julio.meroh.net/2018/03/bazel-tests-in-java-part-1.html</link>
      <pubDate>Fri, 16 Mar 2018 14:00:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/03/bazel-tests-in-java-part-1.html</guid>
      <description>My latest developer productivity rant thesis is that integration tests should be written in the exact same language as the thing they test. Specifically, not shell.
This theory applies mostly to tests that verify infrastructure software like servers or command line tools. It is too easy to fall into the trap of using the shell because it feels like the natural choice to interact with tools. But I argue that this is a big mistake that hurts the long-term health of the project, and once trapped, it&amp;rsquo;s hard to escape.</description>
    </item>
    
    <item>
      <title>Shell readability: local</title>
      <link>http://julio.meroh.net/2018/03/shell-readability-local.html</link>
      <pubDate>Tue, 13 Mar 2018 11:43:00 -0400</pubDate>
      
      <guid>http://julio.meroh.net/2018/03/shell-readability-local.html</guid>
      <description>&lt;p&gt;As most programming languages with support for functions, the shell offers locally-scoped variables. Unfortunately, &lt;em&gt;local variables are not the default&lt;/em&gt;. &lt;strong&gt;You must explicitly declare variables as &lt;code&gt;local&lt;/code&gt;&lt;/strong&gt; and you should &lt;strong&gt;be very strict about doing this&lt;/strong&gt; to prevent subtle but hard-to-diagnose bugs.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it! What else is there to say about this trivial keyword? As it turns out, more than you might think.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>