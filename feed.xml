<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jmmv.dev</title>
    <link>https://jmmv.dev/</link>
    <description>Recent content on jmmv.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 May 2020 06:30:00 -0400</lastBuildDate>
    
	<atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>EndBASIC 0.2.0 is here</title>
      <link>https://jmmv.dev/2020/05/endbasic-0.2.0.html</link>
      <pubDate>Thu, 07 May 2020 06:30:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/05/endbasic-0.2.0.html</guid>
      <description>A couple of weeks ago, I announced EndBASIC: a simple BASIC language interpreter written in Rust with a goal to provide an environment for teaching my kids how to code. That first release provided what-I-think-is a robust interpreter, but that was about it: the language features were still minimal and the interactive features were non-existent.
Well, EndBASIC 0.2.0 is here and things are changing! It&amp;rsquo;s still far from the vision I want to reach, but it&amp;rsquo;s slowly moving towards that direction.</description>
    </item>
    
    <item>
      <title>What is Rust&#39;s Into&lt;T&gt; for?</title>
      <link>https://jmmv.dev/2020/04/rust-into-trait.html</link>
      <pubDate>Mon, 27 Apr 2020 18:50:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/04/rust-into-trait.html</guid>
      <description>Rust provides a bunch of traits that you may use or implement in your code, but unless you have experienced them first-hand, it can be hard to imagine what their real utility is. For example, if you go read Into&amp;rsquo;s documentation, all you find is:
 Trait std::convert::Into
A value-to-value conversion that consumes the input value. The opposite of From. [&amp;hellip;]
 Yay, very useful. This text tells me what this trait does, which is fine for a reference manual, but not when I could find it useful.</description>
    </item>
    
    <item>
      <title>Hello, EndBASIC!</title>
      <link>https://jmmv.dev/2020/04/hello-endbasic.html</link>
      <pubDate>Wed, 22 Apr 2020 09:00:00 -0400</pubDate>
      
      <guid>https://jmmv.dev/2020/04/hello-endbasic.html</guid>
      <description>INPUT&amp;#34;Did you ever experience BASIC (true/false)&amp;#34;;answer? IFanswer?THEN PRINT&amp;#34;Great; you are in for a treat!&amp;#34; ELSE PRINT&amp;#34;Oh noes; try today?&amp;#34; ENDIF I have pretty fond memories of my Amstrad CPC 6128 and its Locomotive BASIC 1.1. The experience was quite unique as the computer was ready to take commands in a couple of seconds, and those commands you typed had an immediate effect on the screen. Changing colors, drawing, playing sounds&amp;hellip; were all at your fingertips, which was pretty exciting for a young boy.</description>
    </item>
    
    <item>
      <title>test, [, and [[</title>
      <link>https://jmmv.dev/2020/03/test-bracket.html</link>
      <pubDate>Wed, 25 Mar 2020 05:55:00 +0500</pubDate>
      
      <guid>https://jmmv.dev/2020/03/test-bracket.html</guid>
      <description>Did you know that Unix systems have a binary whose name is a single symbol?
Go and look for it. Run ls /bin/? and behold:
$ ls /bin/? /bin/[  Uh huh. [? The square bracket? That&amp;rsquo;s a program?!
But wait, it gets more interesting:
$ ls -li /bin/[ /bin/test 834 -rwxr-xr-x 1 root wheel 35824 Jan 23 08:59 /bin/[ 834 -rwxr-xr-x 1 root wheel 35824 Jan 23 08:59 /bin/test  The two names, [ and test, point to the same binary1.</description>
    </item>
    
    <item>
      <title>macOS terminal stalls running a binary</title>
      <link>https://jmmv.dev/2020/03/macos-stuck-terminal-fuse-exec.html</link>
      <pubDate>Mon, 23 Mar 2020 21:20:00 +0500</pubDate>
      
      <guid>https://jmmv.dev/2020/03/macos-stuck-terminal-fuse-exec.html</guid>
      <description>Here I am, confined to my apartment due to the COVID-19 pandemic and without having posted anything for almost two months. Fortunately, my family and I are still are in good condition, and I&amp;rsquo;m even more fortunate to have a job that can employ me remotely without problems. Or can they?
For over a year, my team and I have been working on allowing our mobile engineers to work from their laptops (as opposed to from their powerful workstations).</description>
    </item>
    
    <item>
      <title>FOSDEM navigation 101</title>
      <link>https://jmmv.dev/2020/02/fosdem-navigation-101.html</link>
      <pubDate>Mon, 03 Feb 2020 18:20:00 +0500</pubDate>
      
      <guid>https://jmmv.dev/2020/02/fosdem-navigation-101.html</guid>
      <description>FOSDEM 2020 is over. As I type this, I&amp;rsquo;m on my way back home from the conference in Brussels. And it has been nice. In the end. I must confess I was frustrated by the middle of the first day, though things got better after that.
Here is the thing: FOSDEM is not your usual conference. There are lots of things going on at once and all of them are crowded.</description>
    </item>
    
    <item>
      <title>Ensuring system rewrites are truly necessary</title>
      <link>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</link>
      <pubDate>Fri, 24 Jan 2020 17:10:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2020/01/system-rewrites-and-tuning.html</guid>
      <description>I think it&amp;rsquo;s safe to say that software engineers&amp;mdash;hey, I&amp;rsquo;m one one myself!&amp;mdash;often dream about what the rewrite of a system would look like if they had the chance to start over. Oh so much more usable. Oh so much better structured. Oh so much faster! We are architects after all.
And it might be true that a rewrite can deliver those benefits. But often enough, we are too quick to let our minds wander into that territory.</description>
    </item>
    
    <item>
      <title>The OSXFUSE, hard links, and dladdr puzzle</title>
      <link>https://jmmv.dev/2020/01/osxfuse-hardlinks-dladdr.html</link>
      <pubDate>Fri, 17 Jan 2020 16:30:00 +0500</pubDate>
      
      <guid>https://jmmv.dev/2020/01/osxfuse-hardlinks-dladdr.html</guid>
      <description>Hello everyone and welcome to this new decade!
It&amp;rsquo;s already 2020 and I&amp;rsquo;m only 17 days late in writing a first post. I was planning to start with an opinion article, but as its draft is taking longer than I wanted&amp;hellip; I&amp;rsquo;ll present you the story of a recent crazy bug that has kept me busy for the last couple of days.
Java crashes with Bazel and sandboxfs On a machine running macOS Catalina, install sandboxfs and build Bazel with sandboxfs enabled, like this:</description>
    </item>
    
    <item>
      <title>Tree artifacts and transient files</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-tree-artifacts.html</link>
      <pubDate>Tue, 31 Dec 2019 13:20:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-tree-artifacts.html</guid>
      <description>To conclude the deep dive into Bazel&amp;rsquo;s dynamic spawn strategy, let&amp;rsquo;s look at the nightmare that tree artifacts have been with the local lock-free feature. And, yes, I&amp;rsquo;m double-posting today because I really want to finish these series before the end of the decade1!
Tree artifacts are a fancy name for action outputs that are directories, not files. What&amp;rsquo;s special about them is that Bazel does not know a priori what the directory contents are: the rule behind the action just specifies that there will be a directory with files, and Bazel has to treat that as the unit of output from the action.</description>
    </item>
    
    <item>
      <title>Lifting the local lock for dynamic execution</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-local-lockfree.html</link>
      <pubDate>Tue, 31 Dec 2019 07:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-local-lockfree.html</guid>
      <description>In the previous post, we saw how accounting for artifact download times makes the dynamic strategy live to its promise of delivering the best of local and remote build times.
Or does it? If you think about it closely, that change made it so that builds that were purely local couldn&amp;rsquo;t be made worse by enabling the dynamic scheduler: the dynamic strategy would always favor the local branch of a spawn if the remote one took a long time.</description>
    </item>
    
    <item>
      <title>Artifact downloads and dynamic execution</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-download-times.html</link>
      <pubDate>Mon, 30 Dec 2019 11:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-download-times.html</guid>
      <description>In the previous post of this series, we looked at how the now-legacy implementation of the dynamic strategy uses a per-spawn lock to guard accesses to the output tree. This lock is problematic for a variety of reasons and we are going to peek into one of those here.
To recap, the remote strategy does the following:
 Send spawn execution RPC to the remote service. Wait for successful execution (which can come quickly from a cache hit).</description>
    </item>
    
    <item>
      <title>Output conflicts and dynamic execution</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-output-locking.html</link>
      <pubDate>Fri, 27 Dec 2019 10:10:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-output-locking.html</guid>
      <description>When the dynamic scheduler is active, Bazel runs the same spawn (aka command line) remotely and locally at the same time via two separate strategies. These two strategies want to write to the same output files (e.g. object files, archives, or final binaries) on the local disk. In computing, two things trying to affect the same thing require some kind of coördination.
You might think, however, that because we assume that both strategies are equivalent and will write the same contents to disk1, this is not problematic.</description>
    </item>
    
    <item>
      <title>Bazel&#39;s dynamic strategy</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-strategy.html</link>
      <pubDate>Thu, 26 Dec 2019 10:30:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-strategy.html</guid>
      <description>After introducing Bazel&amp;rsquo;s dynamic execution a couple of posts ago, it&amp;rsquo;s time to dive into its actual implementation details as promised. But pardon for the interruption in the last post, as I had to take a little detour to cover a necessary topic (local resources) for today&amp;rsquo;s article.
Simply put, dynamic execution is implemented as &amp;ldquo;just&amp;rdquo; one more strategy called dynamic. The dynamic strategy, however, is different from all others because it does not have a corresponding spawn runner.</description>
    </item>
    
    <item>
      <title>How does Bazel track local resource usage?</title>
      <link>https://jmmv.dev/2019/12/bazel-local-resources.html</link>
      <pubDate>Mon, 23 Dec 2019 22:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-local-resources.html</guid>
      <description>How does Bazel avoid melting your workstation with concurrent subprocesses? Or&amp;hellip; tries to, because I know it still does that sometimes? There are two mechanisms as play: the jobs number and the local resources tracker. Let&amp;rsquo;s dive into them.
The jobs number, given by the --jobs flag, configures the number of concurrent Skyframe evaluators during the execution phase1. What a mouthful. What this essentially means is that jobs indicates the number of threads used to walk the graph looking for actions to execute&amp;mdash;and also executing them.</description>
    </item>
    
    <item>
      <title>Introduction to Bazel&#39;s dynamic execution</title>
      <link>https://jmmv.dev/2019/12/bazel-dynamic-execution-introduction.html</link>
      <pubDate>Fri, 20 Dec 2019 15:00:00 +0000</pubDate>
      
      <guid>https://jmmv.dev/2019/12/bazel-dynamic-execution-introduction.html</guid>
      <description>Bazel&amp;rsquo;s dynamic execution is a feature that makes your builds faster by using remote and local resources, transparently and at the same time. We launched this feature in Bazel 0.21 back in February 2019 along an introductory blog post and have been hard at work since then to improve it.
The reason dynamic execution makes builds faster is two-fold:
 first, because we can hide hiccups in the connectivity to the remote build service; and, second, because we can take advantage of things like persistent workers, which are designed to offer super-fast edit/build/test cycles.</description>
    </item>
    
  </channel>
</rss>