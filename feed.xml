<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/</link><description>Recent content on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 08 Sep 2023 10:00:00 -0700</lastBuildDate><atom:link href="https://jmmv.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>Good performance is not just big O</title><link>https://jmmv.dev/2023/09/performance-is-not-big-o.html</link><pubDate>Fri, 08 Sep 2023 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/09/performance-is-not-big-o.html</guid><description>&lt;p>Having a fast and responsive app is orthogonal to &amp;ldquo;knowing your big &lt;i>O&lt;/i>s&amp;rdquo;. Unfortunately, most tech companies over-emphasize algorithms in interviews and downplay systems knowledge, and I believe that&amp;rsquo;s one reason behind sluggish apps and bloated systems.&lt;/p>
&lt;p>I&amp;rsquo;ve seen this play out repeatedly. Interviewers ask a LeetCode-style coding question, which is then followed by the ritual of discussing time and memory complexity. Candidates ace the answers. But then&amp;hellip; their &amp;ldquo;real&amp;rdquo; code suffers from subtle yet impactful performance problems.&lt;/p>
&lt;p>Focusing on big &lt;em>O&lt;/em> complexity rarely matters in most apps. Sure, it&amp;rsquo;s important to think about your algorithmic choices, but there are so many more details to worry about that have a direct impact on app performance and responsiveness. Let&amp;rsquo;s look at a bunch of them!&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-09-08-speed-bumps-limit.jpg" length="372231" type="image/jpeg"/></item><item><title>Costs exposed: Frameworks</title><link>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</link><pubDate>Thu, 31 Aug 2023 07:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-frameworks.html</guid><description>&lt;p>&lt;a href="https://jmmv.dev/2023/06/fast-machines-slow-machines.html">&amp;ldquo;Fast machines, slow machines&amp;rdquo;&lt;/a>&amp;hellip; ah, the post that spawned these series. As I frantically typed that article while replying to angry tweets, the thought came to mind: software engineering as a whole is hyper-focused on lowering the costs to write new code, yet there is a disregard for the costs that these improvements bring to other disciplines in a company on even to end users.&lt;/p>
&lt;p>So, in this series finale, I want to compare how some choices that apparently lower development costs actually increase costs elsewhere. I also want to highlight how, if we made different decisions during development, we could possibly expose those extra costs early on. This is beneficial because exposing costs upfront allows us to make tough choices when there is still a chance of changing course.&lt;/p>
&lt;p>To make things specific, I will look at how the use of modern frameworks that facilitate development can end up hurting performance, reliability, and usability. So let&amp;rsquo;s start with a three-part rant first (sorry) and then let&amp;rsquo;s look at what we might do.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-31-dirt-pile.jpg" length="773447" type="image/jpeg"/></item><item><title>Costs exposed: On-call ticket handling</title><link>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</link><pubDate>Sat, 26 Aug 2023 07:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-on-call-ticket-handling.html</guid><description>&lt;p>In the previous post, I proposed that certain engineering practices expose systemic costs and help with planning while other practices hide those same costs and disturb ongoing plans.&lt;/p>
&lt;p>The idea I&amp;rsquo;m trying to convey is hard to communicate in the abstract so, in that post, I used the differences between a monorepo and a multirepo setup as an example. Today, I&amp;rsquo;ll expore a different scenario to support the same idea. I&amp;rsquo;m going to talk about how certain ticket assignment practices during on-call operations can expose service support costs vs. how other practices hide them.&lt;/p>
&lt;p>Keep in mind that, just like in the previous post, I do not want to compare the general merits of one approach vs. the other. The &lt;em>only&lt;/em> thing I want to compare is whether one approach centralizes toil and allows management to quantify its cost vs. how another approach hides toil by smearing it over the whole team in hard-to-quantify ways. Whether management &lt;em>actually does something&lt;/em> to correct the situation once the costs are exposed is a different story.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-26-tickets-phone.jpg" length="539252" type="image/jpeg"/></item><item><title>Costs exposed: Monorepo vs. multirepo</title><link>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</link><pubDate>Wed, 23 Aug 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html</guid><description>&lt;p>In software engineering organizations, there are certain practices that keep costs under control even if those &lt;em>seem&lt;/em> more expensive at first. Unfortunately, because such practices &lt;em>feel&lt;/em> more expensive, teams choose to keep their status quo even when they know it is suboptimal. This choice ends up hurting productivity and morale because planned work is continuously interrupted, which in turn drags project completion.&lt;/p>
&lt;p>The reason I say &lt;em>seem&lt;/em> and not &lt;em>are&lt;/em> is because the alternatives to these cost-exposing practices also suffer from costs. The difference is that, while the former surface costs, leading to the need to allocate time and people to infrastructure work, the latter keeps the costs smeared over teams and individuals in ways that are difficult to account and plan for.&lt;/p>
&lt;p>To illustrate what I&amp;rsquo;m trying to say, I&amp;rsquo;ll present three different scenarios in which this opinion applies. All of these case studies come from past personal experiences while working in different teams and projects. The first one covered in this post is about the adoption of a monorepo vs. the use of multiple different repositories. The other two will come in follow-up articles.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-23-freebsd-gnome-repos.png" length="162711" type="image/jpeg"/></item><item><title>Raspberry Pi 3, rfkill, and real root causing</title><link>https://jmmv.dev/2023/08/rpi3-rfkill-root-causing.html</link><pubDate>Wed, 16 Aug 2023 06:20:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/rpi3-rfkill-root-causing.html</guid><description>&lt;p>I&amp;rsquo;ve had a Raspberry Pi 3 in the garage running Raspbian so it was attached to Ethernet for a long time. A few weeks ago, however, I wanted to bring the Pi into the house so that my kid, who was showing interest in robotics, and I could play with it. That required having the ability to place the device onto the dining table, next to a laptop, which meant connecting it to WiFi. Easy peasy, right?&lt;/p>
&lt;p>Well&amp;hellip; while that should have been trivial, it did not work right away and the solutions I found online back then were all nonsensical. I gave up in desperation because I did not have enough time to find the root cause, and all interest was lost. Until last weekend when I gave this ordeal another try. At this point, I found once again the same nonsensical solutions online, got equally frustrated about the fact that they even existed, and decided to find the real answer to my problem on my own.&lt;/p>
&lt;p>Yes, this is mostly a rant about the Internet being littered with misleading answers of the kind &amp;ldquo;I reinstalled glibc and my problem is gone!&amp;rdquo;. But this is also the tale of a troubleshooting session&amp;mdash;and you know I like to blog about those.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-08-16-rpi3-go2-gpio.jpg" length="346217" type="image/jpeg"/></item><item><title>A failed experiment with Rust static dispatch</title><link>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</link><pubDate>Sun, 06 Aug 2023 05:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/08/rust-static-dispatch-failed-experiment.html</guid><description>&lt;p>Initial versions of the EndBASIC Service, and therefore initial versions of EndTRACKER, used dynamic dispatch to support abstract definitions of system services such as the database they talk to and the clock they use. This looked like a bunch of &lt;tt>Arc&lt;dyn Foo>&lt;/tt> objects passed around and was done to support extremely fast unit testing.&lt;/p>
&lt;p>When I generalized the core logic of these services into the III-IV framework, I decided to experiment with a switch to static dispatch. The rationale was that using static dispatch better aligns with the design of well-regarded crates in the Rust ecosystem, and also because I wanted to avoid unnecessary runtime costs in the foundational pieces of my web services.&lt;/p>
&lt;p>Let me tell you that this decision was a huge mistake and that the experiment has utterly failed. Using static dispatch has been a constant source of frustration due to the difficulty in passing types around and reasoning about trait bounds. The situation had gotten so bad that I dreaded adding new functionality to my services whenever a change to a statically-typed &lt;tt>struct&lt;/tt> was needed, because that meant adding yet another type parameter and plumbing it through tens of source files.&lt;/p>
&lt;p>In lieu of the difficulties, which eventually turned into blockers to implementing new features, I made the choice of going back to dynamic dispatch. The goal was to gain ergonomics at the expense of a supposedly-negligible runtime cost. Let me tell you about the problems I faced, the refactoring journey, and some measurements I gathered after the rewrite.&lt;/p></description></item><item><title>Unit-testing a web service in Rust</title><link>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</link><pubDate>Fri, 07 Jul 2023 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/unit-testing-a-web-service.html</guid><description>&lt;p>One of the things I'm most proud of the Rust web services I have written is how I can run their tests with zero setup and within milliseconds, all while making me confident that "main" can always be shipped to production. I've previously touched upon how this all works in other articles, but it's time for a deep dive.&lt;/p>
&lt;p>To make things specific, I'll be describing the testing infrastructure of EndTRACKER, the EndBASIC Service, and the sample key/value store app of III-IV. These services are all structured in three separate layers, and I'll be covering the testing strategy for each of them.&lt;/p></description></item><item><title>ldd(1) and untrusted binaries</title><link>https://jmmv.dev/2023/07/ldd-untrusted-binaries.html</link><pubDate>Sat, 01 Jul 2023 16:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/07/ldd-untrusted-binaries.html</guid><description>While diagnosing a non-determinism Bazel issue at work, I had to compare the dynamic libraries used by two builds of the same binary. To do so, I used &lt;code>ldd(1)&lt;/code> and I had to refer to its manual page to understand details of the output I had never paid attention to before. What I saw will surprise you: &lt;code>ldd&lt;/code> can end up &lt;em>running&lt;/em> the binary given to it, thus making it unsafe against untrusted binaries. Read on for the history I could find around this issue and what alternatives you have.</description></item><item><title>Fast machines, slow machines</title><link>https://jmmv.dev/2023/06/fast-machines-slow-machines.html</link><pubDate>Tue, 27 Jun 2023 06:50:00 -0700</pubDate><guid>https://jmmv.dev/2023/06/fast-machines-slow-machines.html</guid><description>&lt;p>Well, &lt;em>that&lt;/em> was unexpected. I recorded a couple of crappy videos in 5 minutes, &lt;a href="https://twitter.com/jmmv/status/1671670996921896960">posted them on a Twitter thread&lt;/a>, and went viral with 8.8K likes at this point. I really could not have predicted that, given that I&amp;rsquo;ve been posting what-I-believe-is interesting content for years and&amp;hellip; nothing, almost-zero interest. Now that things have cooled down, it&amp;rsquo;s time to stir the pot and elaborate on those thoughts a bit more rationally.&lt;/p>
&lt;p>To summarize, the Twitter thread shows two videos: one of an old computer running Windows NT 3.51 and one of a new computer running Windows 11. In each video, I opened and closed a command prompt, File Explorer, Notepad, and Paint. You can clearly see how apps on the old computer open up instantly whereas apps on the new computer show significant lag as they load. I questioned how computers are actually getting better when trivial things like this have regressed. And boom, the likes and reshares started coming in. Obviously some people had issues with my claims, but there seems to be an overwhelming majority of people that agree we have a problem.&lt;/p>
&lt;p>To open up, I&amp;rsquo;ll stand my ground: latency in modern computer interfaces, with modern OSes and modern applications, is terrible and getting worse. This applies to smartphones as well. At the same time, while UIs were much more responsible on computers of the past, those computers were also awful in many ways: new systems have changed our lives substantially. So, what gives?&lt;/p></description></item><item><title>A persistent task queue in Rust</title><link>https://jmmv.dev/2023/06/iii-iv-task-queue.html</link><pubDate>Fri, 23 Jun 2023 06:35:00 -0700</pubDate><guid>https://jmmv.dev/2023/06/iii-iv-task-queue.html</guid><description>A couple of posts ago, I described why I built custom email subscriptions for this blog. I briefly mentioned that there is new automation that scrapes the RSS feed and sends new post notifications to you all. Today, it&amp;rsquo;s time to look into how this all works and how this is based on a new persistent task queuing service in Rust. The queue handles tasks to periodically scrape the RSS feed and schedule emails, all with various quota enforcers and retry policies in place. Read on for the design requirements and constraints of the task queue, how the client and worker Rust APIs look like, and how this all can be made to work inside the Azure Functions serverless runtime for minimal deployment hassle and cost.</description></item><item><title>MVC but for non-UI apps</title><link>https://jmmv.dev/2023/06/mvc-non-ui-apps.html</link><pubDate>Tue, 20 Jun 2023 10:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/06/mvc-non-ui-apps.html</guid><description>In MVC isn&amp;rsquo;t MVC, which hit the Hacker News front page overnight, Collin Donnell describes how the MVC design pattern that we use today isn&amp;rsquo;t really what was originally envisioned in 1979 by Tyrgve Reenskaug. This prompted me to think about how this architecture, if tweaked even further, maps pretty well to today&amp;rsquo;s designs of other kinds of programs, and I want to explore two cases in this post: web services and CLI apps.</description></item><item><title>In-house email subscriptions</title><link>https://jmmv.dev/2023/06/in-house-email-subscriptions.html</link><pubDate>Fri, 16 Jun 2023 06:30:00 -0700</pubDate><guid>https://jmmv.dev/2023/06/in-house-email-subscriptions.html</guid><description>Fellow readers! The radio silence for the last two months has an explanation. I&amp;rsquo;ve been busy creating a custom email subscription service for this blog, all so that you can be notified about new posts without the noise added by intermediaries. This feature is built into a little Rust web service that already offered analytics, page comments and more, and that can be potentially integrated into arbitrary static websites. Read on for what was involved, stay tuned for a deep dive on the internals, and&amp;hellip; upfront apologies if this first email does the wrong thing!</description></item><item><title>Addressing Bazel OOMs</title><link>https://jmmv.dev/2023/03/addressing-bazel-ooms.html</link><pubDate>Thu, 16 Mar 2023 14:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/03/addressing-bazel-ooms.html</guid><description>&lt;p>Here at Snowflake, the Developer Productivity organization (DPE for short) is tackling some important problems we face as a company: namely, lengthening build times and complex development environments. A key strategy we are pursuing to resolve these is the migration of key build processes from CMake and Maven to &lt;a href="https://bazel.build/">Bazel&lt;/a>.&lt;/p>
&lt;p>We are still in the early stages of this migration and cannot yet share many details or a success story, but we can start explaining some of the issues we encounter as we work through this ambitious project.&lt;/p></description><enclosure url="https://jmmv.dev/images/2023-03-16-header.jpg" length="345376" type="image/jpeg"/></item><item><title>Introducing III-IV</title><link>https://jmmv.dev/2023/03/introducing-iii-iv.html</link><pubDate>Mon, 13 Mar 2023 06:45:00 -0700</pubDate><guid>https://jmmv.dev/2023/03/introducing-iii-iv.html</guid><description>&lt;p>Over the last couple of years, I have developed two small web services in Rust: &lt;a href="https://jmmv.dev/2021/07/endbasic-0.7.html">one for EndBASIC&lt;/a> and &lt;a href="https://jmmv.dev/2022/02/diy-web-analytics.html">one for this blog&lt;/a>. Those two web services contained significant copy/pasted helper code, which always bothered me because small bug fixes in one rarely propagated to the other. But because this only impacted two inconsequential side projects, the hinderance wasn&amp;rsquo;t a big deal.&lt;/p>
&lt;p>Until now. I now face the need to write two more web services (details TBA), and duplicating those foundations twice more felt just wrong. So I spent the last couple of weeks pulling the common code out of the existing services into a&amp;hellip; you guessed it&amp;hellip; framework, which I have called III-IV (&amp;quot;&lt;em>three four&lt;/em>&amp;quot; if you read it out loud) and am ready to announce.&lt;/p></description></item><item><title>BASIC parsing difficulties in EndBASIC</title><link>https://jmmv.dev/2023/01/endbasic-parsing-difficulties.html</link><pubDate>Fri, 13 Jan 2023 06:00:00 -0700</pubDate><guid>https://jmmv.dev/2023/01/endbasic-parsing-difficulties.html</guid><description>The original BASIC parser in EndBASIC 0.1 was very rudimentary and it stayed pretty much unmodified until the 0.10 release last month. This release brought major changes to the parser to support new features, but it wasn&amp;rsquo;t easy to implement them. In this post, I want to look into various difficulties that arose implementing certain BASIC constructs in EndBASIC. Overcoming these difficulties was difficult, but it was also fascinating because it gave me a glimpse of the design choices that the original BASIC designers must have faced. Capturing these ah-ha moments in a post is also tricky, but I&amp;rsquo;ll try anyway.</description></item></channel></rss>