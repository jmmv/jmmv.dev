<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Waiting for process groups, macOS edition - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Waiting for process groups, macOS edition - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Waiting for process groups, macOS edition - Julio Merino (jmmv.dev)"><meta name=description content="In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (#10245) is the following: given a process group, wait for all of its processes to fully terminate.
macOS has a bunch of fancy features that other systems do not have, but process control is not among them."><meta property="og:description" content="In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (#10245) is the following: given a process group, wait for all of its processes to fully terminate.
macOS has a bunch of fancy features that other systems do not have, but process control is not among them."><meta property="twitter:description" content="In the previous posts, we saw why waiting for a process group is complicated and we covered a specific, bullet-proof mechanism to accomplish this on Linux. Now is the time to investigate this same …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2019/11/wait-for-process-group-darwin.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2019/11/wait-for-process-group-darwin.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.52b548e9c069c09e7522318b2cf209296e28a38aa2739ce528e6f9a488ce0797.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/favicons/favicon-1200x1200.png"><meta property="twitter:image" content="https://jmmv.dev/images/favicons/favicon-1200x1200.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><header class=site-header><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;Julio Merino</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/essays.html>Essays</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Waiting for process groups, macOS edition</h1><p>November 15, 2019 &#183;
About 8 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/darwin>darwin</a>, <a href=/tags/macos>macos</a>, <a href=/tags/unix>unix</a></p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>In the previous posts, we saw why <a href=/2019/11/wait-for-process-group.html>waiting for a process group is complicated</a> and we covered a specific, bullet-proof mechanism to <a href=/2019/11/wait-for-process-group-linux.html>accomplish this on Linux</a>. Now is the time to investigate this same topic on macOS. Remember that the problem we are trying to solve (<a href=https://github.com/bazelbuild/bazel/issues/10245>#10245</a>) is the following: given a process group, wait for all of its processes to fully terminate.</p><p>macOS has a bunch of fancy features that <a href=/2019/03/macos-threads-qos-and-bazel.html>other systems do not have</a>, but process control is not among them. We do not have features like Linux&rsquo;s child subreaper or PID namespaces to keep track of process groups. Therefore, we&rsquo;ll have to roll our own. And the only way to do this is to scan the process table looking for processes with the desired process group identifier (PGID) and waiting until they are gone.</p><p>Unfortunately, there is no portable API to programmatically access the process table. Sure, you can imagine shelling out to <code>ps(1)</code> and parsing its output, but this would be very inefficient and error-prone. So we have no choice but to rely on Darwin-specific primitives for efficiency and reliability.</p><p>We can query the process table in Darwin by using <code>sysctl(3)</code> and looking under the <code>kern.proc.pgrp.&lt;PGID></code> name (MIB). (It&rsquo;s interesting to see that this is modeled after the BSD&rsquo;s <code>kvm_getprocs(2)</code> interface and I&rsquo;m not sure why Darwin had to merge it with <code>sysctl(3)</code>.) However: this MIB doesn&rsquo;t appear to be documented so things might break in the future. The way I found this is by looking at <a href=https://opensource.apple.com/source/adv_cmds/adv_cmds-172/ps/ps.c.auto.html>Apple&rsquo;s own <code>ps.c</code> source code</a>.</p><p>Let&rsquo;s coerce the <code>sysctl(3)</code> interface to give us what we want. The interface is not the easiest to use, but it&rsquo;s not that difficult either; we just have to account for the fact that its return value is of variable size:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/sysctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Waits for a process group to terminate.  Assumes that the process leader
</span></span></span><span class=line><span class=cl><span class=c1>// still exists in the process table (though it may be a zombie), and allows
</span></span></span><span class=line><span class=cl><span class=c1>// it to remain.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// May never converge if the processes in the group are still spawning their
</span></span></span><span class=line><span class=cl><span class=c1>// own subprocesses.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>wait_for_process_group</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pgid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>name</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=n>CTL_KERN</span><span class=p>,</span> <span class=n>KERN_PROC</span><span class=p>,</span> <span class=n>KERN_PROC_PGRP</span><span class=p>,</span> <span class=n>pgid</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Query the list of processes in the group by using sysctl(3).
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// This is &#34;hard&#34; because we don&#39;t know how big that list is, so we
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// have to first query the size of the output data and then account for
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// the fact that the size might change by the time we actually issue
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// the query.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=n>kinfo_proc</span> <span class=o>*</span><span class=n>procs</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>size_t</span> <span class=n>nprocs</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>size_t</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>sysctl</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>procs</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>kinfo_proc</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>sysctl</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=n>procs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>assert</span><span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>ENOMEM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>free</span><span class=p>(</span><span class=n>procs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>procs</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>nprocs</span> <span class=o>=</span> <span class=n>len</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>kinfo_proc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>procs</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span><span class=p>(</span><span class=n>nprocs</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>);</span>  <span class=c1>// Must have found the group leader at least.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nprocs</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Found only one process, which must be the leader because we have
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// purposely expect it as a zombie.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>assert</span><span class=p>(</span><span class=n>procs</span><span class=o>-&gt;</span><span class=n>kp_proc</span><span class=p>.</span><span class=n>p_pid</span> <span class=o>==</span> <span class=n>pgid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>free</span><span class=p>(</span><span class=n>procs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// More than one process left in the process group.  Pause a little bit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// before retrying to avoid burning CPU.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ts</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ts</span><span class=p>.</span><span class=n>tv_nsec</span> <span class=o>=</span> <span class=mi>1000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>nanosleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ts</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/wait-for-process-group/wait-pgid-darwin.c type=text/plain>wait-pgid-darwin.c</a></div></div></div><p>The above code snippet gives us a <code>wait_for_process_group</code> function that ensures all processes in a process group are gone, except for the leader. With this, we could implement the following algorithm:</p><ol><li>Start process group.</li><li>Wait for the process group leader to terminate using <code>waitpid(2)</code>. Remember that we want to report the exit status of the leader, so we must do this.</li><li>Wait for all other processes in the group to exit by calling <code>wait_for_process_group</code>.</li></ol><p>This works&mldr; but there is a little problem. Once <code>waitpid(2)</code> returns, the kernel has cleared all knowledge of our process leader, which means all of its children became orphan and were reparented to <code>init(8)</code>. The PGID was thus reclaimed and could now be used by a racing process. (This is very unlikely because the kernel will try hard to not reallocate PIDs too quickly, but it&rsquo;s still a possibility and experience has shown me that, with scale, the unlikely is actually common.)</p><p>So how do we fix this? We need to introduce an extra step. We have to detect when the process group leader becomes a zombie <em>without actually reaping its status</em> so that the PGID remains assigned while we do our <code>wait_for_process_group</code> dance.</p><p>And to do this, we use another Darwin-specific primitive: <code>kqueue(2)</code>. With this functionality, we can wait for the child process to change its status. (We could possibly do this by monitoring <code>SIGCHLD</code> but I haven&rsquo;t found a way to make this not racy, and anything dealing with signals always makes me cringe.) The code looks like follows:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/event.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stddef.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Waits for a process to terminate but does *not* collect its exit status,
</span></span></span><span class=line><span class=cl><span class=c1>// thus leaving the process as a zombie.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// According to the kqueue(2) documentation (and I confirmed it experimentally),
</span></span></span><span class=line><span class=cl><span class=c1>// registering for an event reports any pending such events, so this is not racy
</span></span></span><span class=line><span class=cl><span class=c1>// if the process happened to exit before we got to installing the kevent.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>wait_for_process</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>kq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>kq</span> <span class=o>=</span> <span class=nf>kqueue</span><span class=p>())</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>kevent</span> <span class=n>kc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>EV_SET</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kc</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=n>EVFILT_PROC</span><span class=p>,</span> <span class=n>EV_ADD</span> <span class=o>|</span> <span class=n>EV_ENABLE</span><span class=p>,</span> <span class=n>NOTE_EXIT</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>kevent</span> <span class=n>ke</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>nev</span> <span class=o>=</span> <span class=nf>kevent</span><span class=p>(</span><span class=n>kq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>kc</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ke</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>nev</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>ke</span><span class=p>.</span><span class=n>ident</span> <span class=o>==</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>ke</span><span class=p>.</span><span class=n>fflags</span> <span class=o>&amp;</span> <span class=n>NOTE_EXIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>close</span><span class=p>(</span><span class=n>kq</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/wait-for-process-group/wait-pid-darwin.c type=text/plain>wait-pid-darwin.c</a></div></div></div><p>Alright. So now we have another function, called <code>wait_for_process</code>, that will wait until the given PID becomes a zombie. With this, our algorithm looks like:</p><ol><li>Start process group.</li><li>Wait for the process group leader to become a zombie with <code>wait_for_process</code>. At this point, the PGID is still assigned to us.</li><li>Wait for all other processes in the group to exit by calling <code>wait_for_process_group</code>.</li><li>Collect the leader&rsquo;s status by using <code>waitpid(2)</code>.</li></ol><p>Simple, right? It was all in the details&mdash;which is why I had to come up with the sample code in these posts.</p><p>Let&rsquo;s put it all into practice by updating our original test tool:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;err.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>wait_for_process</span><span class=p>(</span><span class=kt>pid_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>wait_for_process_group</span><span class=p>(</span><span class=kt>pid_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Convenience macro to abort quickly if a syscall fails with -1.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Not great error handling, but better have some than none given that you, the
</span></span></span><span class=line><span class=cl><span class=c1>// reader, might be copy/pasting this into real production code.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define CHECK_OK(call) if (call == -1) err(EXIT_FAILURE, #call);
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>errx</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>,</span> <span class=s>&#34;Must provide a program name and arguments&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fds</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>pipe</span><span class=p>(</span><span class=n>fds</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK_OK</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Enter a new process group for all of our descendents.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>setpgid</span><span class=p>(</span><span class=nf>getpid</span><span class=p>(),</span> <span class=nf>getpid</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Tell the parent that we have successfully created the group.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>close</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>        <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>write</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;</span><span class=se>\0</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>        <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>close</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>1</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Execute the given program now that the environment is ready.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>execv</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>argv</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>err</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>,</span> <span class=s>&#34;execv&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Wait until the child has created its own process group.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This is a must to prevent a race between the parent waiting for the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// group and the group not existing yet, and is the only safe way to do so.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>close</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>1</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>dummy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>dummy</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>close</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Now wait for the direct child to terminate and keep it around as a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// zombie.  This ensures that the process group is not reparented to init,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which allows us to query it without racing other processes getting the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// same group identifier.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait_for_process</span><span class=p>(</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The direct child is dead and the kernel would reparent all processes of
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// our group to init if we hadn&#39;t kept the child around as a zombie.  Wait
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// for all of them to vanish.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait_for_process_group</span><span class=p>(</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// And now reap the exit status of the direct child.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>CHECK_OK</span><span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>?</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=o>:</span> <span class=n>EXIT_FAILURE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/wait-for-process-group/wait-all-darwin.c type=text/plain>wait-all-darwin.c</a></div></div></div><p>And if we build and run it with the same same sample command as before:</p><pre tabindex=0><code>$ ./wait-all-darwin /bin/sh -c &#39;/bin/sh -c &#34;sleep 5; echo 2&#34; &amp; echo 1&#39;
1
2
$
</code></pre><p>you&rsquo;ll see that <code>wait-all-darwin</code> did not terminate until the nested subshell did, even though the outer shell exited quickly.</p><p>Great. <em>However</em>, be aware that this solution is <em>not</em> bullet-proof: if a subprocess creates a new process group, it will escape our algorithm and there is nothing we can do about it. (It looks like FreeBSD has a <code>NOTE_TRACK</code> event that could let us track those processes&mldr; but of course this doesn&rsquo;t exist on Darwin.) Anyway, in the context of <a href=/2019/11/bazel-process-wrapper.html>Bazel&rsquo;s process wrapper</a>, we are willing to live with this limitation.</p><p>Lastly note that this solution should be generalizable to other systems. In the worst case, you&rsquo;d need to use <code>ps(1)</code> to walk the process table, but you could still do it. The only issue is that you might race against other processes grabbing the PGID as described above, but it&rsquo;s a pretty unlikely scenario and maybe it can be fixed with some <code>SIGCHLD</code> magic.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2019/11/wait-for-process-group-linux.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2019/11/macos-bash-baggage.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Waiting+for+process+groups%2C+macOS+edition&amp;url=https%3A%2F%2Fjmmv.dev%2F2019%2F11%2Fwait-for-process-group-darwin.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Waiting+for+process+groups%2C+macOS+edition&amp;u=https%3A%2F%2Fjmmv.dev%2F2019%2F11%2Fwait-for-process-group-darwin.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Waiting+for+process+groups%2C+macOS+edition+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2019%2F11%2Fwait-for-process-group-darwin.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div><div class="container post-subscribe d-block d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class="col-sm-3 py-2"><div class=row><div class="col px-2 text-center"><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a></div><div class="col px-2 text-center"><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a></div><div class="col px-2 text-center"><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></div></div></div><div class="col-sm-9 py-2 text-center"><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><div class=form-group><div class=row><input type=text name=email placeholder="Enter your email" class="form-control input-sm col-8 text-center">
<button type=submit class="btn btn-primary col-4">Subscribe</button></div></div><small><span class=subscriber-count>0</span> subscribers</small></form></div></div></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class="col-sm-4 text-center"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a></p></div><div class="col-sm-4 text-center"><p><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a></p></div><div class="col-sm-4 text-center"><p><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><div class=form-group><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center">
<button type=submit class="btn btn-primary btn-block">Subscribe</button></div><small><span class=subscriber-count>0</span> subscribers</small></form></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container><div class=row><div class="col-4 order-2 texr-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script><noscript><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDE5LzExL3dhaXQtZm9yLXByb2Nlc3MtZ3JvdXAtZGFyd2luLmh0bWw=/stamp.gif" style=display:none></noscript></body></html>