<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust Review on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/series/rust-review/index.html</link><description>Recent content in Rust Review on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Jul 2018 09:00:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/series/rust-review/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Rust review: Closing thoughts</title><link>https://jmmv.dev/2018/07/rust-review-closing-thoughts.html</link><pubDate>Tue, 10 Jul 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/07/rust-review-closing-thoughts.html</guid><description>&lt;p>Thought that the Rust review was over? Think again; I was just on vacation! I&amp;rsquo;m back now to conclude the series with a bunch of random thoughts and a surprise follow-up post.&lt;/p>
&lt;hr>
&lt;p>The series is coming to an end. It&amp;rsquo;s time to summarize everything we have discussed so far and to cover a few more items that didn&amp;rsquo;t really deserve full posts of their own. Most of these miscellaneous items were thoughts that I jotted down &lt;a href="https://jmmv.dev/2018/06/rust-review-book.html">while reading TRPL book&lt;/a>. I will follow the same good/bad/ugly structure I used for &lt;a href="https://jmmv.dev/2016/03/golang-review.html">the Go review&lt;/a> a couple of years ago.&lt;/p></description></item><item><title>Rust review: The ecosystem</title><link>https://jmmv.dev/2018/06/rust-review-ecosystem.html</link><pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-ecosystem.html</guid><description>&lt;p>In this part of the review, I would like to focus on Rust&amp;rsquo;s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust&amp;rsquo;s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let&amp;rsquo;s look at some.&lt;/p>
&lt;h1 id="the-standard-library">The standard library&lt;/h1>
&lt;p>The &lt;a href="https://doc.rust-lang.org/std/">&lt;code>std&lt;/code>&lt;/a> library feels generally well-thought out and full of features.&lt;/p></description></item><item><title>Rust review: The book</title><link>https://jmmv.dev/2018/06/rust-review-book.html</link><pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-book.html</guid><description>&lt;p>&amp;ldquo;&lt;a href="https://doc.rust-lang.org/book/second-edition/">The Rust Programming Language&lt;/a>&amp;rdquo; is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let&amp;rsquo;s cover these, but first, some background.&lt;/p>
&lt;p>A couple of years ago, right after getting started with Rust, I tried to go through the book&amp;rsquo;s first few chapters. It all sounded cool&amp;hellip; but &lt;a href="https://doc.rust-lang.org/beta/book/first-edition/README.html">&lt;em>the first edition&lt;/em>&lt;/a> of the book moved at a glacially slow pace because it covered things in excruciating detail. E.g. the first chapter I remember was about string formatting, which detailed pretty much all there is on this topic. &amp;ldquo;&lt;em>Who cares? You don&amp;rsquo;t need to know all these details upfront to get started.&lt;/em>&amp;rdquo; I thought. So I gave up.&lt;/p></description></item><item><title>Rust review: The match keyword</title><link>https://jmmv.dev/2018/06/rust-review-match-keyword.html</link><pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-match-keyword.html</guid><description>&lt;p>A commonly-acclaimed feature of Rust is its &lt;strong>&lt;code>match&lt;/code> keyword: a &amp;ldquo;conditional on steroids&amp;rdquo;&lt;/strong>. &lt;code>match&lt;/code> lets you take the value of an expression and compare it against a bunch of values—or, more generally, &lt;em>patterns&lt;/em>.&lt;/p>
&lt;p>As you write and read Rust, you will notice that this keyword is used everywhere because it&amp;rsquo;s &lt;em>the&lt;/em> way to access certain types, like &lt;code>Option&lt;/code> values or error codes.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">match&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_parent&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// node is an Option&amp;lt;Something&amp;gt;.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// Do something with &amp;#34;parent&amp;#34;, which we know points to a node.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// There is no parent so do something else.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the snippet above, we have a &lt;code>match&lt;/code> statement with two &lt;em>arms&lt;/em>. One key detail to observe is how the &lt;code>parent&lt;/code> variable, which was used as a pattern to peek inside the &lt;code>Some&lt;/code> value, is only available in the first arm. The &lt;code>None&lt;/code> arm has no access to the &lt;code>parent&lt;/code> variable, which is obvious because there is no parent in this case.&lt;/p></description></item><item><title>Rust review: Expressions, expressions, expressions</title><link>https://jmmv.dev/2018/06/rust-review-expressions.html</link><pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-expressions.html</guid><description>&lt;p>Rust resembles a functional language in many ways although it &lt;a href="http://rust-lang.org/">does not claim&lt;/a> to be one. In fact, &lt;strong>I have been thinking of Rust as a &amp;ldquo;&lt;em>pragmatic Haskell&lt;/em>&amp;rdquo; or as a &amp;ldquo;&lt;em>well-balanced mixture between C++ and Haskell&lt;/em>&amp;rdquo;&lt;/strong>.&lt;/p>
&lt;p>One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.&lt;/p></description></item><item><title>Rust review: Learning curve</title><link>https://jmmv.dev/2018/06/rust-review-learning-curve.html</link><pubDate>Fri, 08 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-learning-curve.html</guid><description>&lt;p>Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I&amp;rsquo;ll try to convince you that the curve does &lt;em>feel&lt;/em> steep, but it isn&amp;rsquo;t when taken into perspective.&lt;/p>
&lt;p>Let&amp;rsquo;s first start by stating that &lt;strong>learning a &lt;em>language&lt;/em> is &lt;em>not&lt;/em> the same as learning &lt;em>its syntax&lt;/em>&lt;/strong>. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide. Picking up the syntax can be easy as is the case for Go and Python—both of which can be learned in a single day—but the idioms and libraries require weeks, if not months, of frequent practice.&lt;/p></description></item><item><title>Rust review: Protect the data</title><link>https://jmmv.dev/2018/06/rust-review-protect-the-data.html</link><pubDate>Tue, 05 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-protect-the-data.html</guid><description>&lt;p>&lt;em>The one thing&lt;/em> that blew my mind about Rust is its approach to data sharing in concurrent situations.&lt;/p>
&lt;p>I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with &lt;a href="https://github.com/abseil/abseil-cpp/blob/59ae4d5a0e833bedd9d7cc059ac15a9dc130e3f7/absl/synchronization/mutex.h#L499">Abseil&amp;rsquo;s &lt;code>MutexLock&lt;/code>&lt;/a>) was the panacea. (I&amp;rsquo;m a fan of RAII in C++ by the way, in case you haven&amp;rsquo;t noticed.)&lt;/p>
&lt;p>As Rust has taught me, that&amp;rsquo;s far from the truth: &lt;strong>in Rust, you protect the &lt;em>data&lt;/em>, not the &lt;em>code&lt;/em>.&lt;/strong> What this means is that, e.g. a mutex is not an object to control access to a piece of data: &lt;strong>a mutex is a &lt;em>container&lt;/em> for a piece of data&lt;/strong>. It is impossible to access the data without going through the mutex.&lt;/p></description></item><item><title>Rust review: The borrow checker</title><link>https://jmmv.dev/2018/06/rust-review-borrow-checker.html</link><pubDate>Fri, 01 Jun 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/06/rust-review-borrow-checker.html</guid><description>&lt;p>Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that&amp;rsquo;s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality&amp;hellip; the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.&lt;/p></description></item><item><title>Rust review: Immutable by default</title><link>https://jmmv.dev/2018/05/rust-review-immutable-by-default.html</link><pubDate>Tue, 29 May 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/05/rust-review-immutable-by-default.html</guid><description>&lt;p>Let&amp;rsquo;s start the deep dive by looking into a powerful feature of Rust: &lt;strong>all variables and references are immutable by default unless qualified with &lt;code>mut&lt;/code>&lt;/strong>.&lt;/p>
&lt;p>To understand why this is important, let&amp;rsquo;s cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the &lt;code>const&lt;/code> qualifier &lt;em>everywhere&lt;/em>: if something ain&amp;rsquo;t mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc. Unfortunately, there are plenty of people that argue that doing so is stupid: &lt;a href="http://www.gotw.ca/gotw/081.htm">&lt;code>const&lt;/code> doesn&amp;rsquo;t help the compiler apply optimizations&lt;/a> and it makes the code harder to &lt;em>write&lt;/em>. So why should everything be marked immutable?&lt;/p></description></item><item><title>Rust review: Introduction</title><link>https://jmmv.dev/2018/05/rust-review-introduction.html</link><pubDate>Fri, 25 May 2018 09:00:00 -0400</pubDate><guid>https://jmmv.dev/2018/05/rust-review-introduction.html</guid><description>&lt;p>I had been meaning to learn &lt;a href="https://www.rust-lang.org/en-US/">Rust&lt;/a> since &lt;a href="https://jmmv.dev/2016/03/golang-review.html">I first toyed with Go&lt;/a> a couple of years ago. During this period, I&amp;rsquo;ve written a non-trivial amount of Go code both inside and &lt;a href="https://jmmv.dev/2017/08/introducing-sandboxfs.html">outside Google&lt;/a>, but never found the chance to sit back and learn Rust.&lt;/p>
&lt;p>This changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would &lt;em>not&lt;/em> work on any personal or work projects for the 2-week long vacation. Instead, I would focus all spare time in reading. And I would read &lt;a href="https://doc.rust-lang.org/book/second-edition/">&amp;ldquo;The Rust Programming Language&amp;rdquo;, second edition&lt;/a>. The plan worked: getting through the book took the two weeks and I barely wrote any code.&lt;/p></description></item></channel></rss>