<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Readability on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/series/readability/index.html</link><description>Recent content in Readability on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2024 Julio Merino</copyright><lastBuildDate>Thu, 01 Aug 2013 12:00:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/series/readability/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>Readability: Series wrap-up</title><link>https://jmmv.dev/2013/08/readability-series-wrap-up.html</link><pubDate>Thu, 01 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/readability-series-wrap-up.html</guid><description>&lt;p>That&amp;rsquo;s it! After two months worth of posts, it is time to part with the the readability series. We have covered a lot of ground with these 14 posts: from mundane things such as blank lines and spelling to deeper topics involving dictionaries and global state.&lt;/p>
&lt;p>Before some parting words, here comes the full list of posts on this series. This is your time to catch up with any posts you have not yet read!&lt;/p></description></item><item><title>Readability: Narrow try/catch blocks</title><link>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</link><pubDate>Mon, 29 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-narrow-trycatch-blocks.html</guid><description>&lt;p>&lt;code>Try&lt;/code>/&lt;code>catch&lt;/code> blocks (or &lt;code>try&lt;/code>/&lt;code>except&lt;/code>, or whatever they happen to be named in your favorite language) are the mechanism by which you capture exceptions raised by a chunk of code in a controlled manner. Within that chunk of code, it does not matter which line throws the exception: any exception specified in the &lt;code>catch&lt;/code> statement will be captured, and it is &amp;ldquo;impossible&amp;rdquo; to know at that point where it originated.&lt;/p>
&lt;p>Consider this piece of code:&lt;/p></description></item><item><title>Readability: Don't modify variables</title><link>https://jmmv.dev/2013/07/readability-don-modify-variables.html</link><pubDate>Thu, 25 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-don-modify-variables.html</guid><description>&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment">Single assignment&lt;/a> says that a variable should only be assigned a value once; i.e. a variable should only be &lt;em>initialized&lt;/em> and never modified later. This could be said to be a property of functional programming—never mind that it&amp;rsquo;s used in compiler optimization a damn lot—so it may sound a bit out of scope in a readability post. Not really.&lt;/p>
&lt;p>When you &lt;em>force yourself to avoid modifying already-defined variables&lt;/em>, you will need to find other ways to express your intent. To do so, in general: you will use a high-order construction instead of a loop; you will end up having to define intermediate variables, each with its own descriptive name; or you will move pieces of the code to an auxiliary function, also with a descriptive name.&lt;/p></description></item><item><title>Readability: Conditionals as functions</title><link>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</link><pubDate>Mon, 22 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-conditionals-as-functions.html</guid><description>&lt;p>Conceptually, there are two kinds of conditional statements: ones that compute—or affect the computation of—a value and others that guard the execution of optional code (e.g. functionality enabled by a command-line flag). In this article we will focus on the former kind.&lt;/p>
&lt;p>One way to think of those conditionals is as if they were to represent functions, just written inline. In other words: while it should be possible to move the conditional statement to a separate function, it has not been done because the algorithm is simple enough to not warrant it.&lt;/p></description></item><item><title>Readability: Explicitly state complementary conditions</title><link>https://jmmv.dev/2013/07/readability-explicitly-state.html</link><pubDate>Thu, 18 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-explicitly-state.html</guid><description>&lt;p>In the most basic form, a conditional has two branches and the conditional expression inspects a single variable on entry. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">balance&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BLACK&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">RED&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this little code snippet, the condition &lt;code>balance &amp;gt;= 0&lt;/code> only depends on one variable, and the two branches of the conditional cover all possible values of the input variable. I.e. the first branch covers all cases where the balance is positive or zero, and the second branch covers all cases where the balance is negative. The balance variable cannot have a value not covered by these cases. Easy.&lt;/p></description></item><item><title>Readability: Do not abuse classes as global state</title><link>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</link><pubDate>Mon, 08 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-do-not-abuse-classes-as.html</guid><description>&lt;p>You know that passing state around different functions by using global variables is bad: it results in spaghetti code, it introduces side-effects to your functions and, well, is just bad practice. Then: don&amp;rsquo;t make the same mistake when using classes.&lt;/p>
&lt;p>The form this manifests in code is by having a particular class method (not necessarily the constructor!) initializing a member field and later having other unrelated methods querying the attribute &amp;ldquo;out of the blue&amp;rdquo;.&lt;/p></description></item><item><title>Readability: Dictionaries are not data types</title><link>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</link><pubDate>Thu, 04 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-dictionaries-are-not-data.html</guid><description>&lt;p>Yes: a dictionary is a data type. No: a dictionary is not a way to implement abstract data types; doing so is lazy programming and is asking for trouble later on.&lt;/p>
&lt;p>What do I mean by this? In Python and other similar dynamic languages, dictionaries are a mapping of keys to values that have no typing restrictions: the dictionary is heterogeneous, and a single dictionary can contain elements of different types both as its keys and its values. To make things worse, the syntax of the language makes it incredibly easy to create and populate dictionaries (unlike, say, in C++). Combine these two facts together and the temptation to abuse a dictionary to implement a structured data type is high.&lt;/p></description></item><item><title>Readability: Abuse assertions</title><link>https://jmmv.dev/2013/07/readability-abuse-assertions.html</link><pubDate>Mon, 01 Jul 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/07/readability-abuse-assertions.html</guid><description>&lt;p>Assertions are statements to ensure that a particular condition or state holds true at a certain point in the execution of a program. These checks are usually only performed in debug builds, which means that you must ensure that the expressions in the assertions are side-effect free.&lt;/p>
&lt;p>Because assertions are only validated in debug builds, you can abuse them to make your code more readable without impacting performance and &lt;a href="https://jmmv.dev/2013/06/readability-avoid-comments.html">without having to write a comment&lt;/a>. Every time you write a line in which you assume a particular machine state that is not clearly implied by the code immediately preceding the new line, write an assertion.&lt;/p></description></item><item><title>Readability: Avoid comments</title><link>https://jmmv.dev/2013/06/readability-avoid-comments.html</link><pubDate>Thu, 27 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-avoid-comments.html</guid><description>&lt;p>One of the best things you can do to improve the readability of your code is to &lt;em>avoid&lt;/em> comments. &amp;ldquo;Uh, &lt;em>what&lt;/em>?&amp;quot;—I hear you say—&amp;ldquo;That goes against all good coding guidelines, which state to heavily comment your code!&amp;rdquo;&lt;/p>
&lt;p>Right. Except that the real goal is to have &lt;em>valuable&lt;/em> comments &lt;em>only&lt;/em>, and doing so is a (very) complex matter. The code should document itself at all times, and be crystal-clear at doing so. Redundant or useless comments hinder readability, if only because their presence denotes that the code is not clear enough to be self-descriptive, because they are obsolete, because they are confusing, or because they very frequently include typos or grammar mistakes.&lt;/p></description></item><item><title>Readability: Document your types</title><link>https://jmmv.dev/2013/06/readability-document-your-types.html</link><pubDate>Mon, 24 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-document-your-types.html</guid><description>&lt;p>Wow. The previous post titled &lt;a href="https://jmmv.dev/2013/06/self-interview-after-leaving-netbsd.html">Self-interview after leaving the NetBSD board&lt;/a> has turned out to be, by far, the most popular article in this blog. The feedback so far has been positive and I owe all of you a follow-up post. However, writing such post will take a while and content must keep flowing. So let&amp;rsquo;s get back to the &lt;a href="http://julipedia.meroh.net/search/label/readability">readability series&lt;/a> for now.&lt;/p>
&lt;hr>
&lt;p>In dynamically-typed languages&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, variable and function definitions do not state the type of their arguments. This is quite convenient when writing code, but results in very hard to read &amp;ldquo;stuff&amp;rdquo; later on. Consider this snippet:&lt;/p></description></item><item><title>Readability: Mind your typos and grammar</title><link>https://jmmv.dev/2013/06/readability-mind-your-typos-and-grammar.html</link><pubDate>Mon, 17 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-mind-your-typos-and-grammar.html</guid><description>&lt;p>I can&amp;rsquo;t claim to be an expert writer—not in English, and not even in my native languages—but I do put a lot of attention to whatever I write: emails, presentations, letters and, of course, code. As it turns out, code has prose in it most of the time in the form of comments and documentation.&lt;/p>
&lt;p>So, when you write any text in your code, engrave this in mind: any obvious typos and/or any grammar mistake very quickly denote sloppiness in what you wrote. If that is the impression the reader gets from your comments&amp;hellip; why would he trust that you have been less sloppy when writing the code itself? Let me tell you that they won&amp;rsquo;t, with good reason.&lt;/p></description></item><item><title>Readability: No abbreviations</title><link>https://jmmv.dev/2013/06/readability-no-abbreviations.html</link><pubDate>Thu, 13 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-no-abbreviations.html</guid><description>&lt;p>When you are writing code, it is very tempting to shorten the names of functions and variables when the shortening seems blatantly obvious. All of us have, at some point, written &lt;code>calc_usage&lt;/code> instead of &lt;code>calculate_usage&lt;/code>; &lt;code>res&lt;/code> instead of &lt;code>result&lt;/code>; &lt;code>stmt&lt;/code> instead of &lt;code>statement&lt;/code>; &lt;code>ctx&lt;/code> instead of &lt;code>context&lt;/code>; etc. The thought goes &amp;ldquo;&lt;em>well, these abbreviations are obvious, and I&amp;rsquo;ll be a much faster developer!&lt;/em>&amp;rdquo;&lt;/p>
&lt;p>Wrong. You might think you are faster at typing, but you don&amp;rsquo;t write code in one go and never ever get back to it again. As we have already mentioned, code is usually only written once and is later read many times, possibly by people other than the original developer. At the very least, I&amp;rsquo;d expect you going over your code &lt;em>once&lt;/em> before checking it into your repository. Spending the extra minute it takes to write words in full will benefit you and your readers.&lt;/p></description></item><item><title>Readability: Blank lines matter</title><link>https://jmmv.dev/2013/06/readability-blank-lines-matter.html</link><pubDate>Mon, 10 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-blank-lines-matter.html</guid><description>&lt;p>Vertical spacing is important for readability reasons: group together pieces of code that should not be split apart, and otherwise add blank lines among chunks of code that could be easily reordered and/or repurposed. That&amp;rsquo;s a pretty loose suggestion though, so let&amp;rsquo;s look at some specific situations in which you want to consider your vertical spacing practices (both adding and removing).&lt;/p>
&lt;h1 id="give-some-air-to-long-functions">Give some air to long functions&lt;/h1>
&lt;p>Functions longer than a handful lines generally deserve some vertical spacing. A first guideline is to separate the return of the result value (along all of its boilerplate) from everything else that the function may be doing.&lt;/p></description></item><item><title>Readability: Blocks and variable scoping</title><link>https://jmmv.dev/2013/06/readability-blocks-and-variable-scoping.html</link><pubDate>Thu, 06 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-blocks-and-variable-scoping.html</guid><description>&lt;p>In a dynamically-typed language, it is common for the scoping semantics of a variable to be wider than a single code block. For example: in at least Python and the shell, it is the case that a variable defined &lt;em>anywhere&lt;/em> within a function —even inside conditionals or loops— is reachable anywhere in the function from there on.&lt;/p>
&lt;p>To illustrate what this means, consider this snippet in which we define a function to compute the CPU requirements needed in a database system to support a set of tables:&lt;/p></description></item><item><title>Readability: Series introduction</title><link>https://jmmv.dev/2013/06/readability-series-introduction.html</link><pubDate>Mon, 03 Jun 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/06/readability-series-introduction.html</guid><description>&lt;p>Dear readers,&lt;/p>
&lt;p>This post is the beginning of a new series on the idioms and style that I use to keep code readable and &lt;em>obvious&lt;/em>. I often get positive comments when undergoing peer reviews at Google and externally, so I am going to share such personal style in the hope that it might be useful to some of you. Explaining these ideas to coworkers when I review their code has proven to be useful in the long term.&lt;/p></description></item></channel></rss>