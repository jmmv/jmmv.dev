<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CLI Design on Julio Merino (jmmv.dev)</title><link>https://jmmv.dev/series/cli-design/index.html</link><description>Recent content in CLI Design on Julio Merino (jmmv.dev)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>julio@meroh.net (Julio Merino)</managingEditor><webMaster>julio@meroh.net (Julio Merino)</webMaster><copyright>Copyright 2004&ndash;2024 Julio Merino</copyright><lastBuildDate>Thu, 19 Sep 2013 12:00:00 -0400</lastBuildDate><atom:link href="https://jmmv.dev/series/cli-design/index/feed.xml" rel="self" type="application/rss+xml"/><item><title>CLI design: Series wrap-up</title><link>https://jmmv.dev/2013/09/cli-design-series-wrap-up.html</link><pubDate>Thu, 19 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-series-wrap-up.html</guid><description>&lt;p>The time to conclude the CLI design series has come. I hope you have enjoyed the topic and that got some useful tips and tricks for your future developments!&lt;/p>
&lt;p>Here is the summary of all the topics that were covered:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-series-introduction.html">Series introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-cli-is-presentation-layer.html">The CLI is the presentation layer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-error-reporting.html">Error reporting&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-requesting-and-offering-help.html">Requesting and offering help&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-putting-flags-to-good-use.html">Putting flags to good use&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/08/cli-design-do-not-reinvent-option.html">Do not reinvent option parsing&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/09/cli-design-subcommand-based-interfaces.html">Subcommand-based interfaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/09/cli-design-single-command-interfaces.html">Single-command interfaces&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/09/cli-design-handling-output-messages.html">Handling output messages&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/09/cli-design-screen-wrapping.html">Screen wrapping&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmmv.dev/2013/09/cli-design-consider-interactive-prompts.html">Consider interactive prompts twice&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Stay tuned for the next series!&lt;/p></description></item><item><title>CLI design: Consider interactive prompts twice</title><link>https://jmmv.dev/2013/09/cli-design-consider-interactive-prompts.html</link><pubDate>Mon, 16 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-consider-interactive-prompts.html</guid><description>&lt;p>While it is a rare thing to find, CLI-based applications can be interactive just like any other kind of application can. If you choose to interactively query the user for details in your program or script, you should be aware of the two scenarios that can result from this choice (which, interestingly, are &lt;a href="https://jmmv.dev/2013/09/cli-design-handling-output-messages.html">the same scenarios that we already saw regarding output verbosity&lt;/a>).&lt;/p>
&lt;p>The first scenario is about &amp;ldquo;fast&amp;rdquo; applications: if the program is expected to complete in a short amount of time—where short is defined as an amount of time in which the user will not context-switch—it is alright to pop up interactive prompts at any point during the execution of the application. The user will be there watching the command prompt, and he will be ready to answer such questions. Nothing wrong here.&lt;/p></description></item><item><title>CLI design: Screen wrapping</title><link>https://jmmv.dev/2013/09/cli-design-screen-wrapping.html</link><pubDate>Thu, 12 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-screen-wrapping.html</guid><description>&lt;p>In a world of terminal emulators within graphical environments, there is no longer a &amp;ldquo;standard&amp;rdquo; window size. 80x24 is still the default, sure, but it&amp;rsquo;s trivial for users to resize the terminal. Why does this matter?&lt;/p>
&lt;p>Consider the most obvious case: the help message of your program. It is incredibly common to see &lt;a href="http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=src/cp.c;h=e235b326d4d45b82aadaccef6a2f95da7137c1aa;hb=46f7e05291a22a1f15f839827ed257782138fae0#l149">carefully-formatted embedded strings into the program&amp;rsquo;s code&lt;/a> designed to fit within a 80x24 window (which is especially true for the width of the text). Other than being a nightmare to maintain such a piece of code, what happens when the user resizes the terminal? If he increases the number of columns, the output of the application won&amp;rsquo;t make use of such extra space and will continue to use the same number of lines — a situation that may be undesirable in a widescreen setting. If he decreases the number of columns, the output of the application will get wrapped at weird boundaries.&lt;/p></description></item><item><title>CLI design: Handling output messages</title><link>https://jmmv.dev/2013/09/cli-design-handling-output-messages.html</link><pubDate>Mon, 09 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-handling-output-messages.html</guid><description>&lt;p>Your CLI-based program has to communicate with the user. The most obvious case is to display error or warning messages, but in some cases it is also to report progress status. There are a few details to be considered in this area.&lt;/p>
&lt;h1 id="quietness-vs-verbosity-by-default">Quietness vs. verbosity by default&lt;/h1>
&lt;p>You&amp;rsquo;ve probably heard the &amp;ldquo;No news is good news&amp;rdquo; principle. This is a major guideline behind the design of most standard Unix tools: when no problems arise, the tool just does what it was asked for and does not print anything on the screen. Only when something goes wrong an error or warning message is printed. Examples include &lt;code>cp&lt;/code>, &lt;code>mv&lt;/code>, &lt;code>git add&lt;/code>, etc.&lt;/p></description></item><item><title>CLI design: Single-command interfaces</title><link>https://jmmv.dev/2013/09/cli-design-single-command-interfaces.html</link><pubDate>Thu, 05 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-single-command-interfaces.html</guid><description>&lt;p>In the &lt;a href="https://jmmv.dev/2013/09/cli-design-subcommand-based-interfaces.html">previous post&lt;/a>, I provided common guidelines on how to implement a subcommand-based interface. It is now the time to look into the interface of those applications that implement a single command or function, which are actually quite abundant. Without going too far, you will encounter &lt;code>cp&lt;/code>, &lt;code>ls&lt;/code> and &lt;code>sudo&lt;/code>, all of which are just a tiny sample of tools that fit this model.&lt;/p>
&lt;h1 id="general-syntax">General syntax&lt;/h1>
&lt;p>The general syntax of a single-command interface is simple:&lt;/p></description></item><item><title>CLI design: Subcommand-based interfaces</title><link>https://jmmv.dev/2013/09/cli-design-subcommand-based-interfaces.html</link><pubDate>Mon, 02 Sep 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/09/cli-design-subcommand-based-interfaces.html</guid><description>&lt;p>Subcommand-based interfaces are common: the majority of the CLI tools that provide more than one operation within them expose their features in this manner. Examples of such interfaces include &lt;code>svn&lt;/code>, &lt;code>git&lt;/code>, &lt;code>ifconfig&lt;/code>, &lt;code>yum&lt;/code>, &lt;code>apt-get&lt;/code> and many, many more.&lt;/p>
&lt;p>Designing the interface of these applications is quite straightforward once you have the concepts clear, but there are quite a few common pitfalls that you need to be aware of to prevent falling into them. In this post, I will guide you through what the general design of such interfaces is and I will cover a bunch of the common problems. Let&amp;rsquo;s get started.&lt;/p></description></item><item><title>CLI design: Do not reinvent option parsing</title><link>https://jmmv.dev/2013/08/cli-design-do-not-reinvent-option.html</link><pubDate>Thu, 29 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-do-not-reinvent-option.html</guid><description>&lt;p>In the &lt;a href="https://jmmv.dev/2013/08/cli-design-putting-flags-to-good-use.html">previous post&lt;/a>, we saw what good and bad use cases for flags in the interface of a command-line application are. We talked about the theory, so it is now the time to talk about the implementation details.&lt;/p>
&lt;p>The point I want to make in this post is simple: &lt;em>do &lt;strong>not&lt;/strong> reinvent option parsing&lt;/em>. Use the libraries provided by the platform you are targeting to implement the interface of your application: even if there is some little detail of the library that you don&amp;rsquo;t agree with, consistency with the platform is lightyears better than a custom implementation that fails to handle some corner cases and/or behaves in an unexpected manner.&lt;/p></description></item><item><title>CLI design: Putting flags to good use</title><link>https://jmmv.dev/2013/08/cli-design-putting-flags-to-good-use.html</link><pubDate>Mon, 26 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-putting-flags-to-good-use.html</guid><description>&lt;p>As the Wikipedia puts it in its &lt;a href="http://en.wikipedia.org/wiki/Command-line_interface">Command-line interface page&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>A &lt;strong>command-line option&lt;/strong> or simply &lt;strong>option&lt;/strong> (also known as a &lt;strong>flag&lt;/strong> or &lt;strong>switch&lt;/strong>) modifies the operation of a command; the effect is determined by the command&amp;rsquo;s program.&lt;/p>
&lt;/blockquote>
&lt;p>Yet, many developers abuse flags to do many unrelated things and therefore end up providing a non-standard and confusing user interface. Let&amp;rsquo;s take a look at some specific use cases, both bad and good.&lt;/p></description></item><item><title>CLI design: Requesting and offering help</title><link>https://jmmv.dev/2013/08/cli-design-requesting-and-offering-help.html</link><pubDate>Thu, 22 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-requesting-and-offering-help.html</guid><description>&lt;p>Any CLI application must offer help to describe its command line syntax: the flags it supports, the subcommands it implements, the meaning of the positional arguments, etc. Failure to do results in an application that is completely unusable: unlike GUI applications, the interface of CLI tools is not discoverable without instructions.&lt;/p>
&lt;p>It is, therefore, important to realize that help does not only exist to aid the user in recovering from errors. Help also exists to teach users how the application works, what the expectations are and, more importantly, to showcase the features of the program.&lt;/p></description></item><item><title>CLI design: Error reporting</title><link>https://jmmv.dev/2013/08/cli-design-error-reporting.html</link><pubDate>Mon, 19 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-error-reporting.html</guid><description>&lt;p>Error reporting is a tricky business. Get it right and your users will be able to correct their actions quickly. Get it wrong and you will be the cause of your user&amp;rsquo;s frustration — because, face it: A) users &lt;em>will&lt;/em> make mistakes and B) your application will encounter erroneous conditions due to bugs or unpredicted scenarios.&lt;/p>
&lt;h1 id="understand-usage-errors-and-application-errors">Understand usage errors and application errors&lt;/h1>
&lt;p>From the programmer&amp;rsquo;s point of view, there are many types of errors that an application can detect; but, from the point of view of the user, errors can be classified in two broad categories: usage errors and application errors. Let&amp;rsquo;s take a look at what these are before diving into how to handle them.&lt;/p></description></item><item><title>CLI design: The CLI is the presentation layer</title><link>https://jmmv.dev/2013/08/cli-design-cli-is-presentation-layer.html</link><pubDate>Thu, 15 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-cli-is-presentation-layer.html</guid><description>&lt;p>Treat the code that implements a CLI utility to the highest standards.&lt;/p>
&lt;p>Let&amp;rsquo;s step back for a moment. In any graphical application, there always is a chunk of code to deal with the interface of the tool and there is another chunk of code to do the &amp;ldquo;real work&amp;rdquo; behind the interface, possibly split into multiple logical layers. This basic split of presentation vs. logic is essential for the maintainability of the code. &lt;em>The same is equally true for CLI tools&lt;/em>: the code that interacts with the console &lt;em>is&lt;/em> the presentation layer, and anything else is part of the backend.&lt;/p></description></item><item><title>CLI design: Series introduction</title><link>https://jmmv.dev/2013/08/cli-design-series-introduction.html</link><pubDate>Mon, 12 Aug 2013 12:00:00 -0400</pubDate><author>julio@meroh.net (Julio Merino)</author><guid>https://jmmv.dev/2013/08/cli-design-series-introduction.html</guid><description>&lt;p>Ready for a new series?&lt;/p>
&lt;p>Having just gone over a bunch of items regarding &lt;a href="https://jmmv.dev/2013/08/readability-series-wrap-up.html">code readability&lt;/a>, it is time to shift gears and get into the topic of the design of Command Line Interfaces (or CLIs for short).&lt;/p>
&lt;p>The main focus of this series will be to cover best practices involved in creating applications whose interface is command-line oriented. Among other things, I will detail how the CLI should accept optional and required arguments, how a tool should expose more than one action and how interactive help should be handled.&lt;/p></description></item></channel></rss>