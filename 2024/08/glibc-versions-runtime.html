<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Picking glibc versions at runtime - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Picking glibc versions at runtime - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Picking glibc versions at runtime - Julio Merino (jmmv.dev)"><meta name=description content="In a recent work discussion, I came across an argument that didn&rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a modern glibc. The justifications were that using LD_LIBRARY_PATH to load a different glibc didn&rsquo;t work and statically linking glibc wasn&rsquo;t possible either.
But&mldr; running a program against a version of glibc that&rsquo;s different from the one installed on the system seems like a pretty standard requirement, doesn&rsquo;t it? Consider this: how do the developers of glibc test their changes? glibc has existed for much longer than containers have. And before containers existed, they surely weren&rsquo;t testing glibc changes by installing modified versions of the library over the system-wide one and YOLOing it.
"><meta property="og:description" content="In a recent work discussion, I came across an argument that didn&rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a modern glibc. The justifications were that using LD_LIBRARY_PATH to load a different glibc didn&rsquo;t work and statically linking glibc wasn&rsquo;t possible either.
But&mldr; running a program against a version of glibc that&rsquo;s different from the one installed on the system seems like a pretty standard requirement, doesn&rsquo;t it? Consider this: how do the developers of glibc test their changes? glibc has existed for much longer than containers have. And before containers existed, they surely weren&rsquo;t testing glibc changes by installing modified versions of the library over the system-wide one and YOLOing it.
"><meta property="twitter:description" content="In a recent work discussion, I came across an argument that didn&rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://jmmv.dev/2024/08/glibc-versions-runtime.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/08/glibc-versions-runtime.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-08-11-glibc-versions-runtime-dynamic.png"><meta property="twitter:image" content="https://jmmv.dev/images/2024-08-11-glibc-versions-runtime-dynamic.png"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzA4L2dsaWJjLXZlcnNpb25zLXJ1bnRpbWUuaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/glibc-versions-runtime")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Picking glibc versions at runtime</h1><p>August 11, 2024 &#183;
About 11 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/programming>programming</a>, <a href=/tags/unix>unix</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/glibc-versions-runtime>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>In a recent work discussion, I came across an argument that didn&rsquo;t sound quite right. The claim was that we needed to set up containers in our developer machines in order to run tests against a modern glibc. The justifications were that using <code>LD_LIBRARY_PATH</code> to load a different glibc didn&rsquo;t work and statically linking glibc wasn&rsquo;t possible either.</p><p>But&mldr; running a program against a version of glibc that&rsquo;s different from the one installed on the system seems like a pretty standard requirement, doesn&rsquo;t it? Consider this: how do the developers of glibc test their changes? glibc has existed for much longer than containers have. And before containers existed, they surely weren&rsquo;t testing glibc changes by installing modified versions of the library over the system-wide one and YOLOing it.</p><p>So. What options do we really have? To answer this question, we need to look at how dynamic binaries work and what glibc is.</p><h1 id=static-binaries>Static binaries</h1><p>Static binaries are binaries whose program code is all contained in one executable. Such binaries can access system services via system calls&mdash;or else their utility would be minimal because they wouldn&rsquo;t be able to interact with the OS&mdash;but their binary code is, in a sense, &ldquo;complete&rdquo;: what you see in the executable is exactly what gets laid out in memory for execution.</p><p>Here is how a sample static binary looks like. This is for a &ldquo;hello world&rdquo; program written in Go, which was the easiest thing to put together because Go is designed to bypass the C library <a href=https://utcc.utoronto.ca/~cks/space/blog/programming/Go116OpenBSDUsesLibc>almost everywhere</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ file hello_go
</span></span><span class=line><span class=cl>hello_go: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=2H_kXH_UFAOR5K6ibAke/aj_2VBvakhN2KujNxtMN/K5TtKP8HHiX65VdbA19s/KxdoZHQEiOxCEbwRE346, with debug_info, not stripped
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>In the above, note that <code>file</code> claims that our sample <code>hello_go</code> program is <em>statically linked</em>.</p><p>When we ask the shell to run this <code>hello_go</code> binary, the shell forks a new process and uses the <code>exec(2)</code> family of system calls to replace the running image of the process with the content of <code>hello_go</code>. And because <code>hello_go</code> is statically linked, the text segment of the binary is loaded verbatim into the process.</p><figure><img src=/images/2024-08-11-glibc-versions-runtime-static.png><figcaption>Representation of how a static binary is directly mapped into a process when executed.</figcaption></figure><h1 id=dynamic-binaries>Dynamic binaries</h1><p>Let&rsquo;s compare the above to a dynamically-linked binary by looking at the same &ldquo;hello world&rdquo; program written in C and linked against glibc:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ file hello_c
</span></span><span class=line><span class=cl>hello_c: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=feeb95b014ef8151780e23fc7ca15de0599f05df, for GNU/Linux 3.2.0, not stripped
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>Note that <code>file</code> now claims that our sample <code>hello_c</code> program is <em>dynamically linked</em> and, indeed, if we look at its libraries&mdash;quick reminder: <a href=/2023/07/ldd-untrusted-binaries.html>don&rsquo;t use <code>ldd</code> on untrusted executables</a>!&mdash;we see that glibc (<code>libc.so.6</code>) is there:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ ldd hello_c
</span></span><span class=line><span class=cl>        linux-vdso.so.1 (0x00007f54f25aa000)
</span></span><span class=line><span class=cl>        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f54f239b000)
</span></span><span class=line><span class=cl>        /lib64/ld-linux-x86-64.so.2 (0x00007f54f25ac000)
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>But wait a second. There is more than just <code>libc.so.6</code> in the output of <code>ldd</code>. In particular, there is this other <code>/lib64/ld-linux-x86-64.so.2</code> &ldquo;library&rdquo; and, if you pay close attention to the earlier output of <code>file</code>, you&rsquo;ll note that it claims that this is an <em>interpreter</em>. Why is there an &ldquo;interpreter&rdquo; if we are running machine code?! Did they lie to us when they said C was a compiled language?</p><p>Not so fast, no. &ldquo;Interpreter&rdquo; in this case should be read as &ldquo;loader&rdquo;, but the &ldquo;interpreter&rdquo; word comes from the nomenclature of the ELF headers stored in the program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ readelf -l hello_c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Elf file type is EXEC (Executable file)
</span></span><span class=line><span class=cl>Entry point 0x401040
</span></span><span class=line><span class=cl>There are 13 program headers, starting at offset 64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Program Headers:
</span></span><span class=line><span class=cl>  Type           Offset             VirtAddr           PhysAddr
</span></span><span class=line><span class=cl>                 FileSiz            MemSiz              Flags  Align
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  INTERP         0x0000000000000318 0x0000000000400318 0x0000000000400318
</span></span><span class=line><span class=cl>                 0x000000000000001c 0x000000000000001c  R      0x1
</span></span><span class=line><span class=cl>      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>To understand what this interpreter thing is all about, we need to look at what a dynamically-linked executable is. In essence, the program code in the binary is not <em>complete</em>: the code contains &ldquo;gaps&rdquo; in it that need to be filled with references to portions of code supplied by other libraries before it can begin executing. We can peek into what these &ldquo;gaps&rdquo; are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ readelf -r hello_c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Relocation section &#39;.rela.dyn&#39; at offset 0x4c0 contains 2 entries:
</span></span><span class=line><span class=cl>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
</span></span><span class=line><span class=cl>000000403fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0
</span></span><span class=line><span class=cl>000000403fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Relocation section &#39;.rela.plt&#39; at offset 0x4f0 contains 1 entry:
</span></span><span class=line><span class=cl>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
</span></span><span class=line><span class=cl>000000404000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p><code>readelf</code> tells us that the <code>hello_c</code> binary has three different &ldquo;relocations&rdquo;: in other words, it has three different &ldquo;gaps&rdquo; that need to be patched at runtime with the address of the code that supplies those symbols. The program <em>cannot run</em> without those being filled in first. So if it cannot begin executing before those references are resolved, how does the program run?</p><p>You might think that the kernel is somehow responsible for dealing with dynamic libraries, but that&rsquo;s not the case. Dynamic libraries are a user-space concept and this is precisely where the interpreter comes into play.</p><p>When we ask the kernel to <code>exec(2)</code> a dynamically-linked ELF binary, the kernel loads the <em>interpreter</em> into the process image, <em>not</em> the code of the binary, and passes the path of the binary to the interpreter.</p><figure><img src=/images/2024-08-11-glibc-versions-runtime-dynamic.png><figcaption>Representation of how a dynamic binary is loaded into memory with the help of the dynamic linker, along with glibc and the fixup of a relocation.</figcaption></figure><p>The interpreter, <a href=https://man7.org/linux/man-pages/man8/ld.so.8.html><code>ld-linux.so</code></a> in our case, is then in charge of setting up the remaining of the process by loading all required shared libraries into the process and then resolving relocations (&ldquo;filling the gaps&rdquo;) among them. In particular, the dynamic linker is the one that loads glibc into the process.</p><p>We can see that this is the case by asking the dynamic linker to print its own file accesses by setting <code>LD_DEBUG=files</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ LD_DEBUG=files /lib64/ld-linux-x86-64.so.2 ./hello_c
</span></span><span class=line><span class=cl>     75369:     file=./hello_c [0];  generating link map
</span></span><span class=line><span class=cl>     75369:       dynamic: 0x0000000000403e08  base: 0x0000000000000000   size: 0x0000000000004010
</span></span><span class=line><span class=cl>     75369:         entry: 0x0000000000401040  phdr: 0x0000000000400040  phnum:                 13
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     file=libc.so.6 [0];  needed by ./hello_c [0]
</span></span><span class=line><span class=cl>     75369:     file=libc.so.6 [0];  generating link map
</span></span><span class=line><span class=cl>     75369:       dynamic: 0x00007f9aad868960  base: 0x00007f9aad682000   size: 0x00000000001f0b70
</span></span><span class=line><span class=cl>     75369:         entry: 0x00007f9aad6ac260  phdr: 0x00007f9aad682040  phnum:                 14
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     calling init: /lib64/ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     calling init: /lib64/libc.so.6
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     initialize program: ./hello_c
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     transferring control: ./hello_c
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>Hello, world!
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     calling fini:  [0]
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     calling fini: /lib64/libc.so.6 [0]
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>     75369:     calling fini: /lib64/ld-linux-x86-64.so.2 [0]
</span></span><span class=line><span class=cl>     75369:
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>As a final note, see how I chose to invoke the dynamic linker <em>explicitly</em>&mdash;just as the kernel would do when asked to launch a dynamically-linked binary&mdash;instead of directly running <code>hello_c</code>.</p><h1 id=playing-with-glibc>Playing with glibc</h1><p>OK, now that we know how a dynamically-linked ELF executable is loaded into memory, let&rsquo;s play with glibc.</p><p>First, we download glibc, build and install it into a temporary directory like <code>/tmp/sysroot/</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ git clone https://sourceware.org/git/glibc.git
</span></span><span class=line><span class=cl>$ cd glibc
</span></span><span class=line><span class=cl>glibc$ git checkout release/2.40/master
</span></span><span class=line><span class=cl>glibc$ mkdir build
</span></span><span class=line><span class=cl>glibc/build$ ../configure --prefix=/tmp/sysroot
</span></span><span class=line><span class=cl>glibc/build$ make -j $(nproc)
</span></span><span class=line><span class=cl>glibc/build$ make -j $(nproc) install
</span></span><span class=line><span class=cl>glibc/build$ █
</span></span></code></pre></div><p>With that done, we should be able to use the new glibc. But&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ LD_LIBRARY_PATH=/tmp/sysroot/lib ./hello_c
</span></span><span class=line><span class=cl>Floating point exception (core dumped)
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>Kaboom.</p><p>Indeed, as my coworker claimed, it doesn&rsquo;t seem to be possible to load a different glibc at runtime than the one provided by the system. (YMMV. I got this to work on another system.) Looking at the stack trace of the core dump, we see:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>Stack trace of thread 75841:
</span></span><span class=line><span class=cl>#0  0x00007f227d93903b n/a (/tmp/sysroot/lib/libc.so.6 + 0x15403b)
</span></span><span class=line><span class=cl>#1  0x00007f227d9f19f6 _dl_sysdep_start (ld-linux-x86-64.so.2 + 0x1c9f6)
</span></span><span class=line><span class=cl>#2  0x00007f227d9f335e _dl_start_final (ld-linux-x86-64.so.2 + 0x1e35e)
</span></span><span class=line><span class=cl>#3  0x00007f227d9f2048 _start (ld-linux-x86-64.so.2 + 0x1d048)
</span></span></code></pre></div><p>Our process is crashing within glibc as soon as it is loaded by <code>ld-linux.so</code>. The details of the crash are not interesting for our purposes, but can we do anything about them?</p><h1 id=playing-with-the-dynamic-linker>Playing with the dynamic linker</h1><p>What&rsquo;s more interesting is to peek into what&rsquo;s shipped by glibc. We can do this by looking under the <code>/tmp/sysroot/</code> hierarchy that we generated earlier and finding:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ ls /tmp/sysroot/lib/
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>libc.so
</span></span><span class=line><span class=cl>libc.so.6
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>There is <em>a ton</em> more stuff in there. But what&rsquo;s important to notice is that <em>the dynamic linker ships with glibc</em>. The two are closely coupled, and using one without the other can lead to the kinds of crashes shown earlier.</p><p>And remember: as we saw above, it is possible to manually launch the dynamic linker. So if we do the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ LD_LIBRARY_PATH=/tmp/sysroot/lib /tmp/sysroot/lib/ld-linux-x86-64.so.2 ./hello_c
</span></span><span class=line><span class=cl>Hello, world!
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>We don&rsquo;t get a crash anymore. What&rsquo;s even better is that we also <em>seem</em> to get what we expect without even setting <code>LD_LIBRARY_PATH</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ /tmp/sysroot/lib/ld-linux-x86-64.so.2 ./hello_c
</span></span><span class=line><span class=cl>Hello, world!
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>We should confirm that the previous invocation of <code>hello_c</code> is actually using our own glibc version and not the system-supplied one. To do that, we can <code>strace</code> the dynamic linker; it&rsquo;s just a program after all:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ strace /tmp/sysroot/lib/ld-linux-x86-64.so.2 ./hello_c 2&gt;&amp;1 | grep libc.so
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/tmp/sysroot/lib/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>Indeed, <code>hello_c</code> did use the newly-built glibc by &ldquo;just&rdquo; asking the newly-built dynamic loader to execute the binary.</p><p>To summarize, glibc ships both the <code>ld-linux.so</code> dynamic linker and the <code>libc.so.6</code> shared library. The two are closely coupled. Running a binary against the C library without also using a matching dynamic linker can lead to crashes. But running a binary directly with a specific dynamic linker ensures that the binary picks up the matching C library.</p><h1 id=putting-this-to-use>Putting this to use</h1><p>Alright, now that we know that it is actually possible to run a binary against a version of glibc that&rsquo;s <em>not</em> the one provided by the system, we can try to solve the original problem we faced: running tests against a modern glibc.</p><p>One possibility is to modify the commands used to run the tests to prefix them by <code>.../lib/ld-linux-x86-64.so.2</code>. This could work but I posit is difficult to integrate with a test execution environment because we don&rsquo;t necessarily control the commands that end up executing the test binaries.</p><p>Another possibility is to modify the way the tests programs are being built by supplying additional linker arguments&mdash;say, via the traditional <code>LDFLAGS</code>&mdash;to point the linker at a different interpreter with the <code>--Wl,--dynamic-linker</code> flag:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ cc -o hello_c -Wl,--dynamic-linker=/tmp/sysroot/lib/ld-linux-x86-64.so.2 hello.c
</span></span><span class=line><span class=cl>$ strace ./hello_c 2&gt;&amp;1 | grep libc.so
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/tmp/sysroot/lib/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>Better. Now the built binary &ldquo;knows&rdquo; which glibc to use without us having to specify it explicitly every time we attempt to launch the program.</p><p>What if we aren&rsquo;t <em>building</em> the binaries? What if we are just reusing a binary that already exists? <code>patchelf</code> to the rescue:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ cc -o hello_c hello.c
</span></span><span class=line><span class=cl>$ strace ./hello_c 2&gt;&amp;1 | grep libc.so
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/lib64/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>$ patchelf --set-interpreter /tmp/sysroot/lib/ld-linux-x86-64.so.2 ./hello_c
</span></span><span class=line><span class=cl>$ strace ./hello_c 2&gt;&amp;1 | grep libc.so
</span></span><span class=line><span class=cl>openat(AT_FDCWD, &#34;/tmp/sysroot/lib/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3
</span></span><span class=line><span class=cl>$ █
</span></span></code></pre></div><p>Voila. We have modified an existing executable to use whichever glibc we desire.</p><h1 id=versioning-glibc>Versioning glibc</h1><p>But hold on a second. Can we use <em>whichever</em> glibc really? Is it actually true that glibc versions are completely interchangeable? Unfortunately not.</p><p>A binary built against an old version of glibc is guaranteed to run against a newer version of glibc without recompilation. But the counterpart is not true: a binary built against a new glibc may not run against an older glibc.</p><p>This poses a problem: how can we upgrade glibc across separate production and development environments? If we upgrade production first, binaries built in development environments will continue to work properly but developers may not be able to reproduce bugs found in production. And if we upgrade development environments first, the binaries they produce may be incompatible with production, leading to random crashes later on.</p><p>Here is an idea I&rsquo;ve seen work in the past: let&rsquo;s extend the sysroot concept presented above and version it!</p><p>We start with <code>/usr/sysroot/v1/</code> which contains the first version of the core system libraries we have to support. All binaries that we build for production deployment are explicitly linked against the <code>ld-linux.so</code> of this directory, so they are always validated against <code>v1</code> of the sysroot. <code>v1</code> remains immutable, which means new builds of the binaries will continue to work as tested in the past.</p><p>Whenever we want to upgrade glibc, we create a <em>new</em> sysroot, <code>/usr/sysroot/v2/</code>. This new <code>v2</code> is deployed to all environments (development and production) that may need to use the new glibc. This deployment step is risk-free because nothing is yet dependent on <code>v2</code>. After that, we proceed to rebuild all binaries that we want to test and run, this time pointing at the <code>ld-linux.so</code> within <code>v2</code>. Deploying these new binaries causes them to use the new version.</p><p>As long as the <code>/usr/sysroot/</code> subdirectories remain immutable and synchronized across all environments in which binaries run, we are guaranteed to always get a deterministic version of glibc for a given binary.</p><p>That&rsquo;s just a design sketch though. It may or it may not work for you. As I mentioned earlier, I&rsquo;ve seen this work well in a large corporate environment before, but it introduces some extra complexity that you need to take care of.</p><hr><p>What&rsquo;s the moral of the story? Containers are, usually, not the best solution to a systems problem. While they might be coerced to deliver the desired results, they come with a heavy cost. Unix has been around for a long time and there exist alternate solutions to problems that don&rsquo;t require full replicas of a functioning system. A ton of the bloat we face today in development tools and deployments comes from the abuse of heavyweight containers. So, every time you think &ldquo;containers!&rdquo;, pause to explore alternatives&mdash;you may find cheaper, more portable, and simpler solutions.</p><p>If you want to learn more about this and related topics, I&rsquo;d recommend grabbing a copy of the classic <a href="https://www.amazon.com/Linkers-Kaufmann-Software-Engineering-Programming/dp/1558604960?&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=421e6bc20c93925de6766b135a24239a&amp;language=en_US&amp;ref_=as_li_ss_tl">&ldquo;Linkers and Loaders&rdquo; book</a>. It&rsquo;s old, but it&rsquo;s still very relevant.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/08/kyua-graduates.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2024/09/windows-nt-vs-unix-design.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Picking+glibc+versions+at+runtime&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F08%2Fglibc-versions-runtime.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Picking+glibc+versions+at+runtime&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F08%2Fglibc-versions-runtime.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Picking+glibc+versions+at+runtime+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F08%2Fglibc-versions-runtime.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>