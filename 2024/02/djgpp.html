<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Running GNU on DOS with DJGPP - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Running GNU on DOS with DJGPP - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Running GNU on DOS with DJGPP - Julio Merino (jmmv.dev)"><meta name=description content="The recent deep dive into the IDEs of the DOS times 30 years ago made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.
I remember using DJGPP back in the 1990s before I had been exposed to Linux and feeling that it was a strange beast. Compared to the Microsoft C Compiler and Turbo C++, the tooling was bloated and alien to DOS, and the resulting binaries were huge. But DJGPP provided a complete development environment for free, which I got from a monthly magazine, and I could even look at its source code if I wished. You can&amp;rsquo;t imagine what a big deal that was at the time.
But even if I could look under the cover, I never did. I never really understood why was DJGPP so strange, slow, and huge, or why it even existed. Until now. As I&amp;rsquo;m in the mood of looking back, I&amp;rsquo;ve spent the last couple of months figuring out what the foundations of this software were and how it actually worked. Part of this research has resulted in the previous two posts on DOS memory management. And part of this research is this article. Let&amp;rsquo;s take a look!
"><meta property="og:description" content="The recent deep dive into the IDEs of the DOS times 30 years ago made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.
I remember using DJGPP back in the 1990s before I had been exposed to Linux and feeling that it was a strange beast. Compared to the Microsoft C Compiler and Turbo C++, the tooling was bloated and alien to DOS, and the resulting binaries were huge. But DJGPP provided a complete development environment for free, which I got from a monthly magazine, and I could even look at its source code if I wished. You can&amp;rsquo;t imagine what a big deal that was at the time.
But even if I could look under the cover, I never did. I never really understood why was DJGPP so strange, slow, and huge, or why it even existed. Until now. As I&amp;rsquo;m in the mood of looking back, I&amp;rsquo;ve spent the last couple of months figuring out what the foundations of this software were and how it actually worked. Part of this research has resulted in the previous two posts on DOS memory management. And part of this research is this article. Let&amp;rsquo;s take a look!
"><meta property="twitter:description" content="The recent deep dive into the IDEs of the DOS times 30 years ago made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.
I remember using DJGPP back in the 1990s before I had â€¦"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2024/02/djgpp.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/02/djgpp.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-02-14-djgpp-cover-image.png"><meta property="twitter:image" content="https://jmmv.dev/images/2024-02-14-djgpp-cover-image.png"><meta property="og:image:alt" content="Cover image consisting on a tiny portion of the sources of DJGPP's <tt>dosexec.c</tt> source file, with a big MS-DOS logo in the center surrounded by the logos of GNU, GCC, Bash, and Emacs."><meta property="twitter:image:alt" content="Cover image consisting on a tiny portion of the sources of DJGPP's <tt>dosexec.c</tt> source file, with a big MS-DOS logo in the center surrounded by the logos of GNU, GCC, Bash, and Emacs."><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzAyL2RqZ3BwLmh0bWw=/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/running-gnu-on-dos-with-djgpp")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Running GNU on DOS with DJGPP</h1><p>February 14, 2024 &#183;
About 20 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/dos>dos</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/running-gnu-on-dos-with-djgpp>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-02-14-djgpp-cover-image.png style=max-width:100%><figcaption>Cover image consisting on a tiny portion of the sources of DJGPP's <tt>dosexec.c</tt> source file, with a big MS-DOS logo in the center surrounded by the logos of GNU, GCC, Bash, and Emacs.</figcaption></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>The recent deep dive into <a href=/2023/12/the-ides-we-had-30-years-ago.html>the IDEs of the DOS times 30 years ago</a> made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.</p><p>I remember using DJGPP back in the 1990s before I had been exposed to Linux and feeling that it was a strange beast. Compared to the Microsoft C Compiler and Turbo C++, the tooling was bloated and alien to DOS, and the resulting binaries were huge. But DJGPP provided a complete development environment <em>for free</em>, which I got from a monthly magazine, and I could even look at its source code if I wished. You can&rsquo;t imagine what a big deal that was at the time.</p><p>But even if I could look under the cover, I never did. I never really understood why was DJGPP so strange, slow, and huge, or why it even existed. Until now. As I&rsquo;m in the mood of looking back, I&rsquo;ve spent the last couple of months figuring out what the foundations of this software were and how it actually worked. Part of this research has resulted in the previous two posts on DOS memory management. And part of this research is this article. Let&rsquo;s take a look!</p><p><em>Special thanks go to DJ Delorie himself for reviewing a draft of this article. Make sure to <a href=https://delorie.com/>visit his website</a> for DJGPP and a lot more cool stuff!</em></p><h1 id=what-is-djgpp>What is DJGPP?</h1><p>Simply put, DJGPP is a port of the GNU development tools to DOS. You would think that this was an easy feat to achieve given that other compilers did exist for DOS. However&mldr; you should know that Richard Stallman (RMS)&mdash;the creator of GNU and GCC&mdash;thought that GCC, a 32-bit compiler, was too big to run on a 16-bit operating system restricted to 1 MB of memory. DJ Delorie took this as a challenge in 1989 and, with all the contortions that we shall see below, made GCC and other tools like GDB and Emacs work on DOS.</p><p>To a DOS and Windows user, DJGPP was, and still is, an alien development environment: the tools&rsquo; behavior is strange compared to other DOS compilers, and that&rsquo;s primarily due to their Unix heritage. For example, as soon as you start using DJGPP, you realize that flags are prefixed by a dash instead of a slash, paths use forward slashes instead of backward slashes, and the files don&rsquo;t ship in a flat directory structure like most other programs did. But hey, all the tools worked and, best of all, they were free!</p><p>In fact, from reading about <a href=https://www.delorie.com/djgpp/doc/eli-m17n99.html#Introduction>the historical goals of the project</a>, I gather that a secondary goal was for DJ to evangelize free software to as many people as possible, meeting them where they already were: PC users with a not-very-powerful machine that ran DOS. Mind you, this plan worked on some of us as we ended up moving to Linux and the free software movement later on.</p><p>In any case, being a free alien development environment doesn&rsquo;t explain why it had to be huge and slow compared to other others. To explain this, we need to look at the &ldquo;32-bit compiler&rdquo; part.</p><h1 id=dos-and-hardware-constraints>DOS and hardware constraints</h1><p>As we saw in <a href=/2024/01/from-0-to-1-mb-in-dos.html>a previous article</a>, Intel PCs based on the 80386 have two main modes of operation: real mode and protected mode. In real mode, the processor behaves like a fast 16-bit 8086, limiting programs to a 1 MB address space and with free reign to access memory and hardware peripherals. In protected mode, programs are 32-bit, have access to a 4 GB address space, and there are protection rules in place to access memory and hardware.</p><p>DOS was a 16-bit operating system that ran in real mode. Applications that ran on DOS leveraged DOS&rsquo; services for things like disk access, were limited to addressing 1 MB of memory, and had complete control of the computer. Contrary to that, GCC was a 32-bit program that had been designed to run on Unix (oops sorry, <a href=https://www.gnu.org/gnu/about-gnu.html>GNU is Not Unix</a>) <em>and</em> produce binaries for Unix, and Unix required virtual memory from the ground up to support multiprocessing. (I know that&rsquo;s <a href=https://unix.stackexchange.com/questions/332699/how-the-original-unix-kernel-adressed-memory>not totally accurate</a> but it&rsquo;s easier to think about it that way.)</p><p>Intel-native compilers for DOS, such as the Microsoft C compiler and Turbo C++, targeted the 8086&rsquo;s weird segmented architecture and generated code accordingly. Those compilers had to deal with short, near, and far jumps&mdash;which is to say I have extra research to do and write <em>another</em> article on ancient DOS memory models. GCC, on the other hand, assumes the full address space is available to programs and generates code making such assumptions.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><p>GCC was not <em>only</em> a 32-bit program, though: it was also <em>big</em>. In order to compile itself and other programs, GCC needed more physical memory than PCs had back then. This means that, in order to port GCC to DOS, GCC needed virtual memory. In turn, this means that GCC had to run in protected mode. Yet&mldr; DOS is a real mode operating system, and calling into DOS services to access files and the like requires the processor to be in real mode.</p><p>To address this conundrum, DJ had to find a way to make GCC <em>and the programs it compiles</em> integrate with DOS. After all, if you have a C program that opens a file and you compile said program with GCC, you want the program to open the file via the DOS file system for interoperability reasons.</p><p>Here, witness this. The following silly program, <code>headself.c</code>, goes out of its way to allocate a buffer above the 2 MB mark and then uses said buffer to read itself into it, printing the very first line of its source code:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;inttypes.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define BUFMINBASE  2 * 1024 * 1024
</span></span></span><span class=line><span class=cl><span class=cp>#define BUFSIZE     1 * 1024 * 1024
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate a buffer until its base address is past the 2MB boundary.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span><span class=o>*</span> <span class=n>buf</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>buf</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)(</span><span class=n>BUFMINBASE</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>buf</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=n>BUFSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Read buffer base is at %zd KB</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>((</span><span class=kt>intptr_t</span><span class=p>)</span><span class=n>buf</span><span class=p>)</span> <span class=o>/</span> <span class=mi>1024</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Open this source file and print its first line.  Really unsafe.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;headself.c&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUFSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buf</span><span class=p>;</span> <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>ptr</span> <span class=o>!=</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=n>ptr</span><span class=o>++</span><span class=p>;</span> <span class=o>*</span><span class=p>(</span><span class=n>ptr</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/djgpp/headself.c type=text/plain>headself.c</a></div></div></div><p>Yes, yes, I know the above code is really unsafe and lacks error handling throughout. But that&rsquo;s not important here. Watch out what happens when we compile and run this program with DJGPP on DOS:</p><figure><img src=/images/2024-02-14-headself.png></figure><p>Note two things. The first is that the program <em>has to</em> have run in protected mode because it successfully allocated a buffer above the 1 MB mark and <em>used</em> it without extraneous API calls. The second is that the program is invoking file operations, and those operations interact with files managed by DOS.</p><p>And here is where the <em>really cool</em> stuff begins. On the one hand, we have DOS as a real mode operating system. On the other hand, we have programs that want to interoperate with DOS but they also want to take advantage of protected mode to leverage the larger address space and virtual memory. Unfortunately, protected mode cannot call DOS services because those require real mode.</p><p>The accepted solution to this issue is the use of a DOS Extender as we already saw <a href=/2024/02/beyond-the-1-mb-barrier-in-dos.html>in the previous article</a> but such technology was in its infancy. DJ actually went through <em>three</em> different iterations to fully resolve this problem in DJGPP:</p><ol><li>The first prototype used Phar Lap&rsquo;s DOS Extender but it didn&rsquo;t get very far because it didn&rsquo;t support virtual memory.</li><li>Then, the first real version of DJGPP used DJ&rsquo;s own DOS Extender called go32, a big hack that I&rsquo;m not going to talk about here.</li><li>And then, the second major version of DJGPP&mdash;almost a full rewrite of the first one&mdash;switched to using the DOS Protected Mode Interface (DPMI).</li></ol><p>At this point, DJGPP was able to run inside existing DPMI hosts such as Windows or the many memory managers that already existed for DOS and it didn&rsquo;t have to carry the hacks that previously existed in go32 (although the go32 code went on to live inside <a href=https://en.wikipedia.org/wiki/CWSDPMI><code>CWSDPMI</code></a>). The remainder of this article only talks about the latter of these versions.</p><h1 id=large-buffers>Large buffers</h1><p>One thing you may have noticed in the code of the <code>headself.c</code> example above is that I&rsquo;m using a buffer for the file read that&rsquo;s 1 MB-long. That&rsquo;s not unintentional: for such a large buffer to even exist (no matter our attempts to push it above 2 MBs), the buffer must be allocated in extended memory. But if it is allocated in extended memory, how can the file read operations that we send to DOS actually address such memory? After all, even if we used unreal mode, the DOS APIs wouldn&rsquo;t understand it.</p><p>The answer is the <em>transfer buffer</em>. The transfer buffer is a small and static piece of memory that DJGPP-built programs allocate at startup time below the 1 MB mark. With that in mind, and taking a file read as an example, DJGPP&rsquo;s C library does something akin to the following:</p><ol><li>The protected-mode <code>read</code> stub starts executing.</li><li>The stub issues a DPMI read call (which is to say, it executes the DOS read file API but uses the DPMI trampoline) onto the transfer buffer.</li><li>The DPMI host switches to real mode and calls the DOS read file API.</li><li>The real-mode DOS read places the data in the transfer buffer.</li><li>The real-mode DPMI host switches back to protected mode and returns control to the protected-mode stub.</li><li>The protected-mode <code>read</code> stub copies the data from the transfer buffer into the user-supplied buffer.</li></ol><p>This is all good and dandy but&mldr; take a close look at <a href=https://www.ctyme.com/intr/rb-2783.htm>DOS&rsquo;s file read API</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>Request:
</span></span><span class=line><span class=cl>INT 21h
</span></span><span class=line><span class=cl>AH    -&gt; 3Fh
</span></span><span class=line><span class=cl>BX    -&gt; file handle
</span></span><span class=line><span class=cl>CX    -&gt; number of bytes to read
</span></span><span class=line><span class=cl>DS:DX -&gt; buffer for data
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Return:
</span></span><span class=line><span class=cl>CF    -&gt; clear if successful
</span></span><span class=line><span class=cl>AX    -&gt; number of bytes actually read (0 if at EOF before call)
</span></span><span class=line><span class=cl>CF    -&gt; set on error
</span></span><span class=line><span class=cl>AX    -&gt; error code (05h,06h) (see #01680 at AH=59h/BX=0000h)
</span></span></code></pre></div><p>That&rsquo;s right: file read and write operations are restricted to 64 KB at a time because the number of bytes to process is specified in the 16-bit <code>CX</code> register. Which means that, in order to perform large file operations, we need to go through the dance above multiple times in a loop. And that&rsquo;s why DJGPP is slow: if the DPMI host has to switch to real mode and back for every system call, the overhead of each system call is significant.</p><p>Now is a good time to take a short break and <a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/io/_read.c?rev=1.4">peek into DJGPP&rsquo;s <code>read</code> implementation</a>. It&rsquo;s succinct and clearly illustrates what I described just above. And with that done, let&rsquo;s switch gears.</p><h1 id=globs-without-a-unix-shell>Globs without a Unix shell</h1><p>Leveraging protected mode and a large memory address space are just two important but small parts of the DJGPP puzzle. The other interesting pieces of DJGPP are those that make Unix programs run semi-seamlessly on DOS, and there are many such pieces. I won&rsquo;t cover them all here because <a href=http://www.delorie.com/djgpp/doc/eli-m17n99.html>Eli Zarateskii&rsquo;s presentation</a> did an excellent job at that. So want I to do instead is look at a subset of them apart and show them in action.</p><p>To begin, let&rsquo;s try to answer this question: how do you <em>interact</em> with a program originally designed for Unix on a DOS system? The Unix shell is <a href=/2020/11/cmdline-args-unix-vs-windows.html>a big part of such interaction</a> and <code>COMMAND.COM</code> is no Unix shell. To summarize the linked article: the API to invoke an executable on Unix takes a list of arguments while on DOS and Windows it takes a flat string. Partially because of this, the Unix shell is responsible for expanding globs and dealing with quotation characters, while on DOS and Windows each program is responsible for tokenizing the command line.</p><p>Leaving aside the fact that the DOS API is&mldr; ehem&mldr; bad, this fundamental difference means that any Unix program ported to DOS has a usability problem: you cannot use globs anymore when invoking it! Something as simple and common as <code>gcc -o program.exe *.c</code> would just not work. So then&mldr; how can we explain the following output from the <a href=/src/djgpp/showargs.c><code>showargs.c</code></a> program, a little piece of code that prints <code>argv</code>?</p><figure><img src=/images/2024-02-14-showargs-glob-expansion-gcc.png></figure><p>In the picture above, you can see how I ran the <tt>showargs.c</tt> program with <tt>*.c</tt> as its own argument and somehow it worked as you would expect. But if we build it with a standard DOS compiler we get different results:</p><figure><img src=/images/2024-02-14-showargs-glob-expansion-gcc-tcc.png></figure><p>GCC is actually doing <em>something</em> to make glob expansion work&mdash;and it <em>has</em> to, because remember that DJGPP was not just about porting GCC: it was about porting many more GNU developer tools to DOS. Having had to patch them one by one to work with DOS&rsquo; <code>COMMAND.COM</code> semantics would have been a sad state of affairs.</p><p>To understand what&rsquo;s happening here, know that all C programs compiled by <em>any</em> compiler include a prelude: <code>main</code> is <em>not</em> the program&rsquo;s true entry point. All compilers wrap <code>main</code> with some code of their own to set up the process and the C library, and DJGPP is no different. Such code is often known as the <code>crt</code> (or C Runtime) and it comes in two phases: <code>crt0</code>, written in assembly for early bootstrapping, and <code>crt1</code>, written in C.</p><p>As you can imagine, this is where the magic lives. DJGPP&rsquo;s <code>crt1</code> is in charge of processing the flat command line that it receives from DOS and transforming it into the <code>argv</code> that POSIX C programs expect, following common Unix semantics. In a way, this code performs the job of a Unix shell.</p><p>Once again, take a break to inspect the <a href=https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/crt0/><code>crt0</code> sources</a> and, in particular, the contents of the <a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/crt0/c1args.c?rev=1.11"><code>c1args.c</code> file</a>. Pay attention to file reads and the &ldquo;proxy&rdquo; thing, both of which bring us to the next section.</p><h1 id=long-command-lines>Long command lines</h1><p>Unix command lines aren&rsquo;t different just because of glob expansion. They are also different because they are usually <em>long</em>, and they are long in part because of glob expansion and in part because Unix has supported long file names for much longer than DOS.</p><p>Unfortunately&mldr; DOS restricted command lines to a maximum of 126 characters&mdash;fewer characters than you can fit in a Tweet or an SMS&mdash;and this posed a problem because the build process of most GNU developer tools, if not all, required using long command lines. To resolve these issues, DJGPP provides two features.</p><p>The first is support for response files. Response files are text files that contain the full command line. These files are then passed to a process with the <code>@file.txt</code> syntax, which then causes DJGPP&rsquo;s <code>crt1</code> code to load the response files and construct the long command line in extended memory.</p><p>Let&rsquo;s take a look. If we reuse our previous <code>showargs.c</code> program that prints the command line arguments, we can observe how the behavior differs between building this program with a standard DOS compiler and with DJGPP:</p><figure><img src=/images/2024-02-14-showargs-response-files-gcc-tcc.png></figure><p>Response files are easy to implement and they are sufficient to support long command lines: even if they require special handling on the caller side to write the arguments to disk and then place the response file as an argument, this could all be hidden inside the <code>exec</code> family of system calls. Unfortunately, using response files is slow because, in order to invoke a program, you need to write the command line to a file&mdash;only to load it immediately afterwards. And disk I/O used to be really slow.</p><p>For this reason, DJGPP provides a different mechanism to pass long command lines around, and this is via the transfer buffer described earlier. This mechanism involves putting the command line in the transfer buffer and telling the executed command where its command line lives. This mechanism obviously only works when executing a DJGPP program from another DJGPP program, because no matter what, process executions are still routed through DOS and thus are bound by DOS&rsquo; 126 character limit.</p><p>Let&rsquo;s try this too. For this experiment, we&rsquo;ll play with two programs: one that prints the length of the received command line and another one that produces a long command line and executes the former.</p><p>The first program is <code>longcmd1.c</code> and is depicted below. All this program does is allocate a command line longer than DOS&rsquo; maximum length of 126 characters and, once it has built the command line, invokes <code>longcmd2.exe</code> with said long command line:</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifdef __GNUC__
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;process.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>**</span> <span class=n>longcmd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Generate a command line that exceeds DOS&#39; limits.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>longcmd</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>**</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>longcmd</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>31</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>longcmd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;one-argument&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>longcmd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Execute the second stage of this demo to print the received
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// command line.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>execv</span><span class=p>(</span><span class=s>&#34;.</span><span class=se>\\</span><span class=s>longcmd2.exe&#34;</span><span class=p>,</span> <span class=n>longcmd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;execv failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>EXIT_FAILURE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/djgpp/longcmd1.c type=text/plain>longcmd1.c</a></div></div></div><p>The second program is <code>longcmd2.c</code> and is depicted below. This program prints the number of arguments it received and also computes the length of the command line (assuming all arguments were separated by just one space character):</p><div class=src><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// Assume 1 space between arguments.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;argc after re-exec: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;textual length: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>total</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>EXIT_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=footer><div class=filename><a href=/src/djgpp/longcmd2.c type=text/plain>longcmd2.c</a></div></div></div><p>Now let&rsquo;s see what happens when we compile these two programs with Turbo C++ and with DJGPP. First, let&rsquo;s build both with Turbo C++ and run the <code>longcmd1.exe</code> entry point:</p><figure><img src=/images/2024-02-14-longcmd-both-tcc.png></figure><p>Running <code>longcmd1.exe</code> fails because the command line is too long and <code>execv</code> cannot process it. (I&rsquo;m not exactly sure why <code>execv</code> returns <code>ENOMEM</code> because the Turbo C++ documentation claims that this function should return <code>E2BIG</code> on this condition, but alas.)</p><p>Now, let&rsquo;s build <em>just</em> <code>longcmd1.c</code> with DJGPP and run it:</p><figure><img src=/images/2024-02-14-longcmd-1gcc-2tcc.png></figure><p>We get a bit further now! <code>longcmd1.exe</code> runs successfully and executes <code>longcmd2.exe</code>&mldr; but <code>longcmd2.exe</code> claims that the command line is shorter than we expect. This is because DJGPP&rsquo;s <code>execv</code> implementation knew that it was running a standard DOS application <em>not</em> built by DJGPP, so it had to place a truncated command line in the system call issued to DOS. (As a detail also note that this shows 141 and not 126: the reason for this is that DOS does <em>not</em> place <code>argv[0]</code> on the command line, but the C runtime has to synthesize this value.)</p><p>But now look at what happens when we <em>also</em> compile <code>longcmd2.c</code> with DJGPP:</p><figure><img src=/images/2024-02-14-longcmd-both-gcc.png></figure><p>Ta-da! When <code>longcmd2.exe</code> runs, it now sees the full command line. This is because <code>longcmd1.exe</code> now knows that <code>longcmd2.exe</code> understands the transfer buffer arrangement and can send the command line to it this way.</p><p>You can read more about this in the <a href=https://www.delorie.com/djgpp/doc/libc/libc_736.html>spawn documentation</a> from DJGPP&rsquo;s libc and peek at the <a href="https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/process/dosexec.c?rev=1.29"><code>dosexec.c</code> sources</a>.</p><h1 id=unix-style-paths>Unix-style paths</h1><p>Let&rsquo;s move on to one more Unix-y thing that DJGPP has to deal with, which is paths and file names. You see, paths are paths in both DOS and Unix: a sequence of directory names (like <code>/usr/bin/</code>) followed by an optional file name (like <code>/usr/bin/gcc</code>). Unfortunately, DOS and Unix paths differ in two aspects.</p><p>The first is that DOS paths separate directory components with a backslash, not a forward slash. This is a historical artifact of the early CP/M and DOS days, where command-line flags used the forward slash (<code>DIR /P</code>) instead of Unix&rsquo;s dash (<code>ls -l</code>). When DOS gained support for directories in its 2.0 release, it had to pick a different character to separate directories, and it picked the backslash. Dealing with this duality in DJGPP-built programs seems easy: just make DJGPP&rsquo;s libc functions allow both and call it a day. And for the most part, this works&mdash;and in fact even PowerShell does this on Windows today.</p><p>The second is that DOS paths may include an optional drive name such as <code>C:</code> and&mldr; the drive name has the colon character in it. While Unix uses the colon character to separate multiple components of the search <code>PATH</code>, DOS could not do that: it had to pick a different character, and it picked the semicolon. Take a look:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>C:\&gt;path
</span></span><span class=line><span class=cl>PATH=Z:\;C:\DEVEL\BIN;C:\DEVEL\DJGPP\BIN;C:\DEVEL\TC\BIN
</span></span></code></pre></div><p>The problem here is that many Unix applications, particularly shell scripts like <code>configure</code>&mdash;especially <code>configure</code>&mdash;read the value of the <code>PATH</code> variable and split it at colon separators or append to it by adding a colon. But if we do these textual manipulations on a DOS-style <code>PATH</code> like the one shown above&mldr; we&rsquo;ll get the wrong behavior because of the drive names&mdash;and Unix programs don&rsquo;t know they have to split on the semicolon instead and we cannot be expected to fix them all.</p><p>The way DJGPP deals with this is by faking the <code>/dev/</code> device tree. While DJGPP provides implementations of things like <code>/dev/null</code>, it also exposes DOS drives via their corresponding <code>/dev/[a-z]/</code> virtual <em>directory</em>. So, if you wanted to run applications that parse or modify the <code>PATH</code>, you could rewrite the above as this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>PATH=/dev/z:/dev/c/devel/bin:/dev/c/devel/djgpp/bin:/dev/c/devel/tc/bin
</span></span></code></pre></div><p>This would allow any application reading the <code>PATH</code> to continue to work. But note that this value doesn&rsquo;t seem to leave the realm of the current process, which is interesting:</p><figure><img src=/images/2024-02-14-bash-path.png></figure><p>The picture above shows how bash sees a DOS-style <code>PATH</code> after it starts. Manually setting it to a Unix path keeps the Unix path in the current process (as shown by the built-in <code>echo</code> calls), but when we spawn a different one (<code>env</code> is a separate executable), the value is reset. This makes sense because, if we are running a regular DOS program from within a DJGPP one, we want to export a DOS-compatible environment. Which means the Unix variants probably only stick within shell scripts. You can also see how this works by peeking at <a href=https://www.delorie.com/bin/cvsweb.cgi/djgpp/src/libc/dos/process/dosexec.c><code>dosexec.c</code></a> again.</p><p>But wait a minute&mldr; did I just show you bash?! On DOS? Oh yes, yes I did&mldr;</p><h1 id=trying-it-out-yourself>Trying it out yourself</h1><p>It&rsquo;s time to get our hands dirty, try this out, and reminisce the old days! Or, actually, not <em>so</em> old. You should know that DJGPP is <em>still</em> available in this day and age and that it is quite up to date with GCC 12.3&mdash;released less than a year ago.</p><p>First off, start by installing DOSBox. You can use the <a href="https://www.dosbox.com/download.php?main=1">standard DOSBox version</a>, but it&rsquo;s probably better to go the <a href=https://dosbox-x.com/>DOSBox-X route</a> so that you can get Long File Name (LFN) support by setting the <code>ver=7.1</code> configuration option. Otherwise, beware that running Bash later on will create <code>.bash_history</code> under <code>C:\</code> but the file will be named <code>.BAS</code> due to some odd truncation, and this will later confuse Bash on a second start and assume that <code>.BAS</code> is actually <code>.bash_login</code>.</p><p>Now, <a href=https://www.delorie.com/djgpp/getting.html>pick a mirror</a> for your downloads. You&rsquo;ll see various uses of FTP in the list but don&rsquo;t be surprised if clicking on those doesn&rsquo;t work: major browsers have unfortunately dropped their FTP client so you&rsquo;ll have to &ldquo;fall back&rdquo; to an HTTP mirror.</p><p>From there, you can use the <a href=https://www.delorie.com/djgpp/zip-picker.html>Zip Picker</a> to help you choose what you need or you can download the same files I did:</p><ul><li><code>v2apps/csdpmi7b.zip</code>: The <code>CWSDPMI</code> free DPMI host.</li><li><code>v2apps/rhid15ab.zip</code>: The RHIDE <a href=/2023/12/the-ides-we-had-30-years-ago.html>console IDE</a> akin to Turbo C++.</li><li><code>v2/djdev205.zip</code>: Base DJGPP tools.</li><li><code>v2gnu/bnu2351b.zip</code>: GNU Binutils (tools like <code>gas</code> and <code>objdump</code>).</li><li><code>v2gnu/bsh4253b.zip</code>: GNU Bash.</li><li><code>v2gnu/em2802b.zip</code>: GNU Emacs.</li><li><code>v2gnu/fil41br3.zip</code>: GNU coreutils (tools like <code>ls</code> and <code>cp</code>).</li><li><code>v2gnu/gcc930b.zip</code>: GCC itself.</li><li><code>v2gnu/gdb801b.zip</code>: GDB because why not.</li><li><code>v2gnu/gpp930b.zip</code>: G++.</li><li><code>v2gnu/grep228b.zip</code>: grep because I find it very handy.</li><li><code>v2gnu/mak44b.zip</code>: GNU Make.</li><li><code>v2gnu/shl2011br3.zip</code>: Various shell utilities (like <code>basename</code> and <code>dirname</code>) that you&rsquo;ll almost-certainly need to run shell scripts.</li><li><code>v2gnu/txt20br3.zip</code>: GNU textutils (tools like <code>cat</code> and <code>cut</code>).</li></ul><p>Once you have those files, create the &ldquo;root&rdquo; directory for what will be the <code>C:</code> drive in DOSBox. I keep this under <code>~/dos/</code> and it is much easier to prepare this directory from <em>outside</em> of DOSBox. Within that location, create a <code>djgpp</code> subdirectory and unpack <em>all</em> the zip files you downloaded into it. If there are any file conflicts, just tell unzip to overwrite them.</p><p>Once the unpacking finishes, go to your DOSBox configuration. If you are on Windows, you should have a start menu entry called &ldquo;DOSBox 0.74-3 Options&rdquo; or similar which opens the configuration file in Notepad. If you are on Linux or any other reasonable OS, you can find the configuration file under <code>~/.dosbox/</code>. In the configuration, you&rsquo;ll want to set up the <code>C:</code> drive at the very bottom of the file where the <code>[autoexec]</code> section is. Here is what I do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>[autoexec]
</span></span><span class=line><span class=cl>MOUNT C C:\Users\jmmv\dos
</span></span><span class=line><span class=cl>SET PATH=%PATH%;C:\DJGPP\BIN
</span></span><span class=line><span class=cl>SET DJGPP=C:\DJGPP\DJGPP.ENV
</span></span><span class=line><span class=cl>C:
</span></span></code></pre></div><p>Launch DOSBox and you are set. Enter full-screen by pressing <code>Alt+Enter</code> for the full retro experience and then&mldr; launch <code>bash</code>:</p><figure><img src=/images/2024-02-14-dosbox-djgpp.png></figure><p>Pretty neat stuff, huh?</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2024/02/to-c-or-not-to-c.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>ðŸ‘
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>ðŸ‘Ž
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Running+GNU+on+DOS+with+DJGPP&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fdjgpp.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Running+GNU+on+DOS+with+DJGPP&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fdjgpp.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Running+GNU+on+DOS+with+DJGPP+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fdjgpp.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>