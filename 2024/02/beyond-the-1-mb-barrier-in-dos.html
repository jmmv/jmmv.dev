<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Beyond the 1 MB barrier in DOS - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Beyond the 1 MB barrier in DOS - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Beyond the 1 MB barrier in DOS - Julio Merino (jmmv.dev)"><meta name=description content="In &amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.
I know I promised that this follow-up article would be about DJGPP, but before getting into that review, I realized I had to take another detour to cover three more topics. Namely: unreal mode, which I intentionally ignored to not derail the post; LOADALL, which I didn&amp;rsquo;t know about until you readers mentioned it; and DOS extenders, which I was planning to describe in the DJGPP article but they are a better fit for this one.
So&amp;hellip; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&amp;rsquo;ll go over assembly code for a step-by-step jump into unreal mode.
"><meta property="og:description" content="In &amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.
I know I promised that this follow-up article would be about DJGPP, but before getting into that review, I realized I had to take another detour to cover three more topics. Namely: unreal mode, which I intentionally ignored to not derail the post; LOADALL, which I didn&amp;rsquo;t know about until you readers mentioned it; and DOS extenders, which I was planning to describe in the DJGPP article but they are a better fit for this one.
So&amp;hellip; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&amp;rsquo;ll go over assembly code for a step-by-step jump into unreal mode.
"><meta property="twitter:description" content="In &amp;ldquo;From 0 to 1 MB in DOS&amp;rdquo;, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&amp;mdash;even …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/02/beyond-the-1-mb-barrier-in-dos.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-02-07-80386-dos.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2024-02-07-80386-dos.jpg"><meta property="og:image:alt" content="<a href=&#34;https://en.wikipedia.org/wiki/I386#/media/File:KL_Intel_i386DX.jpg&#34;>Intel 80386 chip</a> vs. the <a href=&#34;https://en.m.wikipedia.org/wiki/File:Msdos-icon.svg&#34;>MS-DOS logo</a>. Images from the Wikipedia.</figcaption>"><meta property="twitter:image:alt" content="<a href=&#34;https://en.wikipedia.org/wiki/I386#/media/File:KL_Intel_i386DX.jpg&#34;>Intel 80386 chip</a> vs. the <a href=&#34;https://en.m.wikipedia.org/wiki/File:Msdos-icon.svg&#34;>MS-DOS logo</a>. Images from the Wikipedia.</figcaption>"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src=https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzAyL2JleW9uZC10aGUtMS1tYi1iYXJyaWVyLWluLWRvcy5odG1s/stamp.gif style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/beyond-the-1-mb-barrier-in-dos")</script><header class=site-header><nav class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Beyond the 1 MB barrier in DOS</h1><p>February 7, 2024 &#183;
About 24 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/dos>dos</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/beyond-the-1-mb-barrier-in-dos>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-02-07-80386-dos.jpg style=max-width:100%><figcaption><a href=https://en.wikipedia.org/wiki/I386#/media/File:KL_Intel_i386DX.jpg>Intel 80386 chip</a> vs. the <a href=https://en.m.wikipedia.org/wiki/File:Msdos-icon.svg>MS-DOS logo</a>. Images from the Wikipedia.</figcaption></figcaption></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>In <a href=/2024/01/from-0-to-1-mb-in-dos.html>&ldquo;From 0 to 1 MB in DOS&rdquo;</a>, I presented an overview of all the ways in which DOS and its applications tried to maximize the use of the 1 MB address space inherited from the 8086&mdash;even after the 80286 introduced support for 16 MB of memory and the 80386 opened the gates to 4 GB.</p><p>I know I promised that this follow-up article would be about DJGPP, but before getting into <em>that</em> review, I realized I had to take another detour to cover three more topics. Namely: <em>unreal mode</em>, which I intentionally ignored to not derail the post; <em>LOADALL</em>, which I didn&rsquo;t know about until you readers mentioned it; and <em>DOS extenders</em>, which I was planning to describe in the DJGPP article but they are a better fit for this one.</p><p>So&mldr; strap your seat belts on and dive right in for another tour through the ancient techniques that DOS had to pull off to peek into the memory address space above the first MB. And get your hands ready because we&rsquo;ll go over assembly code for a step-by-step jump into unreal mode.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=what-is-unreal-mode-anyway>What is unreal mode anyway?</h1><p>Having read the preceding post, you should know by now what the real, protected, and VM86 modes of the x86 processors are. But there is one extra unofficial mode I did not talk about, and that is the <em>unreal mode</em>. The mode with the coolest name if you ask me.</p><p>Unreal mode is a special state of the processor in which the CPU acts as if it was in real mode&mldr; but with segment descriptors that allow it to reference memory above the 1 MB limit. These segments are impossible to define in real mode but, with different tricks for the 80286 and 80386, they become a possibility.</p><p>To understand how unreal mode works, we need to go back to the diagram I presented earlier describing the address resolution process that the 80286&rsquo;s MMU executes on every memory access:</p><figure><img src=/images/2024-01-17-80286-mmu-access.png><figcaption>Diagram representing the operations that the 80286 does, in hardware, to resolve a <tt>segment:address</tt> memory reference.</figcaption></figure><p>As you can see in the diagram, for every memory access of the form <code>segment:offset</code>, the MMU:</p><ol><li>decodes the segment selector specified by <code>segment</code> to determine whether to query the GDT or LDT and which segment descriptor to read,</li><li>reads the determined segment descriptor by indexing into the GDT or LDT tables,</li><li>decodes the segments&rsquo; base address and limit as stored in the descriptor,</li><li>checks the privileges of the executing code against the protections recorded in the descriptor,</li><li>and ensures the <code>offset</code> is within the segment limit defined in the descriptor.</li></ol><p>Only after these steps complete successfully, the memory access is allowed; otherwise, the processor raises a General Protection Fault exception.</p><p>This is all conceptually good until you realize that the GDT and LDT live in main memory&mldr; and main memory is slow&mdash;<em>excruciatingly</em> so in processor time. Having to read from main memory to resolve <em>every</em> memory access, even with a good L1 or L2 cache, would have a big performance impact on most applications.</p><p>To resolve this inefficiency, the processor has a cache of segment descriptors. Instructions that update the segment registers, such as <code>MOV DS, AX</code>, fetch descriptors from the GDT or LDT tables and store them in the cache. Instructions that reference memory, such as <code>MOV AX, DS:1234h</code>, read the descriptors from the cache without ever reaching out to main memory.</p><figure><img src=/images/2024-02-07-descriptor-cache.png><figcaption>Diagram representing how the instructions used to load a register like <tt>DS</tt> are decoupled from the instructions that later consume the details about <tt>DS</tt>. It is crucial to note how the segment descriptor cache completely shields the second instruction from accessing main memory to resolve the address.</figcaption></figure><p>So far so good, but let&rsquo;s add another twist. The diagram I presented earlier showing how the 80286 resolves a memory address does not only apply to protected mode: it applies to real mode too. In both modes, the processor accesses the descriptor cache to peek at the segment limits and protection settings. This means that, for real mode to work as 8086 code expects, the cache must contain values that are compatible with real mode: in particular, the limits must be set to 64 KB.</p><p>But what if we could somehow load arbitrary segment descriptors into the processor&rsquo;s cache and leverage those in real mode? If we could do that, we could increase the segment limits stored in the cache, and then any memory references that use those cached descriptors would be able to bypass the real mode rules and access extended memory directly.</p><p>And this, dear reader, is what unreal mode is about. There is a ton of nuance about how this mode was discovered and how it got its name, and to learn more about that story, I&rsquo;ll redirect you to <a href=https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/>OS/2 Museum&rsquo;s excellent history of the unreal mode</a>. But keep in mind that unreal mode is a clutch that DOS applications used to access memory above the 1 MB mark while avoiding expensive protected mode switches.</p><h1 id=leveraging-unreal-mode>Leveraging unreal mode</h1><p>Before describing how we can switch the processor to unreal mode, we must first look at how we can actually take advantage of this mode.</p><p>In the 80286 case, unreal mode is annoying to use: the 80286 is a 16-bit CPU, which means that the <code>offset</code> part of a memory reference is limited to 64 KB. We can configure segments whose base address lies beyond the 1 MB address space, allowing us to read extended memory from real mode, but we can only do so in 64 KB chunks at a time.</p><p>The 80386 fares better due to it being a 32-bit CPU: the <code>offset</code> part of a memory reference can be expressed as a 32-bit quantity. We can do both <code>MOV AX, DS:[SI]</code> and <code>MOV AX, DS:[ESI]</code>, which means that if <code>DS</code> has a base of zero, we can reference any memory position in the 4 GB address space when using the <code>ESI</code> offset. Crucially, and contrary to what some people think, we can issue these two variants from 16-bit real mode: 32-bit instructions are <em>not</em> restricted to protected mode.</p><p>The way the 80386 allows 32-bit instructions in 16-bit mode and vice versa is via two properties. The first is an instruction width setting at the code segment level: segment descriptors can indicate that the code they contain is 16-bit or 32-bit. The default for real mode is to assume that code segments are set to 16 bits, but in protected mode we can choose whatever we prefer. The second is the <code>0x66</code> instruction prefix, which tells the processor that the following instruction operates in <em>the opposite</em> mode of what is configured in the current code segment: e.g. if the current code segment is a 16-bit segment, the <code>0x66</code> prefix marks 32-bit instructions.</p><p>Knowing this, we can see that unreal mode is most useful in the 80386 because, once enabled, code can easily reference any extended memory address using 32-bit offsets and the <code>0x66</code> prefix. But the 16-bit constraints of the 80286 don&rsquo;t make unreal mode less useful given how much the DOS ecosystem needed to escape the real mode address space limitations and how difficult it was to leave protected mode in the 80286.</p><p>With that out of the way, what we are missing in our discussion are the ways by which to enter unreal mode. There are at least two: the undocumented LOADALL instruction and an unsupported jump from protected mode to real mode. Let&rsquo;s take a look at both.</p><h1 id=loadall>LOADALL</h1><p>LOADALL is an undocumented instruction of the 80286 and 80386 processors. This instruction has a long history and I&rsquo;m not going to cover it in detail because <a href=https://rep-lodsb.mataroa.blog/blog/intel-286-secrets-ice-mode-and-f1-0f-04/>others have done a much better job than I could</a>. I&rsquo;ll restrict my explanation to what the instruction does and why it is useful to enter unreal mode.</p><p>Simply put, all LOADALL does is, as its name implies, set all processor registers at once with values that come from a memory region. This is similar to the widely unused built-in task switching functionality of x86 processors, which reloads the processor state with register values stored in a <a href=https://en.wikipedia.org/wiki/Task_state_segment>Task State Segment (TSS)</a> descriptor.</p><p>But LOADALL has some quirks that the TSS descriptor doesn&rsquo;t have, and those are what make it interesting. Witness the contents of the memory that LOADALL reads on an 80286:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Physical Address    CPU Register
</span></span><span class=line><span class=cl>----------------    ------------
</span></span><span class=line><span class=cl>0800h-0805h         None
</span></span><span class=line><span class=cl>0806h-0807h         MSW
</span></span><span class=line><span class=cl>0808h-0815h         None
</span></span><span class=line><span class=cl>0816h-0817h         TR
</span></span><span class=line><span class=cl>0818h-0819h         Flag word
</span></span><span class=line><span class=cl>081Ah-081Bh         IP
</span></span><span class=line><span class=cl>081Ch-081Dh         LDT
</span></span><span class=line><span class=cl>081Eh-081Fh         DS
</span></span><span class=line><span class=cl>0820h-0821h         SS
</span></span><span class=line><span class=cl>0822h-0823h         CS
</span></span><span class=line><span class=cl>0824h-0825h         ES
</span></span><span class=line><span class=cl>0826h-0827h         DI
</span></span><span class=line><span class=cl>0828h-0829h         SI
</span></span><span class=line><span class=cl>082Ah-082Bh         BP
</span></span><span class=line><span class=cl>082Ch-082Dh         SP
</span></span><span class=line><span class=cl>082Eh-082Fh         BX
</span></span><span class=line><span class=cl>0830h-0831h         DX
</span></span><span class=line><span class=cl>0832h-0833h         CX
</span></span><span class=line><span class=cl>0834h-0835h         AX
</span></span><span class=line><span class=cl>0836h-083Bh         ES descriptor cache
</span></span><span class=line><span class=cl>083Ch-0841h         CS descriptor cache
</span></span><span class=line><span class=cl>0842h-0847h         SS descriptor cache
</span></span><span class=line><span class=cl>0848h-084Dh         DS descriptor cache
</span></span><span class=line><span class=cl>084Eh-0853h         GDTR
</span></span><span class=line><span class=cl>0854h-0859h         LDT descriptor cache
</span></span><span class=line><span class=cl>085Ah-085Fh         IDTR
</span></span><span class=line><span class=cl>0860h-0865h         TSS descriptor cache
</span></span></code></pre></div><p>Registers, registers, more registers, descriptor cache&mldr; Wait, what? Entries for the <em>cached</em> segment descriptors? That&rsquo;s interesting. These are the actual values for the segment descriptors that the processor stores in its internal cache. Which means that, by issuing a carefully-crafted LOADALL, we can tell the processor to set the cached descriptors to values that are nonsensical for the current operation mode&mdash;and the processor does <em>not</em> complain.</p><p>In essence, with just one instruction, we can tell the processor that the cached descriptors have base addresses above the 1 MB limit and/or that they have limits larger than 64 KB. And the processor will just accept those into the cache and use them for future memory references.</p><p>As it turns out, <a href=https://www.os2museum.com/wp/himem-sys-unreal-mode-and-loadall/><code>HIMEM.SYS</code> did leverage LOADALL</a> and we can even find its <a href=https://github.com/neozeed/himem.sys-2.06>original source code</a> to peek into <a href=https://github.com/neozeed/himem.sys-2.06/blob/main/oemsrc/xm286.asm#L241>how it achieved</a> this feat. It&rsquo;s not trivial to do, but the performance gains of such an undocumented instruction were too hard to pass on in order to implement efficient transfers between conventional and extended memory.</p><p>This made me curious so I tried replicating LOADALL&rsquo;s usage in <a href=https://www.dosbox.com/>DOSBox</a> and&mldr; failed because DOSBox does not implement this instruction&mdash;which is understandable because it was not documented, it was very specific to two processors, and it apparently was not widely used outside of <code>HIMEM.SYS</code>. Maybe more-accurate processor emulators supply it, but I didn&rsquo;t bother trying.</p><p>Which brings us to the other way to enter unreal mode: an unsupported jump from protected mode to real mode in the 80386.</p><h1 id=real-to-protected-mode-and-back>Real to protected mode and back</h1><p>Protected mode fascinated me as a child when I read about it in books that didn&rsquo;t &ldquo;belong&rdquo; to my age. After having dipped my toes in 8086 assembly and having toyed around with boot sectors and the like, I fantasized about how protected mode &ldquo;unlocked&rdquo; enormous power. I knew I had to learn such black arts to write my own operating system and I remember writing code that tried to enter protected mode and always failed&mdash;yet it sounded so easy from the books: just set bit 0 of <code>CR0</code> to 1!</p><figure><img src=/images/2024-02-07-assembly-books.jpg><figcaption>The assembly and processor books I read once upon a time and that got me interested in all of this low-level systems programming.</figcaption></figure><p>It wasn&rsquo;t until many years later, around 2007, that I decided I wanted to fulfill my long-term dream to write an operating system. At that point, I invested some time to get protected mode to work&mdash;and I finally did, with interrupts enabled and all. (Spoiler alert: I never got to write an OS though&mldr; yet?) But even if that worked, getting into protected mode is always a frustrating experience of having to get many teeny tiny details right just so that the machine doesn&rsquo;t crash. You do it right and you see absolutely nothing; you do it wrong and you see absolutely nothing either.</p><p>But wait. Why am I telling you all this? Ah yes, because another way of entering unreal mode is the following dance:</p><ol><li>Switch to protected mode.</li><li>Set up segment registers to segment descriptors that provide access to the full address space, causing the cached descriptors to have a 4 GB limit.</li><li>Switch back to real mode with the previous unsupported segment configuration in place.</li></ol><p>Upon switching back to real mode, the properties of the segment descriptors that don&rsquo;t make sense in real mode (those limits higher than 64 KB) are <em>sticky</em>, meaning that no architectural operations such as <code>MOV DS, AX</code> touch those bits of the cache. With that, it becomes possible to address extended memory.</p><figure><img src=/images/2024-02-07-real-mode-load.png><figcaption>Diagram representing how a real mode segment descriptor load does <i>not</i> modify the limit or flags already stored in the descriptor cache.</figcaption></figure><p>Unfortunately, the 80286 did not have a mechanism to switch from protected mode back to real mode. Creative folks found ways to do this by triple-faulting the CPU and carefully setting registers to skip the BIOS POST code, but this process was extremely slow and thus unfeasible for frequent switches. At the time, the lack of this feature in the 80286 was a major complaint from OS vendors because it made it difficult to support running DOS programs from within a modern operating system.</p><p>Intel addressed those concerns with the launch of the 80386 and its new VM86 mode. But&mldr; that wasn&rsquo;t the only change. The 80386 also added the ability to return to real mode from protected mode&mdash;with a lot of caveats. Intel was prescriptive in how exactly to return to real mode and never described what would happen if you didn&rsquo;t follow the rules to the letter&mldr; which was essentially begging for someone to try and see what would happen when doing that.</p><p>The answer, as we saw above, is unreal mode.</p><h1 id=hands-on-unreal-mode>Hands-on unreal mode</h1><p>All of the above research made me really curious so I got the urge to see unreal mode in action. So, in preparation for this article, I wrote a trivial DOS program that enters unreal mode and shows it working.</p><p>As in the past, getting this demo to a functional state was a frustrating experience of fighting with carefully-crafted register values and memory offsets, DOSBox crashes, and <a href=https://bochs.sourceforge.io/>Bochs</a> oddities. But in the end my demo ran successfully, and because I couldn&rsquo;t find any trivial, readily-available sample piece of code online that did this, I concluded that I <em>had to</em> present it to you here for posterity&rsquo;s sake.</p><p>So. Let&rsquo;s get our hands dirty. All you need is <a href=https://github.com/doomemacs/doomemacs><del>Doom Emacs</del></a> a text editor, <a href=https://www.nasm.org/>NASM</a>, and DOSBox. Our goal is to:</p><ol><li>write a flat COM executable,</li><li>without sections (code and data mixed),</li><li>all in 16-bit code with the occasional 32-bit operation override,</li><li>that enters protected mode,</li><li>that stores a string somewhere in extended memory far from the reach of real mode,</li><li>that drops back to (un)real mode,</li><li>that copies the string we stored in extended memory to conventional memory,</li><li>that tells DOS to print the string we fetched,</li><li>and that finally returns to DOS to prove that DOS still works.</li></ol><p>Let&rsquo;s begin.</p><p>The first thing we have to do is set up the GDT. We&rsquo;ll use statically-configured descriptors in the code, like these:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>;;; Null descriptor.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>dq</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>;;; Code descriptor for this binary.  The base address needs fixup at
</span></span></span><span class=line><span class=cl><span class=c1>;;; runtime to point to the location where the code was loaded.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>CODE_DESC</span>       <span class=no>equ</span> <span class=mi>1</span> <span class=err>&lt;&lt;</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>                <span class=nf>dw</span> <span class=mi>0</span><span class=no>ffffh</span>       <span class=c1>; Low 16 bits of the limit.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>code_base_low</span>   <span class=no>dw</span> <span class=mi>0</span>            <span class=c1>; Low 16 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>code_base_mid</span>   <span class=no>db</span> <span class=mi>0</span>            <span class=c1>; Middle 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>10011110</span><span class=no>b</span>    <span class=c1>; Code/data, exec, conforming, read allowed.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>00000000</span><span class=no>b</span>    <span class=c1>; Not 4KB, 16-bit, no long mode, limit 00h.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>code_base_high</span>  <span class=no>db</span> <span class=mi>0</span>            <span class=c1>; High 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>;;; Data/stack descriptor for this binary.  The base address needs fixup
</span></span></span><span class=line><span class=cl><span class=c1>;;; at runtime to point to the location where the code was loaded.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>DATA_DESC</span>       <span class=no>equ</span> <span class=mi>2</span> <span class=err>&lt;&lt;</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>                <span class=nf>dw</span> <span class=mi>0</span><span class=no>ffffh</span>       <span class=c1>; Low 16 bits of the limit.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>data_base_low</span>   <span class=no>dw</span> <span class=mi>0</span>            <span class=c1>; Low 16 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>data_base_mid</span>   <span class=no>db</span> <span class=mi>0</span>            <span class=c1>; Middle 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>10010010</span><span class=no>b</span>    <span class=c1>; Code/data, data, grows up, read-write.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>00000000</span><span class=no>b</span>    <span class=c1>; Not 4KB, 16-bit, no long mode, limit 00h.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>data_base_high</span>  <span class=no>db</span> <span class=mi>0</span>            <span class=c1>; High 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>;;; Linear data descriptor covering the full 4 GB address space.  No fixup
</span></span></span><span class=line><span class=cl><span class=c1>;;; necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>LINEAR_DESC</span>     <span class=no>equ</span> <span class=mi>3</span> <span class=err>&lt;&lt;</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>                <span class=nf>dw</span> <span class=mi>0</span><span class=no>ffffh</span>       <span class=c1>; Low 16 bits of the limit.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>dw</span> <span class=mi>0</span>            <span class=c1>; Low 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>0</span>            <span class=c1>; Middle 8 bits of the base address.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>10010010</span><span class=no>b</span>    <span class=c1>; Code/data, data, grows up, read-write.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>11001111</span><span class=no>b</span>    <span class=c1>; 4KB, 16-bit, no long mode, limit=0fh.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>db</span> <span class=mi>0</span>            <span class=c1>; High 8 bits of the base address.
</span></span></span></code></pre></div><p>The GDT presented above defines four descriptors:</p><ol><li>The null descriptor, which is unused but must be present.</li><li>The code descriptor (<code>CODE_DESC</code>) for our COM executable. This is configured to 16 bits so that we don&rsquo;t have to mix 16-bit and 32-bit sections in the same source file (which is easy but I wanted to avoid). Note also that the base address is zero, but we&rsquo;ll have to patch it up at runtime to point to the actual location where DOS loaded our executable. We cannot predict this and all the offsets built into the code must remain valid when in protected mode, so we must compute this dynamically.</li><li>The data and stack descriptor (<code>DATA_DESC</code>) for our COM executable. For the same reasons as the code descriptor, we must compute its base address at runtime.</li><li>A linear data descriptor (<code>LINEAR_DESC</code>) to be able to reference the whole 4 GB address space. We&rsquo;ll use this one to set up the segments for unreal mode.</li></ol><p>Next up, we need to define the descriptor for the GDT itself right after the GDT data section:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>gdt_desc</span>        <span class=no>equ</span> <span class=no>$-gdt</span>
</span></span><span class=line><span class=cl><span class=nf>gdt_base</span>        <span class=no>dd</span> <span class=mi>0</span>
</span></span></code></pre></div><p>Easy, but again, note how <code>gdt_base</code> is zero. The address to the GDT needs to be a linear address, and because we don&rsquo;t know where the COM file will be loaded, we have to compute this address at runtime.</p><p>After this, it&rsquo;s time to start the code section. The first thing we do is fix up all of the base addresses we left blank in the GDT itself and the GDT descriptor. Note that, because we target a COM binary (or a boot sector if you are so inclined), we can assume that <code>CS</code>, <code>DS</code>, <code>ES</code>, and <code>SS</code> all point to the same place, which makes things significantly easier:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Assume CS = DS = ES = SS (COM file or boot sector).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=p>[</span><span class=no>real_cs</span><span class=p>],</span> <span class=no>cs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; Populate the GDT code and data descriptors with our actual base address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>;; so that the built-in code offsets work once we enter protected mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>xor</span> <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=no>cs</span>
</span></span><span class=line><span class=cl>    <span class=nf>shl</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>code_base_low</span><span class=p>],</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>data_base_low</span><span class=p>],</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=nf>shr</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>16</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>code_base_mid</span><span class=p>],</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>data_base_mid</span><span class=p>],</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>code_base_high</span><span class=p>],</span> <span class=no>ah</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>data_base_mid</span><span class=p>],</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; Populate the GDT descriptor with the linear address of the GDT.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>xor</span> <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=no>ds</span>
</span></span><span class=line><span class=cl>    <span class=nf>shl</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span> <span class=no>eax</span><span class=p>,</span> <span class=no>gdt</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=p>[</span><span class=no>gdt_base</span><span class=p>],</span> <span class=no>eax</span>
</span></span></code></pre></div><p>Then, we do preparatory work to enter protected mode: namely, we disable the <a href=https://wiki.osdev.org/Non_Maskable_Interrupt>Non-Maskable Interrupt (NMI)</a> and interrupts in general, and we enable the A20 gate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Disable the Non-Maskable Interrupt (NMI) and interrupts.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>in</span> <span class=no>al</span><span class=p>,</span> <span class=mi>70</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>or</span> <span class=no>al</span><span class=p>,</span> <span class=mi>80</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>out</span> <span class=mi>70</span><span class=no>h</span><span class=p>,</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>    <span class=nf>in</span> <span class=no>al</span><span class=p>,</span> <span class=mi>71</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>cli</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; Enable the A20 gate.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>in</span> <span class=no>al</span><span class=p>,</span> <span class=mi>92</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>or</span> <span class=no>al</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nf>out</span> <span class=mi>92</span><span class=no>h</span><span class=p>,</span> <span class=no>al</span>
</span></span></code></pre></div><p>And then, we can finally do the magic to enter protected mode by loading the GDT descriptor, updating the <code>PE</code> (0th) bit in the <code>CR0</code> register, and doing a long jump:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Load the GDT.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>lgdt</span> <span class=p>[</span><span class=no>gdt_desc</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; Enable protected mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=no>cr0</span>
</span></span><span class=line><span class=cl>    <span class=nf>or</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>cr0</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; Flush out the processor pipeline and reload CS.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>jmp</span> <span class=no>CODE_DESC</span><span class=p>:</span><span class=no>protected_mode</span>
</span></span></code></pre></div><p>That&rsquo;s it. We have reached the protected mode realm! How exciting is <em>that</em>? We are now in a 16-bit code segment but the machine state is mostly &ldquo;unusable&rdquo;. None of the segment registers except <code>CS</code> are valid and interrupts are disabled (because we didn&rsquo;t bother to set up the IDT&mdash;and we don&rsquo;t have to for this simple experiment). So let&rsquo;s do the minimum set up that we need:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>protected_mode:</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; Set up the data and stack segments.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=no>DATA_DESC</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>ds</span><span class=p>,</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>ss</span><span class=p>,</span> <span class=no>ax</span>
</span></span></code></pre></div><p>Now that the basic segments are configured, let&rsquo;s copy the <code>msg</code> string built into the binary into extended memory. We do this by pointing <code>ES</code> to our linear segment and using the <code>EXTENDED_ADDR</code> offset, which I set to an arbitrary 4 MB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Store a message in extended memory.  We are in protected mode so this
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>;; works by design.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=no>LINEAR_DESC</span>         <span class=c1>; Load the linear address space in ES.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>es</span><span class=p>,</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>esi</span><span class=p>,</span> <span class=no>msg</span>                <span class=c1>; Point DS:[ESI] to our message.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>EXTENDED_ADDR</span>      <span class=c1>; Point ES:[EDI] to extended memory.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ecx</span><span class=p>,</span> <span class=no>MSGLEN</span>
</span></span><span class=line><span class=cl>    <span class=nf>o32</span> <span class=no>rep</span> <span class=no>movsb</span>               <span class=c1>; Must use 32-bit addressing.
</span></span></span></code></pre></div><p>Once this is done, we prepare the <code>FS</code> segment with a large limit so that we can use it from unreal mode and restore <code>ES</code> to the conventional values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Set up FS as an &#34;unreal mode&#34; segment.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=no>LINEAR_DESC</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>fs</span><span class=p>,</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; ... but restore ES to have standard real mode limits.  Not strictly
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>;; necessary but helps to prove our example.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=no>DATA_DESC</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>es</span><span class=p>,</span> <span class=no>ax</span>
</span></span></code></pre></div><p>And, with that, we are ready to pivot back to real mode&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Disable protected mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=no>cr0</span>
</span></span><span class=line><span class=cl>    <span class=nf>and</span> <span class=no>eax</span><span class=p>,</span> <span class=err>~</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>cr0</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; And now return to real mode with a far jump.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>pushf</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=no>word</span> <span class=p>[</span><span class=no>real_cs</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=no>unreal_mode</span>
</span></span><span class=line><span class=cl>    <span class=nf>iret</span>
</span></span></code></pre></div><p>&mldr; except that it isn&rsquo;t &ldquo;valid&rdquo; real mode! Remember that we left <code>FS</code> configured with a high, non-standard limit of 4 GB? Such non-standard limit remains in the segment cache. But before leveraging that, let&rsquo;s make our new machine state functional to continue executing the COM binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>unreal_mode:</span>
</span></span><span class=line><span class=cl>    <span class=c1>;; Reload real mode COM segment layout.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>bx</span><span class=p>,</span> <span class=no>cs</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>ds</span><span class=p>,</span> <span class=no>bx</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>es</span><span class=p>,</span> <span class=no>bx</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>ss</span><span class=p>,</span> <span class=no>bx</span>
</span></span></code></pre></div><p>We can now also reenable interrupts, which we must do before we decide to return to DOS:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Reenable the NMI and interrupts.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sti</span>
</span></span><span class=line><span class=cl>    <span class=nf>in</span> <span class=no>al</span><span class=p>,</span> <span class=mi>70</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>and</span> <span class=no>al</span><span class=p>,</span> <span class=mi>7</span><span class=no>fh</span>
</span></span><span class=line><span class=cl>    <span class=nf>out</span> <span class=mi>70</span><span class=no>h</span><span class=p>,</span> <span class=no>al</span>
</span></span><span class=line><span class=cl>    <span class=nf>in</span> <span class=no>al</span><span class=p>,</span> <span class=mi>71</span><span class=no>h</span>
</span></span></code></pre></div><p>But, crucially, we keep the A20 enabled in order to correctly reference extended memory later on!</p><p>And after all of this dance, that&rsquo;s really it. We are in unreal mode. Any memory references we make through the <code>FS</code> segment register can use offsets beyond the 1 MB limit no matter what its segment base is and no matter if the segment base <em>changes</em>.</p><p>Easy to say, hard to believe. Let&rsquo;s prove that this is true. Let&rsquo;s first fetch the message we stored in extended memory by copying it to conventional memory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Fetch the message from extended memory by using a large offset.  This
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>;; would not work in real mode or VM86 (even with 32-bit addressing), but
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>;; does because we are actually in unreal mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>xor</span> <span class=no>ax</span><span class=p>,</span> <span class=no>ax</span>                  <span class=c1>; Clear FS to show its high limits remain.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>fs</span><span class=p>,</span> <span class=no>ax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>esi</span><span class=p>,</span> <span class=no>EXTENDED_ADDR</span>      <span class=c1>; Point FS:[ESI] to extended memory.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>msgcopy</span>            <span class=c1>; Point ES:[EDI] to our buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ecx</span><span class=p>,</span> <span class=no>MSGLEN</span>
</span></span><span class=line><span class=cl>    <span class=nf>o32</span> <span class=no>fs</span> <span class=no>rep</span> <span class=no>movsb</span>            <span class=c1>; Must use 32-bit addressing.
</span></span></span></code></pre></div><p>And now that we got it copied, let&rsquo;s call into DOS to print the message and return control to DOS:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=c1>;; Print the message we fetched from extended mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ah</span><span class=p>,</span> <span class=mi>40</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>bx</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>cx</span><span class=p>,</span> <span class=no>MSGLEN</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span> <span class=no>dx</span><span class=p>,</span> <span class=no>msgcopy</span>             <span class=c1>; Remember this was all ... at first!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>int</span> <span class=mi>21</span><span class=no>h</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>;; And jump back to DOS.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mov</span> <span class=no>ax</span><span class=p>,</span> <span class=mi>4</span><span class=no>c00h</span>
</span></span><span class=line><span class=cl>    <span class=nf>int</span> <span class=mi>21</span><span class=no>h</span>
</span></span></code></pre></div><p>If all goes well, you should see <code>Hello, unreal mode!</code> in the console and the usual <code>C:\></code> prompt should greet you again.</p><p>But, wait, there is more! If you happen to be running this under Bochs&mdash;and I recommend that you do because it offers much better debugging facilities than DOSBox&mdash;you can pause the simulation with <code>CTRL+C</code> and dump the segment registers with <code>sreg</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>&lt;bochs:2&gt; sreg
</span></span><span class=line><span class=cl>es:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
</span></span><span class=line><span class=cl>        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>cs:0x000f, dh=0x00009300, dl=0x00f0ffff, valid=3
</span></span><span class=line><span class=cl>        Data segment, base=0x000000f0, limit=0x0000ffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>ss:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=7
</span></span><span class=line><span class=cl>        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>ds:0x010e, dh=0x00009300, dl=0x10e0ffff, valid=3
</span></span><span class=line><span class=cl>        Data segment, base=0x000010e0, limit=0x0000ffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>fs:0x0000, dh=0x00cf9300, dl=0x0000ffff, valid=11
</span></span><span class=line><span class=cl>        Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
</span></span><span class=line><span class=cl>        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
</span></span><span class=line><span class=cl>ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
</span></span><span class=line><span class=cl>tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
</span></span><span class=line><span class=cl>gdtr:base=0x0000000000011c72, limit=0x20
</span></span><span class=line><span class=cl>idtr:base=0x0000000000000000, limit=0x3ff
</span></span></code></pre></div><p>Pay attention to the details for the <code>limit</code> field of all the segment registers. You can see how the value is <code>0x0000ffff</code> for all of them as you&rsquo;d expect in real mode&mldr; but <code>FS</code>&rsquo;s limit is the non-standard <code>0xffffffff</code>. We did it. We are in unreal mode and DOS still runs fine. (In fact, remember that <code>HIMEM.SYS</code> itself <em>does</em> leverage unreal mode and this driver was active almost all the time in a DOS installation.)</p><p>IMPORTANT: You can download the full source code by clicking on <a href=/src/unreal-mode/unreal.asm><code>unreal.asm</code></a>.</p><p>Once you download the source code, you can build it with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nasm -o unreal.com unreal.asm
</span></span></code></pre></div><p>And once built, you can run it within DOSBox by copying the binary into a directory you mount within the emulator or use <a href=https://www.gnu.org/software/mtools/>mtools</a> to copy it into a DOS boot disk image for Bochs.</p><h1 id=dos-extenders>DOS extenders</h1><p>If you resisted the urge to keep toying with the example code presented above and are still reading, great! We can continue onto our final topic: <a href=https://en.wikipedia.org/wiki/DOS_extender>DOS extenders</a>. These programs are what truly set DOS free from the 1 MB address space limitations and thus are the right way to conclude this article.</p><p>A DOS extender, in rough terms, is a wrapper for your code that enters protected mode and transfers control back to you. This is very useful because, by running in protected mode, your <em>code</em> segment can span more than 640 KB, finally letting you run large binaries without resorting to ancient spells like <a href=https://en.wikipedia.org/wiki/Overlay_(programming)>overlays</a>. But if that was the only thing that a DOS extender did, it would be too simple of a thing and not make it a DOS-anything.</p><figure><img src=/images/2024-02-07-dos-extender.png><figcaption>Representation of the structure of a DOS-extended application and how it relates to a DOS extender, DOS drivers, and raw hardware access.</figcaption></figure><p>The crucial feature that DOS extenders provide is a mechanism to call <em>back</em> into the BIOS and DOS to access the services these provide. In particular, this means accessing <em>drivers</em> and <em>the file system</em>. They do so by exposing the same <a href=https://en.wikipedia.org/wiki/DOS_API>DOS API</a> of the real mode host in protected mode, and they do this so that they can transparently service it in an efficient manner.</p><p>The general mechanics behind DOS extenders are very similar to what I described earlier: they enter protected mode to use extended memory and run your code, but they <em>temporarily</em> return to real mode to issue BIOS and DOS service calls. Unfortunately, this naive implementation would be quite inefficient, so DOS extenders actually service various APIs in protected mode to avoid returning to real mode, and they optimize large buffer transfers to minimize the number of switches when they <em>do</em> have to switch modes. In other words, DOS extenders are their own mini OS on top of DOS.</p><p>DOS extenders were widely used in games, and you may well remember the iconic message that DOOM printed on startup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>C:\&gt;DOOM
</span></span><span class=line><span class=cl>DOS/4GW Protected Mode Run-time  Version 1.97
</span></span><span class=line><span class=cl>Copyright (c) Rational Systems, Inc. 1990-1994
</span></span></code></pre></div><p>These messages came from <a href=https://en.wikipedia.org/wiki/DOS/4G>DOS/4G</a>, the most common DOS extender of all. The reason it was so common is because the &ldquo;W version&rdquo; was the free (but limited) edition of DOS/4G, and it shipped with the popular <a href=https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B>Watcom</a> C compiler that produced protected mode binaries. But pay attention to &ldquo;run-time&rdquo; in that message. Why run-time?</p><p>DOS extenders were not the only system component that entered protected mode. By the time DOS extenders became popular, Windows was already a thing and Windows likes protected mode too. And as we saw in the previous post, DOS itself came with <code>EMM386.EXE</code>, another mini hypervisor that put DOS inside a VM86 instance so that it could easily reference extended memory. So what if you wanted to run a popular DOS-extended program, say DOOM, inside one of these also-popular protected mode environments?</p><p>Tough luck. Nesting protected modes was impossible until <a href=https://en.wikipedia.org/wiki/X86_virtualization>virtualization appeared</a>. VM86 was close to what was necessary but it didn&rsquo;t allow running protected mode programs from within it. So, how did this work? How could you run a DOS-extended program inside Windows or while <code>EMM386.EXE</code> was running?</p><p>Like in any computing problem, the answer is simple: by means of an abstraction layer! To support this flow, Microsoft defined the <a href=https://en.wikipedia.org/wiki/DOS_Protected_Mode_Interface>DOS Protected Mode Interface (DPMI)</a>, an API to abstract the core services to interact with protected mode. DPMI is <em>not</em> a replacement for a DOS extender though: DPMI is an API that DOS extenders themselves use to deal with protected mode operations.</p><figure><img src=/images/2024-02-07-dpmi.png><figcaption>Simple representation of the role that DPMI plays in DOS-extended applications and different host operating systems.</figcaption></figure><p>In the case of DOS-extended programs, the first thing that they do at startup is check if a DPMI kernel is present. If one exists, such as when the DOS program runs within Windows, then the DOS extender leverages Windows&rsquo; DPMI services and delegates all operations to Windows. But if such a provider isn&rsquo;t running, the DOS extender starts the DPMI kernel typically built into itself.</p><p>If you want to see even more code in action, I refer you to skim through the sources of the free <a href=https://sourceforge.net/projects/dos32a/>DOS/32</a> extender and the free <a href=https://en.wikipedia.org/wiki/CWSDPMI>CWSDPMI</a> host.</p><p>And with that, I&rsquo;m hoping that the next article will finally be the one talking about DJGPP and everything else it had to do to make Unix applications run semi-seamlessly on DOS&mldr; unless some other preparatory essay becomes necessary!</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/01/links-january-2024-edition.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2024/02/djgpp.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Beyond+the+1+MB+barrier+in+DOS&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fbeyond-the-1-mb-barrier-in-dos.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Beyond+the+1+MB+barrier+in+DOS&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fbeyond-the-1-mb-barrier-in-dos.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Beyond+the+1+MB+barrier+in+DOS+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F02%2Fbeyond-the-1-mb-barrier-in-dos.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>