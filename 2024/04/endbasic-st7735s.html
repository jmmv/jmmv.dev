<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Porting the EndBASIC console to an LCD - Julio Merino (jmmv.dev)</title>
<meta property="og:title" content="Porting the EndBASIC console to an LCD - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Porting the EndBASIC console to an LCD - Julio Merino (jmmv.dev)"><meta name=description content="Hello again Blog System/5 and sorry for the radio silence for the last couple of months. I had been writing too much in here and neglecting my side projects so I needed to get back to them. And now that I&rsquo;ve made significant progress on cool new features for EndBASIC, it&rsquo;s time to write about them a little!
One of the defining characteristics of EndBASIC is its hybrid console: what looks like a simple text terminal at first glance can actually render overlapping graphics and text at the same time. This is a feature that I believe is critical to simplify learning and it first appeared with the 0.8 release back in 2021.
"><meta property="og:description" content="Hello again Blog System/5 and sorry for the radio silence for the last couple of months. I had been writing too much in here and neglecting my side projects so I needed to get back to them. And now that I&rsquo;ve made significant progress on cool new features for EndBASIC, it&rsquo;s time to write about them a little!
One of the defining characteristics of EndBASIC is its hybrid console: what looks like a simple text terminal at first glance can actually render overlapping graphics and text at the same time. This is a feature that I believe is critical to simplify learning and it first appeared with the 0.8 release back in 2021.
"><meta property="twitter:description" content="Hello again Blog System/5 and sorry for the radio silence for the last couple of months. I had been writing too much in here and neglecting my side projects so I needed to get back to them. And now …"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.136.5"><meta property="og:url" content="https://jmmv.dev/2024/04/endbasic-st7735s.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/04/endbasic-st7735s.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-04-26-endbasic-st7735s-editor.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2024-04-26-endbasic-st7735s-editor.jpg"><meta property="og:image:alt" content="My exciting quest to leverage a teeny-tiny display to play retro-style games."><meta property="twitter:image:alt" content="My exciting quest to leverage a teeny-tiny display to play retro-style games."><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzA0L2VuZGJhc2ljLXN0NzczNXMuaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/porting-the-endbasic-console-to-an")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Porting the EndBASIC console to an LCD</h1><p>April 26, 2024 &#183;
About 16 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/endbasic>endbasic</a>, <a href=/tags/rust>rust</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/porting-the-endbasic-console-to-an>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-04-26-endbasic-st7735s-editor.jpg style=max-width:100%><figcaption>My exciting quest to leverage a teeny-tiny display to play retro-style games.</figcaption></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>Hello again Blog System/5 and sorry for the radio silence for the last couple of months. I had been writing too much in here and neglecting my side projects so I <em>needed</em> to get back to them. And now that I&rsquo;ve made significant progress on cool new features for <a href=https://www.endbasic.dev/>EndBASIC</a>, it&rsquo;s time to write about them a little!</p><p>One of the defining characteristics of EndBASIC is its hybrid console: what looks like a simple text terminal at first glance can actually render overlapping graphics and text <em>at the same time</em>. This is a feature that I believe is critical to simplify learning and it first appeared with <a href=/2021/11/endbasic-0.8.html>the 0.8 release</a> back in 2021.</p><figure><img src=/images/2024-04-26-endbasic-hybrid-console.png width=100%><figcaption>EndBASIC's hybrid console running in the web browser, rendering text and overlapping graphics at once, all controlled from the built-in command prompt.</figcaption></figure><p>A few months before that, I had added support for simple GPIO manipulation in <a href=/2021/02/endbasic-0.6.html>the 0.6 release</a> and, around that same time, I impulse-bought a tiny LCD for the Raspberry Pi with the hope of making the console work on it. But life happened and I lost momentum on the project&mldr; until recently.</p><p>In this post, I&rsquo;ll guide you through the process of porting the EndBASIC hybrid console to the ST7735s 1.44" LCD shown below, which sports a resolution of 128x128 pixels, a D-pad, and 3 other buttons. I will cover the prerequisite work to make the port possible, dig into the GPIO and SPI interface of an LCD, outline the design for a fast rendering engine, and conclude with pointers for you to build your own &ldquo;developer kit&rdquo;. Let&rsquo;s go!</p><figure><a href="https://www.amazon.com/gp/product/B077Z7DWW1?ie=UTF8&psc=1&linkCode=ll1&tag=&linkId=7a97236b22ca32377d308871eedde6fc&language=en_US&ref_=as_li_ss_tl"><img src=/images/2024-04-26-st7735s-box.jpg width=100%></a><figcaption>The <a href="https://www.amazon.com/gp/product/B077Z7DWW1?ie=UTF8&psc=1&linkCode=ll1&tag=&linkId=7a97236b22ca32377d308871eedde6fc&language=en_US&ref_=as_li_ss_tl">ST7735s 1.44" LCD</a>. Photo from back when I first unboxed this little device... on February 7th, 2021.</figcaption></figure><h1 id=previous-implementation>Previous implementation</h1><p>Even though I had plans to support graphics in the EndBASIC console from the very beginning, the first versions of the product did <em>not</em> support graphics. That fact didn&rsquo;t prevent me from defining a <code>Console</code> abstraction anyway because I needed to support various operating systems and, more importantly, write <a href=/2020/12/unit-testing-a-console-app.html>unit tests for the console</a>. Such abstraction was a straightforward trait representing text-only operations, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Console</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>clear</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>how</span>: <span class=nc>ClearType</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>color</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=nb>Option</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=nb>Option</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>print</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>text</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... and more text operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Later on, when the time came to add graphics support, I extended the <code>Console</code> trait with additional rendering primitives, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Console</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... same as previous ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw_circle</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_center</span>: <span class=nc>PixelsXY</span><span class=p>,</span><span class=w> </span><span class=n>_radius</span>: <span class=kt>u16</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>new</span><span class=p>(</span><span class=n>io</span>::<span class=n>ErrorKind</span>::<span class=n>Other</span><span class=p>,</span><span class=w> </span><span class=s>&#34;No graphics support&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw_pixel</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_xy</span>: <span class=nc>PixelsXY</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>io</span>::<span class=n>Error</span>::<span class=n>new</span><span class=p>(</span><span class=n>io</span>::<span class=n>ErrorKind</span>::<span class=n>Other</span><span class=p>,</span><span class=w> </span><span class=s>&#34;No graphics support&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... and more graphics operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>What constitutes a primitive or not depends on the graphics device. In the snippet above, it&rsquo;s fairly easy to understand why <code>draw_pixel</code> exists. But why is <code>draw_circle</code> there? SDL2, for example, does not provide a circle drawing primitive and forces you to implement your own algorithm on top of individual pixel plotting. However, the HTML <code>canvas</code> element <em>does</em> provide such a primitive and thus it is important to expose access to it for performance reasons.</p><p>A reasonable design, right?</p><p>Not quite. The problem is that mixing the textual and graphical operations under just one abstraction bundles two concepts together. Take, for example, the innocent-looking <code>print</code> function: writing text to the console requires knowing the current cursor position, writing text at that location, wrapping long lines, and then updating the cursor position and moving its glyph. This sequence of operations is given to us &ldquo;for free&rdquo; when the <code>Console</code> is backed by a terminal&mdash;the kernel or terminal emulator handle all details&mdash;but none of this exists when you stare at a blank graphical canvas.</p><p>As a result, the SDL2 and the HTML canvas console implementations had to supply their own code to represent a textual console on top of their backing graphical canvases. But due to tight timelines&mdash;I wanted to release graphics support <a href=https://vimeo.com/641791002>in time for a conference</a>&mdash;I ended up with <em>a lot</em> of copy/pasted code between the two. Unfortunately, it wasn&rsquo;t just copy/pasted code. Oh no. It was copy/pasted code with minor variations throughout. For example: SDL2 coordinates are <code>i32</code> whereas HTML canvas coordinates are <code>float</code>s.</p><p>This duplication with minor differences required unification before attempting to write a console driver for the LCD because I could not afford to introduce yet another duplicate of the same code.</p><h1 id=past-netbsd-experience-to-the-rescue>Past NetBSD experience to the rescue</h1><p>The first step to resolving this conundrum was to unify the implementation of the two graphical consoles as much as possible. Having worked on <a href=https://www.netbsd.org/docs/guide/en/chap-cons.html>NetBSD&rsquo;s <code>wscons</code> console framework</a> eons ago, I knew how this had to be done.</p><p>The idea was to separate the text console manipulation from the underlying graphics primitives. As you can imagine, the way to do this was via a new abstraction, <code>RasterOps</code>, providing direct access to the &ldquo;raster operations&rdquo; of the graphics device. Take a look:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>RasterOps</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw_circle</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>center</span>: <span class=nc>PixelsXY</span><span class=p>,</span><span class=w> </span><span class=n>radius</span>: <span class=kt>u16</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw_pixel</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>xy</span>: <span class=nc>PixelsXY</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>move_pixels</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>x1y1</span>: <span class=nc>PixelsXY</span><span class=p>,</span><span class=w> </span><span class=n>x2y2</span>: <span class=nc>PixelsXY</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=nc>SizeInPixels</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>write_text</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>xy</span>: <span class=nc>PixelsXY</span><span class=p>,</span><span class=w> </span><span class=n>text</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... and more operations ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>As you can see in this snippet, the earlier operations <code>draw_circle</code> and <code>draw_pixel</code> exist as raster operations because some devices may provide them as primitives. But we now see other functions like <code>move_pixels</code> and <code>write_text</code> (which differs from <code>print</code> because it writes text at a specific pixel location, not at the &ldquo;current cursor position&rdquo;) and these are meant to expose other primitives of the device.</p><p>Having done this, I added a new <code>GraphicsConsole</code> type that encapsulates the logic to implement a terminal backed by an arbitrary graphical display, and then relies on a specific implementation of the <code>RasterOps</code> trait to do the screen manipulation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=no>RO</span><span class=o>&gt;</span><span class=w> </span><span class=n>Console</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>GraphicsConsole</span><span class=o>&lt;</span><span class=no>RO</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=no>RO</span>: <span class=nc>RasterOps</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... implement Console in terms of RasterOps ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Most details of this refactor are uninteresting at this point, except for the fact that it eliminated all of the tricky duplicate code between the SDL2 and HTML canvas variants. A side-effect was that these changes increased my confidence in the HTML canvas variant because most code was now unit-tested indirectly via the SDL2 implementation. Here is how the simplification looked like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ wc -l {before,after}/sdl/src/host.rs {before,after}/web/src/canvas.rs
</span></span><span class=line><span class=cl> 1245 before/sdl/src/host.rs
</span></span><span class=line><span class=cl>  887 after/sdl/src/host.rs     # 358 fewer lines
</span></span><span class=line><span class=cl>  760 before/web/src/canvas.rs
</span></span><span class=line><span class=cl>  444 after/web/src/canvas.rs   # 320 fewer lines
</span></span></code></pre></div><p>I was now ready to reuse the <code>GraphicsConsole</code> to quickly provide a new backend on top of the LCD.</p><h1 id=playing-with-the-c-interface>Playing with the C interface</h1><p>With the foundational abstractions in place, it was time to prove that my idea of rendering the EndBASIC console on the tiny LCD was <del>feasible</del> cool enough to pursue. But I knew absolutely nothing about the LCD so, before diving right into the &ldquo;correct&rdquo; implementation, I had to create a prototype to get used to its API.</p><p>Fortunately, I found an &ldquo;SDK&rdquo;&mdash;and I put it in quotes because SDK is quite an overstatement&mdash;for the LCD somewhere online. The SDK consists of a pair of C and Python libraries that provide basic graphics drawing primitives, text rendering, and access to the D-pad and the buttons. This was a &ldquo;perfect&rdquo; finding because the code was simple enough to understand, functional enough to build a prototype, and allowed me to skip reading through the data sheet.</p><p>So I chose to do the easiest thing: I folded the C library into EndBASIC using Rust&rsquo;s C FFI and quickly implemented a <code>RasterOps</code> on it. With that, I could instantiate a <code>GraphicsConsole</code> backed by the LCD and demonstrate, in just a couple of hours before the crack of dawn, that the idea was feasible. And it was more than feasible: it was super-exciting! Here, witness the very first results:</p><figure><video width=100% controls>
<source src=/images/2024-04-26-endbasic-st7735s-prototype.mov type=video/mp4></video><figcaption>First prototype of the EndBASIC console on the ST7735s LCD display, reusing the vendor-provided C library from Rust with lots of hacks.</figcaption></figure><p>But performance was also awful. Using the C library was enough to show that this idea was cool and worth pursuing, but it was not the best path forward. On the one hand, the code in the C library was rather crappy and fragile to integrate into Rust via <code>build.rs</code>; and, on the other hand, I needed precise control of the hardware primitives to achieve good rendering performance levels.</p><h1 id=the-lcd-hardware-interface>The LCD hardware interface</h1><p>Before diving into the solution, let&rsquo;s take a quick peek at the hardware interface of the LCD. Note that this is just a very simplified picture of what the LCD offers and is derived from my reverse-engineering of the code in the SDK. I&rsquo;m sure there is more to it, but I do not have the drive to go through the aforementioned data sheet.</p><p>The LCD is a matrix of pixels where each position contains an integer representing the color of the pixel. The representation of each color value depends on the selected pixel format, but what the SDK uses by default is RGB565: a 16-bit value decomposed into two 5-bit quantities for red and blue and one 6-bit quantity for green.</p><p>This is pretty standard stuff for a framebuffer-style device but the mechanism to write to the LCD is different. Unlike most framebuffer devices backed by video cards, the LCD matrix is not memory-mapped: we have to issue specific reads and writes via the GPIO and SPI busses. The GPIO bus is used to control hardware registers and the SPI bus is used to transfer large data sequences.</p><p>Simplifying, the LCD offers just two primitives. The first is a &ldquo;set window&rdquo; operation to define the window for rendering. This tells the LCD what rectangular region to update with new pixel values on the <em>subsequent</em> &ldquo;set data&rdquo; operation. Executing this operation requires a GPIO write to select the operation followed by an SPI write to set the window position and dimensions.</p><figure><img src=/images/2024-04-26-rpi-lcd-set-window.png width=100%><figcaption>Representation of an LCD's "set window" operation.</figcaption></figure><p>The second is a &ldquo;set data&rdquo; primitive to set the contents of the previously-defined window. This primitive just sends a stream of pixel color values that will be written on the window, top-left to bottom-right. Executing this operation requires a GPIO write to select the operation followed by a &ldquo;very large&rdquo; SPI write to write the pixel data.</p><figure><img src=/images/2024-04-26-rpi-lcd-set-data.png width=100%><figcaption>Representation of an LCD's "set data" operation.</figcaption></figure><p>By default, SPI writes on Linux are limited to 4KB in size and the full LCD content is 128x128 pixels * 2 bytes per pixel = 32KB, which means drawing the whole LCD requires 8 separate SPI writes. (It is possible to raise the default via a kernel setting, which I did too, but let&rsquo;s ignore that for now.)</p><p>Understanding that the LCD hardware interface is as simple and constrained as this is super-important to devise an efficient higher-level API, which is what we are going to do next.</p><h1 id=double-buffering>Double-buffering</h1><p>Having figured out the native interface, I faced two problems.</p><p>The first one was performance. Issuing individual &ldquo;set window&rdquo; and &ldquo;set data&rdquo; commands works great to draw on large portions of the LCD, but sending these commands on a pixel basis as would be necessary to render letters or shapes like circles would be prohibitively slow.</p><figure><video width=100% controls>
<source src=/images/2024-04-26-endbasic-st7735s-demo-ffi.mov type=video/mp4></video><figcaption>An EndBASIC demo program bouncing a bunch of rectangles on the screen running with the prototype console driver that relied on the C library without double-buffering or damage tracking.</figcaption></figure><p>The second one was the inability to <em>read</em> the contents of the LCD. Certain operations of the console, like moving the cursor or entering/exiting the builtin editor, require saving portions of the screen aside for later restoration. The LCD does not offer an interface to read what it currently displays. (Actually I don&rsquo;t know because I did not read the data sheet&mldr; but even if it does, the reads would involve slow SPI bus traffic which we should avoid.)</p><p>To address these two problems, I decided to implement double-buffering for the LCD: the console driver reserves a portion of main memory to track the content of the LCD and all operations that update the LCD first write to this buffer. This allows the code to decide <em>when</em> to send the buffer to the LCD, allowing it to compose complex patterns in memory&mdash;e.g. plotting letters pixel by pixel&mdash;before ever touching the GPIO and SPI busses. And this also allows trivially reading portions of the LCD.</p><figure><img src=/images/2024-04-26-rpi-lcd-buffer-damage.png width=100%><figcaption>Representation of the double-buffering and damage tracking techniques.</figcaption></figure><p>Which brings me to the next point. Part of this solution required adding damage tracking as well. Flushing the full in-memory buffer to the LCD is expensive&mdash;remember, with the default SPI configuration, we need to issue 8 separate writes to flush 32KB of data&mdash;and many times, like when moving the cursor around in the editor, this is not necessary. Therefore, it is important to keep track of the portion of the display that has been &ldquo;damaged&rdquo; by drawing operations and then only flush that portion of the buffer to the LCD. This maps perfectly well to the hardware primitives offered by the LCD.</p><p>With that in mind, and after a bit of iteration, I ended up splitting the implementation of the LCD <code>RasterOps</code> into two pieces. One is the <code>Lcd</code> trait, which exposes the basic &ldquo;set window&rdquo; and &ldquo;set data&rdquo; primitives of an LCD as a single <code>set_data</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Lcd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set_data</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>x1y1</span>: <span class=nc>LcdXY</span><span class=p>,</span><span class=w> </span><span class=n>x2y2</span>: <span class=nc>LcdXY</span><span class=p>,</span><span class=w> </span><span class=n>data</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... some more stuff ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The other is the <code>BufferedLcd</code> type, which implements the general idea of buffering and damage tracking on top of a generic <code>Lcd</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span><span class=w> </span><span class=n>RasterOps</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>BufferedLcd</span><span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>L</span>: <span class=nc>Lcd</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... implementation of RasterOps in terms of an Lcd ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This design keeps all of the complex logic in one place and, as was the case with the <code>Console</code> abstraction, allowed me to unit-test the tricky corner cases of the double-buffering and damage tracking by supplying a test-only <code>Lcd</code> implementation. This was critical during development because I wrote most of this code while I was on a trip without access to the device, and when I came back home, the &ldquo;real thing&rdquo; worked on the first try.</p><figure><video width=100% controls>
<source src=/images/2024-04-26-endbasic-st7735s-demo-native.mov type=video/mp4></video><figcaption>Same EndBASIC demo program as before but running with the improved console that implements double-buffering and damage tracking. No more flickering.</figcaption></figure><p>Invest in Rust and exhaustive unit testing! They really are worth it to deliver working software quickly. But I digress&mldr;</p><h1 id=font-rendering>Font rendering</h1><p>The last interesting part of the puzzle was rendering text. You see: for the previous graphical consoles I wrote based on SDL2 and the HTML <code>canvas</code> element, I was able to use <a href=https://www.ibm.com/plex/>a nice TTF font</a>. But with the LCD&mldr; well, the LCD has no builtin mechanism to render text and the very restrictive 128x128 resolution means that most fonts would render poorly at small sizes anyway.</p><p>To solve this problem, I had to implement my own text rendering code, which sounds scary at first but isn&rsquo;t as hard as it sounds. One issue was coming up with the font data, but the SDK for the LCD came with a free reusable 5x8 font that I took over. Another issue was coming up with a mechanism to efficiently render the letters because plotting them pixel by pixel on the LCD would be unfeasible, but this was solved by the previous buffering and damage tracking techniques.</p><p>Having my own font rendering code is interesting. If you used a BASIC machine back in the 1980s, the computer-supplied manual would show you the glyphs used by the machine like this page demonstrates:</p><figure><img src=/images/2024-04-26-amstrad-cpc-c7p9.png width=100% class=with-border><figcaption>Page 9 of Chapter 7 of the Amstrad CPC 6128 user manual showing the glyphs corresponding to characters 32&ndash;48.</figcaption></figure><p>In some machines like the Amstrad CPC 6128, you could use the <code>SYMBOL</code> command to define your own glyphs. And in some others, you could <code>POKE</code> the memory locations where the glyphs were stored to (re)define them. So I&rsquo;m thinking that&mldr; maybe I should forget about the TTF font and instead expose a custom bitmap font in all EndBASIC consoles to allow for these neat tricks.</p><h1 id=putting-it-all-together>Putting it all together</h1><p>And that&rsquo;s all folks! Having gone through all the pieces involved in providing support for the LCD, we can now connect them all. Here is how the code on the <code>main</code> branch looks like with additional inline commentary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Instantiate access to the GPIO bus, required to control the LCD and
</span></span></span><span class=line><span class=cl><span class=c1>// to read the status of the D-pad and buttons.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>gpio</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Gpio</span>::<span class=n>new</span><span class=p>().</span><span class=n>map_err</span><span class=p>(</span><span class=n>gpio_error_to_io_error</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Build the struct used to interface with the LCD.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>lcd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ST7735SLcd</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>gpio</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Wrap the low-level LCD with the double-buffering and damage tracking
</span></span></span><span class=line><span class=cl><span class=c1>// features for high speed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>lcd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BufferedLcd</span>::<span class=n>new</span><span class=p>(</span><span class=n>lcd</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Instantiate the input controller. I haven&#39;t covered this in the post
</span></span></span><span class=line><span class=cl><span class=c1>// because it&#39;s uninteresting.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ST7735SInput</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>gpio</span><span class=p>,</span><span class=w> </span><span class=n>signals_tx</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Wrap the display and the buttons with the generic graphical console
</span></span></span><span class=line><span class=cl><span class=c1>// logic -- the same one used by the SDL2 and HTML canvas variants.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>inner</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GraphicsConsole</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>,</span><span class=w> </span><span class=n>lcd</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Even though this looks complex, this composition of three different types keeps the responsibilities of each layer separate. The layers help make the logic simpler to understand, allow the possibility of supporting more LCDs with ease, and make unit-testing a reality. And thanks to Rust&rsquo;s static dispatch, the overhead of the separate types is minimal.</p><p>Witness the finished result:</p><figure><video width=100% controls>
<source src=/images/2024-04-26-endbasic-st7735s-snake.mov type=video/mp4></video><figcaption>EndBASIC running the snake game on the Raspberry Pi with the ST7735s console, showing the final graphics support as well as interaction with the physical buttons.</figcaption></figure><h1 id=build-your-own-developer-kit>Build your own Developer Kit</h1><p>Does the above sound cool? Do you want to play with it? Here are the parts you&rsquo;ll need to build you own:</p><ul><li><p><strong><a href="https://www.amazon.com/ELEMENT-Element14-Raspberry-Pi-Motherboard/dp/B07BDR5PDW?&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=cab45a45b3e43934d489486d416be7a0&amp;language=en_US&amp;ref_=as_li_ss_tl">Raspberry Pi 3 B+</a>:</strong> I suppose a newer model will work but I don&rsquo;t have one to try it out; let me know if it does! I also have my eyes on the <a href="https://www.amazon.com/gp/product/B074P6BNGZ?th=1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=1f5bdad0f78d4512685cda89db5c6d87&amp;language=en_US&amp;ref_=as_li_ss_tl">Libre Computer Board - Le Potato</a>, but if you go this route, know that it will <em>definitely</em> require extra work in EndBASIC to be functional. Hardware donations welcome if you want me to give it a try 😉.</p></li><li><p><strong><a href="https://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Listed/dp/B00MARDJZ4?&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=ef82e298644b68298cd9bf5559b74aaa&amp;language=en_US&amp;ref_=as_li_ss_tl">CanaKit 5V 2.5A Power Supply</a>:</strong> Yes, the Raspberry Pi is USB-powered but you need a lot of power for it to run properly&mdash;particularly if you are going to attach any USB devices like hard disks. Don&rsquo;t skimp on the power supply. This is the one I have and works well.</p></li><li><p><strong><a href="https://www.amazon.com/PNY-Elite-microSDHC-Memory-P-SDU32GU185GW-GE/dp/B07R8GVGN9?th=1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=33a25c49f236d8bd6e8f2259a6c57148&amp;language=en_US&amp;ref_=as_li_ss_tl">PNY 32GB microSD card</a>:</strong> Buy any microSD card you like. The SD bay is incredibly slow no matter what and 32GB should be plenty for experimentation.</p></li><li><p><strong><a href="https://www.amazon.com/gp/product/B077Z7DWW1?ie=UTF8&amp;psc=1&amp;linkCode=ll1&amp;tag=&amp;linkId=7a97236b22ca32377d308871eedde6fc&amp;language=en_US&amp;ref_=as_li_ss_tl">waveshare 1.44inch LCD Display HAT 128x128</a>:</strong> The star product of this whole article! You may find other LCD hats and I&rsquo;m sure they can be made to work, but they&rsquo;ll require code changes. Hopefully the abstractions I implemented make it easy to support other hats, but I can&rsquo;t tell yet. Again, hardware donations welcome if you want to keep me busy 😉.</p></li></ul><p>Once you have those pieces, get either Raspbian or Ubuntu, flash the image to the microSD, and boot the machine. After that, you have to build and run EndBASIC from unreleased sources until I publish 0.11:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cargo install --git<span class=o>=</span>https://github.com/endbasic/endbasic.git --features<span class=o>=</span>rpi
</span></span><span class=line><span class=cl>$ ~/.cargo/bin/endbasic --console<span class=o>=</span>st7735s
</span></span></code></pre></div><p>I know, I know, this is all quite convoluted. You have to manually go through the process of setting up Linux, then installing Rust, and then building EndBASIC from source. All of this is super-slow too.</p><p>Which means&mldr; what I want to do next is to build a complete &ldquo;Developer Kit&rdquo;, including a lightweight prebuilt SD image that gives you access to EndBASIC out of the box in just a few seconds. Right now I&rsquo;m playing with downsizing a NetBSD/evbarm build so that the machine can boot quickly and, once I have that ready, I&rsquo;ll have to port EndBASIC&rsquo;s hardware-specific features to work on it. I don&rsquo;t think I&rsquo;ll postpone 0.11 until this is done, but we&rsquo;ll see.</p><p>Interested in any of this? Please leave a note! And if you have tried the above at all with your own hardware, post your story too!</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/03/new-type-and-production-outages.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2024/06/20-years-of-blogging.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>👍
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>👎
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Porting+the+EndBASIC+console+to+an+LCD&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F04%2Fendbasic-st7735s.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Porting+the+EndBASIC+console+to+an+LCD&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F04%2Fendbasic-st7735s.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Porting+the+EndBASIC+console+to+an+LCD+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F04%2Fendbasic-st7735s.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>