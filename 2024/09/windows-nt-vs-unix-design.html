<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Windows NT vs. Unix: A design comparison - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Windows NT vs. Unix: A design comparison - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Windows NT vs. Unix: A design comparison - Julio Merino (jmmv.dev)"><meta name=description content="Over the years, I&amp;rsquo;ve repeatedly heard that Windows NT is a very advanced operating system and, being a Unix person myself, it has bothered me to not know why. I&amp;rsquo;ve been meaning to answer this question for years and I can do so now, which means I want to present you my findings.
My desire to know about NT&amp;rsquo;s internals started in 2006 when I applied to the Google Summer of Code program to develop Boost."><meta property="og:description" content="Over the years, I&amp;rsquo;ve repeatedly heard that Windows NT is a very advanced operating system and, being a Unix person myself, it has bothered me to not know why. I&amp;rsquo;ve been meaning to answer this question for years and I can do so now, which means I want to present you my findings.
My desire to know about NT&amp;rsquo;s internals started in 2006 when I applied to the Google Summer of Code program to develop Boost."><meta property="twitter:description" content="Over the years, I&amp;rsquo;ve repeatedly heard that Windows NT is a very advanced operating system and, being a Unix person myself, it has bothered me to not know why. I&amp;rsquo;ve been meaning to answer ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2024/09/windows-nt-vs-unix-design.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/09/windows-nt-vs-unix-design.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-09-09-windows-nt-vs-unix-design.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2024-09-09-windows-nt-vs-unix-design.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzA5L3dpbmRvd3MtbnQtdnMtdW5peC1kZXNpZ24uaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/windows-nt-vs-unix-design")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Windows NT vs. Unix: A design comparison</h1><p>September 9, 2024 &#183;
About 23 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/unix>unix</a>, <a href=/tags/windows>windows</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/windows-nt-vs-unix-design>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-09-09-windows-nt-vs-unix-design.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>Over the years, I&rsquo;ve repeatedly heard that Windows NT is a very advanced operating system and, being a Unix person myself, it has bothered me to not know <em>why</em>. I&rsquo;ve been meaning to answer this question for years and I can do so now, which means I want to present you my findings.</p><p>My desire to know about NT&rsquo;s internals started in 2006 when I applied to the Google Summer of Code program to develop Boost.Process. I needed such a library for ATF, but I also saw the project as a chance to learn something about the Win32 API. This journey then continued in 2020 with me <a href=/2020/10/bye-google-hi-microsoft.html>choosing to join Microsoft</a> after a long stint at Google and me buying the <a href="https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189?crid=2F7UR8S48RP6O&amp;dib=eyJ2IjoiMSJ9.p9cBb_-Q8GjuK0z0kDLKG6xoExPM_2QWt_jn0PlqVBSWYNyqRp2Cd7MHXFeQ4EiRACaX_Y_9xzECC0YpECzSl5kCBD3u1KUPduAgmnO732G9aqw1aLdQszw8LIXBOE1cYvOf3KYQmQ5vdFV6i4eFOttVvIa2XerkHVGiPd1OzTk32tEOchCbnUqpzW3QqCG7AjEmmKHFGuo5T2_UQDUERaSVRa26oAZHYuePCzDrwbY.bcHnZQWFYjmL64ZRnMieVsUH5JVx-T-WY88kj8V-uno&amp;dib_tag=se&amp;keywords=windows+internals&amp;qid=1725808358&amp;sprefix=windows+internals%2Caps%2C155&amp;sr=8-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=08d00ee830fe99b6e648add99e1b64c5&amp;language=en_US&amp;ref_=as_li_ss_tl">Windows Internals</a> 5th edition book in 2021 (which I never fully read due to its incredible detail and length). None of these made me learn what I wanted though: the ways in which NT fundamentally differs from Unix, if at all.</p><p>Then, at the end of 2023, the <a href=/2023/11/windows-nt-peeking-into-the-cradle.html>Showstopper</a> book sparked this curiosity once again. And soon, a new thought came to mind: the Windows Internals 5th edition book was too obtuse but&mldr; what about the first edition? Surely it must have been easier to digest because the system was much simpler back in the early 1990s. So lo and behold, I searched for this edition, found it under the title <a href="https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X?crid=1DW4GVN0DXZR4&amp;dib=eyJ2IjoiMSJ9.T5IY8OXVnanYLCjv3cX4UA18lTT67S00r-GHOWD5mzHAUtLk4np5tyXDZB6t25N5JGVVo4y_Yi-4Fv6TrXMJ_rs_BjLK_hTqetPsJAsHRsaw6ZbhMH07OitAfS2LpgEmdUNfdU8KoIM8BEJHof4aPIJMHkemWy0IFcaXoyQ9TLMcgLdTlMVF5Yqen-dG6NZeJ03UYK9NJXzHMgt4noQO1UmhxTMA2xw2Bhi-GDbZT4k.vGalnM5AX1xcE149fGsl5IjcbdD3yE0gw0F7_RojBV4&amp;dib_tag=se&amp;keywords=inside+windows+nt&amp;qid=1725808269&amp;sprefix=inside+windows+nt%2Caps%2C160&amp;sr=8-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=3f47c0d7cea553fed13057b16d417b6c&amp;language=en_US&amp;ref_=as_li_ss_tl">Inside Windows NT</a>, read it cover to cover, and took notes to evaluate NT vs. Unix.</p><p>Which brings me to this article&mdash;a collection of thoughts comparing the design of NT (July 1993) against contemporary Unix systems such as 4.4BSD (June 1994) or Linux 1.0 (March 1994). Beware that, due to my background, the text is written from the point of view of a Unix &ldquo;expert&rdquo; and an NT &ldquo;clueless&rdquo;, so it focuses on describing the things that NT does differently.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=mission>Mission</h1><p><a href=https://en.wikipedia.org/wiki/Unix>Unix</a>&rsquo;s history is long&mdash;much longer than NT&rsquo;s. Unix&rsquo;s development started in 1969 and its primary goal was to be a convenient platform for programmers. Unix was inspired by <a href=https://en.wikipedia.org/wiki/Multics>Multics</a>, but compared to that other system, Unix focused on simplicity which is a trait that let it triumph over Multics. Portability and multitasking were not original goals of the Unix design though: these features were retrofitted in the many &ldquo;forks&rdquo; and reinventions of Unix years later.</p><p>On Microsoft&rsquo;s side, the first release of MS-DOS launched in August 1981 and the first release of &ldquo;legacy Windows&rdquo; (the DOS-based editions) launched in November 1985. While MS-DOS was a widespread success, it wasn&rsquo;t until <a href=https://en.wikipedia.org/wiki/Windows_3.0>Windows 3.0</a> in May 1990 that Windows started to really matter. Windows NT was conceived in 1989 and saw the light with the NT 3.1 release in July 1993.</p><p>This timeline gave Microsoft an edge: the design of NT started 20 years after Unix&rsquo;s, and Microsoft already had a large user base thanks to MS-DOS and legacy Windows. The team at Microsoft designing NT had the hindsight of these developments, previous experience developing other operating systems, and access to more modern technology, so they could &ldquo;shoot for the moon&rdquo; with the creation of NT.</p><p>In particular, NT started with the following design goals as part of its mission, which are in stark contrast to Unix&rsquo;s:</p><ol><li>portability,</li><li>support for multiprocessing systems (SMP), and</li><li>compatibility with DOS, legacy Windows, OS/2, and POSIX.</li></ol><p>These were not goals to scoff at and meant that NT started with solid design principles from the get go. In other words: these features were all present from day one and not bolted on at a later stage like they were in many Unixes.</p><h1 id=the-kernel>The kernel</h1><p>Now that we know some of these design goals and constraints, let&rsquo;s take a look at the specifics of how they are implemented.</p><p>Unix is, with few exceptions like <a href=https://www.minix3.org/>Minix</a> or <a href=https://www.gnu.org/software/hurd/>GNU Hurd</a>, implemented as a monolithic kernel that exposes a collection of system calls to interact with the facilities offered by the operating system. NT, on the other hand, is a hybrid between a monolithic kernel and a microkernel: the privileged component, known as the <em>executive</em>, presents itself as a collection of modular components to user-space <em>subsystems</em>. The user-space subsystems are special processes which &ldquo;translate&rdquo; the APIs that the applications consume (be it POSIX, OS/2, etc.) into executive system calls.</p><p>One important piece of the NT executive is the Hardware Abstraction Layer (HAL), a module that provides abstract primitives to access the machine&rsquo;s hardware and that serves as the foundation for the rest of the kernel. This layer is the key that allows NT to run on various architectures, including i386, Alpha, and PowerPC. To put the importance of the HAL in perspective, contemporary Unixes were coupled to a specific architecture: yes, Unix-the-concept was portable because there existed many different variants for different machines, but the implementation was not. SunOS originally only supported the Motorola 68000; 386BSD was the first port of BSD to the Intel architecture; IRIX was the Unix variant for Silicon Graphic&rsquo;s MIPS-based workstations; and so on. This explains why NetBSD&rsquo;s main focus on portability via a minimal shim over the hardware was so interesting at the time: other operating systems, except NT, did <em>not</em> have this internal clean design, and NT had come years before.</p><p>Another important piece of the NT executive is its support for multiprocessing systems and its preemptive kernel. The kernel has various interrupt levels (<a href=https://en.wikipedia.org/wiki/Spl_(Unix)>SPLs</a> in BSD terminology) to determine what can interrupt what else (e.g. a clock interrupt has higher priority than a disk interrupt) but, more importantly, the kernel threads can be preempted by other kernel threads. This is &ldquo;of course&rdquo; what every high-performance Unix system does today, but it&rsquo;s not how many Unixes started: those systems started with a kernel that didn&rsquo;t support preemption nor multiprocessing; then they added support for user-space multiprocessing; and then they added kernel preemption. The latter is the hardest step of all and explains the <a href=https://en.wikipedia.org/wiki/FreeBSD_version_history#FreeBSD_5>FreeBSD 5.0</a> saga fiasco. So it is interesting to see that NT started with the right foundations from its inception.</p><h1 id=objects>Objects</h1><p>NT is an object-oriented kernel. You might think that Unix is too: after all, processes are defined by a struct and file system implementations deal with vnodes (&ldquo;virtual nodes&rdquo;, not to be confused with inodes which are a file system-specific implementation detail). But that&rsquo;s not quite the same as what NT does: NT forces all of these different objects to have a common representation in the system.</p><p>You can rightfully be skeptical about this because&mldr; how can you offer a meaningful abstraction over such disparate things as processes and file handles? You can&rsquo;t, really, but NT forced all of these to inherit from a common object type and, surprisingly, this results in some nice properties:</p><ul><li><p><strong>Centralized access control:</strong> Objects are exclusively created by the <em>object manager</em>, which means there is a single place in the code to enforce policy. This is powerful because the semantics for, say, permission checks, can be defined in just one location and applied uniformly throughout the system. NetBSD concluded this was a good idea too, but it wasn&rsquo;t until 2001 that it gained its <a href=https://man.netbsd.org/NetBSD-9.3/kauth.9>Kernel Authorization (kauth)</a> framework.</p></li><li><p><strong>Common identity:</strong> Objects have identities and they are all represented in a single tree. This means that there is a unique namespace for all objects, no matter if we are talking about processes, file handles, or pipes. The objects in the tree are addressable via names (paths) and different portions of the tree can be owned by different subsystems. For example, a portion of the tree can represent a mounted file system, and thus traversing that subtree&rsquo;s root node will cause the file system to resolve the remainder of the path. This is akin to the VFS layer of a Unix system, with the difference that the VFS is exclusively about file systems whereas the object tree is about <em>every single kernel object</em>. It&rsquo;s true that Unix has attempted to shoehorn other types of non-file objects into the file system via <code>/proc/</code>, <code>/sys/</code>, and the like&mdash;but these feel like afterthoughts compared to what NT offers.</p></li><li><p><strong>Unified event handling:</strong> All object types have a <em>signaled</em> state, whose semantics are specific to each object type. For example, a process object enters the signaled state when the process exits, and a file handle object enters the signaled state when an I/O request completes. This makes it trivial to write event-driven code (ehem, async code) in userspace, as a single wait-style system call can await for a group of objects to change their state&mdash;no matter what type they are. Try to wait for I/O and process completion on a Unix system at once; it&rsquo;s painful.</p></li></ul><p>Objects are an NT-specific construct though, and they don&rsquo;t generalize well to all of the APIs that NT intended to support. An example of this is the POSIX subsystem: POSIX doesn&rsquo;t have the same concept of objects as NT does, yet NT has to offer some sort of compatibility with POSIX applications. For this reason, while the POSIX subsystem allocates objects from the executive, this subsystem must keep its own bookkeeping to represent the corresponding POSIX entities and performs the logical translation between the two on the fly. The Win32 subsystem, on the other hand, just hands objects to clients without an intermediary.</p><h1 id=processes>Processes</h1><p>Processes are a common entity in both NT and Unix but they aren&rsquo;t quite the same. In Unix, processes are represented in a tree, which means that each process has a parent and a process can have zero or more children. In NT, however, there is no such relationship: processes can &ldquo;inherit&rdquo; resources from their creators&mdash;any type of object, basically&mdash;but they are standalone entities after they are created.</p><p>What wasn&rsquo;t common back when NT was designed were threads: Mach was the first Unix-like kernel to integrate threads in 1985, which means that other Unixes adopted this concept later on and had to retrofit it into their existing designs. For example, Linux chose to represent threads as processes, each with its own PID, in its 2.0 release in June 1996; and NetBSD didn&rsquo;t get threads, represented as separate entities from processes, until its 2.0 release in 2004. Contrary to Unix, NT chose to support threads from the very beginning, knowing that they were a necessity for high-performance computing on SMP machines.</p><p>NT doesn&rsquo;t have signals in the traditional Unix sense. What it does have, however, are <em>alerts</em>, and these can be kernel mode and user mode. User mode alerts must be waited for as any other object and kernel mode alerts are invisible to processes. The POSIX subsystem uses kernel mode alerts to emulate signals. Note that signals have often been called a wart in Unix because of the way they interfere with process execution: handling signals correctly is a really difficult endeavor, so it sounds like NT&rsquo;s alternative is more elegant.</p><p>An interesting recent development in NT-land has been the introduction of <a href=https://www.microsoft.com/en-us/research/project/drawbridge/>picoprocesses</a>. Up until this feature was added, processes in NT were quite heavyweight: new processes would get a bunch of the NT runtime libraries mapped in their address space at startup time. In a picoprocess, the process has minimal ties to the Windows architecture, and this is used to implement Linux-compatible processes in WSL 1. In a way, picoprocesses are closer to Unix processes than native Windows processes, but they are not used for much anymore&mdash;even if they have only existed since August 2016&mdash;because of the move to WSL 2.</p><p>Lastly, as much as we like to bash Windows for security problems, NT started with an advanced security design for early Internet standards given that the system works, basically, as a capability-based system. The first user process that starts after logon gets an access token from the kernel representing the privileges of the user session, and the process and its subprocesses must supply this token to the kernel to assert their privileges. This is different from Unix where processes just have identifiers and the kernel needs to keep track of what each process can do in the process table.</p><h1 id=compatibility>Compatibility</h1><p>As mentioned in the introduction, a major goal of NT was to be compatible with applications written for legacy Windows, DOS, OS/2 and POSIX. One reason for this was technical, as this forced the system to have an elegant design; the other reason was political, as NT was a joint development with IBM and NT <em>had</em> to support OS/2 applications even if, in the end, NT ended up <em>being</em> Windows.</p><p>This need for compatibility forced NT&rsquo;s design to be significantly different than Unix&rsquo;s. In Unix, user-space applications talk to the kernel directly via its system call interface, and this interface <em>is</em> the Unix interface. Oftentimes, <a href=https://utcc.utoronto.ca/~cks/space/blog/programming/Go116OpenBSDUsesLibc>but not always</a>, the C library provides the glue to call the kernel and applications never issue system calls themselves&mdash;but that&rsquo;s a minor detail.</p><p>Contrast this to NT where applications do <em>not</em> talk to the executive (the kernel) directly. Instead, each application talks to one specific protected <em>subsystem</em>, and these subsystems are the ones that implement the APIs of the various operating systems that NT wanted to be compatible with. These subsystems are implemented as user-space servers (they are not inside the NT &ldquo;microkernel&rdquo;). Support for Windows applications comes from the Win32 server, which is special because it&rsquo;s the only one that&rsquo;s directly visible by users: it controls console programs and DOS terminals, and it has certain privileges for performance reasons.</p><p>Compared to traditional Unix, NT&rsquo;s design is very different because the BSDs and Linux have a monolithic kernel. These kernels expose a system call interface that userspace applications leverage to interact directly with the system. The BSDs, however, have offered support to run alternate <em>binaries</em> for a long time, all within the monolithic kernel: the way this works is by exposing different system call tables to userspace depending on the binary that&rsquo;s being run, and then translating those &ldquo;foreign&rdquo; system calls to whatever the kernel understands. Linux has limited support for this as well via <a href=https://man7.org/linux/man-pages/man2/personality.2.html><em>personalities</em></a>.</p><p>Even though the BSD approach is quite different from how NT handles supporting other systems, WSL 1 is extremely similar and is not a subsystem in the literal terms that subsystems were originally defined. In WSL 1, the NT kernel marks Linux processes as picoprocesses and, from there on, exposes a different system call interface to them. Within the NT kernel, those Linux-specific system calls are translated into NT operations and served within the same kernel&mdash;just like BSD&rsquo;s Linux compatibility does. The only problem is that, NT not being Unix, its &ldquo;emulation&rdquo; of Linux is tricky and much slower than what BSD can offer. It&rsquo;s a pity that <a href=/2020/11/wsl-lost-potential.html>WSL 2 lost the essence of this design</a> and went with a full-on VM design&mldr;</p><p>To finish this section, two more interesting details: a goal of NT&rsquo;s design was to allow seamless I/O redirection between subsystems, all from a single shell; and subsystems are exposed to applications via <em>ports</em> which are, of course, NT objects and are similar to how Mach allows processes and servers to communicate.</p><h1 id=virtual-memory>Virtual memory</h1><p>NT, just as Unix, relies on a Memory Management Unit (MMU) with pagination to offer protection across processes and to offer virtual memory. Paging in user-space processes is a common mechanism to give them a larger address space than the amount of physical memory on a machine. But one thing that put NT ahead of contemporary Unix systems is that the kernel itself can be paged out to disk too. Obviously not the whole kernel&mdash;if it all were pageable, you&rsquo;d run into the situation where a resolving kernel page fault requires code from a file system driver that was paged out&mdash;but large portions of it are. This is not particularly interesting these days because kernels are small compared to the typical installed memory on a machine, but it certainly made a big difference in the past where every byte was precious.</p><p>Additionally, while we take the way virtual memory and paging works these days for granted, this was a big area of research back when NT was designed. Older Unix implementations had separate memory caches for the file system and virtual memory, and it wasn&rsquo;t until 1987 that <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=a36b01c8fd5071f64b981dd3ffc66a6bce56736d">SunOS implemented a unified virtual memory architecture</a> to reduce the overheads of this old design.</p><p>In contrast, NT started with a unified memory architecture from the beginning. You&rsquo;d say that this was easy to do because they had the hindsight of the inefficiencies found in Unix and could see the solution that SunOS had implemented before the design of NT started. But regardless, this made NT &ldquo;more advanced&rdquo; that many alternate operating systems back then, and it has to be noted that other systems like NetBSD didn&rsquo;t catch up until 2002 with the implementation of the <a href=https://www.usenix.org/legacy/publications/library/proceedings/usenix2000/freenix/full_papers/silvers/silvers.pdf>Unified Buffer Cache (UBC)</a> in NetBSD 1.6.</p><p>An interesting difference between NT and Unix is how they manage and represent shared memory. In NT, shared memory sections are (surprise) objects and are thus subject to the exact same access validation checks as any other object. Furthermore, they are addressable in the same manner as any other object because they are part of the single object tree. Contrast this to Unix where this feature is bolted on: shared memory objects have a <a href=https://man7.org/linux/man-pages/man3/shm_open.3.html>different namespace</a>, a different API to every other entity, and thus typical permissions don&rsquo;t apply to them.</p><h1 id=io-subsystem>I/O subsystem</h1><p>Early versions of Unix only supported one file system. For example, it wasn&rsquo;t until 4.3BSD in 1990 that the BSDs gained the Virtual File System (VFS) abstraction to support more than just UFS. NT, on the other hand, started with a design that allowed multiple file systems.</p><p>In order to support multiple file systems, the kernel has to expose their namespaces in some way. Unix combines the file systems under a single file hierarchy via mount points: the VFS layer provides the mechanisms to identify which nodes correspond to the root of a file system and redirects requests to those file system drivers when traversing a path. NT has a similar design even if, from the standard user interface, file systems appear as disjoint drives: internally, the executive represents file systems as objects in the object tree, and each object is responsible for parsing the remainder of a path. Those file system objects are remapped as DOS drives so that userspace can access them. And guess what? The DOS drives are also objects under a separate subtree that redirects I/O to the file systems they reference.</p><p>In file system terms, NT ended up shipping with NTFS. NTFS was a really advanced file system for its time even if we like to bash on it for its poor performance (a <a href="https://www.youtube.com/watch?v=qbKGw8MQ0i8">misguided claim</a>). The I/O subsystem of NT, in combination with NTFS, brought 64-bit addressing, journaling, and even Unicode file names. Linux didn&rsquo;t get 64-bit file support until the late 1990s and didn&rsquo;t get journaling until ext3 launched in 2001. <a href=https://www.usenix.org/conference/1999-usenix-annual-technical-conference/soft-updates-technique-eliminating-most>Soft updates</a>, an alternate fault tolerance mechanism, didn&rsquo;t appear in FreeBSD until 1998. And Unix represents <a href=/2023/12/strings-encodings-nuls-and-bazel.html>filenames as nul-terminated byte arrays</a>, not Unicode.</p><p>Other features that NT included at launch were disk stripping and mirroring&mdash;what we know today as RAID&mdash; and device hot plugging. These features were not a novelty given that SunOS did include RAID support since the early 1990s, but what&rsquo;s interesting is that these were all accounted for as part of the original design.</p><p>At a higher level, <em>the</em> thing that makes the I/O subsystem of NT much more advanced than Unix&rsquo;s is the fact that its interface is asynchronous in nature and has been like that since the very beginning. To put this in perspective, FreeBSD didn&rsquo;t see support for <a href=https://man7.org/linux/man-pages/man7/aio.7.html><code>aio(7)</code></a> until FreeBSD 3.0 in 1998, and Linux didn&rsquo;t see this either until Linux 2.5 in 2002. And even if support for asynchronous I/O has existed in Unix systems for more than 20 years now, it&rsquo;s still not widespread: few people know of these APIs, the vast majority of applications don&rsquo;t use them, and their performance is poor. Linux&rsquo;s <a href=https://en.wikipedia.org/wiki/Io_uring><code>io_uring</code></a> is a relatively recent addition that improves asynchronous I/O, but it has been a significant source of security vulnerabilities and is not in widespread use.</p><h1 id=networking>Networking</h1><p>The Internet is everywhere today, but when NT was designed, that was not the case. Looking back at the Microsoft ecosystem, DOS 3.1 (1987) included the foundations for file sharing in the FAT file system, yet the &ldquo;OS&rdquo; itself did not provide any networking features: a separate product called Microsoft Networks (MS-NET) did. Windows 3.0 (1990) included support for NetBIOS, which allowed primitive printer and file sharing on local networks, but support for TCP/IP was nowhere to be seen.</p><p>In contrast, Unix <em>was</em> the Internet: all foundational Internet protocols were written for and with it. During the design of NT, it was therefore critical to account for good network support, and indeed NT did launch with networking features. As a result, NT did support both Internet protocols and the traditional LAN protocols used in pre-existing Microsoft environments, which put it ahead of Unix in corporate environments.</p><p>An an example, take NT&rsquo;s network domains. In Unix, network administrators typically synchronized user accounts across machines by hand; they&rsquo;d maybe use the X.500 directory protocol (1988) and Kerberos (1980s) for user authentication, which systems like SunOS implemented, but these technologies weren&rsquo;t particularly simple. Instead, NT offered <em>domains</em> from the get go, which integrated directory and authentication features, and it seems to me that these &ldquo;won the day&rdquo; in corporate networks because they were much easier to set up and were built into the system.</p><p>The goal of synchronized user accounts is to share resources across machines, primarily files, and when doing so, the way to represent permissions matters. For the longest time, Unix only offered the simplistic read/write/execute permission sets for each file. NT, on the other hand, came with advanced ACLs from the get go&mdash;something that&rsquo;s still a sore spot on Unix. Even though Linux and the BSDs now have ACLs too, their interfaces are inconsistent across systems and they feel like an alien add-on to the design of the system. On NT, ACLs work at the object level, which means they apply consistently throughout all kernel features.</p><p>And speaking of sharing files, we must talk about networked file systems. In Unix, the de facto file system was NFS, whereas on NT it was SMB. SMB was inherited from MS-NET and LAN Manager and is implemented in the kernel via a component called the <em>redirector</em>. In essence, the redirector is &ldquo;just&rdquo; one more file system, like NFS is on Unix, that traps file operations and sends them over the network, which brings us to comparing RPC systems.</p><p>Even though protobuf and gRPC may seem like novel ideas due to their widespread use, they are based on old ideas. On Unix, we had Sun RPC from the early 1980s, primarily to support NFS. Similarly, NT shipped with built-in RPC support via its own DSL&mdash;known as MIDL to specify interface definitions and to generate code for remote procedures&mdash;and its own facility to implement RPC clients and servers.</p><p>Moving down the stack, Unix systems have never been big on supporting arbitrary drivers: remember that Unix systems were typically coupled to specific machines and vendors. NT, on the other hand, intended to be an OS for &ldquo;any&rdquo; machine and was sold by a software company, so supporting drivers written by others was critical. As a result, NT came with the Network Driver Interface Specification (NDIS), an abstraction to support network card drivers with ease. To this day, manufacturer-supplied drivers are just not a thing on Linux, which leads to interesting contraptions like the <a href=https://ndiswrapper.sourceforge.net/wiki/index.php/Main_Page>ndiswrapper</a>, a very popular shim in the early 2000s to be able to reuse Windows drivers for WiFi cards on Linux.</p><p>Finally, another difference between NT and Unix lies in their implementation of named pipes. Named pipes are a local construct in Unix: they offer a mechanism for two processes on the same machine to talk to each other with a persistent file name on disk. NT has this same functionality, but its named pipes can operate over the network. By placing a named pipe on a shared file system, two applications on different computers can communicate with each other without having to worry about the networking details.</p><h1 id=user-space>User-space</h1><p>We are getting close to the end, I promise. There are just a few user-space topics to briefly touch on:</p><ul><li><p><strong>Configuration:</strong> NT centralized system and application configuration under a database known as the <em>registry</em>, freeing itself from the old <code>CONFIG.SYS</code>, <code>AUTOEXEC.BAT</code> and the myriad INI files that legacy Windows used. This made some people very angry, but in the end, a unified configuration interface is beneficial to everyone: applications are easier to write because there is a single foundation to support, and users have an easier time tuning their system because there is just one place to look at.</p><p>Unix, on the other hand, is still plagued by dozens of DSLs and inconsistent file locations. Each program that supports a configuration file has its own made-up syntax, and knowing which locations the program reads is difficult and not always well-documented. The Linux ecosystem has pushed for a more NT-like approach via XDG and dconf (previously GConf) but&mldr; it&rsquo;s an uphill battle: while desktop components use these technologies exclusively, the foundational components of the system may never adopt them, leaving an inconsistent mess behind.</p></li><li><p><strong>Internationalization:</strong> Microsoft, being the large company that was already shipping Windows 3.x across the world, understood that localization was important and made NT support such feature from the very beginning. Contrast this to Unix where UTF support didn&rsquo;t start to show up until the late 1990s, and supporting different languages came via the optional <code>gettext</code> add-on.</p></li><li><p><strong>The C language:</strong> One thing Unix systems like FreeBSD and NetBSD have fantasized about for a while is coming up with their own dialect of C to <a href=https://cs.rochester.edu/u/jzhou41/papers/freebsd_checkedc.pdf>implement the kernel in a safer manner</a>. This has never gone anywhere except, maybe, for Linux relying on GCC-only extensions. Microsoft, on the other hand, had the privilege of owning a C compiler, so they did do this with NT, which is written in Microsoft C. As an example, NT relies on Structured Exception Handling (SEH), a feature that adds try/except clauses to handle software and hardware exceptions. I wouldn&rsquo;t say this is a big plus, but it&rsquo;s indeed a difference.</p></li></ul><h1 id=conclusion>Conclusion</h1><p>NT was groundbreaking technology when it launched. As I presented above, many of the features we take for granted today in systems design were present in NT since its inception, whereas almost all other Unix systems had to gain those features slowly over time. As a result, such features don&rsquo;t always integrate seamlessly with Unix philosophies.</p><p>Today, however, it&rsquo;s not clear to me that NT is truly &ldquo;more advanced&rdquo; than, say, Linux or FreeBSD. It is true that NT had more solid design principles at the onset and more features that its contemporary operating systems, but nowadays&mldr; the differences are blurry. Yes, NT is advanced, but not significantly more so than modern Unixes.</p><p>What I find disappointing is that, even though NT has all these solid design principles in place&mldr; bloat in the UI doesn&rsquo;t let the design shine through. The sluggishness of the OS even on super-powerful machines is <a href=/2023/06/fast-machines-slow-machines.html>painful to witness</a> and might even lead to the demise of this OS.</p><p>I&rsquo;ll leave you with the books used to write this article in case you want to go through my learning journey. I had to skip over tons of interesting details, as you can imagine, so these are worth a read:</p><ul><li><a href="https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X?crid=1DW4GVN0DXZR4&amp;dib=eyJ2IjoiMSJ9.T5IY8OXVnanYLCjv3cX4UA18lTT67S00r-GHOWD5mzHAUtLk4np5tyXDZB6t25N5JGVVo4y_Yi-4Fv6TrXMJ_rs_BjLK_hTqetPsJAsHRsaw6ZbhMH07OitAfS2LpgEmdUNfdU8KoIM8BEJHof4aPIJMHkemWy0IFcaXoyQ9TLMcgLdTlMVF5Yqen-dG6NZeJ03UYK9NJXzHMgt4noQO1UmhxTMA2xw2Bhi-GDbZT4k.vGalnM5AX1xcE149fGsl5IjcbdD3yE0gw0F7_RojBV4&amp;dib_tag=se&amp;keywords=inside+windows+nt&amp;qid=1725808269&amp;sprefix=inside+windows+nt%2Caps%2C160&amp;sr=8-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=3f47c0d7cea553fed13057b16d417b6c&amp;language=en_US&amp;ref_=as_li_ss_tl">Inside Windows NT, 1st edition</a>.</li><li><a href="https://www.amazon.com/Design-Implementation-4-4-Operating-System/dp/0201549794?crid=289Z6M1NYSR8L&amp;dib=eyJ2IjoiMSJ9.4h3ssrq_vTu9MaMquFvEbw.YxrfgRofVfFKstV74Q_LR-XOseMUlCrcvkehHW6y5Yc&amp;dib_tag=se&amp;keywords=design+and+implementation+of+4.4bsd&amp;qid=1725808321&amp;sprefix=design+and+implementation+of+4.4bsd%2Caps%2C158&amp;sr=8-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=a0d6cc7fb69bc72b4649609390255bff&amp;language=en_US&amp;ref_=as_li_ss_tl">The Design and Implementation of the BSD 4.4 operating system</a>.</li></ul><p>And if you want to <em>continue</em> my journey and truly dive deep into how each piece of <em>modern</em> NT and Unix works, the newer editions are a must read:</p><ul><li><a href="https://www.amazon.com/Windows-Internals-Part-architecture-management/dp/0735684189?crid=2F7UR8S48RP6O&amp;dib=eyJ2IjoiMSJ9.p9cBb_-Q8GjuK0z0kDLKG6xoExPM_2QWt_jn0PlqVBSWYNyqRp2Cd7MHXFeQ4EiRACaX_Y_9xzECC0YpECzSl5kCBD3u1KUPduAgmnO732G9aqw1aLdQszw8LIXBOE1cYvOf3KYQmQ5vdFV6i4eFOttVvIa2XerkHVGiPd1OzTk32tEOchCbnUqpzW3QqCG7AjEmmKHFGuo5T2_UQDUERaSVRa26oAZHYuePCzDrwbY.bcHnZQWFYjmL64ZRnMieVsUH5JVx-T-WY88kj8V-uno&amp;dib_tag=se&amp;keywords=windows+internals&amp;qid=1725808358&amp;sprefix=windows+internals%2Caps%2C155&amp;sr=8-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=08d00ee830fe99b6e648add99e1b64c5&amp;language=en_US&amp;ref_=as_li_ss_tl">Windows Internals, part 1, 7th edition</a>.</li><li><a href="https://www.amazon.com/Windows-Internals-Part-2-7th/dp/0135462401?pd_rd_w=nmV0o&amp;content-id=amzn1.sym.3858a394-39a9-4946-90e6-86a3153d2546&amp;pf_rd_p=3858a394-39a9-4946-90e6-86a3153d2546&amp;pf_rd_r=FHEDS8GZCH0T6TA52GQD&amp;pd_rd_wg=VUb9D&amp;pd_rd_r=9f324aa8-7d91-4b6f-8c48-a8f09f1e8717&amp;pd_rd_i=0135462401&amp;psc=1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=a174f72e73013533f3ee8ca3f2cedd1c&amp;language=en_US&amp;ref_=as_li_ss_tl">Windows Internals, part 2, 7th edition</a>.</li><li><a href="https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972?crid=23A95KGH3XOCE&amp;dib=eyJ2IjoiMSJ9.WhRSQ2C6OFnyaT9IERCxYyLspyOoCkFSreJbs2Nia7zcYcNs68qdHuNBiIvERx987eDwl_H7YrMkTIj1575PGQ.orMCRh-1sVoQgFKgV2RtSiAxU3OA5fYRt6oAI3SV-p0&amp;dib_tag=se&amp;keywords=the+design+and+implementation+of+freebsd&amp;qid=1725850081&amp;s=books&amp;sprefix=the+design+and+implementation+of+freebsd%2Cstripbooks%2C136&amp;sr=1-1&amp;linkCode=ll1&amp;tag=blogsystem5-20&amp;linkId=ac0d39d3f598c50cd1d9dc650d2b4dd7&amp;language=en_US&amp;ref_=as_li_ss_tl">The Design and Implementation of the FreeBSD operating system, 2nd edition</a>.</li></ul></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/08/glibc-versions-runtime.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Windows+NT+vs.+Unix%3A+A+design+comparison&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F09%2Fwindows-nt-vs-unix-design.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Windows+NT+vs.+Unix%3A+A+design+comparison&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F09%2Fwindows-nt-vs-unix-design.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Windows+NT+vs.+Unix%3A+A+design+comparison+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F09%2Fwindows-nt-vs-unix-design.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>