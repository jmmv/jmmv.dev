<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>BazelCon 2024 recap - Julio Merino (jmmv.dev)</title><meta property="og:title" content="BazelCon 2024 recap - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="BazelCon 2024 recap - Julio Merino (jmmv.dev)"><meta name=description content="Just like that, BazelCon 2024 came and went. So&amp;hellip; it&amp;rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is A LOT to cover, but everything is here in just one article!"><meta property="og:description" content="Just like that, BazelCon 2024 came and went. So&amp;hellip; it&amp;rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is A LOT to cover, but everything is here in just one article!"><meta property="twitter:description" content="Just like that, BazelCon 2024 came and went. So&amp;hellip; it&amp;rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is A LOT to cover, but â€¦"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.111.3"><meta property="og:url" content="https://jmmv.dev/2024/10/bazelcon-2024-recap.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/10/bazelcon-2024-recap.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.cb91349cd93211a37e7d5dc131c35a170fc795721c03373cd05571327eea206b.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-10-22-bazelcon.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2024-10-22-bazelcon.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzEwL2JhemVsY29uLTIwMjQtcmVjYXAuaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/bazelcon-2024-recap")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>BazelCon 2024 recap</h1><p>October 22, 2024 &#183;
About 42 minutes
&#183;
Tags:
<a href=/tags/bazel>bazel</a>, <a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/snowflake>snowflake</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/bazelcon-2024-recap>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-10-22-bazelcon.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>Just like that, BazelCon 2024 came and went. And just like that, Blog System/5 is about to turn 1 year old as the very first post of this newsletter was the <a href=/2023/10/bazelcon-2023-et-al-trip-report.html>recap of BazelCon 2023</a>. Since then, this newsletter has amassed 1200+ subscribers and I have surpassed <a href=/2024/06/20-years-of-blogging.html>20 years of blogging</a>&mdash;so, thank you for your support, everyone!</p><p>To celebrate this milestone, it&rsquo;s obviously time to summarize the two events of last week: BazelCon 2024 and the adjacent Build Meetup. There is <em>A LOT</em> of ground to cover. I could probably write a separate article for each of the sections below, but folks coming for a summary of the conference will want to see everything in one place&mldr; so you get this massive piece instead.</p><p>Overall, this is a 40-minute read&mldr; but let&rsquo;s face it: getting 3 days worth of content in less than an hour sounds like a good deal, doesn&rsquo;t it? Feel free to pick and choose sections though; each stands on its own and each paragraph represents a thought I captured from some presentation or discussion.</p><p>By the way: no LLMs were involved in this work, thus you can only imagine how much effort it went into putting this together. So, subscribe to support this and future posts and&mldr; enjoy!</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=schedule-and-logistics>Schedule and logistics</h1><p>BazelCon 2024 was hosted at the Computer History Museum in Mountain View, CA, on October 14th and 15h. The conference had a <a href=https://bazelcon2024.sched.com/>single track of talks</a> and an overlapping track of BoF sessions. I attended most of the talks but just one BoF&mdash;the IDE one. The conference was followed by evening socials hosted by BuildBuddy and JetBrains/EngFlow.</p><p>The Build Meetup followed BazelCon 2024 on October 16th, and this time around it was cohosted by Meta and EngFlow in Menlo Park, CA. The meetup had three tracks: one for Bazel, one for Buck 2, and one for remote execution. I helped facilitate the Bazel track, including taking notes for the afternoon unconference (notes at the very end), and gave a 15-minute talk on Bazel at Snowflake. Facilitating the track was fun, but unfortunately this made me miss the Buck track and I&rsquo;m still wanting to learn more about it.</p><p>The notes I gathered from the talks and discussions are grouped in the following topics:</p><nav id=TableOfContents><ul><li><a href=#schedule-and-logistics>Schedule and logistics</a></li><li><a href=#community-and-adoption>Community and adoption</a></li><li><a href=#remote-execution>Remote Execution</a></li><li><a href=#ide-support>IDE support</a></li><li><a href=#inner-loop-development>Inner loop development</a></li><li><a href=#toolchains>Toolchains</a></li><li><a href=#sandboxing>Sandboxing</a></li><li><a href=#monorepo-issues>Monorepo issues</a></li><li><a href=#blzmod-and-external-dependencies>blzmod and external dependencies</a></li><li><a href=#secure-and-auditable-builds>Secure and auditable builds</a></li><li><a href=#symbolic-macros>Symbolic macros</a></li><li><a href=#queries>Queries</a></li><li><a href=#linting>Linting</a></li><li><a href=#testing>Testing</a></li><li><a href=#missing-tooling-around-bazel>Missing tooling around Bazel</a></li><li><a href=#the-end>The end</a></li></ul></nav><h1 id=community-and-adoption>Community and adoption</h1><p>The conference opened with the usual briefing and SOTU, which included information on the conference itself and the latest news in the Bazel project. These were followed by talks that touched upon the community and current adoption trends, and these are the thoughts I gathered:</p><ul><li><p><strong>Conference ownership:</strong> This was the first BazelCon <em>not</em> run by Google. The conference is now owned by the Linux Foundation and Google was a sponsor at the same level of BuildBuddy and EngFlow. The Linux Foundation has run the conference excellently thanks to the dedicated team of professionals that they have for the task.</p></li><li><p><strong>Conference history:</strong> Looking back, you should know that the Bazel team was (and still is) distributed across two sites: Google NYC and Google Munich. To mitigate the difficulties that arise from geographical distribution, the team held internal-only summits every 6 months. It wasn&rsquo;t until 2017 that this internal conference became BazelCon and, after that, the team alternated between an internal event and an external event. Last year, BazelCon had 250 attendees with a waitlist that contained 200 extra folks, and this is the second year that the program committee contains non-Google folks (myself included).</p></li><li><p><strong>Google&rsquo;s investment in Bazel:</strong> Does this shift to the Linux Foundation change <a href=https://bazel.build/contribute/policy>Bazel&rsquo;s governance</a> to make it more community-driven? Not yet, but it&rsquo;s a step in that direction! Google still owns Bazel and continues to invest in it because they can leverage contributions from strong non-Google engineers and because Google maintains a bunch of open-source projects that rely on Bazel. But Google also wants to have a more open community to guarantee that Bazel continues to thrive even if company-internal priorities change.</p></li><li><p><strong>The <a href=https://github.com/bazel-contrib><code>bazel-contrib</code> organization</a>:</strong> To support these changes, a few folks have created a new GitHub organization and have gotten Google to donate many repos to this new org. The organization creators have a desire to start a new foundation to support and direct these projects and are looking for about 5 companies to join.</p></li><li><p><strong>Bazel adoption stickiness:</strong> The REBELs research group at the <a href=https://rebels.cs.uwaterloo.ca/>Univesity of Waterloo</a> conducted a study over <a href=https://is.gd/WorldOfCode/>35,000 significant GitHub projects</a> to see why, from the 1.5% of projects that adopted Bazel, 11% of those abandoned the migration at roughly the 2-year mark.</p><ul><li><p><strong>Abandonment reasons:</strong> The reasons cited for abandoning Bazel were varied, but can be summarized as encountering technical challenges, issues with team coordination and onboarding, and seeing community trends (like Kubernetes deciding to move off of Bazel).</p></li><li><p><strong>If not Bazel, then what?:</strong> These projects primarily decided to move to language-specific tools, especially for languages with strong native tooling like Go and Swift. However, a significant proportion also decided to move back to &ldquo;inferior&rdquo; tools like CMake or even GNU Make. These projects acknowledged that these tools are less feature rich and don&rsquo;t support integration with other languages, but they are conventional and easier to understand by the community.</p></li><li><p><strong>If Bazel, then why?:</strong> On the plus side, for the cases where Bazel stuck, we can find the reasons we expect: dependency management, faster builds, and even the influence of other projects shine as reasons for making Bazel a good choice.</p></li></ul></li><li><p><strong>Adoption suggestions:</strong> The CTO of Ergatta spoke on how his small company has been able to successfully leverage Bazel without massive investments in infrastructure. His suggestions were to keep things simple (e.g. by using the GCS-backed cache despite its flaws, or by doing the trivial <code>bazel test ...</code> on CI); to expedite solutions even if not perfect (e.g. by wrapping foreign builds in Bazel); to look for champions and leverage them for adoption; to focus on &ldquo;good enough&rdquo; results; to write documentation for your successors; and, surprisingly, to do frequent and incremental changes to workflows instead of big-bang &ldquo;improvements&rdquo;.</p></li></ul><h1 id=remote-execution>Remote Execution</h1><p>As you know, remote execution is Bazel&rsquo;s raison d&rsquo;etre. Consequently, the SOTU covered various updates on this topic and many talks included related thoughts:</p><ul><li><p><strong>SOTU updates:</strong> The remote output service is now available and bb-clientd offers an implementation. The execution log is now 100x smaller than before and only has a 3% runtime overhead, which is useful to debug cache hits. Upcoming changes include concurrent uploads to the cache in the background without blocking action completion, GCing of local caches (disk cache, install cache, etc.), and BwoB improvements to decrease incremental build times when Skymeld is in use.</p></li><li><p><strong>Remote persistent workers:</strong> AirBnB observed 2x slower builds when not using remote persistent workers. They use dedicated pools for Java and Kotlin and route all actions into these pools, and reminded us that tagging targets comes with pitfalls because targets can spawn multiple actions and just one of them needs the worker.</p></li><li><p><strong>Queuing control:</strong> Remote execution environments typically have different worker pools to support different build environments or to optimize cost. But note: the goal shouldn&rsquo;t always be to tolerate all possible load all the time: it is reasonable to put limits on the worker pools like AirBnB does so that you can dedicate a pool for interactive builds and prioritize low latency, but also create a separate pool for CI builds where you put hard caps and tolerate queuing.</p></li><li><p><strong>Target size matters:</strong> Dealing with tons of individual small files is costly. In some cases, you may be better off tarring them up and declaring a single input to an action and making the action unpack the tar during execution. This came up during the talk on high performance builds for web monorepos, and I found this interesting because this goes in the opposite direction of tree artifacts which have often been problematic.</p></li><li><p><strong>Action deduplication:</strong> Any remote execution service worth its money can coalesce in-flight actions to save on cost. This shines in CI with builds that have long-running actions, and Canva reports that they see 500k dedups per day on about 3 webpack builds. One consideration is that flaky test passes/failures are amplified by action coalescing: without this feature, flakes will show up as random failures over time, whereas with this feature, failures will be clustered. Extracting a signal around flakiness becomes harder.</p></li><li><p><strong>Determinism checks:</strong> While not necessarily an issue with remote execution, having remote execution exacerbates the problem of non-deterministic actions in a build. Spend the time to set up a CI job to <a href="https://www.youtube.com/watch?v=XItY0LmdiFA">look for non-determinism</a> and alert on it. Specific problems that often arise are timestamps in JARs (<code>rules_antrl</code> is impacted), absolute paths (<code>rules_kotlin</code> is impacted), or diagnostics information (Scala <code>sdeps</code> file is problematic).</p></li><li><p><strong>Postmortems and learnings:</strong> Ulf Adams gave a talk reflecting on four different incidents that EngFlow&rsquo;s remote execution service suffered. Personally, seeing companies introspect their failures makes <em>me</em> trust them <em>more</em> than not, but YMMV. In any case, I do not necessarily want to go over the incidents per se, but I do want to go over the recommendations:</p><ul><li><p><strong>Avoid RPC cycles and set timeouts:</strong> The call graph between services must not have cycles, which is hard to enforce because these may show up organically over time. Also make sure to have timeouts on all RPCs, although the RE protocol makes this difficult because it has long-running RPCs.</p></li><li><p><strong>Make sure <a href=https://grpc.io/docs/guides/flow-control/>flow control</a> is configured:</strong> This is a feature of gRPC that allows a server to keep memory consumption in check and is achieved by &ldquo;slowing down&rdquo; incoming traffic (thus &ldquo;controlling the flow&rdquo;). When proxying traffic in a server, special care must be taken to connect the flow control logic of the input and output streams of the proxy. Otherwise, a slow client can have ripple effects through the system and cause OOMs.</p></li><li><p><strong>Auto-scaling is tricky to get right:</strong> From a cost-savings perspective, you want to downsize servers as quickly as possible and increase them slowly. But if you do this and there is queuing, it&rsquo;s possible that auto-scaling will make queuing worse.</p></li><li><p><strong>Guardrails build trust:</strong> You might say that user-induced problems are not service problems: after all, if, for example, they cause compile actions to time out after 20 minutes, it&rsquo;s &ldquo;their fault&rdquo; for doing the wrong thing. However, if this happens, there obviously is something wrong&mdash;and it&rsquo;d be nice for the service provider to notice and have prevention features in place just like your water provider can detect leaks. (And yet&mldr; AWS <em>still</em> doesn&rsquo;t have a way to put a limit on spend.)</p></li></ul></li></ul><h1 id=ide-support>IDE support</h1><p>If you have had to support any developers converting from &ldquo;legacy&rdquo; build systems to Bazel, you may have realized that&mldr; the IDE features they are used to don&rsquo;t quite work after the migration. Things have gotten better in the IDE space for Bazel but aren&rsquo;t great yet. Fortunately, there are a few news that give hope:</p><ul><li><p><strong><a href=https://jb.gg/new-bazel-plugin>New JetBrains plugin for IntelliJ</a>:</strong> Released to the marketplace during the conference, this new plugin provides tighter integration between IntelliJ and Bazel through the BSP abstraction layer. This new plugin can represent the Bazel build graph in the IDE, offers syntax highlighting for <code>bazelrc</code> files (and, feature request: could offer docs on hover), supports inserting breakpoints in Starlark evaluation, implements &ldquo;fast build&rdquo; correctly, and optimizes the sync process. There are some gaps compared to the old plugin, but I&rsquo;m super-excited by what&rsquo;s coming because the old Google-owned plugin is&mldr; underwhelming. See the <a href=https://jb.gg/new-bazel-feature>feature list</a> and the <a href=https://jb.gg/new-bazel-roadmap>roadmap</a> for more details.</p></li><li><p><strong>Build Server Protocol (BSP):</strong> The BSP is a new protocol that aims to achieve the same thing that the Language Server Protocol (LSP) did: namely, solve the M:N problem between IDEs and build systems. The idea is to have an intermediate abstraction for the build system so that M IDEs can talk to N build systems by means of an intermediary process that converts the BSP to build actions. The BSP is still young though and, right now, it&rsquo;s pretty rigid because it has deep knowledge of the languages it supports. In particular, there is no support for custom rules yet, so get involved if you want to see this happen.</p></li><li><p><strong>Old plugin for JetBrains:</strong> The old plugin will be fully supported until mid-2025 (although I predict they&rsquo;ll have to backpedal on this and extend this date). This plugin has many shortcomings because it originates from Android Studio and contains assumptions about Android and about Google&rsquo;s own infrastructure. That said, there is a new feature called &ldquo;query sync&rdquo; that optimizes the sync process massively&mldr; at the expense of having to manually &ldquo;enable analyze&rdquo; for any files where deep IDE integration is desired. The problem is: you <em>have</em> to enable analysis to get insights on generated files, and generated files tend to be everywhere thanks to protobuf, so&mldr; you&rsquo;ll likely find yourself &ldquo;enabling analyze&rdquo; all the time. Shrug.</p></li><li><p><strong>Good IDE support is critical:</strong> Having a good IDE experience is crucial for developers, but the irony is that the people that often work on build migrations or the IDE are <em>experts</em> and know how to tolerate imperfect IDE support. This is not the case for most developers, particularly those that must get up to speed&mldr; so keep that in mind. Running user interviews, surveys, etc. is a necessity to understand what people truly perceive as problems.</p></li><li><p><strong>Compilation database:</strong> JetBrains is not the only contender in the IDE space. There are many more (wink, wink, Emacs) and BSP will make offering a Bazel experience within them possible. Until that&rsquo;s ready, though, you may need to manually deal with a &ldquo;compilation database&rdquo;, especially if you want to integrate with VSCode. A compilation database is, simply put, a JSON file that contains the commands to compile each and every translation unit in a project. There are various options to generate one of these with Bazel, all with different trade-offs:</p><ul><li><p><strong>Intercept builds:</strong> Use <code>bear</code> as a wrapper to run the full clean build. This works with some build systems, but unfortunately, Bazel&rsquo;s client/server model doesn&rsquo;t allow <code>bear</code> to intercept the actions it spawns.</p></li><li><p><strong>Extra actions:</strong> Add a &ldquo;listener&rdquo; extra action that listens for <code>CppCompile</code>. This also requires a full clean build and is deprecated by aspects, but is the approach that <code>kythe</code> uses.</p></li><li><p><strong>Action graph query:</strong> Does not require a full build, just a warmed up analysis cache. However, this does not support tree artifacts. Examples: <code>bazel-compile-commands-extractor</code>, <code>bazel-compile-commands</code> (two forks).</p></li><li><p><strong>Aspect:</strong> Does not require a full build, but the generated commands may not be identical to the ones that are actually used. For example: if you have a code generator that produces a tree artifact and then is fed as an input to a <code>cc_library</code>, then the tree artifact is represented as a <code>CppCompileActionTemplate</code> that is only expanded to a specific command line at runtime.</p></li></ul></li><li><p><strong>Non-blocking queries:</strong> The Bazel server has a global lock that prevents it from running more than one command at a time. This is a problem because the IDE needs to issue Bazel queries all the time, but those queries conflict with other user actions like builds and tests. There are various solutions to this problem, which we discussed in the unconference:</p><ul><li><p><strong>Separate output bases:</strong> This <em>works</em> but it&rsquo;s heavy-handed because you end up with two full separate builds and two separate Bazel server processes.</p></li><li><p><strong>Simpler tools:</strong> Many operations on build files do not require the full weight of Bazel. Google has implemented simpler tools that operate on those precisely to bypass the overhead of calling ito Bazel. These tools include <code>buildifier</code>, <code>buildozer</code>, or the &ldquo;fast builds&rdquo; feature of the IntelliJ plugin.</p></li><li><p><strong>Parallel Skyframe evaluation:</strong> Skyframe&rsquo;s inherent design is to be purely functional, so in principle it should be possible to perform multiple operations on the graph in parallel. Unfortunately, there is a lot of mutable state outside of Skyframe in Bazel and, while theoretically possible, fixing this is <em>a lot</em> of work.</p></li><li><p><strong>Implementing a depserver:</strong> Instead of running a separate Bazel on the same machine to answer queries, you could push this responsibility to an external service. Such a service is easy to build (you can imagine running <code>bazel query ...</code> on each commit) but the problem arises when you want to issue queries against this service from modified source trees.</p></li></ul></li></ul><h1 id=inner-loop-development>Inner loop development</h1><p>Bazel is <em>the</em> tool that glues together the <em>inner loop</em> of the development process. As a reminder, the inner loop refers to the the edit, build, and test cycle, and Bazel has tentacles on these three stages. Various talks gave thoughts on this topic:</p><ul><li><p><strong>Avoid Bazel in the inner loop:</strong> AirBnB reported that they noticed significant overhead and lack of incrementality in certain operations when trying to hook up Bazel into the IDE. They have the equivalent of &ldquo;fast builds&rdquo; in their own IDE plugin and have reduced incremental builds from 30 seconds to 1 second. This is a <em>big deal</em> for interactive builds. Personally, I think that having to side-step Bazel is ridiculous: Bazel is designed to be optimal and has perfect knowledge of the state of the world, yet it&rsquo;s too slow for quick operations.</p></li><li><p><strong>Integrate with native tooling:</strong> Bazel works across many ecosystems, but as such, it&rsquo;s friend to none. For example: Go developers want to work with the (super-fast) Go tooling so, if it&rsquo;s feasible, it&rsquo;s interesting to allow using such tooling directly. The folks at LinkedIn created a rule that generates an <code>.envrc</code> file to expose the native Go tools and relies on <a href=https://direnv.net/><code>direnv</code></a> to make this work transparently for users.</p></li><li><p><strong>macOS as a client is common:</strong> Even for shops where all software runs on Linux, developers tend to have Macs and want to work locally. You may or may not agree, but if you <em>have</em> to support inner-loop development on the Mac, there are various things to consider. One is that cross-platform caching for machine-independent actions like Java may not work, doubling cache requirements; for this, you may consider using &ldquo;universal binaries&rdquo; (aka shell scripts that wrap multiple binaries and choose the right one at runtime). And you should really set up non-determinism checks.</p></li><li><p><strong>No build files:</strong> To my dismay, tons of people seem to really want to <em>not</em> have build files. This makes me sad because manually-curated build files serve as <em>documentation</em> for the <em>conceptual architecture</em> of a project and allow, at PR review time, to see changes to the interactions between components. You might say that <code>#include</code>s or package <code>import</code>s in the source are sufficient for this&mdash;but they really aren&rsquo;t: they are too fine-grained and &ldquo;innocent-looking&rdquo;. I think I&rsquo;ll need to write a follow-up article on this point.</p></li></ul><h1 id=toolchains>Toolchains</h1><p>Bazel supports targeting multiple architectures and systems, and at the core of this support lie toolchains. There were various talks that touched on them:</p><ul><li><p><strong>Toolchains 101:</strong> In Bazel, rules convert providers to action templates, and toolchains help convert those templates to actions by replacing two things in the templates: the paths to the tools required by the action, and the arguments to pass to those tools. Simple, right? But defining toolchains has always been a black art.</p></li><li><p><strong>Simplified toolchains:</strong> Google brings a new way to define toolchains that&rsquo;s much easier than the original one. The new mechanism relies on build rules: a toolchain rule declares a toolchain, and the toolchain depends on a &ldquo;tool map&rdquo; rule, which is a flat map of tool names (strategically specified as labels for typo- and type-checking, not flat strings) to binaries (also specified as labels). These tools are also connected to argument rules that define the sequence of arguments to apply to each tool. The support for &ldquo;features&rdquo; in core Bazel can potentially be removed in favor of this.</p></li><li><p><strong>Default toolchain no more:</strong> Following on the previous, Google said that there is a desire to remove the concept of a default C++ toolchain in favor of explicitly defining a hermetic toolchain like almost all other rules do. This was met with cheering from the audience.</p></li><li><p><strong>Debugging:</strong> It&rsquo;s funny how, despite the complexity of toolchains and how we should make things easier for users&mldr; <code>--toolchain_resolution_debug</code>&rsquo;s help claims that the flag is only for experts. <a href=https://github.com/bazelbuild/bazel/pull/19926>PR 19926</a> made the debugging messages much clearer, but you should still understand the toolchain resolution algorithm to make sense of issues, and the talk on &ldquo;Creating C++ toolchains easily&rdquo; explained that.</p></li><li><p><strong>Universal binaries:</strong> Bazel doesn&rsquo;t like sharing artifacts across different architectures. This is generally the right thing to do but, for platform-agnostic languages like Java, this has the potential of doubling remote execution and caching costs. There is an <a href=https://github.com/bazelbuild/bazel/discussions/18378>ongoing discussion upstream</a> on what to do with this issue and various partial implementations in the code (like the <code>--experimental_platform_in_output_dir</code> flag), but no great solution yet. In the meantime, the alternative is to implement &ldquo;universal binaries&rdquo;. The idea is to create a shell script that wraps a binary tool built for various systems and selects, at runtime, which one to run.</p></li><li><p><strong>C++ shows up everywhere:</strong> Even if your build doesn&rsquo;t seem to require C++ anywhere, the requirement to have this toolchain installed shows up pretty much everywhere because of&mldr; protobuf. bzlmod has the potential to fix this because the protobuf bzlmod packages ship with prebuilt binaries.</p></li></ul><h1 id=sandboxing>Sandboxing</h1><p>In order to offer reproducible builds, Bazel offers sandboxing features at the action level to ensure that actions can only do what they are supposed to do. I used to work in this space while on the Bazel team, so all talks on this topic were really interesting. Here are the notes:</p><ul><li><p><strong>macOS sandboxing is slow:</strong> Ah, the issue that never dies and that came up again in the unconference. While it might be true that macOS handles symlinks poorly, I&rsquo;m still not convinced that there is anything that makes macOS sandboxing inherently slow. Yes, it will be less sandbox-y than what you get on Linux, but performance-wise it should be OK. All of my testing years ago didn&rsquo;t show <code>sandbox-exec</code> as a performance bottleneck, and the sandbox doesn&rsquo;t kill Bazel&rsquo;s own build performance so&mldr; something <em>else</em> is at play here. Which brings us to the next point.</p></li><li><p><strong>Persistent state:</strong> Some compilers like Objective C&rsquo;s build a module cache as they run. This cache is intended to be shared across invocations of the compiler. However, when the sandbox is in effect, sharing of this cache becomes impossible, which in turn makes builds incredibly slow. It may <em>seem</em> as if the sandbox itself is slow, but the real problem here is the lack of state sharing across actions and I suspect this is why people remain convinced that macOS sandboxing is slow. And, by the way, this impacts more than just Objective C.</p></li><li><p><strong>Sandboxing scenarios:</strong> Is it really necessary to sandbox <em>all</em> rules? <code>genrule</code>s, sure, but if we can reason about the behavior of specific rules, we can probably disable sandboxing for them and remain correct, which would decrease build-time overheads. (Remember that the sandbox was never about security.)</p></li><li><p><strong>File monitoring:</strong> An alternative to sandboxing is to monitor the activity of build actions and validate, post-build, that they didn&rsquo;t access things they were not supposed to. This is much faster than sandboxing as it avoids the need to construct on-disk sandboxes&mldr; but fails when tools decide to read directories. So&mldr; this approach isn&rsquo;t really feasible. JavaScript tooling loves to expand globs.</p></li><li><p><strong>Hermetic sandboxing:</strong> The traditional Bazel sandbox does not restrict reading system-wide paths so it cannot guarantee that an action doesn&rsquo;t access certain system headers or arbitrary tools in <code>/bin</code>. There is a &ldquo;new&rdquo; hermetic sandbox for Linux that fixes these issues&mdash;but, obviously, is hard to put in practice. See <code>--experimental_use_hermetic_linux_sandbox</code>.</p></li><li><p><strong>Base POSIX system:</strong> With a hermetic sandbox, it becomes very tempting to model the host system&rsquo;s base libraries and tools (bash and the like) as a toolchain. <a href=https://github.com/tweag/rules_sh><code>rules_sh</code></a> from Tweag can help here.</p></li><li><p><strong>Local remote execution:</strong> A different mechanism to achieve sandboxing would be to use remote execution against a local service. This service could run on a VM or similar and offer a mechanism to cross-compile against weird architectures. This wouldn&rsquo;t be quite the same as the Docker strategy.</p></li><li><p><strong>Separation of responsibilities:</strong> Somebody mentioned that it&rsquo;d be neat to separate the sandboxing logic into its own thing that isn&rsquo;t in Bazel&rsquo;s core. I agree. The <code>linux-sandbox</code> binary that Bazel contains is somewhat akin to this, and I previously implemented something similar in <a href=https://github.com/jmmv/sandboxctl><code>sandboxctl</code></a> (for very different reasons). In any case, this would need to be multi-platform and written in a decent, safe language (<em>cough</em> Rust <em>cough</em>).</p></li></ul><h1 id=monorepo-issues>Monorepo issues</h1><p>With scale come problems, and large monorepos tend to exacerbate issues that have always existed in small repos but that go unnoticed otherwise. Here are some of the issues that talks mentioned:</p><ul><li><p><strong>Glob handling:</strong> Globs are expensive to handle in Bazel, especially when running on networked file systems. Globs are parsed and then expressed as a DAG of functions within Skyframe. Right now, due to limitations in Java&rsquo;s concurrency model, globs are evaluated twice, but Java 21&rsquo;s green threads may alleviate this. Related, I was chatting about this with one of the Buck 2 authors and he said that they take a very different approach and don&rsquo;t find the issues that Google described: basically, they traverse the file system once and then apply the glob as an in-memory only operation.</p></li><li><p><strong>Monolithic targets:</strong> Any large piece of code that has grown without a build system that enforces boundaries across components will grow at least one component that has thousands of source files in it with cyclic dependencies among them. These are harmful to the organization as they tend to reflect the &ldquo;broken windows&rdquo; culture of the team. Tinder explained how they tackle this problem, with basically boils down to: ensuring there are tests, ensuring that leadership is onboard with the cleanup, creating automation to extract files from the monolith (most of the work is repetitive), and then creating visualization tools to graph the problem and identify subsets of files that can be easily extracted.</p></li><li><p><strong>Gradual rollout of library updates:</strong> During the unconference, we discussed how to deal with version upgrades of a single library in a world that favors the &ldquo;One version policy&rdquo;.</p><ul><li><p><strong>Prerequisites:</strong> We agreed that, to succeed at upgrading a library, it&rsquo;s critical to have tests in place and leverage tooling like <code>buildifier</code> to perform the upgrades automatically where possible.</p></li><li><p><strong>Big bang upgrade:</strong> One approach to the problem is to do the version upgrade in one go. This is sometimes really hard to do, and can also be risky because any problem anywhere in the repo would imply a rollback for everyone.</p></li><li><p><strong>Treat it as an exception:</strong> Another approach is to get an exception from the &ldquo;One version policy&rdquo; and temporarily allow two versions of the library in the repo. You can leverage the <code>alias</code> rule to introduce an indirection to the version in use, and then slowly migrate packages. This can work but diamond conflicting dependencies can be a real problem.</p></li><li><p><strong>Parallel build:</strong> Yet another approach is to create a parallel build and test infrastructure for the new version. Maybe use a build flag to select the version to use; maybe duplicate the targets and rename them. The goal with this approach is to keep the &ldquo;new version&rdquo; on the side until it all works, and then submit a trivial &ldquo;3-line PR&rdquo; that flips the default. For this scenario, &ldquo;project files&rdquo; would be useful to group the new set of targets and automatically set the right configuration for them; Buck 2 has something similar in its <code>PACKAGE</code> construct.</p></li><li><p><strong>Different package names:</strong> And another approach is to do what Java tends to do, which is to <em>rename</em> the libraries on major version upgrades so that they do not conflict at all. This is something that the upstream library maintainers have to do, not you. The problem with this approach is that semantic version is not always accurate and upstream maintainers tend to do breaking changes during minor version upgrades without realizing it.</p></li></ul></li><li><p><strong>git pain:</strong> Bazel and large monorepos go hand in hand, but Git&mdash;the most popular version control system&mdash;doesn&rsquo;t like large repos very much: some operations scale with the size of the history (<code>git clone</code>) while others scale with the size of the repo (<code>git status</code>) instead of scaling with the size of the change.</p><ul><li><p><strong>Mitigation tools:</strong> There are various options that can mitigate the problem, including the <a href=https://git-scm.com/docs/git-fsmonitor--daemon>FSMonitor</a>, the &ldquo;untracked cache&rdquo;, keeping <code>.gitignore</code> small, and using sparse checkouts.</p></li><li><p><strong>Materializing a portion of the tree:</strong> Uber previously tried using a Bazel query to find all files required for a build and then using the result of the query to just check those files out from Git. While this can work, it led to confusing error messages when there were missing files. And also, this poses the question: where do you run the query given that the query needs access to the full repo?</p></li><li><p><strong>git archives:</strong> Git is a very chatty protocol. Mark Zeren from Broadcom reports that, while Perforce can easily saturate the network, Git can rarely do so on a similar repo. The slowdown is even visible when using the loopback network interface. Prebuilding <code>git-archive</code>s periodically and using those to build the initial state of a Git clone can significantly improve performance. He mentioned that it&rsquo;d be good to build a service to automate this, and offered help in doing so.</p></li><li><p><strong>Delegating file accesses:</strong> There is an open feature request in <a href=https://github.com/bazelbuild/bazel/issues/16380>#16380</a> asking for a way to delegate file accesses to another tool. This, to me, sounds like FUSE. Someone brought up that FUSE doesn&rsquo;t work well on macOS anymore and that NFS can be used as an alternative, and Meta&rsquo;s EdenFS or Buildbarn&rsquo;s bb-clientd&rsquo;s do that just fine. Another option is to implement a custom VFS instance within Bazel to directly talk to a remote file system.</p></li></ul></li><li><p><strong>Resource consumption:</strong> Bazel&rsquo;s memory usage is&mldr; troublesome. First, because Bazel uses a lot of memory, and second because of the JVM&rsquo;s heap limits. Newer Bazel versions were able to reduce <em>retained</em> heap memory by 95% after a build and 25-30% overall during a build&mldr; but that&rsquo;s not very useful because <em>peak</em> memory consumption is what matters in many cases. The team is looking at various alternate solutions to tackle this problem:</p><ul><li><p><strong>Skyfocus:</strong> Bazel 8 contains a new feature called Skyfocus, in experimental state. The idea is to perform GC based on a user-defined working set. This is useful in large monorepos where users want to only work on a small portion of the tree, but there are questions about the usability aspects and UX of this solution.</p></li><li><p><strong>Skeletal analysis:</strong> The goal of this work is to try to change the evaluation model to reduce peak memory by 20%. The idea is to trade memory usage for wall time, which means this will be useful for CI but could be harmful for interactive builds.</p></li><li><p><strong>(Remote) Analysis caching:</strong> The loss of the Bazel analysis cache across reconfigurations or server restarts has always been a problem and a major usability annoyance, so this is finally being looked at. The goal is to be able to cache configured targets, aspects, action execution results, and other Bazel-internal state, possibly storing this information in the &ldquo;standard&rdquo; remote cache by using a special key. This could also help with a ~70% heap and runtime reduction for analysis phases from cold start, and it could be used to prune entire subgraphs during the execution phase. This would be a massive improvement for IDE interactions, as IDEs primarily rely on analysis-time operations only.</p></li><li><p><strong>Distributed analysis:</strong> The idea is to shard analysis across Bazel workers. This sounds&mldr; OK for gigantic monorepos like Google&rsquo;s but I&rsquo;m not sure I see the use case outside of that environment. Still in very early stages of discussion.</p></li></ul></li></ul><h1 id=blzmod-and-external-dependencies>blzmod and external dependencies</h1><p>The <code>WORKSPACE</code> in Bazel has always been a wart: Google did <em>not</em> have this feature in Blaze but the need to support out-of-tree third-party dependencies became glaringly obvious when they open-sourced Bazel. The <code>WORKSPACE</code> was then bolted on and we have been suffering from its deficiencies for years. bzlmod promises to fix them all, and of course there were talks (and a BoF) on it:</p><ul><li><p><strong>SOTU dependency updates:</strong> bzlmod now provides a vendor mode to download all dependencies of a target or all targets, which is very useful for CI/CD offline builds (e.g. to exercise disaster recovery). <code>MODULE.bazel</code> now has include support and <code>use_repo_rule</code> for easier migration. The lock file format has been revamped to minimize merge conflicts. The <code>WORKSPACE</code> is disabled by default in Bazel 8 and won&rsquo;t be available in Bazel 9. As for future plans, the repo cache will be shared across workspaces and will include the results of evaluation, not just downloads.</p></li><li><p><strong>SOTU rule updates:</strong> The Python, Android, Java, and shell rules have all moved to Starlark. Protobuf and Android support have moved as well, and this comes with new things like &ldquo;mobile install v3&rdquo;. The goal for next year is to complete the Starlarkification effort (with possible new extension points to call into Bazel from the Build API).</p></li><li><p><strong>SOTU Starlark and the Build API:</strong> All struct providers are gone; aspects can propagate to target toolchains; and there are now dormant dependencies for tests. As for upcoming changes: symbolic macros in Bazel 8 (more later); rule finalizers; and types for Starlark (which are compatible with Python 3 but <em>not</em> with Buck).</p></li><li><p><strong>Handling internal artifacts:</strong> It is common for vendors to provide binary blobs that don&rsquo;t integrate with Bazel. Azul&rsquo;s JDK is an example. For these, it is interesting to consume them into the build via a workspace repository, but the question then becomes how to do this with bzlmod. The answer is to &ldquo;layer multiple registries&rdquo;: you&rsquo;d have a company-internal registry that exposes these binaries, and then fall back to the BCR for everything else.</p></li><li><p><strong>Disabling the BCR:</strong> For companies that want to have tight control on what they access during the build, it&rsquo;s perfectly possible to bypass the BCR, either by pointing Bazel to an internal registry or by vendoring sources. The <code>bazel vendor</code> subcommand, which I didn&rsquo;t know about, can come in handy.</p></li><li><p><strong>Missing packages:</strong> There are some glaring omissions from the BCR right now, which include googleapis, gRPC, and <code>rules_scala</code>. The maintainers of the former are not very cooperative, but progress is being made. As for gRPC, there is a desire to avoid pulling in support for all languages all the time, which makes this technically harder.</p></li></ul><h1 id=secure-and-auditable-builds>Secure and auditable builds</h1><p>Maintaining the integrity of the software provenance chain is difficult and &ldquo;recent&rdquo; events like the <a href=https://en.wikipedia.org/wiki/XZ_Utils_backdoor>XZ Utils Backdoor</a> have shown the criticality of, at least, having an audit trail of what goes into software builds. This is where SBOM and other techniques come into play, and Bazel-based builds are perfectly positioned to provide these assurances:</p><ul><li><p><strong>SBOMs:</strong> There are many different formats to produce a <a href=https://www.ntia.gov/page/software-bill-materials>Software bill of materials (SBOM)</a>, and a few of them like CycloneDX and SPDX are standardized. It&rsquo;s important that these files are &ldquo;merge-able&rdquo; so that, when you import a third-party dependency, you can assemble their own SBOM.</p></li><li><p><strong>Types of targets:</strong> It&rsquo;s tricky to generate the SBOM, and not all rules to generate one did or do the right thing. For example: do all deps belong in the SBOM? What about deps that say <code>neverlink=1</code>? What about build-time only deps like compilers?</p></li><li><p><strong>Rules:</strong> Bazel has had a <code>licenses</code> package-level function for a long time, but it is insufficient to generate an SBOM. The newer <a href=https://github.com/bazelbuild/rules_license><code>rules_license</code></a> offers a much more complete solution to tracking licenses and generating SBOMs.</p></li><li><p><strong>Build assurance:</strong> Other than declaring licenses, it&rsquo;s important to be able to verify <em>where</em> builds came from. <a href=https://slsa.dev/>SLSA</a> defines various levels that capture different requirements. At the very least, you should target SLSA 2, which requires builds to be produced from trusted environments and to prevent arbitrary users from tampering with those builds (e.g. only allowing uploads to the Action Cache by CI). SLSA 3 is even more strict but RE doesn&rsquo;t yet provide a mechanism to implement it; there are some talks to support it in V3 and maybe backport it to V2, but no concrete plans yet.</p></li></ul><h1 id=symbolic-macros>Symbolic macros</h1><p>Macros are problematic: they tend to cause targets to require public visibility; they tend to pollute the list of available targets in a package (the output of <code>bazel query</code> is unusable); and they have the potential of bloating the build graph massively. There was a full talk from Google on a new feature that&rsquo;ll make these less of an issue:</p><ul><li><p><strong>New feature:</strong> Bazel 8 ships with <em>symbolic macros</em>, which are first-class citizens of the build graph. Symbolic macros are declared similarly to rules: instead of specifying <code>rule()</code>, you specify <code>macro()</code> and provide a set of attributes and an implementation function. The names of the targets and outputs that these macros produce are constrained to a set of well-defined patterns.</p></li><li><p><strong>Limitations:</strong> One known deficiency is that <code>**kwargs</code> doesn&rsquo;t work as it used to because there is no way to specify this in an attribute list. The way to mitigate this and make it easier to wrap rules will be attribute inheritance. Similarly, while symbolic macros can lead to lazy expansion, this is not yet implemented. Both of these limitations will be addressed later in the 8.x series.</p></li><li><p><strong>Epilogs:</strong> Legacy macros used to call <code>native.existing_rules()</code> and lead to the &ldquo;epilog macro&rdquo; idiom that can be found in large monorepos. These macros are expected to appear at the end of a build file&mldr; but there is no way to enforce this. With symbolic macros, this idiom is now a supported feature via the <code>finalizer=True</code> attribute, which then makes these macros be expanded <em>after</em> the full build file has been processed irrespective of any other targets.</p></li><li><p><strong>Downsides:</strong> Symbolic macros were well-received by conference attendees but have received some pushback inside of Google. The reason is that, because these macros will allow lazy evaluation, it&rsquo;s possible that they&rsquo;ll encourage even larger packages that only become problematic in some (critical) scenarios.</p></li><li><p><strong>Legacy macros:</strong> There are no plans to remove legacy macros right now&mdash;and even if there were, it&rsquo;d take years to eliminate them due to the need to remain backwards-compatible for multiple releases.</p></li></ul><h1 id=queries>Queries</h1><p>For people coming from other build systems, the ability to query a build graph may sound like an alien concept. But Bazel has first-class features to do just this, and they can come in handy when writing automation to modify the source tree or to select tests for execution.</p><p>There was a full 30-minute talk dedicated to queries. I do not intend to repeat everything that was said because everything is in <a href=https://bazel.build/query/language>the query documentation</a>&mldr; but I did learn a bunch of stuff:</p><ul><li><p><strong>Target provenance:</strong> <code>bazel query --output=build ...</code> shows &ldquo;fictitious&rdquo; attributes like <code>generator_{name,function,location}</code> which indicate what produced a target. Useful to understand what macros and globs are doing. These attributes can also be used in filters.</p></li><li><p><strong>Variables:</strong> Queries can have variables in them to avoid repeating complex parts. For example: <code>let v = foo/... in allpaths($v, //common) intersect $v</code>.</p></li><li><p><strong>Removing implicit dependencies:</strong> These often pollute query results with noise and can be removed with <code>--noimplicit_deps</code>. Arguably, this flag should be the default.</p></li><li><p><strong>Graphing:</strong> It is possible to generate a Graphviz file by using <code>--output=graph</code> and then graphing it with <code>dot -Tsvg -o graph.svg</code>. It is important to filter the query or otherwise the resulting graph is overwhelming&mdash;aka useless.</p></li><li><p><strong>Running code on the graph:</strong> The <code>cquery</code> command supports <code>--output=starlark --starlark:expr=...</code> which allows running a piece of Starlark code on every target selected by the query. The current target is bound to the <code>target</code> variable. This is useful to, for example, query transitive runtime JARs. And because Starlark is almost Python, you can explore the API by using the <code>dir</code> function with expressions like <code>dir(target)</code> or <code>dir(target.actions)</code>.</p></li><li><p><strong>Action queries:</strong> The <code>aquery</code> command is a different beast from the other queries and allows inspecting the action graph. Something like <code>bazel aquery 'mnemonic(CppCompiler, //...)'</code> shows all inputs, outputs, and command lines for every action. This can be particularly useful to understand toolchain configuration changes.</p></li><li><p><strong>Filtering by file:</strong> The <code>outputs</code> and <code>inputs</code> filters can be used to filter actions by paths: e.g. you can find actions that produce a particular file with <code>outputs(".*path/to/h", deps(//...)))</code>. (Beware that the path filter is an anchored regexp.)</p></li><li><p><strong>Performance:</strong> Running many queries in a loop doesn&rsquo;t scale. Consider building a bigger query if possible and then do post-processing (the opposite advice of when talking to a database server), or using an aspect to dump all info in a single run.</p></li></ul><h1 id=linting>Linting</h1><p>Back at Google, Jin and I hosted an intern circa 2017 to work on &ldquo;autolint&rdquo;: an innovative tool that was supposed to automate running arbitrary lint checks on arbitrary codebases. The project never materialized&mldr; but Aspect.dev just announced <a href=https://github.com/aspect-build/rules_lint><code>rules_lint</code></a> which basically does the same thing and integrates with Bazel neatly.</p><p>To summarize the talk, <code>rules_lint</code> provides two disjoint features in one:</p><ul><li><p><strong>Formatting:</strong> The goal of formatting is to change a codebase to adhere to predefined standards and stop the bitchering about white space. A quote from the talk I liked was &ldquo;because while your code might be art&mldr; it isn&rsquo;t ASCII art&rdquo;.</p><ul><li><p><strong>Broad support:</strong> Supporting formatters is easy, and there are formatters for almost all languages, so a goal here is to try to support as many as possible.</p></li><li><p><strong>Speed:</strong> Formatting must be deterministic and fast so that it can be hooked into the IDE and/or in pre-commit hooks.</p></li><li><p><strong>Not part of the build graph:</strong> It&rsquo;s tempting to try to hook formatting as an action, but formatting requires unconstrained access to the workspace to modify source files, and many source files that you&rsquo;d like to lint don&rsquo;t necessarily have build rules (e.g. Markdown documentation).</p></li><li><p><strong>Implementation:</strong> Formatting relies on <code>rules_multitool</code> which automates the process of downloading a bunch of tools and <code>rules_multirun</code> which allows running multiple tools in parallel.</p></li><li><p><strong>Git blame:</strong> When applying formatting changes, don&rsquo;t forget to register the commits that did so in <code>.git-blame-ignore-revs</code>. This will prevent your name from showing up in <code>git blame</code> operations as the author of all files.</p></li></ul></li><li><p><strong>Linting:</strong> The goal of linting is to detect potential problems in the code, but the constraints are different: the problems aren&rsquo;t always conclusive, the solutions aren&rsquo;t always unique nor safe to apply automatically, and analyzing a file may require analyzing more than one at once.</p><ul><li><p><strong>Speed:</strong> Linting is slow because it often requires using tools akin to compilers. As such, it should never be added to pre-commit hooks and should instead be plumbed through in CI.</p></li><li><p><strong>Implementation:</strong> The desire is to have a uniform interface for linting all languages and don&rsquo;t want to have extra rules nor modify build files. The obvious answer to this is to use an aspect which then augments existing rules with reports and patches to fix up the source tree. Validation actions were not an option because using them requires modifying the rulesets, and a premise of this work was to <em>not</em> do that.</p></li><li><p><strong>Interface:</strong> Invoking an aspect and handling the resulting patch files is complicated, so Aspect.dev has augmented the Bazel client (the CLI) with an additional <code>lint</code> subcommand that automates this process. Interesting, and I suppose this could be turned into a pluggable mechanism by making Bazel look for <code>bazel-&lt;command></code> binaries at a well-known location (like the <code>git</code> dispatcher does). This reminded me of Twitter&rsquo;s <a href=https://v1.pantsbuild.org/>Pants</a> build system, which is much more than just for building.</p></li></ul></li></ul><h1 id=testing>Testing</h1><p>Bazel is often sold as a &ldquo;build tool&rdquo; but its secret sauce is that it really is a &ldquo;test tool&rdquo;. The true benefits of using Bazel come from realizing that not all tests have to run all the time, and that their results can be safely cached. Various talks touched upon how to do testing effectively:</p><ul><li><p><strong>Profiling data:</strong> Collecting profiling details of tests <em>by default</em>, and exposing these details as test outputs, is very useful because developers can then use this information to understand how to optimize long tests on their own. AirBnB reported that they do this.</p></li><li><p><strong>Test granularity:</strong> We like to think that each test deserves its own test target&mldr; but that&rsquo;s not necessarily how users think or how they interact with tests. Many times, developers end up running certain groups of tests in unison, and if they always do that, combining those tests under a single target will save build and execution time at the expense of a less &ldquo;pure&rdquo; dependency graph.</p></li><li><p><strong>Tests in the build:</strong> In certain scenarios, users would like to depend on test outputs as part of the build process. One example that Luminar Technologies provided was the need to generate a detailed report of test results and code coverage for industry compliance reasons. The report generation should be an action that depends on the test outputs, but that&rsquo;s not doable. As a compromise, they made the tests run as part of the build by replacing <code>cc_test</code> with a macro that spawns a non-test action with a custom runner (but only on CI).</p></li><li><p><strong>Smoke tests:</strong> Related to the previous and during the unconference, Luminar Technologies also brought up the desire to gate parts of the build and test process on &ldquo;smoke tests&rdquo;. In other words: once issuing the build/test operation, if we detect that a simple test fails, we shouldn&rsquo;t continue the build or run any of the more expensive tests. The audience seemed to agree that this belonged into a separate tool. Ulf reminded us that there should still be a flag called <code>--test_keep_going</code>, which can be set to false to stop execution as soon as one test fails.</p></li><li><p><strong>Test selection:</strong> When folks adopt Bazel, their initial approach to CI is to simply do <code>bazel test ...</code> in a job. This works well&mldr; until it doesn&rsquo;t, because even in the presence of test caching, processing the whole monorepo becomes expensive. Uber explains how even an <code>rdeps</code> query becomes expensive and they&rsquo;ve had to find other solutions. A key insight is that 71% of changes to their monorepo only change source files and only 15% change at least one build file. This means that the majority of changes do not modify the build graph structure significantly, so there is room for reusing state from previous builds (e.g. keeping the Bazel server alive) to compute newly-affected targets.</p></li><li><p><strong>Flaky test granularity:</strong> Bazel detects flakes at the test target level&mldr; but a test target can contain tens or hundreds of individual test cases. Which means that if a single test case is flaky and we conclude that its target is flaky, subsequent builds could skip lots of valid test cases. By implementing custom flaky test case detection via <code>junit.xml</code> report files, Uber was able to surface 3500 additional tests that would have been skipped by the naive target-based approach and could re-add those to the build.</p></li><li><p><strong>Profile-guided test execution:</strong> In large test invocations, it&rsquo;s common for one test to be the long pole. If by lack of luck this test ends up running last, it ends dragging the critical path of the test run and lengthening the p99 of test executions. It&rsquo;d be nice if Bazel supported &ldquo;profile-guided execution&rdquo; so that such long poles could be scheduled earlier. Jin reported that this has been looked at but one problem is that there hasn&rsquo;t been a good place to store this information across invocations. Ulf mentioned that when we have async action execution (which Java 21 makes possible), we should be able to improve action scheduling and implement this.</p></li><li><p><strong>Actions per test:</strong> One interesting detail that Ulf shared is that test targets generate three actions, possibly more: one to execute the test itself, another to generate the <code>junit.xml</code> file if the test failed to do so, and another to perform coverage post-processing. If retries, sharding, or <code>--runs_per_test</code> are involved, there can be even more actions. So, if it becomes necessary, there is precedent to add more actions to perform other types of post-processing.</p></li><li><p><strong>CI runners:</strong> A topic that came up during the unconference was that starting Bazel on CI runners is very painful because of the need to download repos, repopulate the local disk cache, and rebuild the analysis graph. The general advice is to prevent discarding CI runners across builds, but that&rsquo;s not always possible (e.g. security might not like to share runners across different jobs). For Kubernetes, stateful sets provide a mechanism to preserve the disk cache even during auto-scaling.</p></li></ul><h1 id=missing-tooling-around-bazel>Missing tooling around Bazel</h1><p>A fun topic that arose in the unconference was: &ldquo;what support tools do you wish Google had open sourced when they published Bazel, or that the community had built?&rdquo; There were many ideas from the audience:</p><ul><li><p><strong>Scripting language for use in genrules:</strong> Writing genrules that work across systems is difficult because they invoke the shell, and the tools that are often called do not always support the same syntax (<a href=/2021/08/useless-use-of-gnu.html>thanks GNU</a>). It&rsquo;d be nice to have a language that allowed writing genrules in a platform-agnostic way. WASM was brought up as well as having a Starlark interpreter with file system access.</p></li><li><p><strong>Affected target determination:</strong> The goal of this tool would be to answer the question of which targets are impacted by a change to the source tree. <a href=https://github.com/Tinder/bazel-diff><code>bazel-diff</code></a> more or less does this. An <code>rdeps</code> query sounds like the right solution, but in practice it is tricky because changes to a toolchain aren&rsquo;t visible in a query; they do show up in <code>cquery</code> though, but then you have to be aware of all possible configurations to do the determination correctly.</p></li><li><p><strong>Build queuing:</strong> The goal here is to have a service that can queue entire builds and not just actions. This might exist in some CI systems already.</p></li><li><p><strong>Unifying bazelisk with bazel:</strong> Users are confused with the fact that <code>sudo apt install bazel</code> is available but generally does the wrong thing, and that it&rsquo;d be good if <code>bazelisk</code>&rsquo;s features existed within Bazel. I explained that we built something similar to <code>bazelisk</code> at Snowflake but for arbitrary tools as a way to hijack command line executions and redirect them to checked-in tools; maybe we should open-source it.</p></li><li><p><strong>buildozer for bzl files:</strong> Automating edits to <code>bzl</code> files would be handy, although this is a hard problem. Maybe it could be scoped down to e.g. automatically clean up old repository rules that aren&rsquo;t referenced.</p></li><li><p><strong>Java library to programmatically edit build and <code>bzl</code> files:</strong>. The current Starlark library isn&rsquo;t useful because it&rsquo;s not standalone and it doesn&rsquo;t preserve the original file structure. A workaround is to extract the AST from Python because these files remain syntactically valid from Python&rsquo;s perspective.</p></li><li><p><strong>Documentation website for all the rules:</strong> The BCR could fulfill this, but it currently does not have links to documentation.</p></li></ul><h1 id=the-end>The end</h1><p>And finally, here are the few leftover toughts that I did not know how to fit in any of the sections above:</p><ul><li><p><strong>Nix:</strong> There were many talks about Nix on the original submissions, but only a couple made it to the final schedule. The folks at Modus Crate described how they use <code>rules_nixpkgs</code> to build external dependencies and how they stage those in an NFS-shared <code>/nix/store/</code> tree. Because Bazel invokes Nix and stages the dependencies during its external repository phase, the execution phase and the remote workers can assume that the Nix packages are in the right locations and things just work.</p></li><li><p><strong>RPM integration:</strong> In a similar spirit to using Nix to install packages and/or build containers, we also have <a href=https://github.com/rmohr/bazeldnf>bazeldnf</a>. This ruleset provides the <code>rpm</code> repository rule to import RPM packages and the <code>rpmtree</code> build rule to combine one or more RPM into a tarball that can later be fed to other rules like <code>container_layer</code>. In this context, you might also be interested in the <a href=https://github.com/NixOS/patchelf><code>patchelf</code></a> ruleset.</p></li><li><p><strong>Migrations:</strong> Migration talks are getting old, but there were some good insights from MongoDB&rsquo;s talk. One such insight was that, as in any software rewrite, the &ldquo;old&rdquo; build system doesn&rsquo;t stay still during a migration, and the set of features to migrate grows over time. Another such insight was that, if you can couple the new build system to the old one (by making one rely on the other for increasing portions of the code), you can minimize the time in which new features get added to the old build and not the new one. The downside is that you&rsquo;ll be building throwaway work, but overall it will pay off.</p></li><li><p><strong>My talk about Snowflake:</strong> I gave a 15-minute &ldquo;migration&rdquo; talk about what we are doing with Bazel at Snowflake. Because of what I said just above, I skipped over all of the migration topics and instead focused on explaining 5 different technical challenges that we faced and how we fixed them. I was met with lots of questions after the talk, which was really nice, but which means that we owe a full migration post when we are done (very soon now!).</p></li></ul><p>I hear you want the raw notes? Are you sure? I really don&rsquo;t recommend that you look&mldr; but if you must, here they are: <a href=/notes/2024-10-14-bazelcon.md>BazelCon day 1 notes</a>, <a href=/notes/2024-10-15-bazelcon.md>BazelCon day 2 notes</a>, and the <a href=/notes/2024-10-16-build-meetup.md>Build Meetup&rsquo;s notes</a>.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/10/x86-64-programming-models.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>ðŸ‘
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>ðŸ‘Ž
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=BazelCon+2024+recap&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F10%2Fbazelcon-2024-recap.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=BazelCon+2024+recap&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F10%2Fbazelcon-2024-recap.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=BazelCon+2024+recap+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F10%2Fbazelcon-2024-recap.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.azurewebsites.net/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon"></a>
<a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter"></a>
<a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.azurewebsites.net/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2023 Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.d30f168b11d80082408f4a983af9a626c6e57d58f7846b2174bac40d43be33e3.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>