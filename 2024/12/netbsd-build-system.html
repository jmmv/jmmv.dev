<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml xmlns:fb=http://ogp.me/ns/fb#><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:site_name" content="Julio Merino (jmmv.dev)"><meta property="twitter:site" content="@jmmv"><title>Revisiting the NetBSD build system - Julio Merino (jmmv.dev)</title><meta property="og:title" content="Revisiting the NetBSD build system - Julio Merino (jmmv.dev)"><meta property="twitter:title" content="Revisiting the NetBSD build system - Julio Merino (jmmv.dev)"><meta name=description content="I recently picked up an embedded project in which I needed to build a highly customized full system image with minimal boot times. As I explored my options, I came to the conclusion that NetBSD, the often-forgotten BSD variant, was the best viable choice for my project.
One reason for this choice is NetBSD&rsquo;s build system. Once you look and get past the fact that it feels frozen in time since 2002, you realize it is still one of the most advanced build systems you can find for an OS. And it shows: the NetBSD build system allows you to build the full OS from scratch, on pretty much any host POSIX platform, while targeting any hardware architecture supported by NetBSD. All without root privileges.
Another reason for this choice is that NetBSD was my daily workhorse for many years and I&rsquo;m quite familiar with its internals, which is useful knowledge to quickly achieve the goals I have in mind. In fact, I was a NetBSD Developer with capital D: I had commit access to the project from about 2002 through 2012 or so, and I have just revived my account in service of this project. jmmv@ is back!
So, strap onto your seats and let&rsquo;s see how today&rsquo;s NetBSD build system looks like and what makes it special. I&rsquo;ll add my own critique at the end, because it ain&rsquo;t perfect, but overall it continues to deliver on its design goals set in the late 1990s.
"><meta property="og:description" content="I recently picked up an embedded project in which I needed to build a highly customized full system image with minimal boot times. As I explored my options, I came to the conclusion that NetBSD, the often-forgotten BSD variant, was the best viable choice for my project.
One reason for this choice is NetBSD&rsquo;s build system. Once you look and get past the fact that it feels frozen in time since 2002, you realize it is still one of the most advanced build systems you can find for an OS. And it shows: the NetBSD build system allows you to build the full OS from scratch, on pretty much any host POSIX platform, while targeting any hardware architecture supported by NetBSD. All without root privileges.
Another reason for this choice is that NetBSD was my daily workhorse for many years and I&rsquo;m quite familiar with its internals, which is useful knowledge to quickly achieve the goals I have in mind. In fact, I was a NetBSD Developer with capital D: I had commit access to the project from about 2002 through 2012 or so, and I have just revived my account in service of this project. jmmv@ is back!
So, strap onto your seats and let&rsquo;s see how today&rsquo;s NetBSD build system looks like and what makes it special. I&rsquo;ll add my own critique at the end, because it ain&rsquo;t perfect, but overall it continues to deliver on its design goals set in the late 1990s.
"><meta property="twitter:description" content="I recently picked up an embedded project in which I needed to build a highly customized full system image with minimal boot times. As I explored my options, I came to the conclusion that NetBSD, the ‚Ä¶"><meta name=author content="Julio Merino"><meta property="twitter:creator" content="@jmmv"><meta name=generator content="Hugo 0.147.8"><meta property="og:url" content="https://jmmv.dev/2024/12/netbsd-build-system.html"><meta property="og:type" content="blog"><meta property="twitter:card" content="summary"><link rel=canonical href=https://jmmv.dev/2024/12/netbsd-build-system.html><link rel=alternate type=application/rss+xml title="Julio Merino (jmmv.dev)" href=/feed.xml><link rel=stylesheet href=/sass/main.min.24b518a51730830025491ef7734bba072a9461f33c61bc812443fd003a8d4901.css><link rel=stylesheet href=/css/chroma.css><link rel=icon type=image/png href=/images/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/images/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicons/favicon-96x96.png sizes=96x96><meta property="og:image" content="/images/2024-12-28-cover-image.jpg"><meta property="twitter:image" content="https://jmmv.dev/images/2024-12-28-cover-image.jpg"><script>const SITE_ID="e8da9f62-b7ac-4fe9-bf20-7c527199a376",BASE_URL="https://jmmv.dev/"</script></head><body><img src="https://hugo-dynamic.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/pages/aHR0cHM6Ly9qbW12LmRldi8yMDI0LzEyL25ldGJzZC1idWlsZC1zeXN0ZW0uaHRtbA==/stamp.gif" style=display:none>
<script>window.location.replace("https://blogsystem5.substack.com/p/netbsd-build-system")</script><header class=site-header><nav class="navbar navbar-expand-md fixed-top navbar-dark bg-primary"><a class=navbar-brand href=/><img src=/images/favicons/favicon-30x30.png width=30 height=30 class="d-inline-block align-top" alt>
&nbsp;jmmv.dev
</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/about.html>About</a></li><li class=nav-item><a class=nav-link href=/blog.html>Blog</a></li><li class=nav-item><a class=nav-link href=/resume.html>Resume</a></li><li class=nav-item><a class=nav-link href=/software.html>Software</a></li></ul><ul class="navbar-nav mr-4"><li class=nav-item><a class=nav-link href=/archive.html>Archive</a></li><li class=nav-item><a class=nav-link href=/series.html>Series</a></li><li class=nav-item><a class=nav-link href=/tags.html>Tags</a></li></ul><form class=form-inline method=get role=search action=https://www.google.com/search><div class=input-group><input type=search name=query class=form-control placeholder=Search aria-label=Search><div class=input-group-append><button type=submit value=Search class="btn btn-light">
<img src=/octicons/search.svg></button></div></div><input type=hidden name=sitesearch value=https://jmmv.dev/></form></div></nav></header><div class=page-header><div class=container><h1>Revisiting the NetBSD build system</h1><p>December 28, 2024 &#183;
About 16 minutes
&#183;
Tags:
<a href=/tags/blogsystem5>blogsystem5</a>, <a href=/tags/netbsd>netbsd</a></p><p class=post-meta-p>This article was
<a href=https://blogsystem5.substack.com/p/netbsd-build-system>originally published
on Substack</a>
in the <a href=https://blogsystem5.substack.com/>Blog System/5 newsletter</a>
and is replicated here for archival purposes.</p><figure class=cover-image><img src=/images/2024-12-28-cover-image.jpg style=max-width:100%></figure></div></div><div class="container post-body"><div class=row><div class=col-md-9><div class=row><div class=col><article><p>I recently picked up an embedded project in which I needed to build a highly customized full system image with minimal boot times. As I explored my options, I came to the conclusion that NetBSD, the often-forgotten BSD variant, was the best viable choice for my project.</p><p>One reason for this choice is NetBSD&rsquo;s build system. Once you look and get past the fact that it feels frozen in time since 2002, you realize it is still one of the most advanced build systems you can find for an OS. And it shows: the NetBSD build system allows you to build the full OS from scratch, on pretty much any host POSIX platform, while targeting any hardware architecture supported by NetBSD. All without root privileges.</p><p>Another reason for this choice is that NetBSD was my daily workhorse for many years and I&rsquo;m quite familiar with its internals, which is useful knowledge to quickly achieve the goals I have in mind. In fact, I was a NetBSD Developer with capital D: I had commit access to the project from about 2002 through 2012 or so, and I have just revived my account in service of this project. <code>jmmv@</code> is back!</p><p>So, strap onto your seats and let&rsquo;s see how today&rsquo;s NetBSD build system looks like and what makes it special. I&rsquo;ll add my own critique at the end, because it ain&rsquo;t perfect, but overall it continues to deliver on its design goals set in the late 1990s.</p><div class="container action-highlight p-4 my-4 d-md-none"><div class="row text-center"><p>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</p></div><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div><h1 id=the-basics>The basics</h1><p>The NetBSD build system is powerful and featureful, but it&rsquo;s also arcane as it&rsquo;s based on a combination of the BSD variant of make and shell scripts. Just peek through the files under <a href=https://cvsweb.netbsd.org/bsdweb.cgi/src/share/mk/><code>src/share/mk/</code></a>, the directory that contains the bulk of the infrastructure, to see what I mean.</p><p>As a user of the build system, however, you rarely interact with make directly. Instead, you use the <code>build.sh</code> script located at the top of the source tree. This script provides a user-friendly interface to most operations you may want to do, and abstracts away the intricacies of the targets that coordinate the build of the system and the configuration that controls it.</p><p>The structure of the command is to pass high-level &ldquo;goals&rdquo; to <code>build.sh</code> as arguments, which indicate the operations to perform. In its most simple form, all you need to do to build a full system distribution targeting the architecture of the host is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh tools release
</span></span></code></pre></div><p>But hey, I promised you can trivially cross-build too, right? Sure, let&rsquo;s compile the system for a Raspberry Pi with a 64-bit chip, produce the USB image that we can write to an SD card, and do everything as an unprivileged user:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh -U -a aarch64 -m evbarm tools release disk-image
</span></span></code></pre></div><p>That&rsquo;s it, really. That&rsquo;s all it takes.</p><p>We must dig deeper though, so let&rsquo;s look at some of those &ldquo;goals&rdquo; to see what <code>tools</code> means and understand how a release is put together without root privileges.</p><h1 id=the-toolchain>The toolchain</h1><p>The very first step of any <code>build.sh</code> invocation is to generate the toolchain used to build the rest of the system. This is true of any build, including those that target the host machine, because this ensures that the build is independent of the host&rsquo;s state. In particular, this avoids the situation where you might have to upgrade certain components before building, which was/is common in other BSDs.</p><p>And you have seen this prerequisite step in the previous section, by the way: all sample <code>build.sh</code> invocations I showed you included <code>tools</code> as the first goal. Now, you don&rsquo;t <em>have</em> to provide <code>tools</code> to <em>every</em> invocation of the script: as soon as you have built a toolchain, you can reuse it in subsequent invocations.</p><p>Building a toolchain with <code>build.sh</code> is incredibly handy on its own, as you can produce cross-build toolchains and use them for other purposes outside of building NetBSD itself. Zig&rsquo;s build system has often been praised for this reason, but NetBSD&rsquo;s has nothing to envy. For example, if we do this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh -a aarch64 -m evbarm -T ~/tools tools
</span></span></code></pre></div><p>We end up with a cross-build C and C++ toolchain under <code>~/tools/</code> that targets NetBSD running on ARM 64 bits. And what goes into the toolchain, you ask?</p><figure><img src=/images/2024-12-28-netbsd-tools.png><figcaption>Directory listing of <tt>tools</tt> as produced by the command above and its <tt>bin</tt> subdirectory.</figcaption></figure><p>In this listing, you can see a bunch of binaries prefixed with <code>aarch64--netbsd-</code>. These are all part of the C and C++ toolchain. The rest of the tools, prefixed with <code>nb</code>, are NetBSD-specific tools required during the build. These are programs that are part of a normal NetBSD installation and would be available without the <code>nb</code> prefix if we were building on a NetBSD host, but remember, the build system supports <em>any</em> POSIX host OS. Take <code>nbsed</code> as an example: yes, all POSIX hosts provide a <code>sed</code> tool, but its syntax varies among systems so the NetBSD build system isolates itself from those differences by compiling <code>sed</code> as a host tool and using that throughout.</p><p>One special tool from this listing is <code>nbmake-evbarm</code>. This is not the binary for make (which is itself stored as <code>nbmake</code>). This is a shell script that captures all settings provided to <code>build.sh</code> and then invokes <code>nbmake</code> with those, and this script is useful when you want to manually rebuild portions of the tree. Not something you would want to use as an &ldquo;end user&rdquo; of the build, but something you definitely will want to use as a NetBSD developer.</p><h1 id=build-structure>Build structure</h1><p>Let&rsquo;s explore the source tree a bit, which is the prime example of a monorepo in an open source project:</p><figure><img src=/images/2024-12-28-netbsd-src-bin-ls.png><figcaption>Directory listing of the source tree, its <tt>bin</tt> and <tt>bin/ls</tt> subdirectories, and the content of <tt>bin/ls/Makefile</tt>.</figcaption></figure><p>In this picture, you can see first the content of the top-level directory of the source tree. It all looks pretty simple: there are various subdirectories, such as <code>bin</code>, <code>lib</code>, or <code>usr.bin</code>, that roughly track the structure of the installed system; there is the <code>build.sh</code> script that I previously described; and there is a <code>Makefile</code> as well. Looking into one subdirectory, like <code>bin</code>, we see another <code>Makefile</code> and many more subdirectories, one per tool installed onto <code>/bin/</code>.</p><p>Knowing this directory-based structure, we can use the <code>nbmake-evbarm</code> wrapper script I mentioned earlier to operate on just a portion of the monorepo. Focusing on the <code>ls</code> example shown in the screenshot, we could build and upgrade this piece of the system on its own by doing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ cd ~/src/bin/ls
</span></span><span class=line><span class=cl>$ ~/tools/bin/nbmake-evbarm all
</span></span><span class=line><span class=cl>... console noise ...
</span></span><span class=line><span class=cl>$ sudo ~/tools/bin/nbmake-evbarm install
</span></span><span class=line><span class=cl>... console noise ...
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>Another extra detail to highlight from the screenshot is that NetBSD&rsquo;s <code>Makefile</code>s are mostly declarative. Each <code>Makefile</code> defines a bunch of variables to specify what is being built and, at the end, includes one of the many <code>bsd.*.mk</code> files that pull in the build logic. Among these, we have <code>bsd.prog.mk</code> to build one program, <code>bsd.lib.mk</code> to build one static/shared library, and <code>bsd.subdir.mk</code> to recurse into subdirectories. Importantly, the general design is to build just <em>one</em> item per directory&mdash;although I myself broke this rule when I added <code>bsd.tests.mk</code> to build tests because splitting them into subdirectories would have added too much noise to the tree.</p><p>This declarative design is interesting because it maps well to the foundations of modern build systems like Bazel. In fact, the design of the NetBSD build system is what fueled my interest in build systems, influenced the design of <a href=/2022/05/remembering-buildtool.html>my own Buildtool</a>, and made me like <del>Bazel</del> Blaze as soon as I first saw it in 2008.</p><h1 id=the-destdir>The destdir</h1><p>In order to produce the structure of the final installation, the build system uses the &ldquo;destdir&rdquo; concept. A destdir is a staging location where built files are installed, but paths to this staging location are <em>not</em> used within the artifacts produced by the build. This idea <a href=https://www.gnu.org/software/automake/manual/html_node/DESTDIR.html>exists in other build systems such as GNU Automake</a> and is pretty much a necessity to build multiple pieces of software together before installing them or to package software without root privileges.</p><p>Imagine that you want to build a library, say <code>libm</code> (the math library), and a tool that uses it, say <code>bc</code> (the calculator). <code>libm</code> typically goes into <code>/lib/</code> so we cannot just build and install it in place: for one, we may &ldquo;break&rdquo; the existing system if the new version happens to be backwards-incompatible; for another, we may be targeting a different architecture so we cannot just replace <code>/lib/libm.so</code> with an incompatible version.</p><p>The destdir comes to the rescue. We first build <code>libm</code> as if it would be installed into <code>/lib/</code>. However, during <em>installation</em>, we prefix all file copy operations with the destdir. In this way, we build a separate &ldquo;system root&rdquo;, say <code>/tmp/destdir/lib/</code>, that contains the newly-built <code>libm.so</code>. After that, we build <code>bc</code> and point it to the <code>libm</code> that&rsquo;s in <code>/tmp/destdir/lib/</code>, but&mldr; we have a problem: we can&rsquo;t allow the <code>/tmp/destdir/</code> path to appear anywhere inside the <code>bc</code> binary because this directory is transient. To fix this, we must separate build paths from runtime paths during the build: when we build <code>bc</code>, we tell the linker to look for libraries under <code>/tmp/destdir/lib/</code> via the <code>-L</code> flag, and we also tell the linker that, at <em>runtime</em>, libraries will be available in <code>/lib/</code> via the <code>--rpath</code> flag (which stands for runtime path).</p><p>As you can imagine, the NetBSD build system heavily relies on this idea and, after a <code>distribution</code> build (implied by the <code>release</code> goal I showed earlier):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh -D /tmp/testdir/ distribution
</span></span></code></pre></div><p>we end up with a destdir that contains all system files laid out exactly as they need to be installed.</p><p>In fact, if you run the build as root and target the host system (where the host is NetBSD), the destdir can serve as the target of a chroot. So, if you do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>chroot /tmp/destdir
</span></span></code></pre></div><p>you essentially can enter the freshly-built system. This may or may not work, however: the newly-built binaries might require new kernel features, which is likely true if you are building a more modern NetBSD release from an older release or if you are tracking NetBSD-current. And this obviously won&rsquo;t work if you are cross-building.</p><h1 id=distribution-media>Distribution media</h1><p>The destdir serves as a staging area but it does not represent the final artifacts of the build. To put the destdir to use, we either have to &ldquo;copy&rdquo; the staging area onto the host to perform an in-place upgrade, or we need to build distribution media.</p><p>The former case of an in-place upgrade is tricky because it requires issuing manual post-installation steps, so I&rsquo;m not going to describe it here. But the latter case of producing distribution media is trivial. For example, we can do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh release
</span></span></code></pre></div><p>to produce the release &ldquo;sets&rdquo; for the system from the contents of the destdir, or we can do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh iso-image install-image live-image
</span></span></code></pre></div><p>to create various types of installation media (a bootable CD, a bootable USB image, a live system image&mldr;) from the contents of the destdir as well.</p><p>The release sets are an interesting thing to discuss because they form the core of a NetBSD distribution. You see: NetBSD ships as a collection of tarballs, and installing NetBSD amounts to simply unpacking those tarballs onto a file system and performing a few post-installation configuration steps.</p><figure><img src=/images/2024-12-28-netbsd-amd64-binary-sets.png class=with-border><figcaption>Content of the <tt>binary/sets</tt> directory of the NetBSD/amd64 distribution.</figcaption></figure><p>Now, the way these tarballs are produced from the destdir is by leveraging <code>mtree</code>, a really cool tool that is not known in Linux land. The purpose of this tool is to compare a textual &ldquo;golden&rdquo; representation of a directory against the actual contents of the directory, and highlight where they might differ.</p><p>BSD systems use <code>mtree</code> to describe how the installed system looks like and, as you can imagine, NetBSD is no exception. The NetBSD build system uses <code>mtree</code> files to ensure the destdir contents match expectations, and also uses the <code>mtree</code> &ldquo;manifests&rdquo; to &ldquo;bucketize&rdquo; the files from the destdir into the individual release sets. You can find these golden manifests in the <a href=https://cvsweb.netbsd.org/bsdweb.cgi/src/distrib/sets/lists/><code>src/distrib/sets/lists/</code></a> directory.</p><h1 id=unprivileged-builds>Unprivileged builds</h1><p>These <code>mtree</code> files are also critical for another very important feature: namely, the ability to build the whole NetBSD system as an unprivileged user. This, to me, is one of the most impressive features of this build system: you can produce the full build, including disk images, without ever running <code>sudo</code> or using weird intercept tools like Debian&rsquo;s <code>fakeroot</code>.</p><p>Here is how this works. When building in unprivileged mode (enabled via the <code>-U</code> flag to <code>build.sh</code>), the build system produces a <code>METALOG</code> file under the destdir. This file looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>$ grep &#39;^\./sbin&#39; ~/destdir/METALOG | head -n 5
</span></span><span class=line><span class=cl>./sbin type=dir uname=root gname=wheel mode=0755
</span></span><span class=line><span class=cl>./sbin/amrctl type=file uname=root gname=wheel mode=0555 size=72120 time=1735119460.0 sha256=d6f474441dc98648a4e8ec633dd76fc3349c85a0af9830ce8eb6566e94291fdb
</span></span><span class=line><span class=cl>./sbin/apmlabel type=file uname=root gname=wheel mode=0555 size=72360 time=1735119460.0 sha256=731cf433328bd14c6d3f322ef60fa92eb9eaa2725baa0cb52253b50743d9d324
</span></span><span class=line><span class=cl>./sbin/atactl type=file uname=root gname=wheel mode=0555 size=73512 time=1735119461.0 sha256=74a15335c8715513ac50f615a8e906319df79f76dad601bc688ae214b3e41673
</span></span><span class=line><span class=cl>./sbin/badsect type=file uname=root gname=wheel mode=0555 size=72328 time=1735119461.0 sha256=76e34649bf100fe490befb2a4ec58455a7710a665dd59bcbbd8c672a6086bde8
</span></span><span class=line><span class=cl>$ ‚ñà
</span></span></code></pre></div><p>Every line of this file maps a file system entry (a directory, a file, a device&mldr;) stored in the destdir to its properties, including ownership information and permissions. These entries are generated from metadata encoded in the <code>Makefile</code>s whenever the build system places a new file under the destdir via the <code>install</code> command (another nice tool often unknown to Linux users). The <code>METALOG</code> is the key that allows building media images without root privileges.</p><p>If you think about it, media images are simply files with an internal structure that represents disk partitions, file systems, and metadata. Because they are simply files, there is no need to have root access nor to make the host&rsquo;s <code>passwd</code> file contain all users represented by entries in these file systems. Traditionally, OS builds have needed root because it&rsquo;s easier to leverage the kernel&rsquo;s virtual devices and file system implementations, but there is not inherent reason for that to be the only choice. All the work can be done in user space, and that&rsquo;s precisely what NetBSD does.</p><p>Now, go back and revisit the screenshot above that showed the toolchain contents. You&rsquo;ll notice tools like <code>nbmakefs</code> (the tool to format a file system) and <code>nbgpt</code> (the tool to create a GPT partitioning scheme). These tools are part of the toolchain because they are needed to generate installation media, and these tools know how to read the <code>METALOG</code> in order to embed the right permissions and special file modes into the built images. All without ever becoming root.</p><h1 id=sysbuild>sysbuild</h1><p>Now, as simple and powerful as <code>build.sh</code> might be, I find it cumbersome for day to day use if you want to customize any of its default settings. It is not uncommon to end up running <code>build.sh</code> with invocations like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./build.sh -O ../obj -T ../tools -U -u -V <span class=nv>MKDEBUG</span><span class=o>=</span>no -V <span class=nv>MKGCC</span><span class=o>=</span>no distribution
</span></span></code></pre></div><p>which the official documentation describes as &ldquo;golden invocations&rdquo; and I have no desire to type or even remember.</p><p>This is what drove me to <a href=/software/sysbuild.html>write sysbuild</a>: a layer of abstraction over <code>build.sh</code> <em>and</em> <code>cvs</code> that coordinates updating the source tree and building it. The tool even integrates with <code>cron</code> trivially, providing a mechanism to keep NetBSD-current installations up-to-date.</p><p>sysbuild is driven by configuration &ldquo;profiles&rdquo; which allow you to customize the paths and settings of a build in just one place and then puts them to use with a trivial command. For example, with a configuration file like the following stored in <code>~/.sysbuild/rpi.conf</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>BUILD_ROOT</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>HOME</span><span class=si>}</span><span class=s2>/netbsd&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>BUILD_TARGETS</span><span class=o>=</span><span class=s2>&#34;tools sets disk-image&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>CVSROOT</span><span class=o>=</span>:ext:anoncvs@cvs.NetBSD.org:/cvsroot
</span></span><span class=line><span class=cl><span class=nv>MACHINES</span><span class=o>=</span>amd64
</span></span><span class=line><span class=cl><span class=nv>RELEASEDIR</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>BUILD_ROOT</span><span class=si>}</span><span class=s2>/release&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>SRCDIR</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>BUILD_ROOT</span><span class=si>}</span><span class=s2>/src&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>UPDATE_SOURCES</span><span class=o>=</span>no
</span></span></code></pre></div><p>We can simply run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sysbuild -c rpi build
</span></span></code></pre></div><p>to update the NetBSD source tree to the latest version, ensure that the tools are up-to-date, and produce the USB disk images for a Raspberry Pi.</p><h1 id=deficiencies>Deficiencies</h1><p>Not everything about the NetBSD build system is rosy though.</p><p><em>The</em> thing that differentiates a good build system from a &ldquo;meh&rdquo; one for me personally is the behavior of incremental builds and, in particular, two aspects of these:</p><ul><li><p>First, incremental builds need to do minimal work, especially when there is &ldquo;nothing to do&rdquo;. The NetBSD build system is a recursive make one (which comes with its own <a href=https://accu.org/journals/overload/14/71/miller_2004/>set of problems</a>), so it does <em>not</em> do minimal work. On my 72-core machine, it takes about 3 minutes to run through a <code>build.sh release</code> invocation that does nothing. This is OK for end users looking to upgrade their running machine, but it is painful because it makes iterating on system changes difficult. As a developer, you end up needing to know how to surgically rebuild individual subdirectories using the <code>nbmake-&lt;arch></code> wrappers I described earlier, and manually track dependencies across those.</p></li><li><p>Second, incremental builds must <a href=/2020/12/google-no-clean-builds.html>always deliver correct results</a> <em>without</em> having to do a <code>make clean</code> in between. But that&rsquo;s generally not true for make-based build systems&mdash;and NetBSD&rsquo;s is no exception. Generally, an incremental build after a <code>git pull</code> (sorry, a <code>cvs update</code>) will work fine, but sometimes it won&rsquo;t. And if you start playing with build-time switches (things like <code>MKDEBUG</code>), then you are out of luck and must resort to a <code>make clean</code> to &ldquo;switch configurations&rdquo;.</p></li></ul><p>And there are other problems. Running a parallel build on a system with many cores sometimes leads to spurious build failures because the interdependencies between components are not always precisely specified (it&rsquo;s <em>really</em> difficult to be correct with make). And the build is inefficient: of those 3 minutes I mentioned earlier, you can see that <em>most of the time</em> is wasted by make recursing through directories and discovering there is nothing to do, whereas other times, make &ldquo;chokes&rdquo; on way too many C++ compiles at once that lead to out of memory situations.</p><p>It has been <a href=/2015/04/on-bazel-and-open-source.html>my dream since the publication of Bazel</a> as open source to have a Bazel-based build of NetBSD. I think Bazel is the perfect build system for such a project because it&rsquo;d deliver correct and efficient incremental builds to NetBSD&rsquo;s monorepo, and it would save tons of resources when running on many-core machines. Except for the fact that it&rsquo;s written in Java, so it&rsquo;d be a really odd choice for such project. Maybe Buck 2 would be suitable. Anyway, one can only dream&mldr;</p><h1 id=but-why>But why?</h1><p>Why I&rsquo;m looking at this at all again, after years of not touching NetBSD? I said it in the opening: I&rsquo;m working on a new embedded project for which NetBSD is the greatest fit. I could tell you what it is about but it&rsquo;s easier to just show you:</p><figure><video width=100% controls>
<source src=/images/2024-12-28-endbasic-rpi-boot.mp4 type=video/mp4></video><figcaption>Second iteration of the "boot to EndBASIC" prototype.</figcaption></figure><p>OK, fine, in words: I am building a minimal system that boots straight into EndBASIC with quick build times and low overhead. You&rsquo;ll have to wait a bit more to get your hands on this though, as I&rsquo;m still ironing out various details and want to end up providing a pre-built &ldquo;box&rdquo; with the right hardware and software combination.</p><p>I&rsquo;m also becoming <em>super</em> tempted to migrate NetBSD&rsquo;s build to Bazel to make my own life easier in this journey. This is a monumental task&mldr; but I&rsquo;m not sure that it&rsquo;d be crazy to tackle the minimum subset of NetBSD that I need for this minimal disk image and port only those portions to Bazel. The results might impress some and then want to help the effort. Right?</p><p>In the meantime, I encourage you to read through the comprehensive <a href=https://www.netbsd.org/docs/guide/en/part-compile.html>Building the system</a> portion of <a href=https://www.netbsd.org/docs/guide/en/index.html>The NetBSD guide</a>, and to play with building a NetBSD image straight from your Linux machine. You may like it.</p></article></div></div><div class="container post-links"><div class=row><div class="col mr-auto text-left"><span><a href=https://jmmv.dev/2024/12/synology-ds923-vs-freebsd.html>&#171; Previous</a></span></div><div class="col text-center"><span><a href=/archive.html>All posts</a></span></div><div class="col ml-auto text-right"><span><a href=https://jmmv.dev/2025/01/make-help.html>Next &#187;</a></span></div></div></div><div class="container post-votes"><div class=row><div class="col-lg-4 my-2"><div class=row><div class=col><a onclick=voteThumbsUp() class="btn btn-block btn-outline-success" id=thumbs-up-btn>üëç
(<span id=thumbs-up-count>0</span>)</a></div><div class=col><a onclick=voteThumbsDown() class="btn btn-block btn-outline-danger" id=thumbs-down-btn>üëé
(<span id=thumbs-down-count>0</span>)</a></div></div></div><div class="col-lg-8 my-2 d-none d-sm-block"><div class=row><div class="col-md-4 text-center"><a href="https://www.reddit.com/submit?title=Revisiting+the+NetBSD+build+system&amp;url=https%3A%2F%2Fjmmv.dev%2F2024%2F12%2Fnetbsd-build-system.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/reddit.png alt=Reddit width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://news.ycombinator.com/submitlink?t=Revisiting+the+NetBSD+build+system&amp;u=https%3A%2F%2Fjmmv.dev%2F2024%2F12%2Fnetbsd-build-system.html" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/ycombinator.png alt="Hacker News" width=24 height=24></a></div><div class="col-md-4 text-center"><a href="https://twitter.com/intent/tweet?status=Revisiting+the+NetBSD+build+system+%E2%80%94+https%3A%2F%2Fjmmv.dev%2F2024%2F12%2Fnetbsd-build-system.html+%E2%80%94+cc+%40jmmv" class="btn btn-block btn-outline-primary">Share on
<img src=/images/badges/Twitter_Social_Icon_Circle_Color.png alt=Twitter width=24 height=24></a></div></div></div></div><div class="row my-4" id=postCommentRow><div class=col><div class=media><img class=mr-3 src=/octicons/pencil.svg width=32px height=32px><div class="media-body container"><form method=post id=newPost><div class=row><div class="col my-1"><textarea class=form-control rows=1 id=postCommentContent onclick=showPostComment() placeholder="Leave a comment"></textarea></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentAuthor>Your name (optional):</label>
<input type=text class=form-control id=postCommentAuthor></div></div><div class="row newPostControls" style=display:none><div class="col my-1 form-group"><label for=postCommentEmail>Your email (optional):</label>
<input type=text class=form-control type=email id=postCommentEmail>
<small class="form-text text-muted">Invisible to all readers; if provided, you will receive notifications when replied to (not implemented yet)</small></div></div><div class=row id=postCommentError style=display:none><div class="col mt-1 alert-danger"><p></p></div></div><div class="row newPostControls" style=display:none><button class="col-md-3 my-1 btn btn-primary" type=submit id=submitCommentButton>Post</button>
<small class="col-md-9 my-1 text-muted">Comments are subject to moderation. This feature is experimental and is powered by <a href=/software/endtracker.html>EndTRACKER</a>. If you experience any issues, please <a href=/about.html#contact>contact me off-band</a>.</small></div></form></div></div></div></div><script>function hidePostComment(){var t,e=document.getElementById("postCommentContent");e.rows=1,e.value="",t=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(t,function(e){e.style.display="none"})}function showPostComment(){var e,t=document.getElementById("postCommentContent");t.rows=5,e=document.getElementsByClassName("newPostControls"),Array.prototype.forEach.call(e,function(e){e.style.display=""})}const form=document.querySelector("#newPost");form.onsubmit=function(e){e.preventDefault();let t=document.getElementById("postCommentAuthor").value,n=document.getElementById("postCommentEmail").value,s=document.getElementById("postCommentContent").value;postComment(t,n,s,hidePostComment)}</script></div></div><div class="col-md-3 sidebar d-none d-md-block"><div class=row><div class="col text-center p-2"><p><a href=/about.html class=clear-link><img src=/images/avatars/20181124-snow.jpg class="rounded-circle shadow my-2" style=width:100px><br><b>Julio Merino</b><br>A blog on operating systems, programming languages, testing, build systems, my own software
projects and even personal productivity. Specifics include FreeBSD, Linux, Rust, Bazel and
EndBASIC.</a></p><div class=row><div class=col><div class=form-group><form action=https://endtracker.jmmv.dev/api/sites/e8da9f62-b7ac-4fe9-bf20-7c527199a376/subscribers/add method=post><input type=text name=email placeholder="Enter your email" class="form-control input-sm text-center my-1">
<button type=submit class="btn btn-primary btn-block my-1">Subscribe</button></form></div></div></div><div class="row px-2"><div class="col-sm-5 text-left"><small><span class=subscriber-count>0</span> subscribers</small></div><div class="col-sm-7 text-right"><p><a rel=me href=https://mastodon.online/@jmmv><img src=/images/badges/mastodon-logo.svg width=32px height=32px alt="Follow @jmmv on Mastodon">
</a><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fjmmv.dev%2F&amp;screen_name=jmmv"><img src=/images/badges/Twitter_logo_blue.svg width=32px height=32px alt="Follow @jmmv on Twitter">
</a><a href=/feed.xml><img src=/images/badges/feed-icon-28x28.png alt="RSS feed"></a></p></div></div></div></div><div class=row><div class=col><h2>Featured software</h2><ul><li class=overflow-ellipsis><a href=https://www.endbasic.dev/ target=_blank>EndBASIC: Online BASIC+DOS env</a></li><li class=overflow-ellipsis><a href=https://endtracker.jmmv.dev/ target=_blank>EndTRACKER: Services for static sites</a></li></ul></div></div><div class=row><div class=col><h2>Featured posts</h2><ul><li class=overflow-ellipsis><a href=/2023/06/fast-machines-slow-machines.html>Fast machines, slow machines</a></li><li class=overflow-ellipsis><a href=/2022/12/endbasic-0.10.html>EndBASIC 0.10: Core language, evolved</a></li><li class=overflow-ellipsis><a href=/2022/10/bye-microsoft-hi-snowflake.html>Farewell, Microsoft; hello, Snowflake!</a></li><li class=overflow-ellipsis><a href=/2022/05/rust-is-hard-but-does-it-matter.html>Rust is hard, yes, but does it matter?</a></li><li class=overflow-ellipsis><a href=/2022/04/rust-traits-and-dependency-injection.html>Rust traits and dependency injection</a></li><li class=overflow-ellipsis><a href=/2022/03/a-year-on-windows-intro.html>A year on Windows: Introduction</a></li><li class=overflow-ellipsis><a href=/2021/04/always-be-quitting.html>Always be quitting</a></li><li class=overflow-ellipsis><a href=/2021/02/google-monorepos-and-caching.html>How does Google keep build times low?</a></li><li class=overflow-ellipsis><a href=/2020/12/google-no-clean-builds.html>How does Google avoid clean builds?</a></li><li class=overflow-ellipsis><a href=/2020/12/unit-testing-a-console-app.html>Unit-testing a console app (a text editor)</a></li><li class=overflow-ellipsis><a href=/essays.html#featured>More...</a></li></ul></div></div></div></div></div><footer class=container-fluid><div class=row><div class="col-4 order-2 text-right"><p class=float-right><a href=#>Back to top</a></p></div><div class="col-8 order-1 mr-auto"><p>Copyright 2004&ndash;2025
Julio Merino</p></div></div></footer><script type=module>
  import { addAnchorsToHeaders, addElementClasses, BatchClient } from "\/js\/main.0de73782e9e0fbcb4184fb5793949b3b0d0ada16455df89320415b4dcc052f88.js";

  var batchClient = new BatchClient(SITE_ID);
  batchClient.doAll({
    put_request: true, get_comments: true, get_subscriber_count: true, get_votes: true });

  window.voteThumbsUp = function() { batchClient.voteThumbsUp(); }
  window.voteThumbsDown = function() { batchClient.voteThumbsDown(); }

  window.postComment = function(...args) {
    batchClient.postComment(...args);
  };

  addAnchorsToHeaders();
  addElementClasses();
</script></body></html>